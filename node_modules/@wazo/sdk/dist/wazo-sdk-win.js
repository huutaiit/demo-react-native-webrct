(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
	typeof define === 'function' && define.amd ? define(factory) :
	(global = global || self, global['@wazo/sdk'] = factory());
}(this, function () { 'use strict';

	var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

	function unwrapExports (x) {
		return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
	}

	function createCommonjsModule(fn, module) {
		return module = { exports: {} }, fn(module, module.exports), module.exports;
	}

	function getCjsExportFromNamespace (n) {
		return n && n['default'] || n;
	}

	var utils = createCommonjsModule(function (module, exports) {

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

	exports.extractVersion = extractVersion;
	exports.wrapPeerConnectionEvent = wrapPeerConnectionEvent;
	exports.disableLog = disableLog;
	exports.disableWarnings = disableWarnings;
	exports.log = log;
	exports.deprecated = deprecated;
	exports.detectBrowser = detectBrowser;
	exports.compactObject = compactObject;
	exports.walkStats = walkStats;
	exports.filterStats = filterStats;

	function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

	var logDisabled_ = true;
	var deprecationWarnings_ = true;

	/**
	 * Extract browser version out of the provided user agent string.
	 *
	 * @param {!string} uastring userAgent string.
	 * @param {!string} expr Regular expression used as match criteria.
	 * @param {!number} pos position in the version string to be returned.
	 * @return {!number} browser version.
	 */
	function extractVersion(uastring, expr, pos) {
	  var match = uastring.match(expr);
	  return match && match.length >= pos && parseInt(match[pos], 10);
	}

	// Wraps the peerconnection event eventNameToWrap in a function
	// which returns the modified event object (or false to prevent
	// the event).
	function wrapPeerConnectionEvent(window, eventNameToWrap, wrapper) {
	  if (!window.RTCPeerConnection) {
	    return;
	  }
	  var proto = window.RTCPeerConnection.prototype;
	  var nativeAddEventListener = proto.addEventListener;
	  proto.addEventListener = function (nativeEventName, cb) {
	    if (nativeEventName !== eventNameToWrap) {
	      return nativeAddEventListener.apply(this, arguments);
	    }
	    var wrappedCallback = function wrappedCallback(e) {
	      var modifiedEvent = wrapper(e);
	      if (modifiedEvent) {
	        cb(modifiedEvent);
	      }
	    };
	    this._eventMap = this._eventMap || {};
	    this._eventMap[cb] = wrappedCallback;
	    return nativeAddEventListener.apply(this, [nativeEventName, wrappedCallback]);
	  };

	  var nativeRemoveEventListener = proto.removeEventListener;
	  proto.removeEventListener = function (nativeEventName, cb) {
	    if (nativeEventName !== eventNameToWrap || !this._eventMap || !this._eventMap[cb]) {
	      return nativeRemoveEventListener.apply(this, arguments);
	    }
	    var unwrappedCb = this._eventMap[cb];
	    delete this._eventMap[cb];
	    return nativeRemoveEventListener.apply(this, [nativeEventName, unwrappedCb]);
	  };

	  Object.defineProperty(proto, 'on' + eventNameToWrap, {
	    get: function get() {
	      return this['_on' + eventNameToWrap];
	    },
	    set: function set(cb) {
	      if (this['_on' + eventNameToWrap]) {
	        this.removeEventListener(eventNameToWrap, this['_on' + eventNameToWrap]);
	        delete this['_on' + eventNameToWrap];
	      }
	      if (cb) {
	        this.addEventListener(eventNameToWrap, this['_on' + eventNameToWrap] = cb);
	      }
	    },

	    enumerable: true,
	    configurable: true
	  });
	}

	function disableLog(bool) {
	  if (typeof bool !== 'boolean') {
	    return new Error('Argument type: ' + (typeof bool === 'undefined' ? 'undefined' : _typeof(bool)) + '. Please use a boolean.');
	  }
	  logDisabled_ = bool;
	  return bool ? 'adapter.js logging disabled' : 'adapter.js logging enabled';
	}

	/**
	 * Disable or enable deprecation warnings
	 * @param {!boolean} bool set to true to disable warnings.
	 */
	function disableWarnings(bool) {
	  if (typeof bool !== 'boolean') {
	    return new Error('Argument type: ' + (typeof bool === 'undefined' ? 'undefined' : _typeof(bool)) + '. Please use a boolean.');
	  }
	  deprecationWarnings_ = !bool;
	  return 'adapter.js deprecation warnings ' + (bool ? 'disabled' : 'enabled');
	}

	function log() {
	  if ((typeof window === 'undefined' ? 'undefined' : _typeof(window)) === 'object') {
	    if (logDisabled_) {
	      return;
	    }
	    if (typeof console !== 'undefined' && typeof console.log === 'function') {
	      console.log.apply(console, arguments);
	    }
	  }
	}

	/**
	 * Shows a deprecation warning suggesting the modern and spec-compatible API.
	 */
	function deprecated(oldMethod, newMethod) {
	  if (!deprecationWarnings_) {
	    return;
	  }
	  console.warn(oldMethod + ' is deprecated, please use ' + newMethod + ' instead.');
	}

	/**
	 * Browser detector.
	 *
	 * @return {object} result containing browser and version
	 *     properties.
	 */
	function detectBrowser(window) {
	  var navigator = window.navigator;

	  // Returned result object.

	  var result = { browser: null, version: null };

	  // Fail early if it's not a browser
	  if (typeof window === 'undefined' || !window.navigator) {
	    result.browser = 'Not a browser.';
	    return result;
	  }

	  if (navigator.mozGetUserMedia) {
	    // Firefox.
	    result.browser = 'firefox';
	    result.version = extractVersion(navigator.userAgent, /Firefox\/(\d+)\./, 1);
	  } else if (navigator.webkitGetUserMedia || window.isSecureContext === false && window.webkitRTCPeerConnection && !window.RTCIceGatherer) {
	    // Chrome, Chromium, Webview, Opera.
	    // Version matches Chrome/WebRTC version.
	    // Chrome 74 removed webkitGetUserMedia on http as well so we need the
	    // more complicated fallback to webkitRTCPeerConnection.
	    result.browser = 'chrome';
	    result.version = extractVersion(navigator.userAgent, /Chrom(e|ium)\/(\d+)\./, 2);
	  } else if (navigator.mediaDevices && navigator.userAgent.match(/Edge\/(\d+).(\d+)$/)) {
	    // Edge.
	    result.browser = 'edge';
	    result.version = extractVersion(navigator.userAgent, /Edge\/(\d+).(\d+)$/, 2);
	  } else if (window.RTCPeerConnection && navigator.userAgent.match(/AppleWebKit\/(\d+)\./)) {
	    // Safari.
	    result.browser = 'safari';
	    result.version = extractVersion(navigator.userAgent, /AppleWebKit\/(\d+)\./, 1);
	    result.supportsUnifiedPlan = window.RTCRtpTransceiver && 'currentDirection' in window.RTCRtpTransceiver.prototype;
	  } else {
	    // Default fallthrough: not supported.
	    result.browser = 'Not a supported browser.';
	    return result;
	  }

	  return result;
	}

	/**
	 * Checks if something is an object.
	 *
	 * @param {*} val The something you want to check.
	 * @return true if val is an object, false otherwise.
	 */
	function isObject(val) {
	  return Object.prototype.toString.call(val) === '[object Object]';
	}

	/**
	 * Remove all empty objects and undefined values
	 * from a nested object -- an enhanced and vanilla version
	 * of Lodash's `compact`.
	 */
	function compactObject(data) {
	  if (!isObject(data)) {
	    return data;
	  }

	  return Object.keys(data).reduce(function (accumulator, key) {
	    var isObj = isObject(data[key]);
	    var value = isObj ? compactObject(data[key]) : data[key];
	    var isEmptyObject = isObj && !Object.keys(value).length;
	    if (value === undefined || isEmptyObject) {
	      return accumulator;
	    }
	    return Object.assign(accumulator, _defineProperty({}, key, value));
	  }, {});
	}

	/* iterates the stats graph recursively. */
	function walkStats(stats, base, resultSet) {
	  if (!base || resultSet.has(base.id)) {
	    return;
	  }
	  resultSet.set(base.id, base);
	  Object.keys(base).forEach(function (name) {
	    if (name.endsWith('Id')) {
	      walkStats(stats, stats.get(base[name]), resultSet);
	    } else if (name.endsWith('Ids')) {
	      base[name].forEach(function (id) {
	        walkStats(stats, stats.get(id), resultSet);
	      });
	    }
	  });
	}

	/* filter getStats for a sender/receiver track. */
	function filterStats(result, track, outbound) {
	  var streamStatsType = outbound ? 'outbound-rtp' : 'inbound-rtp';
	  var filteredResult = new Map();
	  if (track === null) {
	    return filteredResult;
	  }
	  var trackStats = [];
	  result.forEach(function (value) {
	    if (value.type === 'track' && value.trackIdentifier === track.id) {
	      trackStats.push(value);
	    }
	  });
	  trackStats.forEach(function (trackStat) {
	    result.forEach(function (stats) {
	      if (stats.type === streamStatsType && stats.trackId === trackStat.id) {
	        walkStats(result, stats, filteredResult);
	      }
	    });
	  });
	  return filteredResult;
	}
	});

	unwrapExports(utils);
	var utils_1 = utils.extractVersion;
	var utils_2 = utils.wrapPeerConnectionEvent;
	var utils_3 = utils.disableLog;
	var utils_4 = utils.disableWarnings;
	var utils_5 = utils.log;
	var utils_6 = utils.deprecated;
	var utils_7 = utils.detectBrowser;
	var utils_8 = utils.compactObject;
	var utils_9 = utils.walkStats;
	var utils_10 = utils.filterStats;

	var getusermedia = createCommonjsModule(function (module, exports) {

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

	exports.shimGetUserMedia = shimGetUserMedia;



	var utils$1 = _interopRequireWildcard(utils);

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

	var logging = utils$1.log;

	function shimGetUserMedia(window) {
	  var navigator = window && window.navigator;

	  if (!navigator.mediaDevices) {
	    return;
	  }

	  var browserDetails = utils$1.detectBrowser(window);

	  var constraintsToChrome_ = function constraintsToChrome_(c) {
	    if ((typeof c === 'undefined' ? 'undefined' : _typeof(c)) !== 'object' || c.mandatory || c.optional) {
	      return c;
	    }
	    var cc = {};
	    Object.keys(c).forEach(function (key) {
	      if (key === 'require' || key === 'advanced' || key === 'mediaSource') {
	        return;
	      }
	      var r = _typeof(c[key]) === 'object' ? c[key] : { ideal: c[key] };
	      if (r.exact !== undefined && typeof r.exact === 'number') {
	        r.min = r.max = r.exact;
	      }
	      var oldname_ = function oldname_(prefix, name) {
	        if (prefix) {
	          return prefix + name.charAt(0).toUpperCase() + name.slice(1);
	        }
	        return name === 'deviceId' ? 'sourceId' : name;
	      };
	      if (r.ideal !== undefined) {
	        cc.optional = cc.optional || [];
	        var oc = {};
	        if (typeof r.ideal === 'number') {
	          oc[oldname_('min', key)] = r.ideal;
	          cc.optional.push(oc);
	          oc = {};
	          oc[oldname_('max', key)] = r.ideal;
	          cc.optional.push(oc);
	        } else {
	          oc[oldname_('', key)] = r.ideal;
	          cc.optional.push(oc);
	        }
	      }
	      if (r.exact !== undefined && typeof r.exact !== 'number') {
	        cc.mandatory = cc.mandatory || {};
	        cc.mandatory[oldname_('', key)] = r.exact;
	      } else {
	        ['min', 'max'].forEach(function (mix) {
	          if (r[mix] !== undefined) {
	            cc.mandatory = cc.mandatory || {};
	            cc.mandatory[oldname_(mix, key)] = r[mix];
	          }
	        });
	      }
	    });
	    if (c.advanced) {
	      cc.optional = (cc.optional || []).concat(c.advanced);
	    }
	    return cc;
	  };

	  var shimConstraints_ = function shimConstraints_(constraints, func) {
	    if (browserDetails.version >= 61) {
	      return func(constraints);
	    }
	    constraints = JSON.parse(JSON.stringify(constraints));
	    if (constraints && _typeof(constraints.audio) === 'object') {
	      var remap = function remap(obj, a, b) {
	        if (a in obj && !(b in obj)) {
	          obj[b] = obj[a];
	          delete obj[a];
	        }
	      };
	      constraints = JSON.parse(JSON.stringify(constraints));
	      remap(constraints.audio, 'autoGainControl', 'googAutoGainControl');
	      remap(constraints.audio, 'noiseSuppression', 'googNoiseSuppression');
	      constraints.audio = constraintsToChrome_(constraints.audio);
	    }
	    if (constraints && _typeof(constraints.video) === 'object') {
	      // Shim facingMode for mobile & surface pro.
	      var face = constraints.video.facingMode;
	      face = face && ((typeof face === 'undefined' ? 'undefined' : _typeof(face)) === 'object' ? face : { ideal: face });
	      var getSupportedFacingModeLies = browserDetails.version < 66;

	      if (face && (face.exact === 'user' || face.exact === 'environment' || face.ideal === 'user' || face.ideal === 'environment') && !(navigator.mediaDevices.getSupportedConstraints && navigator.mediaDevices.getSupportedConstraints().facingMode && !getSupportedFacingModeLies)) {
	        delete constraints.video.facingMode;
	        var matches = void 0;
	        if (face.exact === 'environment' || face.ideal === 'environment') {
	          matches = ['back', 'rear'];
	        } else if (face.exact === 'user' || face.ideal === 'user') {
	          matches = ['front'];
	        }
	        if (matches) {
	          // Look for matches in label, or use last cam for back (typical).
	          return navigator.mediaDevices.enumerateDevices().then(function (devices) {
	            devices = devices.filter(function (d) {
	              return d.kind === 'videoinput';
	            });
	            var dev = devices.find(function (d) {
	              return matches.some(function (match) {
	                return d.label.toLowerCase().includes(match);
	              });
	            });
	            if (!dev && devices.length && matches.includes('back')) {
	              dev = devices[devices.length - 1]; // more likely the back cam
	            }
	            if (dev) {
	              constraints.video.deviceId = face.exact ? { exact: dev.deviceId } : { ideal: dev.deviceId };
	            }
	            constraints.video = constraintsToChrome_(constraints.video);
	            logging('chrome: ' + JSON.stringify(constraints));
	            return func(constraints);
	          });
	        }
	      }
	      constraints.video = constraintsToChrome_(constraints.video);
	    }
	    logging('chrome: ' + JSON.stringify(constraints));
	    return func(constraints);
	  };

	  var shimError_ = function shimError_(e) {
	    if (browserDetails.version >= 64) {
	      return e;
	    }
	    return {
	      name: {
	        PermissionDeniedError: 'NotAllowedError',
	        PermissionDismissedError: 'NotAllowedError',
	        InvalidStateError: 'NotAllowedError',
	        DevicesNotFoundError: 'NotFoundError',
	        ConstraintNotSatisfiedError: 'OverconstrainedError',
	        TrackStartError: 'NotReadableError',
	        MediaDeviceFailedDueToShutdown: 'NotAllowedError',
	        MediaDeviceKillSwitchOn: 'NotAllowedError',
	        TabCaptureError: 'AbortError',
	        ScreenCaptureError: 'AbortError',
	        DeviceCaptureError: 'AbortError'
	      }[e.name] || e.name,
	      message: e.message,
	      constraint: e.constraint || e.constraintName,
	      toString: function toString() {
	        return this.name + (this.message && ': ') + this.message;
	      }
	    };
	  };

	  var getUserMedia_ = function getUserMedia_(constraints, onSuccess, onError) {
	    shimConstraints_(constraints, function (c) {
	      navigator.webkitGetUserMedia(c, onSuccess, function (e) {
	        if (onError) {
	          onError(shimError_(e));
	        }
	      });
	    });
	  };
	  navigator.getUserMedia = getUserMedia_.bind(navigator);

	  // Even though Chrome 45 has navigator.mediaDevices and a getUserMedia
	  // function which returns a Promise, it does not accept spec-style
	  // constraints.
	  if (navigator.mediaDevices.getUserMedia) {
	    var origGetUserMedia = navigator.mediaDevices.getUserMedia.bind(navigator.mediaDevices);
	    navigator.mediaDevices.getUserMedia = function (cs) {
	      return shimConstraints_(cs, function (c) {
	        return origGetUserMedia(c).then(function (stream) {
	          if (c.audio && !stream.getAudioTracks().length || c.video && !stream.getVideoTracks().length) {
	            stream.getTracks().forEach(function (track) {
	              track.stop();
	            });
	            throw new DOMException('', 'NotFoundError');
	          }
	          return stream;
	        }, function (e) {
	          return Promise.reject(shimError_(e));
	        });
	      });
	    };
	  }
	}
	});

	unwrapExports(getusermedia);
	var getusermedia_1 = getusermedia.shimGetUserMedia;

	var getdisplaymedia = createCommonjsModule(function (module, exports) {

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.shimGetDisplayMedia = shimGetDisplayMedia;
	function shimGetDisplayMedia(window, getSourceId) {
	  if (window.navigator.mediaDevices && 'getDisplayMedia' in window.navigator.mediaDevices) {
	    return;
	  }
	  if (!window.navigator.mediaDevices) {
	    return;
	  }
	  // getSourceId is a function that returns a promise resolving with
	  // the sourceId of the screen/window/tab to be shared.
	  if (typeof getSourceId !== 'function') {
	    console.error('shimGetDisplayMedia: getSourceId argument is not ' + 'a function');
	    return;
	  }
	  window.navigator.mediaDevices.getDisplayMedia = function getDisplayMedia(constraints) {
	    return getSourceId(constraints).then(function (sourceId) {
	      var widthSpecified = constraints.video && constraints.video.width;
	      var heightSpecified = constraints.video && constraints.video.height;
	      var frameRateSpecified = constraints.video && constraints.video.frameRate;
	      constraints.video = {
	        mandatory: {
	          chromeMediaSource: 'desktop',
	          chromeMediaSourceId: sourceId,
	          maxFrameRate: frameRateSpecified || 3
	        }
	      };
	      if (widthSpecified) {
	        constraints.video.mandatory.maxWidth = widthSpecified;
	      }
	      if (heightSpecified) {
	        constraints.video.mandatory.maxHeight = heightSpecified;
	      }
	      return window.navigator.mediaDevices.getUserMedia(constraints);
	    });
	  };
	}
	});

	unwrapExports(getdisplaymedia);
	var getdisplaymedia_1 = getdisplaymedia.shimGetDisplayMedia;

	var chrome_shim = createCommonjsModule(function (module, exports) {

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.shimGetDisplayMedia = exports.shimGetUserMedia = undefined;

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };



	Object.defineProperty(exports, 'shimGetUserMedia', {
	  enumerable: true,
	  get: function get() {
	    return getusermedia.shimGetUserMedia;
	  }
	});



	Object.defineProperty(exports, 'shimGetDisplayMedia', {
	  enumerable: true,
	  get: function get() {
	    return getdisplaymedia.shimGetDisplayMedia;
	  }
	});
	exports.shimMediaStream = shimMediaStream;
	exports.shimOnTrack = shimOnTrack;
	exports.shimGetSendersWithDtmf = shimGetSendersWithDtmf;
	exports.shimGetStats = shimGetStats;
	exports.shimSenderReceiverGetStats = shimSenderReceiverGetStats;
	exports.shimAddTrackRemoveTrackWithNative = shimAddTrackRemoveTrackWithNative;
	exports.shimAddTrackRemoveTrack = shimAddTrackRemoveTrack;
	exports.shimPeerConnection = shimPeerConnection;
	exports.fixNegotiationNeeded = fixNegotiationNeeded;



	var utils$1 = _interopRequireWildcard(utils);

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

	function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

	function shimMediaStream(window) {
	  window.MediaStream = window.MediaStream || window.webkitMediaStream;
	}

	function shimOnTrack(window) {
	  if ((typeof window === 'undefined' ? 'undefined' : _typeof(window)) === 'object' && window.RTCPeerConnection && !('ontrack' in window.RTCPeerConnection.prototype)) {
	    Object.defineProperty(window.RTCPeerConnection.prototype, 'ontrack', {
	      get: function get() {
	        return this._ontrack;
	      },
	      set: function set(f) {
	        if (this._ontrack) {
	          this.removeEventListener('track', this._ontrack);
	        }
	        this.addEventListener('track', this._ontrack = f);
	      },

	      enumerable: true,
	      configurable: true
	    });
	    var origSetRemoteDescription = window.RTCPeerConnection.prototype.setRemoteDescription;
	    window.RTCPeerConnection.prototype.setRemoteDescription = function setRemoteDescription() {
	      var _this = this;

	      if (!this._ontrackpoly) {
	        this._ontrackpoly = function (e) {
	          // onaddstream does not fire when a track is added to an existing
	          // stream. But stream.onaddtrack is implemented so we use that.
	          e.stream.addEventListener('addtrack', function (te) {
	            var receiver = void 0;
	            if (window.RTCPeerConnection.prototype.getReceivers) {
	              receiver = _this.getReceivers().find(function (r) {
	                return r.track && r.track.id === te.track.id;
	              });
	            } else {
	              receiver = { track: te.track };
	            }

	            var event = new Event('track');
	            event.track = te.track;
	            event.receiver = receiver;
	            event.transceiver = { receiver: receiver };
	            event.streams = [e.stream];
	            _this.dispatchEvent(event);
	          });
	          e.stream.getTracks().forEach(function (track) {
	            var receiver = void 0;
	            if (window.RTCPeerConnection.prototype.getReceivers) {
	              receiver = _this.getReceivers().find(function (r) {
	                return r.track && r.track.id === track.id;
	              });
	            } else {
	              receiver = { track: track };
	            }
	            var event = new Event('track');
	            event.track = track;
	            event.receiver = receiver;
	            event.transceiver = { receiver: receiver };
	            event.streams = [e.stream];
	            _this.dispatchEvent(event);
	          });
	        };
	        this.addEventListener('addstream', this._ontrackpoly);
	      }
	      return origSetRemoteDescription.apply(this, arguments);
	    };
	  } else {
	    // even if RTCRtpTransceiver is in window, it is only used and
	    // emitted in unified-plan. Unfortunately this means we need
	    // to unconditionally wrap the event.
	    utils$1.wrapPeerConnectionEvent(window, 'track', function (e) {
	      if (!e.transceiver) {
	        Object.defineProperty(e, 'transceiver', { value: { receiver: e.receiver } });
	      }
	      return e;
	    });
	  }
	}

	function shimGetSendersWithDtmf(window) {
	  // Overrides addTrack/removeTrack, depends on shimAddTrackRemoveTrack.
	  if ((typeof window === 'undefined' ? 'undefined' : _typeof(window)) === 'object' && window.RTCPeerConnection && !('getSenders' in window.RTCPeerConnection.prototype) && 'createDTMFSender' in window.RTCPeerConnection.prototype) {
	    var shimSenderWithDtmf = function shimSenderWithDtmf(pc, track) {
	      return {
	        track: track,
	        get dtmf() {
	          if (this._dtmf === undefined) {
	            if (track.kind === 'audio') {
	              this._dtmf = pc.createDTMFSender(track);
	            } else {
	              this._dtmf = null;
	            }
	          }
	          return this._dtmf;
	        },
	        _pc: pc
	      };
	    };

	    // augment addTrack when getSenders is not available.
	    if (!window.RTCPeerConnection.prototype.getSenders) {
	      window.RTCPeerConnection.prototype.getSenders = function getSenders() {
	        this._senders = this._senders || [];
	        return this._senders.slice(); // return a copy of the internal state.
	      };
	      var origAddTrack = window.RTCPeerConnection.prototype.addTrack;
	      window.RTCPeerConnection.prototype.addTrack = function addTrack(track, stream) {
	        var sender = origAddTrack.apply(this, arguments);
	        if (!sender) {
	          sender = shimSenderWithDtmf(this, track);
	          this._senders.push(sender);
	        }
	        return sender;
	      };

	      var origRemoveTrack = window.RTCPeerConnection.prototype.removeTrack;
	      window.RTCPeerConnection.prototype.removeTrack = function removeTrack(sender) {
	        origRemoveTrack.apply(this, arguments);
	        var idx = this._senders.indexOf(sender);
	        if (idx !== -1) {
	          this._senders.splice(idx, 1);
	        }
	      };
	    }
	    var origAddStream = window.RTCPeerConnection.prototype.addStream;
	    window.RTCPeerConnection.prototype.addStream = function addStream(stream) {
	      var _this2 = this;

	      this._senders = this._senders || [];
	      origAddStream.apply(this, [stream]);
	      stream.getTracks().forEach(function (track) {
	        _this2._senders.push(shimSenderWithDtmf(_this2, track));
	      });
	    };

	    var origRemoveStream = window.RTCPeerConnection.prototype.removeStream;
	    window.RTCPeerConnection.prototype.removeStream = function removeStream(stream) {
	      var _this3 = this;

	      this._senders = this._senders || [];
	      origRemoveStream.apply(this, [stream]);

	      stream.getTracks().forEach(function (track) {
	        var sender = _this3._senders.find(function (s) {
	          return s.track === track;
	        });
	        if (sender) {
	          // remove sender
	          _this3._senders.splice(_this3._senders.indexOf(sender), 1);
	        }
	      });
	    };
	  } else if ((typeof window === 'undefined' ? 'undefined' : _typeof(window)) === 'object' && window.RTCPeerConnection && 'getSenders' in window.RTCPeerConnection.prototype && 'createDTMFSender' in window.RTCPeerConnection.prototype && window.RTCRtpSender && !('dtmf' in window.RTCRtpSender.prototype)) {
	    var origGetSenders = window.RTCPeerConnection.prototype.getSenders;
	    window.RTCPeerConnection.prototype.getSenders = function getSenders() {
	      var _this4 = this;

	      var senders = origGetSenders.apply(this, []);
	      senders.forEach(function (sender) {
	        return sender._pc = _this4;
	      });
	      return senders;
	    };

	    Object.defineProperty(window.RTCRtpSender.prototype, 'dtmf', {
	      get: function get() {
	        if (this._dtmf === undefined) {
	          if (this.track.kind === 'audio') {
	            this._dtmf = this._pc.createDTMFSender(this.track);
	          } else {
	            this._dtmf = null;
	          }
	        }
	        return this._dtmf;
	      }
	    });
	  }
	}

	function shimGetStats(window) {
	  if (!window.RTCPeerConnection) {
	    return;
	  }

	  var origGetStats = window.RTCPeerConnection.prototype.getStats;
	  window.RTCPeerConnection.prototype.getStats = function getStats() {
	    var _this5 = this;

	    var _arguments = Array.prototype.slice.call(arguments),
	        selector = _arguments[0],
	        onSucc = _arguments[1],
	        onErr = _arguments[2];

	    // If selector is a function then we are in the old style stats so just
	    // pass back the original getStats format to avoid breaking old users.


	    if (arguments.length > 0 && typeof selector === 'function') {
	      return origGetStats.apply(this, arguments);
	    }

	    // When spec-style getStats is supported, return those when called with
	    // either no arguments or the selector argument is null.
	    if (origGetStats.length === 0 && (arguments.length === 0 || typeof selector !== 'function')) {
	      return origGetStats.apply(this, []);
	    }

	    var fixChromeStats_ = function fixChromeStats_(response) {
	      var standardReport = {};
	      var reports = response.result();
	      reports.forEach(function (report) {
	        var standardStats = {
	          id: report.id,
	          timestamp: report.timestamp,
	          type: {
	            localcandidate: 'local-candidate',
	            remotecandidate: 'remote-candidate'
	          }[report.type] || report.type
	        };
	        report.names().forEach(function (name) {
	          standardStats[name] = report.stat(name);
	        });
	        standardReport[standardStats.id] = standardStats;
	      });

	      return standardReport;
	    };

	    // shim getStats with maplike support
	    var makeMapStats = function makeMapStats(stats) {
	      return new Map(Object.keys(stats).map(function (key) {
	        return [key, stats[key]];
	      }));
	    };

	    if (arguments.length >= 2) {
	      var successCallbackWrapper_ = function successCallbackWrapper_(response) {
	        onSucc(makeMapStats(fixChromeStats_(response)));
	      };

	      return origGetStats.apply(this, [successCallbackWrapper_, selector]);
	    }

	    // promise-support
	    return new Promise(function (resolve, reject) {
	      origGetStats.apply(_this5, [function (response) {
	        resolve(makeMapStats(fixChromeStats_(response)));
	      }, reject]);
	    }).then(onSucc, onErr);
	  };
	}

	function shimSenderReceiverGetStats(window) {
	  if (!((typeof window === 'undefined' ? 'undefined' : _typeof(window)) === 'object' && window.RTCPeerConnection && window.RTCRtpSender && window.RTCRtpReceiver)) {
	    return;
	  }

	  // shim sender stats.
	  if (!('getStats' in window.RTCRtpSender.prototype)) {
	    var origGetSenders = window.RTCPeerConnection.prototype.getSenders;
	    if (origGetSenders) {
	      window.RTCPeerConnection.prototype.getSenders = function getSenders() {
	        var _this6 = this;

	        var senders = origGetSenders.apply(this, []);
	        senders.forEach(function (sender) {
	          return sender._pc = _this6;
	        });
	        return senders;
	      };
	    }

	    var origAddTrack = window.RTCPeerConnection.prototype.addTrack;
	    if (origAddTrack) {
	      window.RTCPeerConnection.prototype.addTrack = function addTrack() {
	        var sender = origAddTrack.apply(this, arguments);
	        sender._pc = this;
	        return sender;
	      };
	    }
	    window.RTCRtpSender.prototype.getStats = function getStats() {
	      var sender = this;
	      return this._pc.getStats().then(function (result) {
	        return (
	          /* Note: this will include stats of all senders that
	           *   send a track with the same id as sender.track as
	           *   it is not possible to identify the RTCRtpSender.
	           */
	          utils$1.filterStats(result, sender.track, true)
	        );
	      });
	    };
	  }

	  // shim receiver stats.
	  if (!('getStats' in window.RTCRtpReceiver.prototype)) {
	    var origGetReceivers = window.RTCPeerConnection.prototype.getReceivers;
	    if (origGetReceivers) {
	      window.RTCPeerConnection.prototype.getReceivers = function getReceivers() {
	        var _this7 = this;

	        var receivers = origGetReceivers.apply(this, []);
	        receivers.forEach(function (receiver) {
	          return receiver._pc = _this7;
	        });
	        return receivers;
	      };
	    }
	    utils$1.wrapPeerConnectionEvent(window, 'track', function (e) {
	      e.receiver._pc = e.srcElement;
	      return e;
	    });
	    window.RTCRtpReceiver.prototype.getStats = function getStats() {
	      var receiver = this;
	      return this._pc.getStats().then(function (result) {
	        return utils$1.filterStats(result, receiver.track, false);
	      });
	    };
	  }

	  if (!('getStats' in window.RTCRtpSender.prototype && 'getStats' in window.RTCRtpReceiver.prototype)) {
	    return;
	  }

	  // shim RTCPeerConnection.getStats(track).
	  var origGetStats = window.RTCPeerConnection.prototype.getStats;
	  window.RTCPeerConnection.prototype.getStats = function getStats() {
	    if (arguments.length > 0 && arguments[0] instanceof window.MediaStreamTrack) {
	      var track = arguments[0];
	      var sender = void 0;
	      var receiver = void 0;
	      var err = void 0;
	      this.getSenders().forEach(function (s) {
	        if (s.track === track) {
	          if (sender) {
	            err = true;
	          } else {
	            sender = s;
	          }
	        }
	      });
	      this.getReceivers().forEach(function (r) {
	        if (r.track === track) {
	          if (receiver) {
	            err = true;
	          } else {
	            receiver = r;
	          }
	        }
	        return r.track === track;
	      });
	      if (err || sender && receiver) {
	        return Promise.reject(new DOMException('There are more than one sender or receiver for the track.', 'InvalidAccessError'));
	      } else if (sender) {
	        return sender.getStats();
	      } else if (receiver) {
	        return receiver.getStats();
	      }
	      return Promise.reject(new DOMException('There is no sender or receiver for the track.', 'InvalidAccessError'));
	    }
	    return origGetStats.apply(this, arguments);
	  };
	}

	function shimAddTrackRemoveTrackWithNative(window) {
	  // shim addTrack/removeTrack with native variants in order to make
	  // the interactions with legacy getLocalStreams behave as in other browsers.
	  // Keeps a mapping stream.id => [stream, rtpsenders...]
	  window.RTCPeerConnection.prototype.getLocalStreams = function getLocalStreams() {
	    var _this8 = this;

	    this._shimmedLocalStreams = this._shimmedLocalStreams || {};
	    return Object.keys(this._shimmedLocalStreams).map(function (streamId) {
	      return _this8._shimmedLocalStreams[streamId][0];
	    });
	  };

	  var origAddTrack = window.RTCPeerConnection.prototype.addTrack;
	  window.RTCPeerConnection.prototype.addTrack = function addTrack(track, stream) {
	    if (!stream) {
	      return origAddTrack.apply(this, arguments);
	    }
	    this._shimmedLocalStreams = this._shimmedLocalStreams || {};

	    var sender = origAddTrack.apply(this, arguments);
	    if (!this._shimmedLocalStreams[stream.id]) {
	      this._shimmedLocalStreams[stream.id] = [stream, sender];
	    } else if (this._shimmedLocalStreams[stream.id].indexOf(sender) === -1) {
	      this._shimmedLocalStreams[stream.id].push(sender);
	    }
	    return sender;
	  };

	  var origAddStream = window.RTCPeerConnection.prototype.addStream;
	  window.RTCPeerConnection.prototype.addStream = function addStream(stream) {
	    var _this9 = this;

	    this._shimmedLocalStreams = this._shimmedLocalStreams || {};

	    stream.getTracks().forEach(function (track) {
	      var alreadyExists = _this9.getSenders().find(function (s) {
	        return s.track === track;
	      });
	      if (alreadyExists) {
	        throw new DOMException('Track already exists.', 'InvalidAccessError');
	      }
	    });
	    var existingSenders = this.getSenders();
	    origAddStream.apply(this, arguments);
	    var newSenders = this.getSenders().filter(function (newSender) {
	      return existingSenders.indexOf(newSender) === -1;
	    });
	    this._shimmedLocalStreams[stream.id] = [stream].concat(newSenders);
	  };

	  var origRemoveStream = window.RTCPeerConnection.prototype.removeStream;
	  window.RTCPeerConnection.prototype.removeStream = function removeStream(stream) {
	    this._shimmedLocalStreams = this._shimmedLocalStreams || {};
	    delete this._shimmedLocalStreams[stream.id];
	    return origRemoveStream.apply(this, arguments);
	  };

	  var origRemoveTrack = window.RTCPeerConnection.prototype.removeTrack;
	  window.RTCPeerConnection.prototype.removeTrack = function removeTrack(sender) {
	    var _this10 = this;

	    this._shimmedLocalStreams = this._shimmedLocalStreams || {};
	    if (sender) {
	      Object.keys(this._shimmedLocalStreams).forEach(function (streamId) {
	        var idx = _this10._shimmedLocalStreams[streamId].indexOf(sender);
	        if (idx !== -1) {
	          _this10._shimmedLocalStreams[streamId].splice(idx, 1);
	        }
	        if (_this10._shimmedLocalStreams[streamId].length === 1) {
	          delete _this10._shimmedLocalStreams[streamId];
	        }
	      });
	    }
	    return origRemoveTrack.apply(this, arguments);
	  };
	}

	function shimAddTrackRemoveTrack(window) {
	  if (!window.RTCPeerConnection) {
	    return;
	  }
	  var browserDetails = utils$1.detectBrowser(window);
	  // shim addTrack and removeTrack.
	  if (window.RTCPeerConnection.prototype.addTrack && browserDetails.version >= 65) {
	    return shimAddTrackRemoveTrackWithNative(window);
	  }

	  // also shim pc.getLocalStreams when addTrack is shimmed
	  // to return the original streams.
	  var origGetLocalStreams = window.RTCPeerConnection.prototype.getLocalStreams;
	  window.RTCPeerConnection.prototype.getLocalStreams = function getLocalStreams() {
	    var _this11 = this;

	    var nativeStreams = origGetLocalStreams.apply(this);
	    this._reverseStreams = this._reverseStreams || {};
	    return nativeStreams.map(function (stream) {
	      return _this11._reverseStreams[stream.id];
	    });
	  };

	  var origAddStream = window.RTCPeerConnection.prototype.addStream;
	  window.RTCPeerConnection.prototype.addStream = function addStream(stream) {
	    var _this12 = this;

	    this._streams = this._streams || {};
	    this._reverseStreams = this._reverseStreams || {};

	    stream.getTracks().forEach(function (track) {
	      var alreadyExists = _this12.getSenders().find(function (s) {
	        return s.track === track;
	      });
	      if (alreadyExists) {
	        throw new DOMException('Track already exists.', 'InvalidAccessError');
	      }
	    });
	    // Add identity mapping for consistency with addTrack.
	    // Unless this is being used with a stream from addTrack.
	    if (!this._reverseStreams[stream.id]) {
	      var newStream = new window.MediaStream(stream.getTracks());
	      this._streams[stream.id] = newStream;
	      this._reverseStreams[newStream.id] = stream;
	      stream = newStream;
	    }
	    origAddStream.apply(this, [stream]);
	  };

	  var origRemoveStream = window.RTCPeerConnection.prototype.removeStream;
	  window.RTCPeerConnection.prototype.removeStream = function removeStream(stream) {
	    this._streams = this._streams || {};
	    this._reverseStreams = this._reverseStreams || {};

	    origRemoveStream.apply(this, [this._streams[stream.id] || stream]);
	    delete this._reverseStreams[this._streams[stream.id] ? this._streams[stream.id].id : stream.id];
	    delete this._streams[stream.id];
	  };

	  window.RTCPeerConnection.prototype.addTrack = function addTrack(track, stream) {
	    var _this13 = this;

	    if (this.signalingState === 'closed') {
	      throw new DOMException('The RTCPeerConnection\'s signalingState is \'closed\'.', 'InvalidStateError');
	    }
	    var streams = [].slice.call(arguments, 1);
	    if (streams.length !== 1 || !streams[0].getTracks().find(function (t) {
	      return t === track;
	    })) {
	      // this is not fully correct but all we can manage without
	      // [[associated MediaStreams]] internal slot.
	      throw new DOMException('The adapter.js addTrack polyfill only supports a single ' + ' stream which is associated with the specified track.', 'NotSupportedError');
	    }

	    var alreadyExists = this.getSenders().find(function (s) {
	      return s.track === track;
	    });
	    if (alreadyExists) {
	      throw new DOMException('Track already exists.', 'InvalidAccessError');
	    }

	    this._streams = this._streams || {};
	    this._reverseStreams = this._reverseStreams || {};
	    var oldStream = this._streams[stream.id];
	    if (oldStream) {
	      // this is using odd Chrome behaviour, use with caution:
	      // https://bugs.chromium.org/p/webrtc/issues/detail?id=7815
	      // Note: we rely on the high-level addTrack/dtmf shim to
	      // create the sender with a dtmf sender.
	      oldStream.addTrack(track);

	      // Trigger ONN async.
	      Promise.resolve().then(function () {
	        _this13.dispatchEvent(new Event('negotiationneeded'));
	      });
	    } else {
	      var newStream = new window.MediaStream([track]);
	      this._streams[stream.id] = newStream;
	      this._reverseStreams[newStream.id] = stream;
	      this.addStream(newStream);
	    }
	    return this.getSenders().find(function (s) {
	      return s.track === track;
	    });
	  };

	  // replace the internal stream id with the external one and
	  // vice versa.
	  function replaceInternalStreamId(pc, description) {
	    var sdp = description.sdp;
	    Object.keys(pc._reverseStreams || []).forEach(function (internalId) {
	      var externalStream = pc._reverseStreams[internalId];
	      var internalStream = pc._streams[externalStream.id];
	      sdp = sdp.replace(new RegExp(internalStream.id, 'g'), externalStream.id);
	    });
	    return new RTCSessionDescription({
	      type: description.type,
	      sdp: sdp
	    });
	  }
	  function replaceExternalStreamId(pc, description) {
	    var sdp = description.sdp;
	    Object.keys(pc._reverseStreams || []).forEach(function (internalId) {
	      var externalStream = pc._reverseStreams[internalId];
	      var internalStream = pc._streams[externalStream.id];
	      sdp = sdp.replace(new RegExp(externalStream.id, 'g'), internalStream.id);
	    });
	    return new RTCSessionDescription({
	      type: description.type,
	      sdp: sdp
	    });
	  }
	  ['createOffer', 'createAnswer'].forEach(function (method) {
	    var nativeMethod = window.RTCPeerConnection.prototype[method];
	    var methodObj = _defineProperty({}, method, function () {
	      var _this14 = this;

	      var args = arguments;
	      var isLegacyCall = arguments.length && typeof arguments[0] === 'function';
	      if (isLegacyCall) {
	        return nativeMethod.apply(this, [function (description) {
	          var desc = replaceInternalStreamId(_this14, description);
	          args[0].apply(null, [desc]);
	        }, function (err) {
	          if (args[1]) {
	            args[1].apply(null, err);
	          }
	        }, arguments[2]]);
	      }
	      return nativeMethod.apply(this, arguments).then(function (description) {
	        return replaceInternalStreamId(_this14, description);
	      });
	    });
	    window.RTCPeerConnection.prototype[method] = methodObj[method];
	  });

	  var origSetLocalDescription = window.RTCPeerConnection.prototype.setLocalDescription;
	  window.RTCPeerConnection.prototype.setLocalDescription = function setLocalDescription() {
	    if (!arguments.length || !arguments[0].type) {
	      return origSetLocalDescription.apply(this, arguments);
	    }
	    arguments[0] = replaceExternalStreamId(this, arguments[0]);
	    return origSetLocalDescription.apply(this, arguments);
	  };

	  // TODO: mangle getStats: https://w3c.github.io/webrtc-stats/#dom-rtcmediastreamstats-streamidentifier

	  var origLocalDescription = Object.getOwnPropertyDescriptor(window.RTCPeerConnection.prototype, 'localDescription');
	  Object.defineProperty(window.RTCPeerConnection.prototype, 'localDescription', {
	    get: function get() {
	      var description = origLocalDescription.get.apply(this);
	      if (description.type === '') {
	        return description;
	      }
	      return replaceInternalStreamId(this, description);
	    }
	  });

	  window.RTCPeerConnection.prototype.removeTrack = function removeTrack(sender) {
	    var _this15 = this;

	    if (this.signalingState === 'closed') {
	      throw new DOMException('The RTCPeerConnection\'s signalingState is \'closed\'.', 'InvalidStateError');
	    }
	    // We can not yet check for sender instanceof RTCRtpSender
	    // since we shim RTPSender. So we check if sender._pc is set.
	    if (!sender._pc) {
	      throw new DOMException('Argument 1 of RTCPeerConnection.removeTrack ' + 'does not implement interface RTCRtpSender.', 'TypeError');
	    }
	    var isLocal = sender._pc === this;
	    if (!isLocal) {
	      throw new DOMException('Sender was not created by this connection.', 'InvalidAccessError');
	    }

	    // Search for the native stream the senders track belongs to.
	    this._streams = this._streams || {};
	    var stream = void 0;
	    Object.keys(this._streams).forEach(function (streamid) {
	      var hasTrack = _this15._streams[streamid].getTracks().find(function (track) {
	        return sender.track === track;
	      });
	      if (hasTrack) {
	        stream = _this15._streams[streamid];
	      }
	    });

	    if (stream) {
	      if (stream.getTracks().length === 1) {
	        // if this is the last track of the stream, remove the stream. This
	        // takes care of any shimmed _senders.
	        this.removeStream(this._reverseStreams[stream.id]);
	      } else {
	        // relying on the same odd chrome behaviour as above.
	        stream.removeTrack(sender.track);
	      }
	      this.dispatchEvent(new Event('negotiationneeded'));
	    }
	  };
	}

	function shimPeerConnection(window) {
	  var browserDetails = utils$1.detectBrowser(window);

	  if (!window.RTCPeerConnection && window.webkitRTCPeerConnection) {
	    // very basic support for old versions.
	    window.RTCPeerConnection = window.webkitRTCPeerConnection;
	  }
	  if (!window.RTCPeerConnection) {
	    return;
	  }

	  // shim implicit creation of RTCSessionDescription/RTCIceCandidate
	  if (browserDetails.version < 53) {
	    ['setLocalDescription', 'setRemoteDescription', 'addIceCandidate'].forEach(function (method) {
	      var nativeMethod = window.RTCPeerConnection.prototype[method];
	      var methodObj = _defineProperty({}, method, function () {
	        arguments[0] = new (method === 'addIceCandidate' ? window.RTCIceCandidate : window.RTCSessionDescription)(arguments[0]);
	        return nativeMethod.apply(this, arguments);
	      });
	      window.RTCPeerConnection.prototype[method] = methodObj[method];
	    });
	  }

	  // support for addIceCandidate(null or undefined)
	  var nativeAddIceCandidate = window.RTCPeerConnection.prototype.addIceCandidate;
	  window.RTCPeerConnection.prototype.addIceCandidate = function addIceCandidate() {
	    if (!arguments[0]) {
	      if (arguments[1]) {
	        arguments[1].apply(null);
	      }
	      return Promise.resolve();
	    }
	    // Firefox 68+ emits and processes {candidate: "", ...}, ignore
	    // in older versions. Native support planned for Chrome M77.
	    if (browserDetails.version < 78 && arguments[0] && arguments[0].candidate === '') {
	      return Promise.resolve();
	    }
	    return nativeAddIceCandidate.apply(this, arguments);
	  };
	}

	function fixNegotiationNeeded(window) {
	  utils$1.wrapPeerConnectionEvent(window, 'negotiationneeded', function (e) {
	    var pc = e.target;
	    if (pc.signalingState !== 'stable') {
	      return;
	    }
	    return e;
	  });
	}
	});

	unwrapExports(chrome_shim);
	var chrome_shim_1 = chrome_shim.shimGetDisplayMedia;
	var chrome_shim_2 = chrome_shim.shimGetUserMedia;
	var chrome_shim_3 = chrome_shim.shimMediaStream;
	var chrome_shim_4 = chrome_shim.shimOnTrack;
	var chrome_shim_5 = chrome_shim.shimGetSendersWithDtmf;
	var chrome_shim_6 = chrome_shim.shimGetStats;
	var chrome_shim_7 = chrome_shim.shimSenderReceiverGetStats;
	var chrome_shim_8 = chrome_shim.shimAddTrackRemoveTrackWithNative;
	var chrome_shim_9 = chrome_shim.shimAddTrackRemoveTrack;
	var chrome_shim_10 = chrome_shim.shimPeerConnection;
	var chrome_shim_11 = chrome_shim.fixNegotiationNeeded;

	var getusermedia$1 = createCommonjsModule(function (module, exports) {

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.shimGetUserMedia = shimGetUserMedia;
	function shimGetUserMedia(window) {
	  var navigator = window && window.navigator;

	  var shimError_ = function shimError_(e) {
	    return {
	      name: { PermissionDeniedError: 'NotAllowedError' }[e.name] || e.name,
	      message: e.message,
	      constraint: e.constraint,
	      toString: function toString() {
	        return this.name;
	      }
	    };
	  };

	  // getUserMedia error shim.
	  var origGetUserMedia = navigator.mediaDevices.getUserMedia.bind(navigator.mediaDevices);
	  navigator.mediaDevices.getUserMedia = function (c) {
	    return origGetUserMedia(c).catch(function (e) {
	      return Promise.reject(shimError_(e));
	    });
	  };
	}
	});

	unwrapExports(getusermedia$1);
	var getusermedia_1$1 = getusermedia$1.shimGetUserMedia;

	var getdisplaymedia$1 = createCommonjsModule(function (module, exports) {

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.shimGetDisplayMedia = shimGetDisplayMedia;
	function shimGetDisplayMedia(window) {
	  if (!('getDisplayMedia' in window.navigator)) {
	    return;
	  }
	  if (!window.navigator.mediaDevices) {
	    return;
	  }
	  if (window.navigator.mediaDevices && 'getDisplayMedia' in window.navigator.mediaDevices) {
	    return;
	  }
	  window.navigator.mediaDevices.getDisplayMedia = window.navigator.getDisplayMedia.bind(window.navigator);
	}
	});

	unwrapExports(getdisplaymedia$1);
	var getdisplaymedia_1$1 = getdisplaymedia$1.shimGetDisplayMedia;

	var filtericeservers = createCommonjsModule(function (module, exports) {

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.filterIceServers = filterIceServers;



	var utils$1 = _interopRequireWildcard(utils);

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

	// Edge does not like
	// 1) stun: filtered after 14393 unless ?transport=udp is present
	// 2) turn: that does not have all of turn:host:port?transport=udp
	// 3) turn: with ipv6 addresses
	// 4) turn: occurring muliple times
	function filterIceServers(iceServers, edgeVersion) {
	  var hasTurn = false;
	  iceServers = JSON.parse(JSON.stringify(iceServers));
	  return iceServers.filter(function (server) {
	    if (server && (server.urls || server.url)) {
	      var urls = server.urls || server.url;
	      if (server.url && !server.urls) {
	        utils$1.deprecated('RTCIceServer.url', 'RTCIceServer.urls');
	      }
	      var isString = typeof urls === 'string';
	      if (isString) {
	        urls = [urls];
	      }
	      urls = urls.filter(function (url) {
	        // filter STUN unconditionally.
	        if (url.indexOf('stun:') === 0) {
	          return false;
	        }

	        var validTurn = url.startsWith('turn') && !url.startsWith('turn:[') && url.includes('transport=udp');
	        if (validTurn && !hasTurn) {
	          hasTurn = true;
	          return true;
	        }
	        return validTurn && !hasTurn;
	      });

	      delete server.url;
	      server.urls = isString ? urls[0] : urls;
	      return !!urls.length;
	    }
	  });
	}
	});

	unwrapExports(filtericeservers);
	var filtericeservers_1 = filtericeservers.filterIceServers;

	var sdp = createCommonjsModule(function (module) {

	// SDP helpers.
	var SDPUtils = {};

	// Generate an alphanumeric identifier for cname or mids.
	// TODO: use UUIDs instead? https://gist.github.com/jed/982883
	SDPUtils.generateIdentifier = function() {
	  return Math.random().toString(36).substr(2, 10);
	};

	// The RTCP CNAME used by all peerconnections from the same JS.
	SDPUtils.localCName = SDPUtils.generateIdentifier();

	// Splits SDP into lines, dealing with both CRLF and LF.
	SDPUtils.splitLines = function(blob) {
	  return blob.trim().split('\n').map(function(line) {
	    return line.trim();
	  });
	};
	// Splits SDP into sessionpart and mediasections. Ensures CRLF.
	SDPUtils.splitSections = function(blob) {
	  var parts = blob.split('\nm=');
	  return parts.map(function(part, index) {
	    return (index > 0 ? 'm=' + part : part).trim() + '\r\n';
	  });
	};

	// returns the session description.
	SDPUtils.getDescription = function(blob) {
	  var sections = SDPUtils.splitSections(blob);
	  return sections && sections[0];
	};

	// returns the individual media sections.
	SDPUtils.getMediaSections = function(blob) {
	  var sections = SDPUtils.splitSections(blob);
	  sections.shift();
	  return sections;
	};

	// Returns lines that start with a certain prefix.
	SDPUtils.matchPrefix = function(blob, prefix) {
	  return SDPUtils.splitLines(blob).filter(function(line) {
	    return line.indexOf(prefix) === 0;
	  });
	};

	// Parses an ICE candidate line. Sample input:
	// candidate:702786350 2 udp 41819902 8.8.8.8 60769 typ relay raddr 8.8.8.8
	// rport 55996"
	SDPUtils.parseCandidate = function(line) {
	  var parts;
	  // Parse both variants.
	  if (line.indexOf('a=candidate:') === 0) {
	    parts = line.substring(12).split(' ');
	  } else {
	    parts = line.substring(10).split(' ');
	  }

	  var candidate = {
	    foundation: parts[0],
	    component: parseInt(parts[1], 10),
	    protocol: parts[2].toLowerCase(),
	    priority: parseInt(parts[3], 10),
	    ip: parts[4],
	    address: parts[4], // address is an alias for ip.
	    port: parseInt(parts[5], 10),
	    // skip parts[6] == 'typ'
	    type: parts[7]
	  };

	  for (var i = 8; i < parts.length; i += 2) {
	    switch (parts[i]) {
	      case 'raddr':
	        candidate.relatedAddress = parts[i + 1];
	        break;
	      case 'rport':
	        candidate.relatedPort = parseInt(parts[i + 1], 10);
	        break;
	      case 'tcptype':
	        candidate.tcpType = parts[i + 1];
	        break;
	      case 'ufrag':
	        candidate.ufrag = parts[i + 1]; // for backward compability.
	        candidate.usernameFragment = parts[i + 1];
	        break;
	      default: // extension handling, in particular ufrag
	        candidate[parts[i]] = parts[i + 1];
	        break;
	    }
	  }
	  return candidate;
	};

	// Translates a candidate object into SDP candidate attribute.
	SDPUtils.writeCandidate = function(candidate) {
	  var sdp = [];
	  sdp.push(candidate.foundation);
	  sdp.push(candidate.component);
	  sdp.push(candidate.protocol.toUpperCase());
	  sdp.push(candidate.priority);
	  sdp.push(candidate.address || candidate.ip);
	  sdp.push(candidate.port);

	  var type = candidate.type;
	  sdp.push('typ');
	  sdp.push(type);
	  if (type !== 'host' && candidate.relatedAddress &&
	      candidate.relatedPort) {
	    sdp.push('raddr');
	    sdp.push(candidate.relatedAddress);
	    sdp.push('rport');
	    sdp.push(candidate.relatedPort);
	  }
	  if (candidate.tcpType && candidate.protocol.toLowerCase() === 'tcp') {
	    sdp.push('tcptype');
	    sdp.push(candidate.tcpType);
	  }
	  if (candidate.usernameFragment || candidate.ufrag) {
	    sdp.push('ufrag');
	    sdp.push(candidate.usernameFragment || candidate.ufrag);
	  }
	  return 'candidate:' + sdp.join(' ');
	};

	// Parses an ice-options line, returns an array of option tags.
	// a=ice-options:foo bar
	SDPUtils.parseIceOptions = function(line) {
	  return line.substr(14).split(' ');
	};

	// Parses an rtpmap line, returns RTCRtpCoddecParameters. Sample input:
	// a=rtpmap:111 opus/48000/2
	SDPUtils.parseRtpMap = function(line) {
	  var parts = line.substr(9).split(' ');
	  var parsed = {
	    payloadType: parseInt(parts.shift(), 10) // was: id
	  };

	  parts = parts[0].split('/');

	  parsed.name = parts[0];
	  parsed.clockRate = parseInt(parts[1], 10); // was: clockrate
	  parsed.channels = parts.length === 3 ? parseInt(parts[2], 10) : 1;
	  // legacy alias, got renamed back to channels in ORTC.
	  parsed.numChannels = parsed.channels;
	  return parsed;
	};

	// Generate an a=rtpmap line from RTCRtpCodecCapability or
	// RTCRtpCodecParameters.
	SDPUtils.writeRtpMap = function(codec) {
	  var pt = codec.payloadType;
	  if (codec.preferredPayloadType !== undefined) {
	    pt = codec.preferredPayloadType;
	  }
	  var channels = codec.channels || codec.numChannels || 1;
	  return 'a=rtpmap:' + pt + ' ' + codec.name + '/' + codec.clockRate +
	      (channels !== 1 ? '/' + channels : '') + '\r\n';
	};

	// Parses an a=extmap line (headerextension from RFC 5285). Sample input:
	// a=extmap:2 urn:ietf:params:rtp-hdrext:toffset
	// a=extmap:2/sendonly urn:ietf:params:rtp-hdrext:toffset
	SDPUtils.parseExtmap = function(line) {
	  var parts = line.substr(9).split(' ');
	  return {
	    id: parseInt(parts[0], 10),
	    direction: parts[0].indexOf('/') > 0 ? parts[0].split('/')[1] : 'sendrecv',
	    uri: parts[1]
	  };
	};

	// Generates a=extmap line from RTCRtpHeaderExtensionParameters or
	// RTCRtpHeaderExtension.
	SDPUtils.writeExtmap = function(headerExtension) {
	  return 'a=extmap:' + (headerExtension.id || headerExtension.preferredId) +
	      (headerExtension.direction && headerExtension.direction !== 'sendrecv'
	          ? '/' + headerExtension.direction
	          : '') +
	      ' ' + headerExtension.uri + '\r\n';
	};

	// Parses an ftmp line, returns dictionary. Sample input:
	// a=fmtp:96 vbr=on;cng=on
	// Also deals with vbr=on; cng=on
	SDPUtils.parseFmtp = function(line) {
	  var parsed = {};
	  var kv;
	  var parts = line.substr(line.indexOf(' ') + 1).split(';');
	  for (var j = 0; j < parts.length; j++) {
	    kv = parts[j].trim().split('=');
	    parsed[kv[0].trim()] = kv[1];
	  }
	  return parsed;
	};

	// Generates an a=ftmp line from RTCRtpCodecCapability or RTCRtpCodecParameters.
	SDPUtils.writeFmtp = function(codec) {
	  var line = '';
	  var pt = codec.payloadType;
	  if (codec.preferredPayloadType !== undefined) {
	    pt = codec.preferredPayloadType;
	  }
	  if (codec.parameters && Object.keys(codec.parameters).length) {
	    var params = [];
	    Object.keys(codec.parameters).forEach(function(param) {
	      if (codec.parameters[param]) {
	        params.push(param + '=' + codec.parameters[param]);
	      } else {
	        params.push(param);
	      }
	    });
	    line += 'a=fmtp:' + pt + ' ' + params.join(';') + '\r\n';
	  }
	  return line;
	};

	// Parses an rtcp-fb line, returns RTCPRtcpFeedback object. Sample input:
	// a=rtcp-fb:98 nack rpsi
	SDPUtils.parseRtcpFb = function(line) {
	  var parts = line.substr(line.indexOf(' ') + 1).split(' ');
	  return {
	    type: parts.shift(),
	    parameter: parts.join(' ')
	  };
	};
	// Generate a=rtcp-fb lines from RTCRtpCodecCapability or RTCRtpCodecParameters.
	SDPUtils.writeRtcpFb = function(codec) {
	  var lines = '';
	  var pt = codec.payloadType;
	  if (codec.preferredPayloadType !== undefined) {
	    pt = codec.preferredPayloadType;
	  }
	  if (codec.rtcpFeedback && codec.rtcpFeedback.length) {
	    // FIXME: special handling for trr-int?
	    codec.rtcpFeedback.forEach(function(fb) {
	      lines += 'a=rtcp-fb:' + pt + ' ' + fb.type +
	      (fb.parameter && fb.parameter.length ? ' ' + fb.parameter : '') +
	          '\r\n';
	    });
	  }
	  return lines;
	};

	// Parses an RFC 5576 ssrc media attribute. Sample input:
	// a=ssrc:3735928559 cname:something
	SDPUtils.parseSsrcMedia = function(line) {
	  var sp = line.indexOf(' ');
	  var parts = {
	    ssrc: parseInt(line.substr(7, sp - 7), 10)
	  };
	  var colon = line.indexOf(':', sp);
	  if (colon > -1) {
	    parts.attribute = line.substr(sp + 1, colon - sp - 1);
	    parts.value = line.substr(colon + 1);
	  } else {
	    parts.attribute = line.substr(sp + 1);
	  }
	  return parts;
	};

	SDPUtils.parseSsrcGroup = function(line) {
	  var parts = line.substr(13).split(' ');
	  return {
	    semantics: parts.shift(),
	    ssrcs: parts.map(function(ssrc) {
	      return parseInt(ssrc, 10);
	    })
	  };
	};

	// Extracts the MID (RFC 5888) from a media section.
	// returns the MID or undefined if no mid line was found.
	SDPUtils.getMid = function(mediaSection) {
	  var mid = SDPUtils.matchPrefix(mediaSection, 'a=mid:')[0];
	  if (mid) {
	    return mid.substr(6);
	  }
	};

	SDPUtils.parseFingerprint = function(line) {
	  var parts = line.substr(14).split(' ');
	  return {
	    algorithm: parts[0].toLowerCase(), // algorithm is case-sensitive in Edge.
	    value: parts[1]
	  };
	};

	// Extracts DTLS parameters from SDP media section or sessionpart.
	// FIXME: for consistency with other functions this should only
	//   get the fingerprint line as input. See also getIceParameters.
	SDPUtils.getDtlsParameters = function(mediaSection, sessionpart) {
	  var lines = SDPUtils.matchPrefix(mediaSection + sessionpart,
	      'a=fingerprint:');
	  // Note: a=setup line is ignored since we use the 'auto' role.
	  // Note2: 'algorithm' is not case sensitive except in Edge.
	  return {
	    role: 'auto',
	    fingerprints: lines.map(SDPUtils.parseFingerprint)
	  };
	};

	// Serializes DTLS parameters to SDP.
	SDPUtils.writeDtlsParameters = function(params, setupType) {
	  var sdp = 'a=setup:' + setupType + '\r\n';
	  params.fingerprints.forEach(function(fp) {
	    sdp += 'a=fingerprint:' + fp.algorithm + ' ' + fp.value + '\r\n';
	  });
	  return sdp;
	};
	// Parses ICE information from SDP media section or sessionpart.
	// FIXME: for consistency with other functions this should only
	//   get the ice-ufrag and ice-pwd lines as input.
	SDPUtils.getIceParameters = function(mediaSection, sessionpart) {
	  var lines = SDPUtils.splitLines(mediaSection);
	  // Search in session part, too.
	  lines = lines.concat(SDPUtils.splitLines(sessionpart));
	  var iceParameters = {
	    usernameFragment: lines.filter(function(line) {
	      return line.indexOf('a=ice-ufrag:') === 0;
	    })[0].substr(12),
	    password: lines.filter(function(line) {
	      return line.indexOf('a=ice-pwd:') === 0;
	    })[0].substr(10)
	  };
	  return iceParameters;
	};

	// Serializes ICE parameters to SDP.
	SDPUtils.writeIceParameters = function(params) {
	  return 'a=ice-ufrag:' + params.usernameFragment + '\r\n' +
	      'a=ice-pwd:' + params.password + '\r\n';
	};

	// Parses the SDP media section and returns RTCRtpParameters.
	SDPUtils.parseRtpParameters = function(mediaSection) {
	  var description = {
	    codecs: [],
	    headerExtensions: [],
	    fecMechanisms: [],
	    rtcp: []
	  };
	  var lines = SDPUtils.splitLines(mediaSection);
	  var mline = lines[0].split(' ');
	  for (var i = 3; i < mline.length; i++) { // find all codecs from mline[3..]
	    var pt = mline[i];
	    var rtpmapline = SDPUtils.matchPrefix(
	        mediaSection, 'a=rtpmap:' + pt + ' ')[0];
	    if (rtpmapline) {
	      var codec = SDPUtils.parseRtpMap(rtpmapline);
	      var fmtps = SDPUtils.matchPrefix(
	          mediaSection, 'a=fmtp:' + pt + ' ');
	      // Only the first a=fmtp:<pt> is considered.
	      codec.parameters = fmtps.length ? SDPUtils.parseFmtp(fmtps[0]) : {};
	      codec.rtcpFeedback = SDPUtils.matchPrefix(
	          mediaSection, 'a=rtcp-fb:' + pt + ' ')
	        .map(SDPUtils.parseRtcpFb);
	      description.codecs.push(codec);
	      // parse FEC mechanisms from rtpmap lines.
	      switch (codec.name.toUpperCase()) {
	        case 'RED':
	        case 'ULPFEC':
	          description.fecMechanisms.push(codec.name.toUpperCase());
	          break;
	        default: // only RED and ULPFEC are recognized as FEC mechanisms.
	          break;
	      }
	    }
	  }
	  SDPUtils.matchPrefix(mediaSection, 'a=extmap:').forEach(function(line) {
	    description.headerExtensions.push(SDPUtils.parseExtmap(line));
	  });
	  // FIXME: parse rtcp.
	  return description;
	};

	// Generates parts of the SDP media section describing the capabilities /
	// parameters.
	SDPUtils.writeRtpDescription = function(kind, caps) {
	  var sdp = '';

	  // Build the mline.
	  sdp += 'm=' + kind + ' ';
	  sdp += caps.codecs.length > 0 ? '9' : '0'; // reject if no codecs.
	  sdp += ' UDP/TLS/RTP/SAVPF ';
	  sdp += caps.codecs.map(function(codec) {
	    if (codec.preferredPayloadType !== undefined) {
	      return codec.preferredPayloadType;
	    }
	    return codec.payloadType;
	  }).join(' ') + '\r\n';

	  sdp += 'c=IN IP4 0.0.0.0\r\n';
	  sdp += 'a=rtcp:9 IN IP4 0.0.0.0\r\n';

	  // Add a=rtpmap lines for each codec. Also fmtp and rtcp-fb.
	  caps.codecs.forEach(function(codec) {
	    sdp += SDPUtils.writeRtpMap(codec);
	    sdp += SDPUtils.writeFmtp(codec);
	    sdp += SDPUtils.writeRtcpFb(codec);
	  });
	  var maxptime = 0;
	  caps.codecs.forEach(function(codec) {
	    if (codec.maxptime > maxptime) {
	      maxptime = codec.maxptime;
	    }
	  });
	  if (maxptime > 0) {
	    sdp += 'a=maxptime:' + maxptime + '\r\n';
	  }
	  sdp += 'a=rtcp-mux\r\n';

	  if (caps.headerExtensions) {
	    caps.headerExtensions.forEach(function(extension) {
	      sdp += SDPUtils.writeExtmap(extension);
	    });
	  }
	  // FIXME: write fecMechanisms.
	  return sdp;
	};

	// Parses the SDP media section and returns an array of
	// RTCRtpEncodingParameters.
	SDPUtils.parseRtpEncodingParameters = function(mediaSection) {
	  var encodingParameters = [];
	  var description = SDPUtils.parseRtpParameters(mediaSection);
	  var hasRed = description.fecMechanisms.indexOf('RED') !== -1;
	  var hasUlpfec = description.fecMechanisms.indexOf('ULPFEC') !== -1;

	  // filter a=ssrc:... cname:, ignore PlanB-msid
	  var ssrcs = SDPUtils.matchPrefix(mediaSection, 'a=ssrc:')
	  .map(function(line) {
	    return SDPUtils.parseSsrcMedia(line);
	  })
	  .filter(function(parts) {
	    return parts.attribute === 'cname';
	  });
	  var primarySsrc = ssrcs.length > 0 && ssrcs[0].ssrc;
	  var secondarySsrc;

	  var flows = SDPUtils.matchPrefix(mediaSection, 'a=ssrc-group:FID')
	  .map(function(line) {
	    var parts = line.substr(17).split(' ');
	    return parts.map(function(part) {
	      return parseInt(part, 10);
	    });
	  });
	  if (flows.length > 0 && flows[0].length > 1 && flows[0][0] === primarySsrc) {
	    secondarySsrc = flows[0][1];
	  }

	  description.codecs.forEach(function(codec) {
	    if (codec.name.toUpperCase() === 'RTX' && codec.parameters.apt) {
	      var encParam = {
	        ssrc: primarySsrc,
	        codecPayloadType: parseInt(codec.parameters.apt, 10)
	      };
	      if (primarySsrc && secondarySsrc) {
	        encParam.rtx = {ssrc: secondarySsrc};
	      }
	      encodingParameters.push(encParam);
	      if (hasRed) {
	        encParam = JSON.parse(JSON.stringify(encParam));
	        encParam.fec = {
	          ssrc: primarySsrc,
	          mechanism: hasUlpfec ? 'red+ulpfec' : 'red'
	        };
	        encodingParameters.push(encParam);
	      }
	    }
	  });
	  if (encodingParameters.length === 0 && primarySsrc) {
	    encodingParameters.push({
	      ssrc: primarySsrc
	    });
	  }

	  // we support both b=AS and b=TIAS but interpret AS as TIAS.
	  var bandwidth = SDPUtils.matchPrefix(mediaSection, 'b=');
	  if (bandwidth.length) {
	    if (bandwidth[0].indexOf('b=TIAS:') === 0) {
	      bandwidth = parseInt(bandwidth[0].substr(7), 10);
	    } else if (bandwidth[0].indexOf('b=AS:') === 0) {
	      // use formula from JSEP to convert b=AS to TIAS value.
	      bandwidth = parseInt(bandwidth[0].substr(5), 10) * 1000 * 0.95
	          - (50 * 40 * 8);
	    } else {
	      bandwidth = undefined;
	    }
	    encodingParameters.forEach(function(params) {
	      params.maxBitrate = bandwidth;
	    });
	  }
	  return encodingParameters;
	};

	// parses http://draft.ortc.org/#rtcrtcpparameters*
	SDPUtils.parseRtcpParameters = function(mediaSection) {
	  var rtcpParameters = {};

	  // Gets the first SSRC. Note tha with RTX there might be multiple
	  // SSRCs.
	  var remoteSsrc = SDPUtils.matchPrefix(mediaSection, 'a=ssrc:')
	      .map(function(line) {
	        return SDPUtils.parseSsrcMedia(line);
	      })
	      .filter(function(obj) {
	        return obj.attribute === 'cname';
	      })[0];
	  if (remoteSsrc) {
	    rtcpParameters.cname = remoteSsrc.value;
	    rtcpParameters.ssrc = remoteSsrc.ssrc;
	  }

	  // Edge uses the compound attribute instead of reducedSize
	  // compound is !reducedSize
	  var rsize = SDPUtils.matchPrefix(mediaSection, 'a=rtcp-rsize');
	  rtcpParameters.reducedSize = rsize.length > 0;
	  rtcpParameters.compound = rsize.length === 0;

	  // parses the rtcp-mux attrіbute.
	  // Note that Edge does not support unmuxed RTCP.
	  var mux = SDPUtils.matchPrefix(mediaSection, 'a=rtcp-mux');
	  rtcpParameters.mux = mux.length > 0;

	  return rtcpParameters;
	};

	// parses either a=msid: or a=ssrc:... msid lines and returns
	// the id of the MediaStream and MediaStreamTrack.
	SDPUtils.parseMsid = function(mediaSection) {
	  var parts;
	  var spec = SDPUtils.matchPrefix(mediaSection, 'a=msid:');
	  if (spec.length === 1) {
	    parts = spec[0].substr(7).split(' ');
	    return {stream: parts[0], track: parts[1]};
	  }
	  var planB = SDPUtils.matchPrefix(mediaSection, 'a=ssrc:')
	  .map(function(line) {
	    return SDPUtils.parseSsrcMedia(line);
	  })
	  .filter(function(msidParts) {
	    return msidParts.attribute === 'msid';
	  });
	  if (planB.length > 0) {
	    parts = planB[0].value.split(' ');
	    return {stream: parts[0], track: parts[1]};
	  }
	};

	// Generate a session ID for SDP.
	// https://tools.ietf.org/html/draft-ietf-rtcweb-jsep-20#section-5.2.1
	// recommends using a cryptographically random +ve 64-bit value
	// but right now this should be acceptable and within the right range
	SDPUtils.generateSessionId = function() {
	  return Math.random().toString().substr(2, 21);
	};

	// Write boilder plate for start of SDP
	// sessId argument is optional - if not supplied it will
	// be generated randomly
	// sessVersion is optional and defaults to 2
	// sessUser is optional and defaults to 'thisisadapterortc'
	SDPUtils.writeSessionBoilerplate = function(sessId, sessVer, sessUser) {
	  var sessionId;
	  var version = sessVer !== undefined ? sessVer : 2;
	  if (sessId) {
	    sessionId = sessId;
	  } else {
	    sessionId = SDPUtils.generateSessionId();
	  }
	  var user = sessUser || 'thisisadapterortc';
	  // FIXME: sess-id should be an NTP timestamp.
	  return 'v=0\r\n' +
	      'o=' + user + ' ' + sessionId + ' ' + version +
	        ' IN IP4 127.0.0.1\r\n' +
	      's=-\r\n' +
	      't=0 0\r\n';
	};

	SDPUtils.writeMediaSection = function(transceiver, caps, type, stream) {
	  var sdp = SDPUtils.writeRtpDescription(transceiver.kind, caps);

	  // Map ICE parameters (ufrag, pwd) to SDP.
	  sdp += SDPUtils.writeIceParameters(
	      transceiver.iceGatherer.getLocalParameters());

	  // Map DTLS parameters to SDP.
	  sdp += SDPUtils.writeDtlsParameters(
	      transceiver.dtlsTransport.getLocalParameters(),
	      type === 'offer' ? 'actpass' : 'active');

	  sdp += 'a=mid:' + transceiver.mid + '\r\n';

	  if (transceiver.direction) {
	    sdp += 'a=' + transceiver.direction + '\r\n';
	  } else if (transceiver.rtpSender && transceiver.rtpReceiver) {
	    sdp += 'a=sendrecv\r\n';
	  } else if (transceiver.rtpSender) {
	    sdp += 'a=sendonly\r\n';
	  } else if (transceiver.rtpReceiver) {
	    sdp += 'a=recvonly\r\n';
	  } else {
	    sdp += 'a=inactive\r\n';
	  }

	  if (transceiver.rtpSender) {
	    // spec.
	    var msid = 'msid:' + stream.id + ' ' +
	        transceiver.rtpSender.track.id + '\r\n';
	    sdp += 'a=' + msid;

	    // for Chrome.
	    sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].ssrc +
	        ' ' + msid;
	    if (transceiver.sendEncodingParameters[0].rtx) {
	      sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].rtx.ssrc +
	          ' ' + msid;
	      sdp += 'a=ssrc-group:FID ' +
	          transceiver.sendEncodingParameters[0].ssrc + ' ' +
	          transceiver.sendEncodingParameters[0].rtx.ssrc +
	          '\r\n';
	    }
	  }
	  // FIXME: this should be written by writeRtpDescription.
	  sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].ssrc +
	      ' cname:' + SDPUtils.localCName + '\r\n';
	  if (transceiver.rtpSender && transceiver.sendEncodingParameters[0].rtx) {
	    sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].rtx.ssrc +
	        ' cname:' + SDPUtils.localCName + '\r\n';
	  }
	  return sdp;
	};

	// Gets the direction from the mediaSection or the sessionpart.
	SDPUtils.getDirection = function(mediaSection, sessionpart) {
	  // Look for sendrecv, sendonly, recvonly, inactive, default to sendrecv.
	  var lines = SDPUtils.splitLines(mediaSection);
	  for (var i = 0; i < lines.length; i++) {
	    switch (lines[i]) {
	      case 'a=sendrecv':
	      case 'a=sendonly':
	      case 'a=recvonly':
	      case 'a=inactive':
	        return lines[i].substr(2);
	      default:
	        // FIXME: What should happen here?
	    }
	  }
	  if (sessionpart) {
	    return SDPUtils.getDirection(sessionpart);
	  }
	  return 'sendrecv';
	};

	SDPUtils.getKind = function(mediaSection) {
	  var lines = SDPUtils.splitLines(mediaSection);
	  var mline = lines[0].split(' ');
	  return mline[0].substr(2);
	};

	SDPUtils.isRejected = function(mediaSection) {
	  return mediaSection.split(' ', 2)[1] === '0';
	};

	SDPUtils.parseMLine = function(mediaSection) {
	  var lines = SDPUtils.splitLines(mediaSection);
	  var parts = lines[0].substr(2).split(' ');
	  return {
	    kind: parts[0],
	    port: parseInt(parts[1], 10),
	    protocol: parts[2],
	    fmt: parts.slice(3).join(' ')
	  };
	};

	SDPUtils.parseOLine = function(mediaSection) {
	  var line = SDPUtils.matchPrefix(mediaSection, 'o=')[0];
	  var parts = line.substr(2).split(' ');
	  return {
	    username: parts[0],
	    sessionId: parts[1],
	    sessionVersion: parseInt(parts[2], 10),
	    netType: parts[3],
	    addressType: parts[4],
	    address: parts[5]
	  };
	};

	// a very naive interpretation of a valid SDP.
	SDPUtils.isValidSDP = function(blob) {
	  if (typeof blob !== 'string' || blob.length === 0) {
	    return false;
	  }
	  var lines = SDPUtils.splitLines(blob);
	  for (var i = 0; i < lines.length; i++) {
	    if (lines[i].length < 2 || lines[i].charAt(1) !== '=') {
	      return false;
	    }
	    // TODO: check the modifier a bit more.
	  }
	  return true;
	};

	// Expose public methods.
	{
	  module.exports = SDPUtils;
	}
	});

	function fixStatsType(stat) {
	  return {
	    inboundrtp: 'inbound-rtp',
	    outboundrtp: 'outbound-rtp',
	    candidatepair: 'candidate-pair',
	    localcandidate: 'local-candidate',
	    remotecandidate: 'remote-candidate'
	  }[stat.type] || stat.type;
	}

	function writeMediaSection(transceiver, caps, type, stream, dtlsRole) {
	  var sdp$1 = sdp.writeRtpDescription(transceiver.kind, caps);

	  // Map ICE parameters (ufrag, pwd) to SDP.
	  sdp$1 += sdp.writeIceParameters(
	      transceiver.iceGatherer.getLocalParameters());

	  // Map DTLS parameters to SDP.
	  sdp$1 += sdp.writeDtlsParameters(
	      transceiver.dtlsTransport.getLocalParameters(),
	      type === 'offer' ? 'actpass' : dtlsRole || 'active');

	  sdp$1 += 'a=mid:' + transceiver.mid + '\r\n';

	  if (transceiver.rtpSender && transceiver.rtpReceiver) {
	    sdp$1 += 'a=sendrecv\r\n';
	  } else if (transceiver.rtpSender) {
	    sdp$1 += 'a=sendonly\r\n';
	  } else if (transceiver.rtpReceiver) {
	    sdp$1 += 'a=recvonly\r\n';
	  } else {
	    sdp$1 += 'a=inactive\r\n';
	  }

	  if (transceiver.rtpSender) {
	    var trackId = transceiver.rtpSender._initialTrackId ||
	        transceiver.rtpSender.track.id;
	    transceiver.rtpSender._initialTrackId = trackId;
	    // spec.
	    var msid = 'msid:' + (stream ? stream.id : '-') + ' ' +
	        trackId + '\r\n';
	    sdp$1 += 'a=' + msid;
	    // for Chrome. Legacy should no longer be required.
	    sdp$1 += 'a=ssrc:' + transceiver.sendEncodingParameters[0].ssrc +
	        ' ' + msid;

	    // RTX
	    if (transceiver.sendEncodingParameters[0].rtx) {
	      sdp$1 += 'a=ssrc:' + transceiver.sendEncodingParameters[0].rtx.ssrc +
	          ' ' + msid;
	      sdp$1 += 'a=ssrc-group:FID ' +
	          transceiver.sendEncodingParameters[0].ssrc + ' ' +
	          transceiver.sendEncodingParameters[0].rtx.ssrc +
	          '\r\n';
	    }
	  }
	  // FIXME: this should be written by writeRtpDescription.
	  sdp$1 += 'a=ssrc:' + transceiver.sendEncodingParameters[0].ssrc +
	      ' cname:' + sdp.localCName + '\r\n';
	  if (transceiver.rtpSender && transceiver.sendEncodingParameters[0].rtx) {
	    sdp$1 += 'a=ssrc:' + transceiver.sendEncodingParameters[0].rtx.ssrc +
	        ' cname:' + sdp.localCName + '\r\n';
	  }
	  return sdp$1;
	}

	// Edge does not like
	// 1) stun: filtered after 14393 unless ?transport=udp is present
	// 2) turn: that does not have all of turn:host:port?transport=udp
	// 3) turn: with ipv6 addresses
	// 4) turn: occurring muliple times
	function filterIceServers(iceServers, edgeVersion) {
	  var hasTurn = false;
	  iceServers = JSON.parse(JSON.stringify(iceServers));
	  return iceServers.filter(function(server) {
	    if (server && (server.urls || server.url)) {
	      var urls = server.urls || server.url;
	      if (server.url && !server.urls) {
	        console.warn('RTCIceServer.url is deprecated! Use urls instead.');
	      }
	      var isString = typeof urls === 'string';
	      if (isString) {
	        urls = [urls];
	      }
	      urls = urls.filter(function(url) {
	        var validTurn = url.indexOf('turn:') === 0 &&
	            url.indexOf('transport=udp') !== -1 &&
	            url.indexOf('turn:[') === -1 &&
	            !hasTurn;

	        if (validTurn) {
	          hasTurn = true;
	          return true;
	        }
	        return url.indexOf('stun:') === 0 && edgeVersion >= 14393 &&
	            url.indexOf('?transport=udp') === -1;
	      });

	      delete server.url;
	      server.urls = isString ? urls[0] : urls;
	      return !!urls.length;
	    }
	  });
	}

	// Determines the intersection of local and remote capabilities.
	function getCommonCapabilities(localCapabilities, remoteCapabilities) {
	  var commonCapabilities = {
	    codecs: [],
	    headerExtensions: [],
	    fecMechanisms: []
	  };

	  var findCodecByPayloadType = function(pt, codecs) {
	    pt = parseInt(pt, 10);
	    for (var i = 0; i < codecs.length; i++) {
	      if (codecs[i].payloadType === pt ||
	          codecs[i].preferredPayloadType === pt) {
	        return codecs[i];
	      }
	    }
	  };

	  var rtxCapabilityMatches = function(lRtx, rRtx, lCodecs, rCodecs) {
	    var lCodec = findCodecByPayloadType(lRtx.parameters.apt, lCodecs);
	    var rCodec = findCodecByPayloadType(rRtx.parameters.apt, rCodecs);
	    return lCodec && rCodec &&
	        lCodec.name.toLowerCase() === rCodec.name.toLowerCase();
	  };

	  localCapabilities.codecs.forEach(function(lCodec) {
	    for (var i = 0; i < remoteCapabilities.codecs.length; i++) {
	      var rCodec = remoteCapabilities.codecs[i];
	      if (lCodec.name.toLowerCase() === rCodec.name.toLowerCase() &&
	          lCodec.clockRate === rCodec.clockRate) {
	        if (lCodec.name.toLowerCase() === 'rtx' &&
	            lCodec.parameters && rCodec.parameters.apt) {
	          // for RTX we need to find the local rtx that has a apt
	          // which points to the same local codec as the remote one.
	          if (!rtxCapabilityMatches(lCodec, rCodec,
	              localCapabilities.codecs, remoteCapabilities.codecs)) {
	            continue;
	          }
	        }
	        rCodec = JSON.parse(JSON.stringify(rCodec)); // deepcopy
	        // number of channels is the highest common number of channels
	        rCodec.numChannels = Math.min(lCodec.numChannels,
	            rCodec.numChannels);
	        // push rCodec so we reply with offerer payload type
	        commonCapabilities.codecs.push(rCodec);

	        // determine common feedback mechanisms
	        rCodec.rtcpFeedback = rCodec.rtcpFeedback.filter(function(fb) {
	          for (var j = 0; j < lCodec.rtcpFeedback.length; j++) {
	            if (lCodec.rtcpFeedback[j].type === fb.type &&
	                lCodec.rtcpFeedback[j].parameter === fb.parameter) {
	              return true;
	            }
	          }
	          return false;
	        });
	        // FIXME: also need to determine .parameters
	        //  see https://github.com/openpeer/ortc/issues/569
	        break;
	      }
	    }
	  });

	  localCapabilities.headerExtensions.forEach(function(lHeaderExtension) {
	    for (var i = 0; i < remoteCapabilities.headerExtensions.length;
	         i++) {
	      var rHeaderExtension = remoteCapabilities.headerExtensions[i];
	      if (lHeaderExtension.uri === rHeaderExtension.uri) {
	        commonCapabilities.headerExtensions.push(rHeaderExtension);
	        break;
	      }
	    }
	  });

	  // FIXME: fecMechanisms
	  return commonCapabilities;
	}

	// is action=setLocalDescription with type allowed in signalingState
	function isActionAllowedInSignalingState(action, type, signalingState) {
	  return {
	    offer: {
	      setLocalDescription: ['stable', 'have-local-offer'],
	      setRemoteDescription: ['stable', 'have-remote-offer']
	    },
	    answer: {
	      setLocalDescription: ['have-remote-offer', 'have-local-pranswer'],
	      setRemoteDescription: ['have-local-offer', 'have-remote-pranswer']
	    }
	  }[type][action].indexOf(signalingState) !== -1;
	}

	function maybeAddCandidate(iceTransport, candidate) {
	  // Edge's internal representation adds some fields therefore
	  // not all fieldѕ are taken into account.
	  var alreadyAdded = iceTransport.getRemoteCandidates()
	      .find(function(remoteCandidate) {
	        return candidate.foundation === remoteCandidate.foundation &&
	            candidate.ip === remoteCandidate.ip &&
	            candidate.port === remoteCandidate.port &&
	            candidate.priority === remoteCandidate.priority &&
	            candidate.protocol === remoteCandidate.protocol &&
	            candidate.type === remoteCandidate.type;
	      });
	  if (!alreadyAdded) {
	    iceTransport.addRemoteCandidate(candidate);
	  }
	  return !alreadyAdded;
	}


	function makeError(name, description) {
	  var e = new Error(description);
	  e.name = name;
	  // legacy error codes from https://heycam.github.io/webidl/#idl-DOMException-error-names
	  e.code = {
	    NotSupportedError: 9,
	    InvalidStateError: 11,
	    InvalidAccessError: 15,
	    TypeError: undefined,
	    OperationError: undefined
	  }[name];
	  return e;
	}

	var rtcpeerconnection = function(window, edgeVersion) {
	  // https://w3c.github.io/mediacapture-main/#mediastream
	  // Helper function to add the track to the stream and
	  // dispatch the event ourselves.
	  function addTrackToStreamAndFireEvent(track, stream) {
	    stream.addTrack(track);
	    stream.dispatchEvent(new window.MediaStreamTrackEvent('addtrack',
	        {track: track}));
	  }

	  function removeTrackFromStreamAndFireEvent(track, stream) {
	    stream.removeTrack(track);
	    stream.dispatchEvent(new window.MediaStreamTrackEvent('removetrack',
	        {track: track}));
	  }

	  function fireAddTrack(pc, track, receiver, streams) {
	    var trackEvent = new Event('track');
	    trackEvent.track = track;
	    trackEvent.receiver = receiver;
	    trackEvent.transceiver = {receiver: receiver};
	    trackEvent.streams = streams;
	    window.setTimeout(function() {
	      pc._dispatchEvent('track', trackEvent);
	    });
	  }

	  var RTCPeerConnection = function(config) {
	    var pc = this;

	    var _eventTarget = document.createDocumentFragment();
	    ['addEventListener', 'removeEventListener', 'dispatchEvent']
	        .forEach(function(method) {
	          pc[method] = _eventTarget[method].bind(_eventTarget);
	        });

	    this.canTrickleIceCandidates = null;

	    this.needNegotiation = false;

	    this.localStreams = [];
	    this.remoteStreams = [];

	    this._localDescription = null;
	    this._remoteDescription = null;

	    this.signalingState = 'stable';
	    this.iceConnectionState = 'new';
	    this.connectionState = 'new';
	    this.iceGatheringState = 'new';

	    config = JSON.parse(JSON.stringify(config || {}));

	    this.usingBundle = config.bundlePolicy === 'max-bundle';
	    if (config.rtcpMuxPolicy === 'negotiate') {
	      throw(makeError('NotSupportedError',
	          'rtcpMuxPolicy \'negotiate\' is not supported'));
	    } else if (!config.rtcpMuxPolicy) {
	      config.rtcpMuxPolicy = 'require';
	    }

	    switch (config.iceTransportPolicy) {
	      case 'all':
	      case 'relay':
	        break;
	      default:
	        config.iceTransportPolicy = 'all';
	        break;
	    }

	    switch (config.bundlePolicy) {
	      case 'balanced':
	      case 'max-compat':
	      case 'max-bundle':
	        break;
	      default:
	        config.bundlePolicy = 'balanced';
	        break;
	    }

	    config.iceServers = filterIceServers(config.iceServers || [], edgeVersion);

	    this._iceGatherers = [];
	    if (config.iceCandidatePoolSize) {
	      for (var i = config.iceCandidatePoolSize; i > 0; i--) {
	        this._iceGatherers.push(new window.RTCIceGatherer({
	          iceServers: config.iceServers,
	          gatherPolicy: config.iceTransportPolicy
	        }));
	      }
	    } else {
	      config.iceCandidatePoolSize = 0;
	    }

	    this._config = config;

	    // per-track iceGathers, iceTransports, dtlsTransports, rtpSenders, ...
	    // everything that is needed to describe a SDP m-line.
	    this.transceivers = [];

	    this._sdpSessionId = sdp.generateSessionId();
	    this._sdpSessionVersion = 0;

	    this._dtlsRole = undefined; // role for a=setup to use in answers.

	    this._isClosed = false;
	  };

	  Object.defineProperty(RTCPeerConnection.prototype, 'localDescription', {
	    configurable: true,
	    get: function() {
	      return this._localDescription;
	    }
	  });
	  Object.defineProperty(RTCPeerConnection.prototype, 'remoteDescription', {
	    configurable: true,
	    get: function() {
	      return this._remoteDescription;
	    }
	  });

	  // set up event handlers on prototype
	  RTCPeerConnection.prototype.onicecandidate = null;
	  RTCPeerConnection.prototype.onaddstream = null;
	  RTCPeerConnection.prototype.ontrack = null;
	  RTCPeerConnection.prototype.onremovestream = null;
	  RTCPeerConnection.prototype.onsignalingstatechange = null;
	  RTCPeerConnection.prototype.oniceconnectionstatechange = null;
	  RTCPeerConnection.prototype.onconnectionstatechange = null;
	  RTCPeerConnection.prototype.onicegatheringstatechange = null;
	  RTCPeerConnection.prototype.onnegotiationneeded = null;
	  RTCPeerConnection.prototype.ondatachannel = null;

	  RTCPeerConnection.prototype._dispatchEvent = function(name, event) {
	    if (this._isClosed) {
	      return;
	    }
	    this.dispatchEvent(event);
	    if (typeof this['on' + name] === 'function') {
	      this['on' + name](event);
	    }
	  };

	  RTCPeerConnection.prototype._emitGatheringStateChange = function() {
	    var event = new Event('icegatheringstatechange');
	    this._dispatchEvent('icegatheringstatechange', event);
	  };

	  RTCPeerConnection.prototype.getConfiguration = function() {
	    return this._config;
	  };

	  RTCPeerConnection.prototype.getLocalStreams = function() {
	    return this.localStreams;
	  };

	  RTCPeerConnection.prototype.getRemoteStreams = function() {
	    return this.remoteStreams;
	  };

	  // internal helper to create a transceiver object.
	  // (which is not yet the same as the WebRTC 1.0 transceiver)
	  RTCPeerConnection.prototype._createTransceiver = function(kind, doNotAdd) {
	    var hasBundleTransport = this.transceivers.length > 0;
	    var transceiver = {
	      track: null,
	      iceGatherer: null,
	      iceTransport: null,
	      dtlsTransport: null,
	      localCapabilities: null,
	      remoteCapabilities: null,
	      rtpSender: null,
	      rtpReceiver: null,
	      kind: kind,
	      mid: null,
	      sendEncodingParameters: null,
	      recvEncodingParameters: null,
	      stream: null,
	      associatedRemoteMediaStreams: [],
	      wantReceive: true
	    };
	    if (this.usingBundle && hasBundleTransport) {
	      transceiver.iceTransport = this.transceivers[0].iceTransport;
	      transceiver.dtlsTransport = this.transceivers[0].dtlsTransport;
	    } else {
	      var transports = this._createIceAndDtlsTransports();
	      transceiver.iceTransport = transports.iceTransport;
	      transceiver.dtlsTransport = transports.dtlsTransport;
	    }
	    if (!doNotAdd) {
	      this.transceivers.push(transceiver);
	    }
	    return transceiver;
	  };

	  RTCPeerConnection.prototype.addTrack = function(track, stream) {
	    if (this._isClosed) {
	      throw makeError('InvalidStateError',
	          'Attempted to call addTrack on a closed peerconnection.');
	    }

	    var alreadyExists = this.transceivers.find(function(s) {
	      return s.track === track;
	    });

	    if (alreadyExists) {
	      throw makeError('InvalidAccessError', 'Track already exists.');
	    }

	    var transceiver;
	    for (var i = 0; i < this.transceivers.length; i++) {
	      if (!this.transceivers[i].track &&
	          this.transceivers[i].kind === track.kind) {
	        transceiver = this.transceivers[i];
	      }
	    }
	    if (!transceiver) {
	      transceiver = this._createTransceiver(track.kind);
	    }

	    this._maybeFireNegotiationNeeded();

	    if (this.localStreams.indexOf(stream) === -1) {
	      this.localStreams.push(stream);
	    }

	    transceiver.track = track;
	    transceiver.stream = stream;
	    transceiver.rtpSender = new window.RTCRtpSender(track,
	        transceiver.dtlsTransport);
	    return transceiver.rtpSender;
	  };

	  RTCPeerConnection.prototype.addStream = function(stream) {
	    var pc = this;
	    if (edgeVersion >= 15025) {
	      stream.getTracks().forEach(function(track) {
	        pc.addTrack(track, stream);
	      });
	    } else {
	      // Clone is necessary for local demos mostly, attaching directly
	      // to two different senders does not work (build 10547).
	      // Fixed in 15025 (or earlier)
	      var clonedStream = stream.clone();
	      stream.getTracks().forEach(function(track, idx) {
	        var clonedTrack = clonedStream.getTracks()[idx];
	        track.addEventListener('enabled', function(event) {
	          clonedTrack.enabled = event.enabled;
	        });
	      });
	      clonedStream.getTracks().forEach(function(track) {
	        pc.addTrack(track, clonedStream);
	      });
	    }
	  };

	  RTCPeerConnection.prototype.removeTrack = function(sender) {
	    if (this._isClosed) {
	      throw makeError('InvalidStateError',
	          'Attempted to call removeTrack on a closed peerconnection.');
	    }

	    if (!(sender instanceof window.RTCRtpSender)) {
	      throw new TypeError('Argument 1 of RTCPeerConnection.removeTrack ' +
	          'does not implement interface RTCRtpSender.');
	    }

	    var transceiver = this.transceivers.find(function(t) {
	      return t.rtpSender === sender;
	    });

	    if (!transceiver) {
	      throw makeError('InvalidAccessError',
	          'Sender was not created by this connection.');
	    }
	    var stream = transceiver.stream;

	    transceiver.rtpSender.stop();
	    transceiver.rtpSender = null;
	    transceiver.track = null;
	    transceiver.stream = null;

	    // remove the stream from the set of local streams
	    var localStreams = this.transceivers.map(function(t) {
	      return t.stream;
	    });
	    if (localStreams.indexOf(stream) === -1 &&
	        this.localStreams.indexOf(stream) > -1) {
	      this.localStreams.splice(this.localStreams.indexOf(stream), 1);
	    }

	    this._maybeFireNegotiationNeeded();
	  };

	  RTCPeerConnection.prototype.removeStream = function(stream) {
	    var pc = this;
	    stream.getTracks().forEach(function(track) {
	      var sender = pc.getSenders().find(function(s) {
	        return s.track === track;
	      });
	      if (sender) {
	        pc.removeTrack(sender);
	      }
	    });
	  };

	  RTCPeerConnection.prototype.getSenders = function() {
	    return this.transceivers.filter(function(transceiver) {
	      return !!transceiver.rtpSender;
	    })
	    .map(function(transceiver) {
	      return transceiver.rtpSender;
	    });
	  };

	  RTCPeerConnection.prototype.getReceivers = function() {
	    return this.transceivers.filter(function(transceiver) {
	      return !!transceiver.rtpReceiver;
	    })
	    .map(function(transceiver) {
	      return transceiver.rtpReceiver;
	    });
	  };


	  RTCPeerConnection.prototype._createIceGatherer = function(sdpMLineIndex,
	      usingBundle) {
	    var pc = this;
	    if (usingBundle && sdpMLineIndex > 0) {
	      return this.transceivers[0].iceGatherer;
	    } else if (this._iceGatherers.length) {
	      return this._iceGatherers.shift();
	    }
	    var iceGatherer = new window.RTCIceGatherer({
	      iceServers: this._config.iceServers,
	      gatherPolicy: this._config.iceTransportPolicy
	    });
	    Object.defineProperty(iceGatherer, 'state',
	        {value: 'new', writable: true}
	    );

	    this.transceivers[sdpMLineIndex].bufferedCandidateEvents = [];
	    this.transceivers[sdpMLineIndex].bufferCandidates = function(event) {
	      var end = !event.candidate || Object.keys(event.candidate).length === 0;
	      // polyfill since RTCIceGatherer.state is not implemented in
	      // Edge 10547 yet.
	      iceGatherer.state = end ? 'completed' : 'gathering';
	      if (pc.transceivers[sdpMLineIndex].bufferedCandidateEvents !== null) {
	        pc.transceivers[sdpMLineIndex].bufferedCandidateEvents.push(event);
	      }
	    };
	    iceGatherer.addEventListener('localcandidate',
	      this.transceivers[sdpMLineIndex].bufferCandidates);
	    return iceGatherer;
	  };

	  // start gathering from an RTCIceGatherer.
	  RTCPeerConnection.prototype._gather = function(mid, sdpMLineIndex) {
	    var pc = this;
	    var iceGatherer = this.transceivers[sdpMLineIndex].iceGatherer;
	    if (iceGatherer.onlocalcandidate) {
	      return;
	    }
	    var bufferedCandidateEvents =
	      this.transceivers[sdpMLineIndex].bufferedCandidateEvents;
	    this.transceivers[sdpMLineIndex].bufferedCandidateEvents = null;
	    iceGatherer.removeEventListener('localcandidate',
	      this.transceivers[sdpMLineIndex].bufferCandidates);
	    iceGatherer.onlocalcandidate = function(evt) {
	      if (pc.usingBundle && sdpMLineIndex > 0) {
	        // if we know that we use bundle we can drop candidates with
	        // ѕdpMLineIndex > 0. If we don't do this then our state gets
	        // confused since we dispose the extra ice gatherer.
	        return;
	      }
	      var event = new Event('icecandidate');
	      event.candidate = {sdpMid: mid, sdpMLineIndex: sdpMLineIndex};

	      var cand = evt.candidate;
	      // Edge emits an empty object for RTCIceCandidateComplete‥
	      var end = !cand || Object.keys(cand).length === 0;
	      if (end) {
	        // polyfill since RTCIceGatherer.state is not implemented in
	        // Edge 10547 yet.
	        if (iceGatherer.state === 'new' || iceGatherer.state === 'gathering') {
	          iceGatherer.state = 'completed';
	        }
	      } else {
	        if (iceGatherer.state === 'new') {
	          iceGatherer.state = 'gathering';
	        }
	        // RTCIceCandidate doesn't have a component, needs to be added
	        cand.component = 1;
	        // also the usernameFragment. TODO: update SDP to take both variants.
	        cand.ufrag = iceGatherer.getLocalParameters().usernameFragment;

	        var serializedCandidate = sdp.writeCandidate(cand);
	        event.candidate = Object.assign(event.candidate,
	            sdp.parseCandidate(serializedCandidate));

	        event.candidate.candidate = serializedCandidate;
	        event.candidate.toJSON = function() {
	          return {
	            candidate: event.candidate.candidate,
	            sdpMid: event.candidate.sdpMid,
	            sdpMLineIndex: event.candidate.sdpMLineIndex,
	            usernameFragment: event.candidate.usernameFragment
	          };
	        };
	      }

	      // update local description.
	      var sections = sdp.getMediaSections(pc._localDescription.sdp);
	      if (!end) {
	        sections[event.candidate.sdpMLineIndex] +=
	            'a=' + event.candidate.candidate + '\r\n';
	      } else {
	        sections[event.candidate.sdpMLineIndex] +=
	            'a=end-of-candidates\r\n';
	      }
	      pc._localDescription.sdp =
	          sdp.getDescription(pc._localDescription.sdp) +
	          sections.join('');
	      var complete = pc.transceivers.every(function(transceiver) {
	        return transceiver.iceGatherer &&
	            transceiver.iceGatherer.state === 'completed';
	      });

	      if (pc.iceGatheringState !== 'gathering') {
	        pc.iceGatheringState = 'gathering';
	        pc._emitGatheringStateChange();
	      }

	      // Emit candidate. Also emit null candidate when all gatherers are
	      // complete.
	      if (!end) {
	        pc._dispatchEvent('icecandidate', event);
	      }
	      if (complete) {
	        pc._dispatchEvent('icecandidate', new Event('icecandidate'));
	        pc.iceGatheringState = 'complete';
	        pc._emitGatheringStateChange();
	      }
	    };

	    // emit already gathered candidates.
	    window.setTimeout(function() {
	      bufferedCandidateEvents.forEach(function(e) {
	        iceGatherer.onlocalcandidate(e);
	      });
	    }, 0);
	  };

	  // Create ICE transport and DTLS transport.
	  RTCPeerConnection.prototype._createIceAndDtlsTransports = function() {
	    var pc = this;
	    var iceTransport = new window.RTCIceTransport(null);
	    iceTransport.onicestatechange = function() {
	      pc._updateIceConnectionState();
	      pc._updateConnectionState();
	    };

	    var dtlsTransport = new window.RTCDtlsTransport(iceTransport);
	    dtlsTransport.ondtlsstatechange = function() {
	      pc._updateConnectionState();
	    };
	    dtlsTransport.onerror = function() {
	      // onerror does not set state to failed by itself.
	      Object.defineProperty(dtlsTransport, 'state',
	          {value: 'failed', writable: true});
	      pc._updateConnectionState();
	    };

	    return {
	      iceTransport: iceTransport,
	      dtlsTransport: dtlsTransport
	    };
	  };

	  // Destroy ICE gatherer, ICE transport and DTLS transport.
	  // Without triggering the callbacks.
	  RTCPeerConnection.prototype._disposeIceAndDtlsTransports = function(
	      sdpMLineIndex) {
	    var iceGatherer = this.transceivers[sdpMLineIndex].iceGatherer;
	    if (iceGatherer) {
	      delete iceGatherer.onlocalcandidate;
	      delete this.transceivers[sdpMLineIndex].iceGatherer;
	    }
	    var iceTransport = this.transceivers[sdpMLineIndex].iceTransport;
	    if (iceTransport) {
	      delete iceTransport.onicestatechange;
	      delete this.transceivers[sdpMLineIndex].iceTransport;
	    }
	    var dtlsTransport = this.transceivers[sdpMLineIndex].dtlsTransport;
	    if (dtlsTransport) {
	      delete dtlsTransport.ondtlsstatechange;
	      delete dtlsTransport.onerror;
	      delete this.transceivers[sdpMLineIndex].dtlsTransport;
	    }
	  };

	  // Start the RTP Sender and Receiver for a transceiver.
	  RTCPeerConnection.prototype._transceive = function(transceiver,
	      send, recv) {
	    var params = getCommonCapabilities(transceiver.localCapabilities,
	        transceiver.remoteCapabilities);
	    if (send && transceiver.rtpSender) {
	      params.encodings = transceiver.sendEncodingParameters;
	      params.rtcp = {
	        cname: sdp.localCName,
	        compound: transceiver.rtcpParameters.compound
	      };
	      if (transceiver.recvEncodingParameters.length) {
	        params.rtcp.ssrc = transceiver.recvEncodingParameters[0].ssrc;
	      }
	      transceiver.rtpSender.send(params);
	    }
	    if (recv && transceiver.rtpReceiver && params.codecs.length > 0) {
	      // remove RTX field in Edge 14942
	      if (transceiver.kind === 'video'
	          && transceiver.recvEncodingParameters
	          && edgeVersion < 15019) {
	        transceiver.recvEncodingParameters.forEach(function(p) {
	          delete p.rtx;
	        });
	      }
	      if (transceiver.recvEncodingParameters.length) {
	        params.encodings = transceiver.recvEncodingParameters;
	      } else {
	        params.encodings = [{}];
	      }
	      params.rtcp = {
	        compound: transceiver.rtcpParameters.compound
	      };
	      if (transceiver.rtcpParameters.cname) {
	        params.rtcp.cname = transceiver.rtcpParameters.cname;
	      }
	      if (transceiver.sendEncodingParameters.length) {
	        params.rtcp.ssrc = transceiver.sendEncodingParameters[0].ssrc;
	      }
	      transceiver.rtpReceiver.receive(params);
	    }
	  };

	  RTCPeerConnection.prototype.setLocalDescription = function(description) {
	    var pc = this;

	    // Note: pranswer is not supported.
	    if (['offer', 'answer'].indexOf(description.type) === -1) {
	      return Promise.reject(makeError('TypeError',
	          'Unsupported type "' + description.type + '"'));
	    }

	    if (!isActionAllowedInSignalingState('setLocalDescription',
	        description.type, pc.signalingState) || pc._isClosed) {
	      return Promise.reject(makeError('InvalidStateError',
	          'Can not set local ' + description.type +
	          ' in state ' + pc.signalingState));
	    }

	    var sections;
	    var sessionpart;
	    if (description.type === 'offer') {
	      // VERY limited support for SDP munging. Limited to:
	      // * changing the order of codecs
	      sections = sdp.splitSections(description.sdp);
	      sessionpart = sections.shift();
	      sections.forEach(function(mediaSection, sdpMLineIndex) {
	        var caps = sdp.parseRtpParameters(mediaSection);
	        pc.transceivers[sdpMLineIndex].localCapabilities = caps;
	      });

	      pc.transceivers.forEach(function(transceiver, sdpMLineIndex) {
	        pc._gather(transceiver.mid, sdpMLineIndex);
	      });
	    } else if (description.type === 'answer') {
	      sections = sdp.splitSections(pc._remoteDescription.sdp);
	      sessionpart = sections.shift();
	      var isIceLite = sdp.matchPrefix(sessionpart,
	          'a=ice-lite').length > 0;
	      sections.forEach(function(mediaSection, sdpMLineIndex) {
	        var transceiver = pc.transceivers[sdpMLineIndex];
	        var iceGatherer = transceiver.iceGatherer;
	        var iceTransport = transceiver.iceTransport;
	        var dtlsTransport = transceiver.dtlsTransport;
	        var localCapabilities = transceiver.localCapabilities;
	        var remoteCapabilities = transceiver.remoteCapabilities;

	        // treat bundle-only as not-rejected.
	        var rejected = sdp.isRejected(mediaSection) &&
	            sdp.matchPrefix(mediaSection, 'a=bundle-only').length === 0;

	        if (!rejected && !transceiver.rejected) {
	          var remoteIceParameters = sdp.getIceParameters(
	              mediaSection, sessionpart);
	          var remoteDtlsParameters = sdp.getDtlsParameters(
	              mediaSection, sessionpart);
	          if (isIceLite) {
	            remoteDtlsParameters.role = 'server';
	          }

	          if (!pc.usingBundle || sdpMLineIndex === 0) {
	            pc._gather(transceiver.mid, sdpMLineIndex);
	            if (iceTransport.state === 'new') {
	              iceTransport.start(iceGatherer, remoteIceParameters,
	                  isIceLite ? 'controlling' : 'controlled');
	            }
	            if (dtlsTransport.state === 'new') {
	              dtlsTransport.start(remoteDtlsParameters);
	            }
	          }

	          // Calculate intersection of capabilities.
	          var params = getCommonCapabilities(localCapabilities,
	              remoteCapabilities);

	          // Start the RTCRtpSender. The RTCRtpReceiver for this
	          // transceiver has already been started in setRemoteDescription.
	          pc._transceive(transceiver,
	              params.codecs.length > 0,
	              false);
	        }
	      });
	    }

	    pc._localDescription = {
	      type: description.type,
	      sdp: description.sdp
	    };
	    if (description.type === 'offer') {
	      pc._updateSignalingState('have-local-offer');
	    } else {
	      pc._updateSignalingState('stable');
	    }

	    return Promise.resolve();
	  };

	  RTCPeerConnection.prototype.setRemoteDescription = function(description) {
	    var pc = this;

	    // Note: pranswer is not supported.
	    if (['offer', 'answer'].indexOf(description.type) === -1) {
	      return Promise.reject(makeError('TypeError',
	          'Unsupported type "' + description.type + '"'));
	    }

	    if (!isActionAllowedInSignalingState('setRemoteDescription',
	        description.type, pc.signalingState) || pc._isClosed) {
	      return Promise.reject(makeError('InvalidStateError',
	          'Can not set remote ' + description.type +
	          ' in state ' + pc.signalingState));
	    }

	    var streams = {};
	    pc.remoteStreams.forEach(function(stream) {
	      streams[stream.id] = stream;
	    });
	    var receiverList = [];
	    var sections = sdp.splitSections(description.sdp);
	    var sessionpart = sections.shift();
	    var isIceLite = sdp.matchPrefix(sessionpart,
	        'a=ice-lite').length > 0;
	    var usingBundle = sdp.matchPrefix(sessionpart,
	        'a=group:BUNDLE ').length > 0;
	    pc.usingBundle = usingBundle;
	    var iceOptions = sdp.matchPrefix(sessionpart,
	        'a=ice-options:')[0];
	    if (iceOptions) {
	      pc.canTrickleIceCandidates = iceOptions.substr(14).split(' ')
	          .indexOf('trickle') >= 0;
	    } else {
	      pc.canTrickleIceCandidates = false;
	    }

	    sections.forEach(function(mediaSection, sdpMLineIndex) {
	      var lines = sdp.splitLines(mediaSection);
	      var kind = sdp.getKind(mediaSection);
	      // treat bundle-only as not-rejected.
	      var rejected = sdp.isRejected(mediaSection) &&
	          sdp.matchPrefix(mediaSection, 'a=bundle-only').length === 0;
	      var protocol = lines[0].substr(2).split(' ')[2];

	      var direction = sdp.getDirection(mediaSection, sessionpart);
	      var remoteMsid = sdp.parseMsid(mediaSection);

	      var mid = sdp.getMid(mediaSection) || sdp.generateIdentifier();

	      // Reject datachannels which are not implemented yet.
	      if (rejected || (kind === 'application' && (protocol === 'DTLS/SCTP' ||
	          protocol === 'UDP/DTLS/SCTP'))) {
	        // TODO: this is dangerous in the case where a non-rejected m-line
	        //     becomes rejected.
	        pc.transceivers[sdpMLineIndex] = {
	          mid: mid,
	          kind: kind,
	          protocol: protocol,
	          rejected: true
	        };
	        return;
	      }

	      if (!rejected && pc.transceivers[sdpMLineIndex] &&
	          pc.transceivers[sdpMLineIndex].rejected) {
	        // recycle a rejected transceiver.
	        pc.transceivers[sdpMLineIndex] = pc._createTransceiver(kind, true);
	      }

	      var transceiver;
	      var iceGatherer;
	      var iceTransport;
	      var dtlsTransport;
	      var rtpReceiver;
	      var sendEncodingParameters;
	      var recvEncodingParameters;
	      var localCapabilities;

	      var track;
	      // FIXME: ensure the mediaSection has rtcp-mux set.
	      var remoteCapabilities = sdp.parseRtpParameters(mediaSection);
	      var remoteIceParameters;
	      var remoteDtlsParameters;
	      if (!rejected) {
	        remoteIceParameters = sdp.getIceParameters(mediaSection,
	            sessionpart);
	        remoteDtlsParameters = sdp.getDtlsParameters(mediaSection,
	            sessionpart);
	        remoteDtlsParameters.role = 'client';
	      }
	      recvEncodingParameters =
	          sdp.parseRtpEncodingParameters(mediaSection);

	      var rtcpParameters = sdp.parseRtcpParameters(mediaSection);

	      var isComplete = sdp.matchPrefix(mediaSection,
	          'a=end-of-candidates', sessionpart).length > 0;
	      var cands = sdp.matchPrefix(mediaSection, 'a=candidate:')
	          .map(function(cand) {
	            return sdp.parseCandidate(cand);
	          })
	          .filter(function(cand) {
	            return cand.component === 1;
	          });

	      // Check if we can use BUNDLE and dispose transports.
	      if ((description.type === 'offer' || description.type === 'answer') &&
	          !rejected && usingBundle && sdpMLineIndex > 0 &&
	          pc.transceivers[sdpMLineIndex]) {
	        pc._disposeIceAndDtlsTransports(sdpMLineIndex);
	        pc.transceivers[sdpMLineIndex].iceGatherer =
	            pc.transceivers[0].iceGatherer;
	        pc.transceivers[sdpMLineIndex].iceTransport =
	            pc.transceivers[0].iceTransport;
	        pc.transceivers[sdpMLineIndex].dtlsTransport =
	            pc.transceivers[0].dtlsTransport;
	        if (pc.transceivers[sdpMLineIndex].rtpSender) {
	          pc.transceivers[sdpMLineIndex].rtpSender.setTransport(
	              pc.transceivers[0].dtlsTransport);
	        }
	        if (pc.transceivers[sdpMLineIndex].rtpReceiver) {
	          pc.transceivers[sdpMLineIndex].rtpReceiver.setTransport(
	              pc.transceivers[0].dtlsTransport);
	        }
	      }
	      if (description.type === 'offer' && !rejected) {
	        transceiver = pc.transceivers[sdpMLineIndex] ||
	            pc._createTransceiver(kind);
	        transceiver.mid = mid;

	        if (!transceiver.iceGatherer) {
	          transceiver.iceGatherer = pc._createIceGatherer(sdpMLineIndex,
	              usingBundle);
	        }

	        if (cands.length && transceiver.iceTransport.state === 'new') {
	          if (isComplete && (!usingBundle || sdpMLineIndex === 0)) {
	            transceiver.iceTransport.setRemoteCandidates(cands);
	          } else {
	            cands.forEach(function(candidate) {
	              maybeAddCandidate(transceiver.iceTransport, candidate);
	            });
	          }
	        }

	        localCapabilities = window.RTCRtpReceiver.getCapabilities(kind);

	        // filter RTX until additional stuff needed for RTX is implemented
	        // in adapter.js
	        if (edgeVersion < 15019) {
	          localCapabilities.codecs = localCapabilities.codecs.filter(
	              function(codec) {
	                return codec.name !== 'rtx';
	              });
	        }

	        sendEncodingParameters = transceiver.sendEncodingParameters || [{
	          ssrc: (2 * sdpMLineIndex + 2) * 1001
	        }];

	        // TODO: rewrite to use http://w3c.github.io/webrtc-pc/#set-associated-remote-streams
	        var isNewTrack = false;
	        if (direction === 'sendrecv' || direction === 'sendonly') {
	          isNewTrack = !transceiver.rtpReceiver;
	          rtpReceiver = transceiver.rtpReceiver ||
	              new window.RTCRtpReceiver(transceiver.dtlsTransport, kind);

	          if (isNewTrack) {
	            var stream;
	            track = rtpReceiver.track;
	            // FIXME: does not work with Plan B.
	            if (remoteMsid && remoteMsid.stream === '-') ; else if (remoteMsid) {
	              if (!streams[remoteMsid.stream]) {
	                streams[remoteMsid.stream] = new window.MediaStream();
	                Object.defineProperty(streams[remoteMsid.stream], 'id', {
	                  get: function() {
	                    return remoteMsid.stream;
	                  }
	                });
	              }
	              Object.defineProperty(track, 'id', {
	                get: function() {
	                  return remoteMsid.track;
	                }
	              });
	              stream = streams[remoteMsid.stream];
	            } else {
	              if (!streams.default) {
	                streams.default = new window.MediaStream();
	              }
	              stream = streams.default;
	            }
	            if (stream) {
	              addTrackToStreamAndFireEvent(track, stream);
	              transceiver.associatedRemoteMediaStreams.push(stream);
	            }
	            receiverList.push([track, rtpReceiver, stream]);
	          }
	        } else if (transceiver.rtpReceiver && transceiver.rtpReceiver.track) {
	          transceiver.associatedRemoteMediaStreams.forEach(function(s) {
	            var nativeTrack = s.getTracks().find(function(t) {
	              return t.id === transceiver.rtpReceiver.track.id;
	            });
	            if (nativeTrack) {
	              removeTrackFromStreamAndFireEvent(nativeTrack, s);
	            }
	          });
	          transceiver.associatedRemoteMediaStreams = [];
	        }

	        transceiver.localCapabilities = localCapabilities;
	        transceiver.remoteCapabilities = remoteCapabilities;
	        transceiver.rtpReceiver = rtpReceiver;
	        transceiver.rtcpParameters = rtcpParameters;
	        transceiver.sendEncodingParameters = sendEncodingParameters;
	        transceiver.recvEncodingParameters = recvEncodingParameters;

	        // Start the RTCRtpReceiver now. The RTPSender is started in
	        // setLocalDescription.
	        pc._transceive(pc.transceivers[sdpMLineIndex],
	            false,
	            isNewTrack);
	      } else if (description.type === 'answer' && !rejected) {
	        transceiver = pc.transceivers[sdpMLineIndex];
	        iceGatherer = transceiver.iceGatherer;
	        iceTransport = transceiver.iceTransport;
	        dtlsTransport = transceiver.dtlsTransport;
	        rtpReceiver = transceiver.rtpReceiver;
	        sendEncodingParameters = transceiver.sendEncodingParameters;
	        localCapabilities = transceiver.localCapabilities;

	        pc.transceivers[sdpMLineIndex].recvEncodingParameters =
	            recvEncodingParameters;
	        pc.transceivers[sdpMLineIndex].remoteCapabilities =
	            remoteCapabilities;
	        pc.transceivers[sdpMLineIndex].rtcpParameters = rtcpParameters;

	        if (cands.length && iceTransport.state === 'new') {
	          if ((isIceLite || isComplete) &&
	              (!usingBundle || sdpMLineIndex === 0)) {
	            iceTransport.setRemoteCandidates(cands);
	          } else {
	            cands.forEach(function(candidate) {
	              maybeAddCandidate(transceiver.iceTransport, candidate);
	            });
	          }
	        }

	        if (!usingBundle || sdpMLineIndex === 0) {
	          if (iceTransport.state === 'new') {
	            iceTransport.start(iceGatherer, remoteIceParameters,
	                'controlling');
	          }
	          if (dtlsTransport.state === 'new') {
	            dtlsTransport.start(remoteDtlsParameters);
	          }
	        }

	        // If the offer contained RTX but the answer did not,
	        // remove RTX from sendEncodingParameters.
	        var commonCapabilities = getCommonCapabilities(
	          transceiver.localCapabilities,
	          transceiver.remoteCapabilities);

	        var hasRtx = commonCapabilities.codecs.filter(function(c) {
	          return c.name.toLowerCase() === 'rtx';
	        }).length;
	        if (!hasRtx && transceiver.sendEncodingParameters[0].rtx) {
	          delete transceiver.sendEncodingParameters[0].rtx;
	        }

	        pc._transceive(transceiver,
	            direction === 'sendrecv' || direction === 'recvonly',
	            direction === 'sendrecv' || direction === 'sendonly');

	        // TODO: rewrite to use http://w3c.github.io/webrtc-pc/#set-associated-remote-streams
	        if (rtpReceiver &&
	            (direction === 'sendrecv' || direction === 'sendonly')) {
	          track = rtpReceiver.track;
	          if (remoteMsid) {
	            if (!streams[remoteMsid.stream]) {
	              streams[remoteMsid.stream] = new window.MediaStream();
	            }
	            addTrackToStreamAndFireEvent(track, streams[remoteMsid.stream]);
	            receiverList.push([track, rtpReceiver, streams[remoteMsid.stream]]);
	          } else {
	            if (!streams.default) {
	              streams.default = new window.MediaStream();
	            }
	            addTrackToStreamAndFireEvent(track, streams.default);
	            receiverList.push([track, rtpReceiver, streams.default]);
	          }
	        } else {
	          // FIXME: actually the receiver should be created later.
	          delete transceiver.rtpReceiver;
	        }
	      }
	    });

	    if (pc._dtlsRole === undefined) {
	      pc._dtlsRole = description.type === 'offer' ? 'active' : 'passive';
	    }

	    pc._remoteDescription = {
	      type: description.type,
	      sdp: description.sdp
	    };
	    if (description.type === 'offer') {
	      pc._updateSignalingState('have-remote-offer');
	    } else {
	      pc._updateSignalingState('stable');
	    }
	    Object.keys(streams).forEach(function(sid) {
	      var stream = streams[sid];
	      if (stream.getTracks().length) {
	        if (pc.remoteStreams.indexOf(stream) === -1) {
	          pc.remoteStreams.push(stream);
	          var event = new Event('addstream');
	          event.stream = stream;
	          window.setTimeout(function() {
	            pc._dispatchEvent('addstream', event);
	          });
	        }

	        receiverList.forEach(function(item) {
	          var track = item[0];
	          var receiver = item[1];
	          if (stream.id !== item[2].id) {
	            return;
	          }
	          fireAddTrack(pc, track, receiver, [stream]);
	        });
	      }
	    });
	    receiverList.forEach(function(item) {
	      if (item[2]) {
	        return;
	      }
	      fireAddTrack(pc, item[0], item[1], []);
	    });

	    // check whether addIceCandidate({}) was called within four seconds after
	    // setRemoteDescription.
	    window.setTimeout(function() {
	      if (!(pc && pc.transceivers)) {
	        return;
	      }
	      pc.transceivers.forEach(function(transceiver) {
	        if (transceiver.iceTransport &&
	            transceiver.iceTransport.state === 'new' &&
	            transceiver.iceTransport.getRemoteCandidates().length > 0) {
	          console.warn('Timeout for addRemoteCandidate. Consider sending ' +
	              'an end-of-candidates notification');
	          transceiver.iceTransport.addRemoteCandidate({});
	        }
	      });
	    }, 4000);

	    return Promise.resolve();
	  };

	  RTCPeerConnection.prototype.close = function() {
	    this.transceivers.forEach(function(transceiver) {
	      /* not yet
	      if (transceiver.iceGatherer) {
	        transceiver.iceGatherer.close();
	      }
	      */
	      if (transceiver.iceTransport) {
	        transceiver.iceTransport.stop();
	      }
	      if (transceiver.dtlsTransport) {
	        transceiver.dtlsTransport.stop();
	      }
	      if (transceiver.rtpSender) {
	        transceiver.rtpSender.stop();
	      }
	      if (transceiver.rtpReceiver) {
	        transceiver.rtpReceiver.stop();
	      }
	    });
	    // FIXME: clean up tracks, local streams, remote streams, etc
	    this._isClosed = true;
	    this._updateSignalingState('closed');
	  };

	  // Update the signaling state.
	  RTCPeerConnection.prototype._updateSignalingState = function(newState) {
	    this.signalingState = newState;
	    var event = new Event('signalingstatechange');
	    this._dispatchEvent('signalingstatechange', event);
	  };

	  // Determine whether to fire the negotiationneeded event.
	  RTCPeerConnection.prototype._maybeFireNegotiationNeeded = function() {
	    var pc = this;
	    if (this.signalingState !== 'stable' || this.needNegotiation === true) {
	      return;
	    }
	    this.needNegotiation = true;
	    window.setTimeout(function() {
	      if (pc.needNegotiation) {
	        pc.needNegotiation = false;
	        var event = new Event('negotiationneeded');
	        pc._dispatchEvent('negotiationneeded', event);
	      }
	    }, 0);
	  };

	  // Update the ice connection state.
	  RTCPeerConnection.prototype._updateIceConnectionState = function() {
	    var newState;
	    var states = {
	      'new': 0,
	      closed: 0,
	      checking: 0,
	      connected: 0,
	      completed: 0,
	      disconnected: 0,
	      failed: 0
	    };
	    this.transceivers.forEach(function(transceiver) {
	      if (transceiver.iceTransport && !transceiver.rejected) {
	        states[transceiver.iceTransport.state]++;
	      }
	    });

	    newState = 'new';
	    if (states.failed > 0) {
	      newState = 'failed';
	    } else if (states.checking > 0) {
	      newState = 'checking';
	    } else if (states.disconnected > 0) {
	      newState = 'disconnected';
	    } else if (states.new > 0) {
	      newState = 'new';
	    } else if (states.connected > 0) {
	      newState = 'connected';
	    } else if (states.completed > 0) {
	      newState = 'completed';
	    }

	    if (newState !== this.iceConnectionState) {
	      this.iceConnectionState = newState;
	      var event = new Event('iceconnectionstatechange');
	      this._dispatchEvent('iceconnectionstatechange', event);
	    }
	  };

	  // Update the connection state.
	  RTCPeerConnection.prototype._updateConnectionState = function() {
	    var newState;
	    var states = {
	      'new': 0,
	      closed: 0,
	      connecting: 0,
	      connected: 0,
	      completed: 0,
	      disconnected: 0,
	      failed: 0
	    };
	    this.transceivers.forEach(function(transceiver) {
	      if (transceiver.iceTransport && transceiver.dtlsTransport &&
	          !transceiver.rejected) {
	        states[transceiver.iceTransport.state]++;
	        states[transceiver.dtlsTransport.state]++;
	      }
	    });
	    // ICETransport.completed and connected are the same for this purpose.
	    states.connected += states.completed;

	    newState = 'new';
	    if (states.failed > 0) {
	      newState = 'failed';
	    } else if (states.connecting > 0) {
	      newState = 'connecting';
	    } else if (states.disconnected > 0) {
	      newState = 'disconnected';
	    } else if (states.new > 0) {
	      newState = 'new';
	    } else if (states.connected > 0) {
	      newState = 'connected';
	    }

	    if (newState !== this.connectionState) {
	      this.connectionState = newState;
	      var event = new Event('connectionstatechange');
	      this._dispatchEvent('connectionstatechange', event);
	    }
	  };

	  RTCPeerConnection.prototype.createOffer = function() {
	    var pc = this;

	    if (pc._isClosed) {
	      return Promise.reject(makeError('InvalidStateError',
	          'Can not call createOffer after close'));
	    }

	    var numAudioTracks = pc.transceivers.filter(function(t) {
	      return t.kind === 'audio';
	    }).length;
	    var numVideoTracks = pc.transceivers.filter(function(t) {
	      return t.kind === 'video';
	    }).length;

	    // Determine number of audio and video tracks we need to send/recv.
	    var offerOptions = arguments[0];
	    if (offerOptions) {
	      // Reject Chrome legacy constraints.
	      if (offerOptions.mandatory || offerOptions.optional) {
	        throw new TypeError(
	            'Legacy mandatory/optional constraints not supported.');
	      }
	      if (offerOptions.offerToReceiveAudio !== undefined) {
	        if (offerOptions.offerToReceiveAudio === true) {
	          numAudioTracks = 1;
	        } else if (offerOptions.offerToReceiveAudio === false) {
	          numAudioTracks = 0;
	        } else {
	          numAudioTracks = offerOptions.offerToReceiveAudio;
	        }
	      }
	      if (offerOptions.offerToReceiveVideo !== undefined) {
	        if (offerOptions.offerToReceiveVideo === true) {
	          numVideoTracks = 1;
	        } else if (offerOptions.offerToReceiveVideo === false) {
	          numVideoTracks = 0;
	        } else {
	          numVideoTracks = offerOptions.offerToReceiveVideo;
	        }
	      }
	    }

	    pc.transceivers.forEach(function(transceiver) {
	      if (transceiver.kind === 'audio') {
	        numAudioTracks--;
	        if (numAudioTracks < 0) {
	          transceiver.wantReceive = false;
	        }
	      } else if (transceiver.kind === 'video') {
	        numVideoTracks--;
	        if (numVideoTracks < 0) {
	          transceiver.wantReceive = false;
	        }
	      }
	    });

	    // Create M-lines for recvonly streams.
	    while (numAudioTracks > 0 || numVideoTracks > 0) {
	      if (numAudioTracks > 0) {
	        pc._createTransceiver('audio');
	        numAudioTracks--;
	      }
	      if (numVideoTracks > 0) {
	        pc._createTransceiver('video');
	        numVideoTracks--;
	      }
	    }

	    var sdp$1 = sdp.writeSessionBoilerplate(pc._sdpSessionId,
	        pc._sdpSessionVersion++);
	    pc.transceivers.forEach(function(transceiver, sdpMLineIndex) {
	      // For each track, create an ice gatherer, ice transport,
	      // dtls transport, potentially rtpsender and rtpreceiver.
	      var track = transceiver.track;
	      var kind = transceiver.kind;
	      var mid = transceiver.mid || sdp.generateIdentifier();
	      transceiver.mid = mid;

	      if (!transceiver.iceGatherer) {
	        transceiver.iceGatherer = pc._createIceGatherer(sdpMLineIndex,
	            pc.usingBundle);
	      }

	      var localCapabilities = window.RTCRtpSender.getCapabilities(kind);
	      // filter RTX until additional stuff needed for RTX is implemented
	      // in adapter.js
	      if (edgeVersion < 15019) {
	        localCapabilities.codecs = localCapabilities.codecs.filter(
	            function(codec) {
	              return codec.name !== 'rtx';
	            });
	      }
	      localCapabilities.codecs.forEach(function(codec) {
	        // work around https://bugs.chromium.org/p/webrtc/issues/detail?id=6552
	        // by adding level-asymmetry-allowed=1
	        if (codec.name === 'H264' &&
	            codec.parameters['level-asymmetry-allowed'] === undefined) {
	          codec.parameters['level-asymmetry-allowed'] = '1';
	        }

	        // for subsequent offers, we might have to re-use the payload
	        // type of the last offer.
	        if (transceiver.remoteCapabilities &&
	            transceiver.remoteCapabilities.codecs) {
	          transceiver.remoteCapabilities.codecs.forEach(function(remoteCodec) {
	            if (codec.name.toLowerCase() === remoteCodec.name.toLowerCase() &&
	                codec.clockRate === remoteCodec.clockRate) {
	              codec.preferredPayloadType = remoteCodec.payloadType;
	            }
	          });
	        }
	      });
	      localCapabilities.headerExtensions.forEach(function(hdrExt) {
	        var remoteExtensions = transceiver.remoteCapabilities &&
	            transceiver.remoteCapabilities.headerExtensions || [];
	        remoteExtensions.forEach(function(rHdrExt) {
	          if (hdrExt.uri === rHdrExt.uri) {
	            hdrExt.id = rHdrExt.id;
	          }
	        });
	      });

	      // generate an ssrc now, to be used later in rtpSender.send
	      var sendEncodingParameters = transceiver.sendEncodingParameters || [{
	        ssrc: (2 * sdpMLineIndex + 1) * 1001
	      }];
	      if (track) {
	        // add RTX
	        if (edgeVersion >= 15019 && kind === 'video' &&
	            !sendEncodingParameters[0].rtx) {
	          sendEncodingParameters[0].rtx = {
	            ssrc: sendEncodingParameters[0].ssrc + 1
	          };
	        }
	      }

	      if (transceiver.wantReceive) {
	        transceiver.rtpReceiver = new window.RTCRtpReceiver(
	            transceiver.dtlsTransport, kind);
	      }

	      transceiver.localCapabilities = localCapabilities;
	      transceiver.sendEncodingParameters = sendEncodingParameters;
	    });

	    // always offer BUNDLE and dispose on return if not supported.
	    if (pc._config.bundlePolicy !== 'max-compat') {
	      sdp$1 += 'a=group:BUNDLE ' + pc.transceivers.map(function(t) {
	        return t.mid;
	      }).join(' ') + '\r\n';
	    }
	    sdp$1 += 'a=ice-options:trickle\r\n';

	    pc.transceivers.forEach(function(transceiver, sdpMLineIndex) {
	      sdp$1 += writeMediaSection(transceiver, transceiver.localCapabilities,
	          'offer', transceiver.stream, pc._dtlsRole);
	      sdp$1 += 'a=rtcp-rsize\r\n';

	      if (transceiver.iceGatherer && pc.iceGatheringState !== 'new' &&
	          (sdpMLineIndex === 0 || !pc.usingBundle)) {
	        transceiver.iceGatherer.getLocalCandidates().forEach(function(cand) {
	          cand.component = 1;
	          sdp$1 += 'a=' + sdp.writeCandidate(cand) + '\r\n';
	        });

	        if (transceiver.iceGatherer.state === 'completed') {
	          sdp$1 += 'a=end-of-candidates\r\n';
	        }
	      }
	    });

	    var desc = new window.RTCSessionDescription({
	      type: 'offer',
	      sdp: sdp$1
	    });
	    return Promise.resolve(desc);
	  };

	  RTCPeerConnection.prototype.createAnswer = function() {
	    var pc = this;

	    if (pc._isClosed) {
	      return Promise.reject(makeError('InvalidStateError',
	          'Can not call createAnswer after close'));
	    }

	    if (!(pc.signalingState === 'have-remote-offer' ||
	        pc.signalingState === 'have-local-pranswer')) {
	      return Promise.reject(makeError('InvalidStateError',
	          'Can not call createAnswer in signalingState ' + pc.signalingState));
	    }

	    var sdp$1 = sdp.writeSessionBoilerplate(pc._sdpSessionId,
	        pc._sdpSessionVersion++);
	    if (pc.usingBundle) {
	      sdp$1 += 'a=group:BUNDLE ' + pc.transceivers.map(function(t) {
	        return t.mid;
	      }).join(' ') + '\r\n';
	    }
	    sdp$1 += 'a=ice-options:trickle\r\n';

	    var mediaSectionsInOffer = sdp.getMediaSections(
	        pc._remoteDescription.sdp).length;
	    pc.transceivers.forEach(function(transceiver, sdpMLineIndex) {
	      if (sdpMLineIndex + 1 > mediaSectionsInOffer) {
	        return;
	      }
	      if (transceiver.rejected) {
	        if (transceiver.kind === 'application') {
	          if (transceiver.protocol === 'DTLS/SCTP') { // legacy fmt
	            sdp$1 += 'm=application 0 DTLS/SCTP 5000\r\n';
	          } else {
	            sdp$1 += 'm=application 0 ' + transceiver.protocol +
	                ' webrtc-datachannel\r\n';
	          }
	        } else if (transceiver.kind === 'audio') {
	          sdp$1 += 'm=audio 0 UDP/TLS/RTP/SAVPF 0\r\n' +
	              'a=rtpmap:0 PCMU/8000\r\n';
	        } else if (transceiver.kind === 'video') {
	          sdp$1 += 'm=video 0 UDP/TLS/RTP/SAVPF 120\r\n' +
	              'a=rtpmap:120 VP8/90000\r\n';
	        }
	        sdp$1 += 'c=IN IP4 0.0.0.0\r\n' +
	            'a=inactive\r\n' +
	            'a=mid:' + transceiver.mid + '\r\n';
	        return;
	      }

	      // FIXME: look at direction.
	      if (transceiver.stream) {
	        var localTrack;
	        if (transceiver.kind === 'audio') {
	          localTrack = transceiver.stream.getAudioTracks()[0];
	        } else if (transceiver.kind === 'video') {
	          localTrack = transceiver.stream.getVideoTracks()[0];
	        }
	        if (localTrack) {
	          // add RTX
	          if (edgeVersion >= 15019 && transceiver.kind === 'video' &&
	              !transceiver.sendEncodingParameters[0].rtx) {
	            transceiver.sendEncodingParameters[0].rtx = {
	              ssrc: transceiver.sendEncodingParameters[0].ssrc + 1
	            };
	          }
	        }
	      }

	      // Calculate intersection of capabilities.
	      var commonCapabilities = getCommonCapabilities(
	          transceiver.localCapabilities,
	          transceiver.remoteCapabilities);

	      var hasRtx = commonCapabilities.codecs.filter(function(c) {
	        return c.name.toLowerCase() === 'rtx';
	      }).length;
	      if (!hasRtx && transceiver.sendEncodingParameters[0].rtx) {
	        delete transceiver.sendEncodingParameters[0].rtx;
	      }

	      sdp$1 += writeMediaSection(transceiver, commonCapabilities,
	          'answer', transceiver.stream, pc._dtlsRole);
	      if (transceiver.rtcpParameters &&
	          transceiver.rtcpParameters.reducedSize) {
	        sdp$1 += 'a=rtcp-rsize\r\n';
	      }
	    });

	    var desc = new window.RTCSessionDescription({
	      type: 'answer',
	      sdp: sdp$1
	    });
	    return Promise.resolve(desc);
	  };

	  RTCPeerConnection.prototype.addIceCandidate = function(candidate) {
	    var pc = this;
	    var sections;
	    if (candidate && !(candidate.sdpMLineIndex !== undefined ||
	        candidate.sdpMid)) {
	      return Promise.reject(new TypeError('sdpMLineIndex or sdpMid required'));
	    }

	    // TODO: needs to go into ops queue.
	    return new Promise(function(resolve, reject) {
	      if (!pc._remoteDescription) {
	        return reject(makeError('InvalidStateError',
	            'Can not add ICE candidate without a remote description'));
	      } else if (!candidate || candidate.candidate === '') {
	        for (var j = 0; j < pc.transceivers.length; j++) {
	          if (pc.transceivers[j].rejected) {
	            continue;
	          }
	          pc.transceivers[j].iceTransport.addRemoteCandidate({});
	          sections = sdp.getMediaSections(pc._remoteDescription.sdp);
	          sections[j] += 'a=end-of-candidates\r\n';
	          pc._remoteDescription.sdp =
	              sdp.getDescription(pc._remoteDescription.sdp) +
	              sections.join('');
	          if (pc.usingBundle) {
	            break;
	          }
	        }
	      } else {
	        var sdpMLineIndex = candidate.sdpMLineIndex;
	        if (candidate.sdpMid) {
	          for (var i = 0; i < pc.transceivers.length; i++) {
	            if (pc.transceivers[i].mid === candidate.sdpMid) {
	              sdpMLineIndex = i;
	              break;
	            }
	          }
	        }
	        var transceiver = pc.transceivers[sdpMLineIndex];
	        if (transceiver) {
	          if (transceiver.rejected) {
	            return resolve();
	          }
	          var cand = Object.keys(candidate.candidate).length > 0 ?
	              sdp.parseCandidate(candidate.candidate) : {};
	          // Ignore Chrome's invalid candidates since Edge does not like them.
	          if (cand.protocol === 'tcp' && (cand.port === 0 || cand.port === 9)) {
	            return resolve();
	          }
	          // Ignore RTCP candidates, we assume RTCP-MUX.
	          if (cand.component && cand.component !== 1) {
	            return resolve();
	          }
	          // when using bundle, avoid adding candidates to the wrong
	          // ice transport. And avoid adding candidates added in the SDP.
	          if (sdpMLineIndex === 0 || (sdpMLineIndex > 0 &&
	              transceiver.iceTransport !== pc.transceivers[0].iceTransport)) {
	            if (!maybeAddCandidate(transceiver.iceTransport, cand)) {
	              return reject(makeError('OperationError',
	                  'Can not add ICE candidate'));
	            }
	          }

	          // update the remoteDescription.
	          var candidateString = candidate.candidate.trim();
	          if (candidateString.indexOf('a=') === 0) {
	            candidateString = candidateString.substr(2);
	          }
	          sections = sdp.getMediaSections(pc._remoteDescription.sdp);
	          sections[sdpMLineIndex] += 'a=' +
	              (cand.type ? candidateString : 'end-of-candidates')
	              + '\r\n';
	          pc._remoteDescription.sdp =
	              sdp.getDescription(pc._remoteDescription.sdp) +
	              sections.join('');
	        } else {
	          return reject(makeError('OperationError',
	              'Can not add ICE candidate'));
	        }
	      }
	      resolve();
	    });
	  };

	  RTCPeerConnection.prototype.getStats = function(selector) {
	    if (selector && selector instanceof window.MediaStreamTrack) {
	      var senderOrReceiver = null;
	      this.transceivers.forEach(function(transceiver) {
	        if (transceiver.rtpSender &&
	            transceiver.rtpSender.track === selector) {
	          senderOrReceiver = transceiver.rtpSender;
	        } else if (transceiver.rtpReceiver &&
	            transceiver.rtpReceiver.track === selector) {
	          senderOrReceiver = transceiver.rtpReceiver;
	        }
	      });
	      if (!senderOrReceiver) {
	        throw makeError('InvalidAccessError', 'Invalid selector.');
	      }
	      return senderOrReceiver.getStats();
	    }

	    var promises = [];
	    this.transceivers.forEach(function(transceiver) {
	      ['rtpSender', 'rtpReceiver', 'iceGatherer', 'iceTransport',
	          'dtlsTransport'].forEach(function(method) {
	            if (transceiver[method]) {
	              promises.push(transceiver[method].getStats());
	            }
	          });
	    });
	    return Promise.all(promises).then(function(allStats) {
	      var results = new Map();
	      allStats.forEach(function(stats) {
	        stats.forEach(function(stat) {
	          results.set(stat.id, stat);
	        });
	      });
	      return results;
	    });
	  };

	  // fix low-level stat names and return Map instead of object.
	  var ortcObjects = ['RTCRtpSender', 'RTCRtpReceiver', 'RTCIceGatherer',
	    'RTCIceTransport', 'RTCDtlsTransport'];
	  ortcObjects.forEach(function(ortcObjectName) {
	    var obj = window[ortcObjectName];
	    if (obj && obj.prototype && obj.prototype.getStats) {
	      var nativeGetstats = obj.prototype.getStats;
	      obj.prototype.getStats = function() {
	        return nativeGetstats.apply(this)
	        .then(function(nativeStats) {
	          var mapStats = new Map();
	          Object.keys(nativeStats).forEach(function(id) {
	            nativeStats[id].type = fixStatsType(nativeStats[id]);
	            mapStats.set(id, nativeStats[id]);
	          });
	          return mapStats;
	        });
	      };
	    }
	  });

	  // legacy callback shims. Should be moved to adapter.js some days.
	  var methods = ['createOffer', 'createAnswer'];
	  methods.forEach(function(method) {
	    var nativeMethod = RTCPeerConnection.prototype[method];
	    RTCPeerConnection.prototype[method] = function() {
	      var args = arguments;
	      if (typeof args[0] === 'function' ||
	          typeof args[1] === 'function') { // legacy
	        return nativeMethod.apply(this, [arguments[2]])
	        .then(function(description) {
	          if (typeof args[0] === 'function') {
	            args[0].apply(null, [description]);
	          }
	        }, function(error) {
	          if (typeof args[1] === 'function') {
	            args[1].apply(null, [error]);
	          }
	        });
	      }
	      return nativeMethod.apply(this, arguments);
	    };
	  });

	  methods = ['setLocalDescription', 'setRemoteDescription', 'addIceCandidate'];
	  methods.forEach(function(method) {
	    var nativeMethod = RTCPeerConnection.prototype[method];
	    RTCPeerConnection.prototype[method] = function() {
	      var args = arguments;
	      if (typeof args[1] === 'function' ||
	          typeof args[2] === 'function') { // legacy
	        return nativeMethod.apply(this, arguments)
	        .then(function() {
	          if (typeof args[1] === 'function') {
	            args[1].apply(null);
	          }
	        }, function(error) {
	          if (typeof args[2] === 'function') {
	            args[2].apply(null, [error]);
	          }
	        });
	      }
	      return nativeMethod.apply(this, arguments);
	    };
	  });

	  // getStats is special. It doesn't have a spec legacy method yet we support
	  // getStats(something, cb) without error callbacks.
	  ['getStats'].forEach(function(method) {
	    var nativeMethod = RTCPeerConnection.prototype[method];
	    RTCPeerConnection.prototype[method] = function() {
	      var args = arguments;
	      if (typeof args[1] === 'function') {
	        return nativeMethod.apply(this, arguments)
	        .then(function() {
	          if (typeof args[1] === 'function') {
	            args[1].apply(null);
	          }
	        });
	      }
	      return nativeMethod.apply(this, arguments);
	    };
	  });

	  return RTCPeerConnection;
	};

	var edge_shim = createCommonjsModule(function (module, exports) {

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.shimGetDisplayMedia = exports.shimGetUserMedia = undefined;



	Object.defineProperty(exports, 'shimGetUserMedia', {
	  enumerable: true,
	  get: function get() {
	    return getusermedia$1.shimGetUserMedia;
	  }
	});



	Object.defineProperty(exports, 'shimGetDisplayMedia', {
	  enumerable: true,
	  get: function get() {
	    return getdisplaymedia$1.shimGetDisplayMedia;
	  }
	});
	exports.shimPeerConnection = shimPeerConnection;
	exports.shimReplaceTrack = shimReplaceTrack;



	var utils$1 = _interopRequireWildcard(utils);





	var _rtcpeerconnectionShim2 = _interopRequireDefault(rtcpeerconnection);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

	function shimPeerConnection(window) {
	  var browserDetails = utils$1.detectBrowser(window);

	  if (window.RTCIceGatherer) {
	    if (!window.RTCIceCandidate) {
	      window.RTCIceCandidate = function RTCIceCandidate(args) {
	        return args;
	      };
	    }
	    if (!window.RTCSessionDescription) {
	      window.RTCSessionDescription = function RTCSessionDescription(args) {
	        return args;
	      };
	    }
	    // this adds an additional event listener to MediaStrackTrack that signals
	    // when a tracks enabled property was changed. Workaround for a bug in
	    // addStream, see below. No longer required in 15025+
	    if (browserDetails.version < 15025) {
	      var origMSTEnabled = Object.getOwnPropertyDescriptor(window.MediaStreamTrack.prototype, 'enabled');
	      Object.defineProperty(window.MediaStreamTrack.prototype, 'enabled', {
	        set: function set(value) {
	          origMSTEnabled.set.call(this, value);
	          var ev = new Event('enabled');
	          ev.enabled = value;
	          this.dispatchEvent(ev);
	        }
	      });
	    }
	  }

	  // ORTC defines the DTMF sender a bit different.
	  // https://github.com/w3c/ortc/issues/714
	  if (window.RTCRtpSender && !('dtmf' in window.RTCRtpSender.prototype)) {
	    Object.defineProperty(window.RTCRtpSender.prototype, 'dtmf', {
	      get: function get() {
	        if (this._dtmf === undefined) {
	          if (this.track.kind === 'audio') {
	            this._dtmf = new window.RTCDtmfSender(this);
	          } else if (this.track.kind === 'video') {
	            this._dtmf = null;
	          }
	        }
	        return this._dtmf;
	      }
	    });
	  }
	  // Edge currently only implements the RTCDtmfSender, not the
	  // RTCDTMFSender alias. See http://draft.ortc.org/#rtcdtmfsender2*
	  if (window.RTCDtmfSender && !window.RTCDTMFSender) {
	    window.RTCDTMFSender = window.RTCDtmfSender;
	  }

	  var RTCPeerConnectionShim = (0, _rtcpeerconnectionShim2.default)(window, browserDetails.version);
	  window.RTCPeerConnection = function RTCPeerConnection(config) {
	    if (config && config.iceServers) {
	      config.iceServers = (0, filtericeservers.filterIceServers)(config.iceServers, browserDetails.version);
	      utils$1.log('ICE servers after filtering:', config.iceServers);
	    }
	    return new RTCPeerConnectionShim(config);
	  };
	  window.RTCPeerConnection.prototype = RTCPeerConnectionShim.prototype;
	}

	function shimReplaceTrack(window) {
	  // ORTC has replaceTrack -- https://github.com/w3c/ortc/issues/614
	  if (window.RTCRtpSender && !('replaceTrack' in window.RTCRtpSender.prototype)) {
	    window.RTCRtpSender.prototype.replaceTrack = window.RTCRtpSender.prototype.setTrack;
	  }
	}
	});

	unwrapExports(edge_shim);
	var edge_shim_1 = edge_shim.shimGetDisplayMedia;
	var edge_shim_2 = edge_shim.shimGetUserMedia;
	var edge_shim_3 = edge_shim.shimPeerConnection;
	var edge_shim_4 = edge_shim.shimReplaceTrack;

	var getusermedia$2 = createCommonjsModule(function (module, exports) {

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

	exports.shimGetUserMedia = shimGetUserMedia;



	var utils$1 = _interopRequireWildcard(utils);

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

	function shimGetUserMedia(window) {
	  var browserDetails = utils$1.detectBrowser(window);
	  var navigator = window && window.navigator;
	  var MediaStreamTrack = window && window.MediaStreamTrack;

	  navigator.getUserMedia = function (constraints, onSuccess, onError) {
	    // Replace Firefox 44+'s deprecation warning with unprefixed version.
	    utils$1.deprecated('navigator.getUserMedia', 'navigator.mediaDevices.getUserMedia');
	    navigator.mediaDevices.getUserMedia(constraints).then(onSuccess, onError);
	  };

	  if (!(browserDetails.version > 55 && 'autoGainControl' in navigator.mediaDevices.getSupportedConstraints())) {
	    var remap = function remap(obj, a, b) {
	      if (a in obj && !(b in obj)) {
	        obj[b] = obj[a];
	        delete obj[a];
	      }
	    };

	    var nativeGetUserMedia = navigator.mediaDevices.getUserMedia.bind(navigator.mediaDevices);
	    navigator.mediaDevices.getUserMedia = function (c) {
	      if ((typeof c === 'undefined' ? 'undefined' : _typeof(c)) === 'object' && _typeof(c.audio) === 'object') {
	        c = JSON.parse(JSON.stringify(c));
	        remap(c.audio, 'autoGainControl', 'mozAutoGainControl');
	        remap(c.audio, 'noiseSuppression', 'mozNoiseSuppression');
	      }
	      return nativeGetUserMedia(c);
	    };

	    if (MediaStreamTrack && MediaStreamTrack.prototype.getSettings) {
	      var nativeGetSettings = MediaStreamTrack.prototype.getSettings;
	      MediaStreamTrack.prototype.getSettings = function () {
	        var obj = nativeGetSettings.apply(this, arguments);
	        remap(obj, 'mozAutoGainControl', 'autoGainControl');
	        remap(obj, 'mozNoiseSuppression', 'noiseSuppression');
	        return obj;
	      };
	    }

	    if (MediaStreamTrack && MediaStreamTrack.prototype.applyConstraints) {
	      var nativeApplyConstraints = MediaStreamTrack.prototype.applyConstraints;
	      MediaStreamTrack.prototype.applyConstraints = function (c) {
	        if (this.kind === 'audio' && (typeof c === 'undefined' ? 'undefined' : _typeof(c)) === 'object') {
	          c = JSON.parse(JSON.stringify(c));
	          remap(c, 'autoGainControl', 'mozAutoGainControl');
	          remap(c, 'noiseSuppression', 'mozNoiseSuppression');
	        }
	        return nativeApplyConstraints.apply(this, [c]);
	      };
	    }
	  }
	}
	});

	unwrapExports(getusermedia$2);
	var getusermedia_1$2 = getusermedia$2.shimGetUserMedia;

	var getdisplaymedia$2 = createCommonjsModule(function (module, exports) {

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.shimGetDisplayMedia = shimGetDisplayMedia;
	function shimGetDisplayMedia(window, preferredMediaSource) {
	  if (window.navigator.mediaDevices && 'getDisplayMedia' in window.navigator.mediaDevices) {
	    return;
	  }
	  if (!window.navigator.mediaDevices) {
	    return;
	  }
	  window.navigator.mediaDevices.getDisplayMedia = function getDisplayMedia(constraints) {
	    if (!(constraints && constraints.video)) {
	      var err = new DOMException('getDisplayMedia without video ' + 'constraints is undefined');
	      err.name = 'NotFoundError';
	      // from https://heycam.github.io/webidl/#idl-DOMException-error-names
	      err.code = 8;
	      return Promise.reject(err);
	    }
	    if (constraints.video === true) {
	      constraints.video = { mediaSource: preferredMediaSource };
	    } else {
	      constraints.video.mediaSource = preferredMediaSource;
	    }
	    return window.navigator.mediaDevices.getUserMedia(constraints);
	  };
	}
	});

	unwrapExports(getdisplaymedia$2);
	var getdisplaymedia_1$2 = getdisplaymedia$2.shimGetDisplayMedia;

	var firefox_shim = createCommonjsModule(function (module, exports) {

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.shimGetDisplayMedia = exports.shimGetUserMedia = undefined;

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };



	Object.defineProperty(exports, 'shimGetUserMedia', {
	  enumerable: true,
	  get: function get() {
	    return getusermedia$2.shimGetUserMedia;
	  }
	});



	Object.defineProperty(exports, 'shimGetDisplayMedia', {
	  enumerable: true,
	  get: function get() {
	    return getdisplaymedia$2.shimGetDisplayMedia;
	  }
	});
	exports.shimOnTrack = shimOnTrack;
	exports.shimPeerConnection = shimPeerConnection;
	exports.shimSenderGetStats = shimSenderGetStats;
	exports.shimReceiverGetStats = shimReceiverGetStats;
	exports.shimRemoveStream = shimRemoveStream;
	exports.shimRTCDataChannel = shimRTCDataChannel;



	var utils$1 = _interopRequireWildcard(utils);

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

	function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

	function shimOnTrack(window) {
	  if ((typeof window === 'undefined' ? 'undefined' : _typeof(window)) === 'object' && window.RTCTrackEvent && 'receiver' in window.RTCTrackEvent.prototype && !('transceiver' in window.RTCTrackEvent.prototype)) {
	    Object.defineProperty(window.RTCTrackEvent.prototype, 'transceiver', {
	      get: function get() {
	        return { receiver: this.receiver };
	      }
	    });
	  }
	}

	function shimPeerConnection(window) {
	  var browserDetails = utils$1.detectBrowser(window);

	  if ((typeof window === 'undefined' ? 'undefined' : _typeof(window)) !== 'object' || !(window.RTCPeerConnection || window.mozRTCPeerConnection)) {
	    return; // probably media.peerconnection.enabled=false in about:config
	  }
	  if (!window.RTCPeerConnection && window.mozRTCPeerConnection) {
	    // very basic support for old versions.
	    window.RTCPeerConnection = window.mozRTCPeerConnection;
	  }

	  if (browserDetails.version < 53) {
	    // shim away need for obsolete RTCIceCandidate/RTCSessionDescription.
	    ['setLocalDescription', 'setRemoteDescription', 'addIceCandidate'].forEach(function (method) {
	      var nativeMethod = window.RTCPeerConnection.prototype[method];
	      var methodObj = _defineProperty({}, method, function () {
	        arguments[0] = new (method === 'addIceCandidate' ? window.RTCIceCandidate : window.RTCSessionDescription)(arguments[0]);
	        return nativeMethod.apply(this, arguments);
	      });
	      window.RTCPeerConnection.prototype[method] = methodObj[method];
	    });
	  }

	  // support for addIceCandidate(null or undefined)
	  var nativeAddIceCandidate = window.RTCPeerConnection.prototype.addIceCandidate;
	  window.RTCPeerConnection.prototype.addIceCandidate = function addIceCandidate() {
	    if (!arguments[0]) {
	      if (arguments[1]) {
	        arguments[1].apply(null);
	      }
	      return Promise.resolve();
	    }
	    // Firefox 68+ emits and processes {candidate: "", ...}, ignore
	    // in older versions.
	    if (browserDetails.version < 68 && arguments[0] && arguments[0].candidate === '') {
	      return Promise.resolve();
	    }
	    return nativeAddIceCandidate.apply(this, arguments);
	  };

	  var modernStatsTypes = {
	    inboundrtp: 'inbound-rtp',
	    outboundrtp: 'outbound-rtp',
	    candidatepair: 'candidate-pair',
	    localcandidate: 'local-candidate',
	    remotecandidate: 'remote-candidate'
	  };

	  var nativeGetStats = window.RTCPeerConnection.prototype.getStats;
	  window.RTCPeerConnection.prototype.getStats = function getStats() {
	    var _arguments = Array.prototype.slice.call(arguments),
	        selector = _arguments[0],
	        onSucc = _arguments[1],
	        onErr = _arguments[2];

	    return nativeGetStats.apply(this, [selector || null]).then(function (stats) {
	      if (browserDetails.version < 53 && !onSucc) {
	        // Shim only promise getStats with spec-hyphens in type names
	        // Leave callback version alone; misc old uses of forEach before Map
	        try {
	          stats.forEach(function (stat) {
	            stat.type = modernStatsTypes[stat.type] || stat.type;
	          });
	        } catch (e) {
	          if (e.name !== 'TypeError') {
	            throw e;
	          }
	          // Avoid TypeError: "type" is read-only, in old versions. 34-43ish
	          stats.forEach(function (stat, i) {
	            stats.set(i, Object.assign({}, stat, {
	              type: modernStatsTypes[stat.type] || stat.type
	            }));
	          });
	        }
	      }
	      return stats;
	    }).then(onSucc, onErr);
	  };
	}

	function shimSenderGetStats(window) {
	  if (!((typeof window === 'undefined' ? 'undefined' : _typeof(window)) === 'object' && window.RTCPeerConnection && window.RTCRtpSender)) {
	    return;
	  }
	  if (window.RTCRtpSender && 'getStats' in window.RTCRtpSender.prototype) {
	    return;
	  }
	  var origGetSenders = window.RTCPeerConnection.prototype.getSenders;
	  if (origGetSenders) {
	    window.RTCPeerConnection.prototype.getSenders = function getSenders() {
	      var _this = this;

	      var senders = origGetSenders.apply(this, []);
	      senders.forEach(function (sender) {
	        return sender._pc = _this;
	      });
	      return senders;
	    };
	  }

	  var origAddTrack = window.RTCPeerConnection.prototype.addTrack;
	  if (origAddTrack) {
	    window.RTCPeerConnection.prototype.addTrack = function addTrack() {
	      var sender = origAddTrack.apply(this, arguments);
	      sender._pc = this;
	      return sender;
	    };
	  }
	  window.RTCRtpSender.prototype.getStats = function getStats() {
	    return this.track ? this._pc.getStats(this.track) : Promise.resolve(new Map());
	  };
	}

	function shimReceiverGetStats(window) {
	  if (!((typeof window === 'undefined' ? 'undefined' : _typeof(window)) === 'object' && window.RTCPeerConnection && window.RTCRtpSender)) {
	    return;
	  }
	  if (window.RTCRtpSender && 'getStats' in window.RTCRtpReceiver.prototype) {
	    return;
	  }
	  var origGetReceivers = window.RTCPeerConnection.prototype.getReceivers;
	  if (origGetReceivers) {
	    window.RTCPeerConnection.prototype.getReceivers = function getReceivers() {
	      var _this2 = this;

	      var receivers = origGetReceivers.apply(this, []);
	      receivers.forEach(function (receiver) {
	        return receiver._pc = _this2;
	      });
	      return receivers;
	    };
	  }
	  utils$1.wrapPeerConnectionEvent(window, 'track', function (e) {
	    e.receiver._pc = e.srcElement;
	    return e;
	  });
	  window.RTCRtpReceiver.prototype.getStats = function getStats() {
	    return this._pc.getStats(this.track);
	  };
	}

	function shimRemoveStream(window) {
	  if (!window.RTCPeerConnection || 'removeStream' in window.RTCPeerConnection.prototype) {
	    return;
	  }
	  window.RTCPeerConnection.prototype.removeStream = function removeStream(stream) {
	    var _this3 = this;

	    utils$1.deprecated('removeStream', 'removeTrack');
	    this.getSenders().forEach(function (sender) {
	      if (sender.track && stream.getTracks().includes(sender.track)) {
	        _this3.removeTrack(sender);
	      }
	    });
	  };
	}

	function shimRTCDataChannel(window) {
	  // rename DataChannel to RTCDataChannel (native fix in FF60):
	  // https://bugzilla.mozilla.org/show_bug.cgi?id=1173851
	  if (window.DataChannel && !window.RTCDataChannel) {
	    window.RTCDataChannel = window.DataChannel;
	  }
	}
	});

	unwrapExports(firefox_shim);
	var firefox_shim_1 = firefox_shim.shimGetDisplayMedia;
	var firefox_shim_2 = firefox_shim.shimGetUserMedia;
	var firefox_shim_3 = firefox_shim.shimOnTrack;
	var firefox_shim_4 = firefox_shim.shimPeerConnection;
	var firefox_shim_5 = firefox_shim.shimSenderGetStats;
	var firefox_shim_6 = firefox_shim.shimReceiverGetStats;
	var firefox_shim_7 = firefox_shim.shimRemoveStream;
	var firefox_shim_8 = firefox_shim.shimRTCDataChannel;

	var safari_shim = createCommonjsModule(function (module, exports) {

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

	exports.shimLocalStreamsAPI = shimLocalStreamsAPI;
	exports.shimRemoteStreamsAPI = shimRemoteStreamsAPI;
	exports.shimCallbacksAPI = shimCallbacksAPI;
	exports.shimGetUserMedia = shimGetUserMedia;
	exports.shimConstraints = shimConstraints;
	exports.shimRTCIceServerUrls = shimRTCIceServerUrls;
	exports.shimTrackEventTransceiver = shimTrackEventTransceiver;
	exports.shimCreateOfferLegacy = shimCreateOfferLegacy;



	var utils$1 = _interopRequireWildcard(utils);

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

	function shimLocalStreamsAPI(window) {
	  if ((typeof window === 'undefined' ? 'undefined' : _typeof(window)) !== 'object' || !window.RTCPeerConnection) {
	    return;
	  }
	  if (!('getLocalStreams' in window.RTCPeerConnection.prototype)) {
	    window.RTCPeerConnection.prototype.getLocalStreams = function getLocalStreams() {
	      if (!this._localStreams) {
	        this._localStreams = [];
	      }
	      return this._localStreams;
	    };
	  }
	  if (!('addStream' in window.RTCPeerConnection.prototype)) {
	    var _addTrack = window.RTCPeerConnection.prototype.addTrack;
	    window.RTCPeerConnection.prototype.addStream = function addStream(stream) {
	      var _this = this;

	      if (!this._localStreams) {
	        this._localStreams = [];
	      }
	      if (!this._localStreams.includes(stream)) {
	        this._localStreams.push(stream);
	      }
	      // Try to emulate Chrome's behaviour of adding in audio-video order.
	      // Safari orders by track id.
	      stream.getAudioTracks().forEach(function (track) {
	        return _addTrack.call(_this, track, stream);
	      });
	      stream.getVideoTracks().forEach(function (track) {
	        return _addTrack.call(_this, track, stream);
	      });
	    };

	    window.RTCPeerConnection.prototype.addTrack = function addTrack(track, stream) {
	      if (stream) {
	        if (!this._localStreams) {
	          this._localStreams = [stream];
	        } else if (!this._localStreams.includes(stream)) {
	          this._localStreams.push(stream);
	        }
	      }
	      return _addTrack.call(this, track, stream);
	    };
	  }
	  if (!('removeStream' in window.RTCPeerConnection.prototype)) {
	    window.RTCPeerConnection.prototype.removeStream = function removeStream(stream) {
	      var _this2 = this;

	      if (!this._localStreams) {
	        this._localStreams = [];
	      }
	      var index = this._localStreams.indexOf(stream);
	      if (index === -1) {
	        return;
	      }
	      this._localStreams.splice(index, 1);
	      var tracks = stream.getTracks();
	      this.getSenders().forEach(function (sender) {
	        if (tracks.includes(sender.track)) {
	          _this2.removeTrack(sender);
	        }
	      });
	    };
	  }
	}

	function shimRemoteStreamsAPI(window) {
	  if ((typeof window === 'undefined' ? 'undefined' : _typeof(window)) !== 'object' || !window.RTCPeerConnection) {
	    return;
	  }
	  if (!('getRemoteStreams' in window.RTCPeerConnection.prototype)) {
	    window.RTCPeerConnection.prototype.getRemoteStreams = function getRemoteStreams() {
	      return this._remoteStreams ? this._remoteStreams : [];
	    };
	  }
	  if (!('onaddstream' in window.RTCPeerConnection.prototype)) {
	    Object.defineProperty(window.RTCPeerConnection.prototype, 'onaddstream', {
	      get: function get() {
	        return this._onaddstream;
	      },
	      set: function set(f) {
	        var _this3 = this;

	        if (this._onaddstream) {
	          this.removeEventListener('addstream', this._onaddstream);
	          this.removeEventListener('track', this._onaddstreampoly);
	        }
	        this.addEventListener('addstream', this._onaddstream = f);
	        this.addEventListener('track', this._onaddstreampoly = function (e) {
	          e.streams.forEach(function (stream) {
	            if (!_this3._remoteStreams) {
	              _this3._remoteStreams = [];
	            }
	            if (_this3._remoteStreams.includes(stream)) {
	              return;
	            }
	            _this3._remoteStreams.push(stream);
	            var event = new Event('addstream');
	            event.stream = stream;
	            _this3.dispatchEvent(event);
	          });
	        });
	      }
	    });
	    var origSetRemoteDescription = window.RTCPeerConnection.prototype.setRemoteDescription;
	    window.RTCPeerConnection.prototype.setRemoteDescription = function setRemoteDescription() {
	      var pc = this;
	      if (!this._onaddstreampoly) {
	        this.addEventListener('track', this._onaddstreampoly = function (e) {
	          e.streams.forEach(function (stream) {
	            if (!pc._remoteStreams) {
	              pc._remoteStreams = [];
	            }
	            if (pc._remoteStreams.indexOf(stream) >= 0) {
	              return;
	            }
	            pc._remoteStreams.push(stream);
	            var event = new Event('addstream');
	            event.stream = stream;
	            pc.dispatchEvent(event);
	          });
	        });
	      }
	      return origSetRemoteDescription.apply(pc, arguments);
	    };
	  }
	}

	function shimCallbacksAPI(window) {
	  if ((typeof window === 'undefined' ? 'undefined' : _typeof(window)) !== 'object' || !window.RTCPeerConnection) {
	    return;
	  }
	  var prototype = window.RTCPeerConnection.prototype;
	  var origCreateOffer = prototype.createOffer;
	  var origCreateAnswer = prototype.createAnswer;
	  var setLocalDescription = prototype.setLocalDescription;
	  var setRemoteDescription = prototype.setRemoteDescription;
	  var addIceCandidate = prototype.addIceCandidate;

	  prototype.createOffer = function createOffer(successCallback, failureCallback) {
	    var options = arguments.length >= 2 ? arguments[2] : arguments[0];
	    var promise = origCreateOffer.apply(this, [options]);
	    if (!failureCallback) {
	      return promise;
	    }
	    promise.then(successCallback, failureCallback);
	    return Promise.resolve();
	  };

	  prototype.createAnswer = function createAnswer(successCallback, failureCallback) {
	    var options = arguments.length >= 2 ? arguments[2] : arguments[0];
	    var promise = origCreateAnswer.apply(this, [options]);
	    if (!failureCallback) {
	      return promise;
	    }
	    promise.then(successCallback, failureCallback);
	    return Promise.resolve();
	  };

	  var withCallback = function withCallback(description, successCallback, failureCallback) {
	    var promise = setLocalDescription.apply(this, [description]);
	    if (!failureCallback) {
	      return promise;
	    }
	    promise.then(successCallback, failureCallback);
	    return Promise.resolve();
	  };
	  prototype.setLocalDescription = withCallback;

	  withCallback = function withCallback(description, successCallback, failureCallback) {
	    var promise = setRemoteDescription.apply(this, [description]);
	    if (!failureCallback) {
	      return promise;
	    }
	    promise.then(successCallback, failureCallback);
	    return Promise.resolve();
	  };
	  prototype.setRemoteDescription = withCallback;

	  withCallback = function withCallback(candidate, successCallback, failureCallback) {
	    var promise = addIceCandidate.apply(this, [candidate]);
	    if (!failureCallback) {
	      return promise;
	    }
	    promise.then(successCallback, failureCallback);
	    return Promise.resolve();
	  };
	  prototype.addIceCandidate = withCallback;
	}

	function shimGetUserMedia(window) {
	  var navigator = window && window.navigator;

	  if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
	    // shim not needed in Safari 12.1
	    var mediaDevices = navigator.mediaDevices;
	    var _getUserMedia = mediaDevices.getUserMedia.bind(mediaDevices);
	    navigator.mediaDevices.getUserMedia = function (constraints) {
	      return _getUserMedia(shimConstraints(constraints));
	    };
	  }

	  if (!navigator.getUserMedia && navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
	    navigator.getUserMedia = function getUserMedia(constraints, cb, errcb) {
	      navigator.mediaDevices.getUserMedia(constraints).then(cb, errcb);
	    }.bind(navigator);
	  }
	}

	function shimConstraints(constraints) {
	  if (constraints && constraints.video !== undefined) {
	    return Object.assign({}, constraints, { video: utils$1.compactObject(constraints.video) });
	  }

	  return constraints;
	}

	function shimRTCIceServerUrls(window) {
	  // migrate from non-spec RTCIceServer.url to RTCIceServer.urls
	  var OrigPeerConnection = window.RTCPeerConnection;
	  window.RTCPeerConnection = function RTCPeerConnection(pcConfig, pcConstraints) {
	    if (pcConfig && pcConfig.iceServers) {
	      var newIceServers = [];
	      for (var i = 0; i < pcConfig.iceServers.length; i++) {
	        var server = pcConfig.iceServers[i];
	        if (!server.hasOwnProperty('urls') && server.hasOwnProperty('url')) {
	          utils$1.deprecated('RTCIceServer.url', 'RTCIceServer.urls');
	          server = JSON.parse(JSON.stringify(server));
	          server.urls = server.url;
	          delete server.url;
	          newIceServers.push(server);
	        } else {
	          newIceServers.push(pcConfig.iceServers[i]);
	        }
	      }
	      pcConfig.iceServers = newIceServers;
	    }
	    return new OrigPeerConnection(pcConfig, pcConstraints);
	  };
	  window.RTCPeerConnection.prototype = OrigPeerConnection.prototype;
	  // wrap static methods. Currently just generateCertificate.
	  if ('generateCertificate' in window.RTCPeerConnection) {
	    Object.defineProperty(window.RTCPeerConnection, 'generateCertificate', {
	      get: function get() {
	        return OrigPeerConnection.generateCertificate;
	      }
	    });
	  }
	}

	function shimTrackEventTransceiver(window) {
	  // Add event.transceiver member over deprecated event.receiver
	  if ((typeof window === 'undefined' ? 'undefined' : _typeof(window)) === 'object' && window.RTCTrackEvent && 'receiver' in window.RTCTrackEvent.prototype && !('transceiver' in window.RTCTrackEvent.prototype)) {
	    Object.defineProperty(window.RTCTrackEvent.prototype, 'transceiver', {
	      get: function get() {
	        return { receiver: this.receiver };
	      }
	    });
	  }
	}

	function shimCreateOfferLegacy(window) {
	  var origCreateOffer = window.RTCPeerConnection.prototype.createOffer;
	  window.RTCPeerConnection.prototype.createOffer = function createOffer(offerOptions) {
	    if (offerOptions) {
	      if (typeof offerOptions.offerToReceiveAudio !== 'undefined') {
	        // support bit values
	        offerOptions.offerToReceiveAudio = !!offerOptions.offerToReceiveAudio;
	      }
	      var audioTransceiver = this.getTransceivers().find(function (transceiver) {
	        return transceiver.receiver.track.kind === 'audio';
	      });
	      if (offerOptions.offerToReceiveAudio === false && audioTransceiver) {
	        if (audioTransceiver.direction === 'sendrecv') {
	          if (audioTransceiver.setDirection) {
	            audioTransceiver.setDirection('sendonly');
	          } else {
	            audioTransceiver.direction = 'sendonly';
	          }
	        } else if (audioTransceiver.direction === 'recvonly') {
	          if (audioTransceiver.setDirection) {
	            audioTransceiver.setDirection('inactive');
	          } else {
	            audioTransceiver.direction = 'inactive';
	          }
	        }
	      } else if (offerOptions.offerToReceiveAudio === true && !audioTransceiver) {
	        this.addTransceiver('audio');
	      }

	      if (typeof offerOptions.offerToReceiveVideo !== 'undefined') {
	        // support bit values
	        offerOptions.offerToReceiveVideo = !!offerOptions.offerToReceiveVideo;
	      }
	      var videoTransceiver = this.getTransceivers().find(function (transceiver) {
	        return transceiver.receiver.track.kind === 'video';
	      });
	      if (offerOptions.offerToReceiveVideo === false && videoTransceiver) {
	        if (videoTransceiver.direction === 'sendrecv') {
	          if (videoTransceiver.setDirection) {
	            videoTransceiver.setDirection('sendonly');
	          } else {
	            videoTransceiver.direction = 'sendonly';
	          }
	        } else if (videoTransceiver.direction === 'recvonly') {
	          if (videoTransceiver.setDirection) {
	            videoTransceiver.setDirection('inactive');
	          } else {
	            videoTransceiver.direction = 'inactive';
	          }
	        }
	      } else if (offerOptions.offerToReceiveVideo === true && !videoTransceiver) {
	        this.addTransceiver('video');
	      }
	    }
	    return origCreateOffer.apply(this, arguments);
	  };
	}
	});

	unwrapExports(safari_shim);
	var safari_shim_1 = safari_shim.shimLocalStreamsAPI;
	var safari_shim_2 = safari_shim.shimRemoteStreamsAPI;
	var safari_shim_3 = safari_shim.shimCallbacksAPI;
	var safari_shim_4 = safari_shim.shimGetUserMedia;
	var safari_shim_5 = safari_shim.shimConstraints;
	var safari_shim_6 = safari_shim.shimRTCIceServerUrls;
	var safari_shim_7 = safari_shim.shimTrackEventTransceiver;
	var safari_shim_8 = safari_shim.shimCreateOfferLegacy;

	var common_shim = createCommonjsModule(function (module, exports) {

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

	exports.shimRTCIceCandidate = shimRTCIceCandidate;
	exports.shimMaxMessageSize = shimMaxMessageSize;
	exports.shimSendThrowTypeError = shimSendThrowTypeError;
	exports.shimConnectionState = shimConnectionState;
	exports.removeAllowExtmapMixed = removeAllowExtmapMixed;



	var _sdp2 = _interopRequireDefault(sdp);



	var utils$1 = _interopRequireWildcard(utils);

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function shimRTCIceCandidate(window) {
	  // foundation is arbitrarily chosen as an indicator for full support for
	  // https://w3c.github.io/webrtc-pc/#rtcicecandidate-interface
	  if (!window.RTCIceCandidate || window.RTCIceCandidate && 'foundation' in window.RTCIceCandidate.prototype) {
	    return;
	  }

	  var NativeRTCIceCandidate = window.RTCIceCandidate;
	  window.RTCIceCandidate = function RTCIceCandidate(args) {
	    // Remove the a= which shouldn't be part of the candidate string.
	    if ((typeof args === 'undefined' ? 'undefined' : _typeof(args)) === 'object' && args.candidate && args.candidate.indexOf('a=') === 0) {
	      args = JSON.parse(JSON.stringify(args));
	      args.candidate = args.candidate.substr(2);
	    }

	    if (args.candidate && args.candidate.length) {
	      // Augment the native candidate with the parsed fields.
	      var nativeCandidate = new NativeRTCIceCandidate(args);
	      var parsedCandidate = _sdp2.default.parseCandidate(args.candidate);
	      var augmentedCandidate = Object.assign(nativeCandidate, parsedCandidate);

	      // Add a serializer that does not serialize the extra attributes.
	      augmentedCandidate.toJSON = function toJSON() {
	        return {
	          candidate: augmentedCandidate.candidate,
	          sdpMid: augmentedCandidate.sdpMid,
	          sdpMLineIndex: augmentedCandidate.sdpMLineIndex,
	          usernameFragment: augmentedCandidate.usernameFragment
	        };
	      };
	      return augmentedCandidate;
	    }
	    return new NativeRTCIceCandidate(args);
	  };
	  window.RTCIceCandidate.prototype = NativeRTCIceCandidate.prototype;

	  // Hook up the augmented candidate in onicecandidate and
	  // addEventListener('icecandidate', ...)
	  utils$1.wrapPeerConnectionEvent(window, 'icecandidate', function (e) {
	    if (e.candidate) {
	      Object.defineProperty(e, 'candidate', {
	        value: new window.RTCIceCandidate(e.candidate),
	        writable: 'false'
	      });
	    }
	    return e;
	  });
	}

	function shimMaxMessageSize(window) {
	  if (!window.RTCPeerConnection) {
	    return;
	  }
	  var browserDetails = utils$1.detectBrowser(window);

	  if (!('sctp' in window.RTCPeerConnection.prototype)) {
	    Object.defineProperty(window.RTCPeerConnection.prototype, 'sctp', {
	      get: function get() {
	        return typeof this._sctp === 'undefined' ? null : this._sctp;
	      }
	    });
	  }

	  var sctpInDescription = function sctpInDescription(description) {
	    if (!description || !description.sdp) {
	      return false;
	    }
	    var sections = _sdp2.default.splitSections(description.sdp);
	    sections.shift();
	    return sections.some(function (mediaSection) {
	      var mLine = _sdp2.default.parseMLine(mediaSection);
	      return mLine && mLine.kind === 'application' && mLine.protocol.indexOf('SCTP') !== -1;
	    });
	  };

	  var getRemoteFirefoxVersion = function getRemoteFirefoxVersion(description) {
	    // TODO: Is there a better solution for detecting Firefox?
	    var match = description.sdp.match(/mozilla...THIS_IS_SDPARTA-(\d+)/);
	    if (match === null || match.length < 2) {
	      return -1;
	    }
	    var version = parseInt(match[1], 10);
	    // Test for NaN (yes, this is ugly)
	    return version !== version ? -1 : version;
	  };

	  var getCanSendMaxMessageSize = function getCanSendMaxMessageSize(remoteIsFirefox) {
	    // Every implementation we know can send at least 64 KiB.
	    // Note: Although Chrome is technically able to send up to 256 KiB, the
	    //       data does not reach the other peer reliably.
	    //       See: https://bugs.chromium.org/p/webrtc/issues/detail?id=8419
	    var canSendMaxMessageSize = 65536;
	    if (browserDetails.browser === 'firefox') {
	      if (browserDetails.version < 57) {
	        if (remoteIsFirefox === -1) {
	          // FF < 57 will send in 16 KiB chunks using the deprecated PPID
	          // fragmentation.
	          canSendMaxMessageSize = 16384;
	        } else {
	          // However, other FF (and RAWRTC) can reassemble PPID-fragmented
	          // messages. Thus, supporting ~2 GiB when sending.
	          canSendMaxMessageSize = 2147483637;
	        }
	      } else if (browserDetails.version < 60) {
	        // Currently, all FF >= 57 will reset the remote maximum message size
	        // to the default value when a data channel is created at a later
	        // stage. :(
	        // See: https://bugzilla.mozilla.org/show_bug.cgi?id=1426831
	        canSendMaxMessageSize = browserDetails.version === 57 ? 65535 : 65536;
	      } else {
	        // FF >= 60 supports sending ~2 GiB
	        canSendMaxMessageSize = 2147483637;
	      }
	    }
	    return canSendMaxMessageSize;
	  };

	  var getMaxMessageSize = function getMaxMessageSize(description, remoteIsFirefox) {
	    // Note: 65536 bytes is the default value from the SDP spec. Also,
	    //       every implementation we know supports receiving 65536 bytes.
	    var maxMessageSize = 65536;

	    // FF 57 has a slightly incorrect default remote max message size, so
	    // we need to adjust it here to avoid a failure when sending.
	    // See: https://bugzilla.mozilla.org/show_bug.cgi?id=1425697
	    if (browserDetails.browser === 'firefox' && browserDetails.version === 57) {
	      maxMessageSize = 65535;
	    }

	    var match = _sdp2.default.matchPrefix(description.sdp, 'a=max-message-size:');
	    if (match.length > 0) {
	      maxMessageSize = parseInt(match[0].substr(19), 10);
	    } else if (browserDetails.browser === 'firefox' && remoteIsFirefox !== -1) {
	      // If the maximum message size is not present in the remote SDP and
	      // both local and remote are Firefox, the remote peer can receive
	      // ~2 GiB.
	      maxMessageSize = 2147483637;
	    }
	    return maxMessageSize;
	  };

	  var origSetRemoteDescription = window.RTCPeerConnection.prototype.setRemoteDescription;
	  window.RTCPeerConnection.prototype.setRemoteDescription = function setRemoteDescription() {
	    this._sctp = null;
	    // Chrome decided to not expose .sctp in plan-b mode.
	    // As usual, adapter.js has to do an 'ugly worakaround'
	    // to cover up the mess.
	    if (browserDetails.browser === 'chrome' && browserDetails.version >= 76) {
	      var _getConfiguration = this.getConfiguration(),
	          sdpSemantics = _getConfiguration.sdpSemantics;

	      if (sdpSemantics === 'plan-b') {
	        Object.defineProperty(this, 'sctp', {
	          get: function get() {
	            return typeof this._sctp === 'undefined' ? null : this._sctp;
	          },

	          enumerable: true,
	          configurable: true
	        });
	      }
	    }

	    if (sctpInDescription(arguments[0])) {
	      // Check if the remote is FF.
	      var isFirefox = getRemoteFirefoxVersion(arguments[0]);

	      // Get the maximum message size the local peer is capable of sending
	      var canSendMMS = getCanSendMaxMessageSize(isFirefox);

	      // Get the maximum message size of the remote peer.
	      var remoteMMS = getMaxMessageSize(arguments[0], isFirefox);

	      // Determine final maximum message size
	      var maxMessageSize = void 0;
	      if (canSendMMS === 0 && remoteMMS === 0) {
	        maxMessageSize = Number.POSITIVE_INFINITY;
	      } else if (canSendMMS === 0 || remoteMMS === 0) {
	        maxMessageSize = Math.max(canSendMMS, remoteMMS);
	      } else {
	        maxMessageSize = Math.min(canSendMMS, remoteMMS);
	      }

	      // Create a dummy RTCSctpTransport object and the 'maxMessageSize'
	      // attribute.
	      var sctp = {};
	      Object.defineProperty(sctp, 'maxMessageSize', {
	        get: function get() {
	          return maxMessageSize;
	        }
	      });
	      this._sctp = sctp;
	    }

	    return origSetRemoteDescription.apply(this, arguments);
	  };
	}

	function shimSendThrowTypeError(window) {
	  if (!(window.RTCPeerConnection && 'createDataChannel' in window.RTCPeerConnection.prototype)) {
	    return;
	  }

	  // Note: Although Firefox >= 57 has a native implementation, the maximum
	  //       message size can be reset for all data channels at a later stage.
	  //       See: https://bugzilla.mozilla.org/show_bug.cgi?id=1426831

	  function wrapDcSend(dc, pc) {
	    var origDataChannelSend = dc.send;
	    dc.send = function send() {
	      var data = arguments[0];
	      var length = data.length || data.size || data.byteLength;
	      if (dc.readyState === 'open' && pc.sctp && length > pc.sctp.maxMessageSize) {
	        throw new TypeError('Message too large (can send a maximum of ' + pc.sctp.maxMessageSize + ' bytes)');
	      }
	      return origDataChannelSend.apply(dc, arguments);
	    };
	  }
	  var origCreateDataChannel = window.RTCPeerConnection.prototype.createDataChannel;
	  window.RTCPeerConnection.prototype.createDataChannel = function createDataChannel() {
	    var dataChannel = origCreateDataChannel.apply(this, arguments);
	    wrapDcSend(dataChannel, this);
	    return dataChannel;
	  };
	  utils$1.wrapPeerConnectionEvent(window, 'datachannel', function (e) {
	    wrapDcSend(e.channel, e.target);
	    return e;
	  });
	}

	/* shims RTCConnectionState by pretending it is the same as iceConnectionState.
	 * See https://bugs.chromium.org/p/webrtc/issues/detail?id=6145#c12
	 * for why this is a valid hack in Chrome. In Firefox it is slightly incorrect
	 * since DTLS failures would be hidden. See
	 * https://bugzilla.mozilla.org/show_bug.cgi?id=1265827
	 * for the Firefox tracking bug.
	 */
	function shimConnectionState(window) {
	  if (!window.RTCPeerConnection || 'connectionState' in window.RTCPeerConnection.prototype) {
	    return;
	  }
	  var proto = window.RTCPeerConnection.prototype;
	  Object.defineProperty(proto, 'connectionState', {
	    get: function get() {
	      return {
	        completed: 'connected',
	        checking: 'connecting'
	      }[this.iceConnectionState] || this.iceConnectionState;
	    },

	    enumerable: true,
	    configurable: true
	  });
	  Object.defineProperty(proto, 'onconnectionstatechange', {
	    get: function get() {
	      return this._onconnectionstatechange || null;
	    },
	    set: function set(cb) {
	      if (this._onconnectionstatechange) {
	        this.removeEventListener('connectionstatechange', this._onconnectionstatechange);
	        delete this._onconnectionstatechange;
	      }
	      if (cb) {
	        this.addEventListener('connectionstatechange', this._onconnectionstatechange = cb);
	      }
	    },

	    enumerable: true,
	    configurable: true
	  });

	  ['setLocalDescription', 'setRemoteDescription'].forEach(function (method) {
	    var origMethod = proto[method];
	    proto[method] = function () {
	      if (!this._connectionstatechangepoly) {
	        this._connectionstatechangepoly = function (e) {
	          var pc = e.target;
	          if (pc._lastConnectionState !== pc.connectionState) {
	            pc._lastConnectionState = pc.connectionState;
	            var newEvent = new Event('connectionstatechange', e);
	            pc.dispatchEvent(newEvent);
	          }
	          return e;
	        };
	        this.addEventListener('iceconnectionstatechange', this._connectionstatechangepoly);
	      }
	      return origMethod.apply(this, arguments);
	    };
	  });
	}

	function removeAllowExtmapMixed(window) {
	  /* remove a=extmap-allow-mixed for Chrome < M71 */
	  if (!window.RTCPeerConnection) {
	    return;
	  }
	  var browserDetails = utils$1.detectBrowser(window);
	  if (browserDetails.browser === 'chrome' && browserDetails.version >= 71) {
	    return;
	  }
	  var nativeSRD = window.RTCPeerConnection.prototype.setRemoteDescription;
	  window.RTCPeerConnection.prototype.setRemoteDescription = function setRemoteDescription(desc) {
	    if (desc && desc.sdp && desc.sdp.indexOf('\na=extmap-allow-mixed') !== -1) {
	      desc.sdp = desc.sdp.split('\n').filter(function (line) {
	        return line.trim() !== 'a=extmap-allow-mixed';
	      }).join('\n');
	    }
	    return nativeSRD.apply(this, arguments);
	  };
	}
	});

	unwrapExports(common_shim);
	var common_shim_1 = common_shim.shimRTCIceCandidate;
	var common_shim_2 = common_shim.shimMaxMessageSize;
	var common_shim_3 = common_shim.shimSendThrowTypeError;
	var common_shim_4 = common_shim.shimConnectionState;
	var common_shim_5 = common_shim.removeAllowExtmapMixed;

	var adapter_factory = createCommonjsModule(function (module, exports) {

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.adapterFactory = adapterFactory;



	var utils$1 = _interopRequireWildcard(utils);



	var chromeShim = _interopRequireWildcard(chrome_shim);



	var edgeShim = _interopRequireWildcard(edge_shim);



	var firefoxShim = _interopRequireWildcard(firefox_shim);



	var safariShim = _interopRequireWildcard(safari_shim);



	var commonShim = _interopRequireWildcard(common_shim);

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

	// Shimming starts here.
	/*
	 *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
	 *
	 *  Use of this source code is governed by a BSD-style license
	 *  that can be found in the LICENSE file in the root of the source
	 *  tree.
	 */
	function adapterFactory() {
	  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
	      window = _ref.window;

	  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
	    shimChrome: true,
	    shimFirefox: true,
	    shimEdge: true,
	    shimSafari: true
	  };

	  // Utils.
	  var logging = utils$1.log;
	  var browserDetails = utils$1.detectBrowser(window);

	  var adapter = {
	    browserDetails: browserDetails,
	    commonShim: commonShim,
	    extractVersion: utils$1.extractVersion,
	    disableLog: utils$1.disableLog,
	    disableWarnings: utils$1.disableWarnings
	  };

	  // Shim browser if found.
	  switch (browserDetails.browser) {
	    case 'chrome':
	      if (!chromeShim || !chromeShim.shimPeerConnection || !options.shimChrome) {
	        logging('Chrome shim is not included in this adapter release.');
	        return adapter;
	      }
	      logging('adapter.js shimming chrome.');
	      // Export to the adapter global object visible in the browser.
	      adapter.browserShim = chromeShim;

	      chromeShim.shimGetUserMedia(window);
	      chromeShim.shimMediaStream(window);
	      chromeShim.shimPeerConnection(window);
	      chromeShim.shimOnTrack(window);
	      chromeShim.shimAddTrackRemoveTrack(window);
	      chromeShim.shimGetSendersWithDtmf(window);
	      chromeShim.shimGetStats(window);
	      chromeShim.shimSenderReceiverGetStats(window);
	      chromeShim.fixNegotiationNeeded(window);

	      commonShim.shimRTCIceCandidate(window);
	      commonShim.shimConnectionState(window);
	      commonShim.shimMaxMessageSize(window);
	      commonShim.shimSendThrowTypeError(window);
	      commonShim.removeAllowExtmapMixed(window);
	      break;
	    case 'firefox':
	      if (!firefoxShim || !firefoxShim.shimPeerConnection || !options.shimFirefox) {
	        logging('Firefox shim is not included in this adapter release.');
	        return adapter;
	      }
	      logging('adapter.js shimming firefox.');
	      // Export to the adapter global object visible in the browser.
	      adapter.browserShim = firefoxShim;

	      firefoxShim.shimGetUserMedia(window);
	      firefoxShim.shimPeerConnection(window);
	      firefoxShim.shimOnTrack(window);
	      firefoxShim.shimRemoveStream(window);
	      firefoxShim.shimSenderGetStats(window);
	      firefoxShim.shimReceiverGetStats(window);
	      firefoxShim.shimRTCDataChannel(window);

	      commonShim.shimRTCIceCandidate(window);
	      commonShim.shimConnectionState(window);
	      commonShim.shimMaxMessageSize(window);
	      commonShim.shimSendThrowTypeError(window);
	      break;
	    case 'edge':
	      if (!edgeShim || !edgeShim.shimPeerConnection || !options.shimEdge) {
	        logging('MS edge shim is not included in this adapter release.');
	        return adapter;
	      }
	      logging('adapter.js shimming edge.');
	      // Export to the adapter global object visible in the browser.
	      adapter.browserShim = edgeShim;

	      edgeShim.shimGetUserMedia(window);
	      edgeShim.shimGetDisplayMedia(window);
	      edgeShim.shimPeerConnection(window);
	      edgeShim.shimReplaceTrack(window);

	      // the edge shim implements the full RTCIceCandidate object.

	      commonShim.shimMaxMessageSize(window);
	      commonShim.shimSendThrowTypeError(window);
	      break;
	    case 'safari':
	      if (!safariShim || !options.shimSafari) {
	        logging('Safari shim is not included in this adapter release.');
	        return adapter;
	      }
	      logging('adapter.js shimming safari.');
	      // Export to the adapter global object visible in the browser.
	      adapter.browserShim = safariShim;

	      safariShim.shimRTCIceServerUrls(window);
	      safariShim.shimCreateOfferLegacy(window);
	      safariShim.shimCallbacksAPI(window);
	      safariShim.shimLocalStreamsAPI(window);
	      safariShim.shimRemoteStreamsAPI(window);
	      safariShim.shimTrackEventTransceiver(window);
	      safariShim.shimGetUserMedia(window);

	      commonShim.shimRTCIceCandidate(window);
	      commonShim.shimMaxMessageSize(window);
	      commonShim.shimSendThrowTypeError(window);
	      commonShim.removeAllowExtmapMixed(window);
	      break;
	    default:
	      logging('Unsupported browser!');
	      break;
	  }

	  return adapter;
	}

	// Browser shims.
	});

	unwrapExports(adapter_factory);
	var adapter_factory_1 = adapter_factory.adapterFactory;

	var adapter_core = createCommonjsModule(function (module, exports) {

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});



	var adapter = (0, adapter_factory.adapterFactory)({ window: window });
	exports.default = adapter;
	});

	unwrapExports(adapter_core);

	// Copyright Joyent, Inc. and other Node contributors.

	var R = typeof Reflect === 'object' ? Reflect : null;
	var ReflectApply = R && typeof R.apply === 'function'
	  ? R.apply
	  : function ReflectApply(target, receiver, args) {
	    return Function.prototype.apply.call(target, receiver, args);
	  };

	var ReflectOwnKeys;
	if (R && typeof R.ownKeys === 'function') {
	  ReflectOwnKeys = R.ownKeys;
	} else if (Object.getOwnPropertySymbols) {
	  ReflectOwnKeys = function ReflectOwnKeys(target) {
	    return Object.getOwnPropertyNames(target)
	      .concat(Object.getOwnPropertySymbols(target));
	  };
	} else {
	  ReflectOwnKeys = function ReflectOwnKeys(target) {
	    return Object.getOwnPropertyNames(target);
	  };
	}

	function ProcessEmitWarning(warning) {
	  if (console && console.warn) console.warn(warning);
	}

	var NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {
	  return value !== value;
	};

	function EventEmitter() {
	  EventEmitter.init.call(this);
	}
	var events = EventEmitter;

	// Backwards-compat with node 0.10.x
	EventEmitter.EventEmitter = EventEmitter;

	EventEmitter.prototype._events = undefined;
	EventEmitter.prototype._eventsCount = 0;
	EventEmitter.prototype._maxListeners = undefined;

	// By default EventEmitters will print a warning if more than 10 listeners are
	// added to it. This is a useful default which helps finding memory leaks.
	var defaultMaxListeners = 10;

	Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
	  enumerable: true,
	  get: function() {
	    return defaultMaxListeners;
	  },
	  set: function(arg) {
	    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {
	      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + '.');
	    }
	    defaultMaxListeners = arg;
	  }
	});

	EventEmitter.init = function() {

	  if (this._events === undefined ||
	      this._events === Object.getPrototypeOf(this)._events) {
	    this._events = Object.create(null);
	    this._eventsCount = 0;
	  }

	  this._maxListeners = this._maxListeners || undefined;
	};

	// Obviously not all Emitters should be limited to 10. This function allows
	// that to be increased. Set to zero for unlimited.
	EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
	  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {
	    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + '.');
	  }
	  this._maxListeners = n;
	  return this;
	};

	function $getMaxListeners(that) {
	  if (that._maxListeners === undefined)
	    return EventEmitter.defaultMaxListeners;
	  return that._maxListeners;
	}

	EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
	  return $getMaxListeners(this);
	};

	EventEmitter.prototype.emit = function emit(type) {
	  var args = [];
	  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);
	  var doError = (type === 'error');

	  var events = this._events;
	  if (events !== undefined)
	    doError = (doError && events.error === undefined);
	  else if (!doError)
	    return false;

	  // If there is no 'error' event listener then throw.
	  if (doError) {
	    var er;
	    if (args.length > 0)
	      er = args[0];
	    if (er instanceof Error) {
	      // Note: The comments on the `throw` lines are intentional, they show
	      // up in Node's output if this results in an unhandled exception.
	      throw er; // Unhandled 'error' event
	    }
	    // At least give some kind of context to the user
	    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));
	    err.context = er;
	    throw err; // Unhandled 'error' event
	  }

	  var handler = events[type];

	  if (handler === undefined)
	    return false;

	  if (typeof handler === 'function') {
	    ReflectApply(handler, this, args);
	  } else {
	    var len = handler.length;
	    var listeners = arrayClone(handler, len);
	    for (var i = 0; i < len; ++i)
	      ReflectApply(listeners[i], this, args);
	  }

	  return true;
	};

	function _addListener(target, type, listener, prepend) {
	  var m;
	  var events;
	  var existing;

	  if (typeof listener !== 'function') {
	    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
	  }

	  events = target._events;
	  if (events === undefined) {
	    events = target._events = Object.create(null);
	    target._eventsCount = 0;
	  } else {
	    // To avoid recursion in the case that type === "newListener"! Before
	    // adding it to the listeners, first emit "newListener".
	    if (events.newListener !== undefined) {
	      target.emit('newListener', type,
	                  listener.listener ? listener.listener : listener);

	      // Re-assign `events` because a newListener handler could have caused the
	      // this._events to be assigned to a new object
	      events = target._events;
	    }
	    existing = events[type];
	  }

	  if (existing === undefined) {
	    // Optimize the case of one listener. Don't need the extra array object.
	    existing = events[type] = listener;
	    ++target._eventsCount;
	  } else {
	    if (typeof existing === 'function') {
	      // Adding the second element, need to change to array.
	      existing = events[type] =
	        prepend ? [listener, existing] : [existing, listener];
	      // If we've already got an array, just append.
	    } else if (prepend) {
	      existing.unshift(listener);
	    } else {
	      existing.push(listener);
	    }

	    // Check for listener leak
	    m = $getMaxListeners(target);
	    if (m > 0 && existing.length > m && !existing.warned) {
	      existing.warned = true;
	      // No error code for this since it is a Warning
	      // eslint-disable-next-line no-restricted-syntax
	      var w = new Error('Possible EventEmitter memory leak detected. ' +
	                          existing.length + ' ' + String(type) + ' listeners ' +
	                          'added. Use emitter.setMaxListeners() to ' +
	                          'increase limit');
	      w.name = 'MaxListenersExceededWarning';
	      w.emitter = target;
	      w.type = type;
	      w.count = existing.length;
	      ProcessEmitWarning(w);
	    }
	  }

	  return target;
	}

	EventEmitter.prototype.addListener = function addListener(type, listener) {
	  return _addListener(this, type, listener, false);
	};

	EventEmitter.prototype.on = EventEmitter.prototype.addListener;

	EventEmitter.prototype.prependListener =
	    function prependListener(type, listener) {
	      return _addListener(this, type, listener, true);
	    };

	function onceWrapper() {
	  var args = [];
	  for (var i = 0; i < arguments.length; i++) args.push(arguments[i]);
	  if (!this.fired) {
	    this.target.removeListener(this.type, this.wrapFn);
	    this.fired = true;
	    ReflectApply(this.listener, this.target, args);
	  }
	}

	function _onceWrap(target, type, listener) {
	  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };
	  var wrapped = onceWrapper.bind(state);
	  wrapped.listener = listener;
	  state.wrapFn = wrapped;
	  return wrapped;
	}

	EventEmitter.prototype.once = function once(type, listener) {
	  if (typeof listener !== 'function') {
	    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
	  }
	  this.on(type, _onceWrap(this, type, listener));
	  return this;
	};

	EventEmitter.prototype.prependOnceListener =
	    function prependOnceListener(type, listener) {
	      if (typeof listener !== 'function') {
	        throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
	      }
	      this.prependListener(type, _onceWrap(this, type, listener));
	      return this;
	    };

	// Emits a 'removeListener' event if and only if the listener was removed.
	EventEmitter.prototype.removeListener =
	    function removeListener(type, listener) {
	      var list, events, position, i, originalListener;

	      if (typeof listener !== 'function') {
	        throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
	      }

	      events = this._events;
	      if (events === undefined)
	        return this;

	      list = events[type];
	      if (list === undefined)
	        return this;

	      if (list === listener || list.listener === listener) {
	        if (--this._eventsCount === 0)
	          this._events = Object.create(null);
	        else {
	          delete events[type];
	          if (events.removeListener)
	            this.emit('removeListener', type, list.listener || listener);
	        }
	      } else if (typeof list !== 'function') {
	        position = -1;

	        for (i = list.length - 1; i >= 0; i--) {
	          if (list[i] === listener || list[i].listener === listener) {
	            originalListener = list[i].listener;
	            position = i;
	            break;
	          }
	        }

	        if (position < 0)
	          return this;

	        if (position === 0)
	          list.shift();
	        else {
	          spliceOne(list, position);
	        }

	        if (list.length === 1)
	          events[type] = list[0];

	        if (events.removeListener !== undefined)
	          this.emit('removeListener', type, originalListener || listener);
	      }

	      return this;
	    };

	EventEmitter.prototype.off = EventEmitter.prototype.removeListener;

	EventEmitter.prototype.removeAllListeners =
	    function removeAllListeners(type) {
	      var listeners, events, i;

	      events = this._events;
	      if (events === undefined)
	        return this;

	      // not listening for removeListener, no need to emit
	      if (events.removeListener === undefined) {
	        if (arguments.length === 0) {
	          this._events = Object.create(null);
	          this._eventsCount = 0;
	        } else if (events[type] !== undefined) {
	          if (--this._eventsCount === 0)
	            this._events = Object.create(null);
	          else
	            delete events[type];
	        }
	        return this;
	      }

	      // emit removeListener for all listeners on all events
	      if (arguments.length === 0) {
	        var keys = Object.keys(events);
	        var key;
	        for (i = 0; i < keys.length; ++i) {
	          key = keys[i];
	          if (key === 'removeListener') continue;
	          this.removeAllListeners(key);
	        }
	        this.removeAllListeners('removeListener');
	        this._events = Object.create(null);
	        this._eventsCount = 0;
	        return this;
	      }

	      listeners = events[type];

	      if (typeof listeners === 'function') {
	        this.removeListener(type, listeners);
	      } else if (listeners !== undefined) {
	        // LIFO order
	        for (i = listeners.length - 1; i >= 0; i--) {
	          this.removeListener(type, listeners[i]);
	        }
	      }

	      return this;
	    };

	function _listeners(target, type, unwrap) {
	  var events = target._events;

	  if (events === undefined)
	    return [];

	  var evlistener = events[type];
	  if (evlistener === undefined)
	    return [];

	  if (typeof evlistener === 'function')
	    return unwrap ? [evlistener.listener || evlistener] : [evlistener];

	  return unwrap ?
	    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
	}

	EventEmitter.prototype.listeners = function listeners(type) {
	  return _listeners(this, type, true);
	};

	EventEmitter.prototype.rawListeners = function rawListeners(type) {
	  return _listeners(this, type, false);
	};

	EventEmitter.listenerCount = function(emitter, type) {
	  if (typeof emitter.listenerCount === 'function') {
	    return emitter.listenerCount(type);
	  } else {
	    return listenerCount.call(emitter, type);
	  }
	};

	EventEmitter.prototype.listenerCount = listenerCount;
	function listenerCount(type) {
	  var events = this._events;

	  if (events !== undefined) {
	    var evlistener = events[type];

	    if (typeof evlistener === 'function') {
	      return 1;
	    } else if (evlistener !== undefined) {
	      return evlistener.length;
	    }
	  }

	  return 0;
	}

	EventEmitter.prototype.eventNames = function eventNames() {
	  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
	};

	function arrayClone(arr, n) {
	  var copy = new Array(n);
	  for (var i = 0; i < n; ++i)
	    copy[i] = arr[i];
	  return copy;
	}

	function spliceOne(list, index) {
	  for (; index + 1 < list.length; index++)
	    list[index] = list[index + 1];
	  list.pop();
	}

	function unwrapListeners(arr) {
	  var ret = new Array(arr.length);
	  for (var i = 0; i < ret.length; ++i) {
	    ret[i] = arr[i].listener || arr[i];
	  }
	  return ret;
	}

	var name = "sip.js";
	var title = "SIP.js";
	var description = "A simple, intuitive, and powerful JavaScript signaling library";
	var version = "0.13.8";
	var license = "MIT";
	var main = "./lib/index.js";
	var types = "./lib/index.d.ts";
	var homepage = "https://sipjs.com";
	var author = "OnSIP <developer@onsip.com> (https://sipjs.com/aboutus/)";
	var contributors = [
		{
			url: "https://github.com/onsip/SIP.js/blob/master/THANKS.md"
		}
	];
	var repository = {
		type: "git",
		url: "https://github.com/onsip/SIP.js.git"
	};
	var keywords = [
		"sip",
		"webrtc",
		"library",
		"websocket",
		"javascript",
		"typescript"
	];
	var dependencies = {
		"crypto-js": "^3.1.9-1"
	};
	var devDependencies = {
		"@types/jasmine": "^3.3.11",
		"@types/node": "^11.11.6",
		"circular-dependency-plugin": "^5.0.2",
		"jasmine-core": "^3.3.0",
		karma: "^4.0.1",
		"karma-chrome-launcher": "^2.2.0",
		"karma-cli": "^2.0.0",
		"karma-jasmine": "^2.0.1",
		"karma-jasmine-html-reporter": "^1.4.0",
		"karma-mocha-reporter": "^2.2.5",
		"karma-sourcemap-loader": "^0.3.7",
		"karma-webpack": "^3.0.5",
		pegjs: "^0.10.0",
		"ts-loader": "^5.3.3",
		"ts-pegjs": "0.2.2",
		tslint: "^5.14.0",
		typescript: "^3.3.4000",
		webpack: "^4.29.6",
		"webpack-cli": "^3.3.0"
	};
	var engines = {
		node: ">=8.0"
	};
	var scripts = {
		prebuild: "tslint -p tsconfig-base.json -c tslint.json",
		"generate-grammar": "node build/grammarGenerator.js",
		"build-reg-bundle": "webpack --progress --config build/webpack.config.js --env.buildType reg",
		"build-min-bundle": "webpack --progress --config build/webpack.config.js --env.buildType min",
		"build-bundles": "npm run build-reg-bundle && npm run build-min-bundle",
		"build-lib": "tsc -p src",
		"build-test": "tsc -p test",
		"copy-dist-files": "cp dist/sip.js dist/sip-$npm_package_version.js && cp dist/sip.min.js dist/sip-$npm_package_version.min.js",
		build: "npm run generate-grammar && npm run build-lib && npm run build-reg-bundle && npm run build-min-bundle && npm run copy-dist-files",
		browserTest: "npm run build-test && sleep 2 && open http://0.0.0.0:9876/debug.html & karma start --reporters kjhtml --no-single-run",
		commandLineTest: "npm run build-test && karma start --reporters mocha --browsers ChromeHeadless --single-run",
		buildAndTest: "npm run build && npm run commandLineTest",
		buildAndBrowserTest: "npm run build && npm run browserTest"
	};
	var _package = {
		name: name,
		title: title,
		description: description,
		version: version,
		license: license,
		main: main,
		types: types,
		homepage: homepage,
		author: author,
		contributors: contributors,
		repository: repository,
		keywords: keywords,
		dependencies: dependencies,
		devDependencies: devDependencies,
		engines: engines,
		scripts: scripts
	};

	var _package$1 = /*#__PURE__*/Object.freeze({
		name: name,
		title: title,
		description: description,
		version: version,
		license: license,
		main: main,
		types: types,
		homepage: homepage,
		author: author,
		contributors: contributors,
		repository: repository,
		keywords: keywords,
		dependencies: dependencies,
		devDependencies: devDependencies,
		engines: engines,
		scripts: scripts,
		'default': _package
	});

	var pkg = getCjsExportFromNamespace(_package$1);

	var Constants = createCommonjsModule(function (module, exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	// tslint:disable-next-line:no-var-requires

	var C;
	(function (C) {
	    C.USER_AGENT = pkg.title + "/" + pkg.version;
	    // SIP scheme
	    C.SIP = "sip";
	    C.SIPS = "sips";
	    // End and Failure causes
	    var causes;
	    (function (causes) {
	        // Generic error causes
	        causes["CONNECTION_ERROR"] = "Connection Error";
	        causes["INTERNAL_ERROR"] = "Internal Error";
	        causes["REQUEST_TIMEOUT"] = "Request Timeout";
	        causes["SIP_FAILURE_CODE"] = "SIP Failure Code";
	        // SIP error causes
	        causes["ADDRESS_INCOMPLETE"] = "Address Incomplete";
	        causes["AUTHENTICATION_ERROR"] = "Authentication Error";
	        causes["BUSY"] = "Busy";
	        causes["DIALOG_ERROR"] = "Dialog Error";
	        causes["INCOMPATIBLE_SDP"] = "Incompatible SDP";
	        causes["NOT_FOUND"] = "Not Found";
	        causes["REDIRECTED"] = "Redirected";
	        causes["REJECTED"] = "Rejected";
	        causes["UNAVAILABLE"] = "Unavailable";
	        // Session error causes
	        causes["BAD_MEDIA_DESCRIPTION"] = "Bad Media Description";
	        causes["CANCELED"] = "Canceled";
	        causes["EXPIRES"] = "Expires";
	        causes["NO_ACK"] = "No ACK";
	        causes["NO_ANSWER"] = "No Answer";
	        causes["NO_PRACK"] = "No PRACK";
	        causes["RTP_TIMEOUT"] = "RTP Timeout";
	        causes["USER_DENIED_MEDIA_ACCESS"] = "User Denied Media Access";
	        causes["WEBRTC_ERROR"] = "WebRTC Error";
	        causes["WEBRTC_NOT_SUPPORTED"] = "WebRTC Not Supported";
	    })(causes = C.causes || (C.causes = {}));
	    var supported;
	    (function (supported) {
	        supported["REQUIRED"] = "required";
	        supported["SUPPORTED"] = "supported";
	        supported["UNSUPPORTED"] = "none";
	    })(supported = C.supported || (C.supported = {}));
	    C.SIP_ERROR_CAUSES = {
	        ADDRESS_INCOMPLETE: [484],
	        AUTHENTICATION_ERROR: [401, 407],
	        BUSY: [486, 600],
	        INCOMPATIBLE_SDP: [488, 606],
	        NOT_FOUND: [404, 604],
	        REDIRECTED: [300, 301, 302, 305, 380],
	        REJECTED: [403, 603],
	        UNAVAILABLE: [480, 410, 408, 430]
	    };
	    // SIP Methods
	    C.ACK = "ACK";
	    C.BYE = "BYE";
	    C.CANCEL = "CANCEL";
	    C.INFO = "INFO";
	    C.INVITE = "INVITE";
	    C.MESSAGE = "MESSAGE";
	    C.NOTIFY = "NOTIFY";
	    C.OPTIONS = "OPTIONS";
	    C.REGISTER = "REGISTER";
	    C.UPDATE = "UPDATE";
	    C.SUBSCRIBE = "SUBSCRIBE";
	    C.PUBLISH = "PUBLISH";
	    C.REFER = "REFER";
	    C.PRACK = "PRACK";
	    /* SIP Response Reasons
	     * DOC: http://www.iana.org/assignments/sip-parameters
	     * Copied from https://github.com/versatica/OverSIP/blob/master/lib/oversip/sip/constants.rb#L7
	     */
	    C.REASON_PHRASE = {
	        100: "Trying",
	        180: "Ringing",
	        181: "Call Is Being Forwarded",
	        182: "Queued",
	        183: "Session Progress",
	        199: "Early Dialog Terminated",
	        200: "OK",
	        202: "Accepted",
	        204: "No Notification",
	        300: "Multiple Choices",
	        301: "Moved Permanently",
	        302: "Moved Temporarily",
	        305: "Use Proxy",
	        380: "Alternative Service",
	        400: "Bad Request",
	        401: "Unauthorized",
	        402: "Payment Required",
	        403: "Forbidden",
	        404: "Not Found",
	        405: "Method Not Allowed",
	        406: "Not Acceptable",
	        407: "Proxy Authentication Required",
	        408: "Request Timeout",
	        410: "Gone",
	        412: "Conditional Request Failed",
	        413: "Request Entity Too Large",
	        414: "Request-URI Too Long",
	        415: "Unsupported Media Type",
	        416: "Unsupported URI Scheme",
	        417: "Unknown Resource-Priority",
	        420: "Bad Extension",
	        421: "Extension Required",
	        422: "Session Interval Too Small",
	        423: "Interval Too Brief",
	        428: "Use Identity Header",
	        429: "Provide Referrer Identity",
	        430: "Flow Failed",
	        433: "Anonymity Disallowed",
	        436: "Bad Identity-Info",
	        437: "Unsupported Certificate",
	        438: "Invalid Identity Header",
	        439: "First Hop Lacks Outbound Support",
	        440: "Max-Breadth Exceeded",
	        469: "Bad Info Package",
	        470: "Consent Needed",
	        478: "Unresolvable Destination",
	        480: "Temporarily Unavailable",
	        481: "Call/Transaction Does Not Exist",
	        482: "Loop Detected",
	        483: "Too Many Hops",
	        484: "Address Incomplete",
	        485: "Ambiguous",
	        486: "Busy Here",
	        487: "Request Terminated",
	        488: "Not Acceptable Here",
	        489: "Bad Event",
	        491: "Request Pending",
	        493: "Undecipherable",
	        494: "Security Agreement Required",
	        500: "Internal Server Error",
	        501: "Not Implemented",
	        502: "Bad Gateway",
	        503: "Service Unavailable",
	        504: "Server Time-out",
	        505: "Version Not Supported",
	        513: "Message Too Large",
	        580: "Precondition Failure",
	        600: "Busy Everywhere",
	        603: "Decline",
	        604: "Does Not Exist Anywhere",
	        606: "Not Acceptable"
	    };
	    /* SIP Option Tags
	     * DOC: http://www.iana.org/assignments/sip-parameters/sip-parameters.xhtml#sip-parameters-4
	     */
	    C.OPTION_TAGS = {
	        "100rel": true,
	        "199": true,
	        "answermode": true,
	        "early-session": true,
	        "eventlist": true,
	        "explicitsub": true,
	        "from-change": true,
	        "geolocation-http": true,
	        "geolocation-sip": true,
	        "gin": true,
	        "gruu": true,
	        "histinfo": true,
	        "ice": true,
	        "join": true,
	        "multiple-refer": true,
	        "norefersub": true,
	        "nosub": true,
	        "outbound": true,
	        "path": true,
	        "policy": true,
	        "precondition": true,
	        "pref": true,
	        "privacy": true,
	        "recipient-list-invite": true,
	        "recipient-list-message": true,
	        "recipient-list-subscribe": true,
	        "replaces": true,
	        "resource-priority": true,
	        "sdp-anat": true,
	        "sec-agree": true,
	        "tdialog": true,
	        "timer": true,
	        "uui": true // RFC 7433
	    };
	    var dtmfType;
	    (function (dtmfType) {
	        dtmfType["INFO"] = "info";
	        dtmfType["RTP"] = "rtp";
	    })(dtmfType = C.dtmfType || (C.dtmfType = {}));
	})(C = exports.C || (exports.C = {}));
	});

	unwrapExports(Constants);
	var Constants_1 = Constants.C;

	var Enums = createCommonjsModule(function (module, exports) {
	// enums can't really be declared, so they are set here.
	// pulled out of individual files to avoid circular dependencies
	Object.defineProperty(exports, "__esModule", { value: true });
	var DialogStatus;
	(function (DialogStatus) {
	    DialogStatus[DialogStatus["STATUS_EARLY"] = 1] = "STATUS_EARLY";
	    DialogStatus[DialogStatus["STATUS_CONFIRMED"] = 2] = "STATUS_CONFIRMED";
	})(DialogStatus = exports.DialogStatus || (exports.DialogStatus = {}));
	var SessionStatus;
	(function (SessionStatus) {
	    // Session states
	    SessionStatus[SessionStatus["STATUS_NULL"] = 0] = "STATUS_NULL";
	    SessionStatus[SessionStatus["STATUS_INVITE_SENT"] = 1] = "STATUS_INVITE_SENT";
	    SessionStatus[SessionStatus["STATUS_1XX_RECEIVED"] = 2] = "STATUS_1XX_RECEIVED";
	    SessionStatus[SessionStatus["STATUS_INVITE_RECEIVED"] = 3] = "STATUS_INVITE_RECEIVED";
	    SessionStatus[SessionStatus["STATUS_WAITING_FOR_ANSWER"] = 4] = "STATUS_WAITING_FOR_ANSWER";
	    SessionStatus[SessionStatus["STATUS_ANSWERED"] = 5] = "STATUS_ANSWERED";
	    SessionStatus[SessionStatus["STATUS_WAITING_FOR_PRACK"] = 6] = "STATUS_WAITING_FOR_PRACK";
	    SessionStatus[SessionStatus["STATUS_WAITING_FOR_ACK"] = 7] = "STATUS_WAITING_FOR_ACK";
	    SessionStatus[SessionStatus["STATUS_CANCELED"] = 8] = "STATUS_CANCELED";
	    SessionStatus[SessionStatus["STATUS_TERMINATED"] = 9] = "STATUS_TERMINATED";
	    SessionStatus[SessionStatus["STATUS_ANSWERED_WAITING_FOR_PRACK"] = 10] = "STATUS_ANSWERED_WAITING_FOR_PRACK";
	    SessionStatus[SessionStatus["STATUS_EARLY_MEDIA"] = 11] = "STATUS_EARLY_MEDIA";
	    SessionStatus[SessionStatus["STATUS_CONFIRMED"] = 12] = "STATUS_CONFIRMED";
	})(SessionStatus = exports.SessionStatus || (exports.SessionStatus = {}));
	var TypeStrings;
	(function (TypeStrings) {
	    TypeStrings[TypeStrings["ClientContext"] = 0] = "ClientContext";
	    TypeStrings[TypeStrings["ConfigurationError"] = 1] = "ConfigurationError";
	    TypeStrings[TypeStrings["Dialog"] = 2] = "Dialog";
	    TypeStrings[TypeStrings["DigestAuthentication"] = 3] = "DigestAuthentication";
	    TypeStrings[TypeStrings["DTMF"] = 4] = "DTMF";
	    TypeStrings[TypeStrings["IncomingMessage"] = 5] = "IncomingMessage";
	    TypeStrings[TypeStrings["IncomingRequest"] = 6] = "IncomingRequest";
	    TypeStrings[TypeStrings["IncomingResponse"] = 7] = "IncomingResponse";
	    TypeStrings[TypeStrings["InvalidStateError"] = 8] = "InvalidStateError";
	    TypeStrings[TypeStrings["InviteClientContext"] = 9] = "InviteClientContext";
	    TypeStrings[TypeStrings["InviteServerContext"] = 10] = "InviteServerContext";
	    TypeStrings[TypeStrings["Logger"] = 11] = "Logger";
	    TypeStrings[TypeStrings["LoggerFactory"] = 12] = "LoggerFactory";
	    TypeStrings[TypeStrings["MethodParameterError"] = 13] = "MethodParameterError";
	    TypeStrings[TypeStrings["NameAddrHeader"] = 14] = "NameAddrHeader";
	    TypeStrings[TypeStrings["NotSupportedError"] = 15] = "NotSupportedError";
	    TypeStrings[TypeStrings["OutgoingRequest"] = 16] = "OutgoingRequest";
	    TypeStrings[TypeStrings["Parameters"] = 17] = "Parameters";
	    TypeStrings[TypeStrings["PublishContext"] = 18] = "PublishContext";
	    TypeStrings[TypeStrings["ReferClientContext"] = 19] = "ReferClientContext";
	    TypeStrings[TypeStrings["ReferServerContext"] = 20] = "ReferServerContext";
	    TypeStrings[TypeStrings["RegisterContext"] = 21] = "RegisterContext";
	    TypeStrings[TypeStrings["RenegotiationError"] = 22] = "RenegotiationError";
	    TypeStrings[TypeStrings["RequestSender"] = 23] = "RequestSender";
	    TypeStrings[TypeStrings["ServerContext"] = 24] = "ServerContext";
	    TypeStrings[TypeStrings["Session"] = 25] = "Session";
	    TypeStrings[TypeStrings["SessionDescriptionHandler"] = 26] = "SessionDescriptionHandler";
	    TypeStrings[TypeStrings["SessionDescriptionHandlerError"] = 27] = "SessionDescriptionHandlerError";
	    TypeStrings[TypeStrings["SessionDescriptionHandlerObserver"] = 28] = "SessionDescriptionHandlerObserver";
	    TypeStrings[TypeStrings["Subscription"] = 29] = "Subscription";
	    TypeStrings[TypeStrings["Transport"] = 30] = "Transport";
	    TypeStrings[TypeStrings["UA"] = 31] = "UA";
	    TypeStrings[TypeStrings["URI"] = 32] = "URI";
	})(TypeStrings = exports.TypeStrings || (exports.TypeStrings = {}));
	// UA status codes
	var UAStatus;
	(function (UAStatus) {
	    UAStatus[UAStatus["STATUS_INIT"] = 0] = "STATUS_INIT";
	    UAStatus[UAStatus["STATUS_STARTING"] = 1] = "STATUS_STARTING";
	    UAStatus[UAStatus["STATUS_READY"] = 2] = "STATUS_READY";
	    UAStatus[UAStatus["STATUS_USER_CLOSED"] = 3] = "STATUS_USER_CLOSED";
	    UAStatus[UAStatus["STATUS_NOT_READY"] = 4] = "STATUS_NOT_READY";
	})(UAStatus = exports.UAStatus || (exports.UAStatus = {}));
	});

	unwrapExports(Enums);
	var Enums_1 = Enums.DialogStatus;
	var Enums_2 = Enums.SessionStatus;
	var Enums_3 = Enums.TypeStrings;
	var Enums_4 = Enums.UAStatus;

	var Exceptions_1 = createCommonjsModule(function (module, exports) {
	var __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	Object.defineProperty(exports, "__esModule", { value: true });

	// tslint:disable:max-classes-per-file
	/**
	 * An Exception is considered a condition that a reasonable application may wish to catch.
	 * An Error indicates serious problems that a reasonable application should not try to catch.
	 */
	var Exception = /** @class */ (function (_super) {
	    __extends(Exception, _super);
	    function Exception(message) {
	        var _newTarget = this.constructor;
	        var _this = _super.call(this, message) || this;
	        Object.setPrototypeOf(_this, _newTarget.prototype); // restore prototype chain
	        return _this;
	    }
	    return Exception;
	}(Error));
	exports.Exception = Exception;
	var Exceptions;
	(function (Exceptions) {
	    /**
	     * Transport error.
	     */
	    var TransportError = /** @class */ (function (_super) {
	        __extends(TransportError, _super);
	        function TransportError(message) {
	            return _super.call(this, message ? message : "Unspecified transport error.") || this;
	        }
	        return TransportError;
	    }(Exception));
	    Exceptions.TransportError = TransportError;
	})(Exceptions = exports.Exceptions || (exports.Exceptions = {}));
	/**
	 * DEPRECATED: The original implementation of exceptions in this library attempted to
	 * deal with the lack of type checking in JavaScript by adding a "type" attribute
	 * to objects and using that to discriminate. On top of that it layered allcoated
	 * "code" numbers and constant "name" strings. All of that is unnecessary when using
	 * TypeScript, inheriting from Error and properly setting up the prototype chain...
	 */
	var LegacyException = /** @class */ (function (_super) {
	    __extends(LegacyException, _super);
	    function LegacyException(code, name, message) {
	        var _this = _super.call(this, message) || this;
	        _this.code = code;
	        _this.name = name;
	        _this.message = message;
	        return _this;
	    }
	    return LegacyException;
	}(Exception));
	(function (Exceptions) {
	    var ConfigurationError = /** @class */ (function (_super) {
	        __extends(ConfigurationError, _super);
	        function ConfigurationError(parameter, value) {
	            var _this = _super.call(this, 1, "CONFIGURATION_ERROR", (!value) ? "Missing parameter: " + parameter :
	                "Invalid value " + JSON.stringify(value) + " for parameter '" + parameter + "'") || this;
	            _this.type = Enums.TypeStrings.ConfigurationError;
	            _this.parameter = parameter;
	            _this.value = value;
	            return _this;
	        }
	        return ConfigurationError;
	    }(LegacyException));
	    Exceptions.ConfigurationError = ConfigurationError;
	    var InvalidStateError = /** @class */ (function (_super) {
	        __extends(InvalidStateError, _super);
	        function InvalidStateError(status) {
	            var _this = _super.call(this, 2, "INVALID_STATE_ERROR", "Invalid status: " + status) || this;
	            _this.type = Enums.TypeStrings.InvalidStateError;
	            _this.status = status;
	            return _this;
	        }
	        return InvalidStateError;
	    }(LegacyException));
	    Exceptions.InvalidStateError = InvalidStateError;
	    var NotSupportedError = /** @class */ (function (_super) {
	        __extends(NotSupportedError, _super);
	        function NotSupportedError(message) {
	            var _this = _super.call(this, 3, "NOT_SUPPORTED_ERROR", message) || this;
	            _this.type = Enums.TypeStrings.NotSupportedError;
	            return _this;
	        }
	        return NotSupportedError;
	    }(LegacyException));
	    Exceptions.NotSupportedError = NotSupportedError;
	    // 4 was GetDescriptionError, which was deprecated and now removed
	    var RenegotiationError = /** @class */ (function (_super) {
	        __extends(RenegotiationError, _super);
	        function RenegotiationError(message) {
	            var _this = _super.call(this, 5, "RENEGOTIATION_ERROR", message) || this;
	            _this.type = Enums.TypeStrings.RenegotiationError;
	            return _this;
	        }
	        return RenegotiationError;
	    }(LegacyException));
	    Exceptions.RenegotiationError = RenegotiationError;
	    var MethodParameterError = /** @class */ (function (_super) {
	        __extends(MethodParameterError, _super);
	        function MethodParameterError(method, parameter, value) {
	            var _this = _super.call(this, 6, "METHOD_PARAMETER_ERROR", (!value) ?
	                "Missing parameter: " + parameter :
	                "Invalid value " + JSON.stringify(value) + " for parameter '" + parameter + "'") || this;
	            _this.type = Enums.TypeStrings.MethodParameterError;
	            _this.method = method;
	            _this.parameter = parameter;
	            _this.value = value;
	            return _this;
	        }
	        return MethodParameterError;
	    }(LegacyException));
	    Exceptions.MethodParameterError = MethodParameterError;
	    // 7 was TransportError, which was replaced
	    var SessionDescriptionHandlerError = /** @class */ (function (_super) {
	        __extends(SessionDescriptionHandlerError, _super);
	        function SessionDescriptionHandlerError(method, error, message) {
	            var _this = _super.call(this, 8, "SESSION_DESCRIPTION_HANDLER_ERROR", message || "Error with Session Description Handler") || this;
	            _this.type = Enums.TypeStrings.SessionDescriptionHandlerError;
	            _this.method = method;
	            _this.error = error;
	            return _this;
	        }
	        return SessionDescriptionHandlerError;
	    }(LegacyException));
	    Exceptions.SessionDescriptionHandlerError = SessionDescriptionHandlerError;
	})(Exceptions = exports.Exceptions || (exports.Exceptions = {}));
	});

	unwrapExports(Exceptions_1);
	var Exceptions_2 = Exceptions_1.Exception;
	var Exceptions_3 = Exceptions_1.Exceptions;

	var Timers = createCommonjsModule(function (module, exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	var T1 = 500;
	var T2 = 4000;
	var T4 = 5000;
	exports.Timers = {
	    T1: T1,
	    T2: T2,
	    T4: T4,
	    TIMER_B: 64 * T1,
	    TIMER_D: 0 * T1,
	    TIMER_F: 64 * T1,
	    TIMER_H: 64 * T1,
	    TIMER_I: 0 * T4,
	    TIMER_J: 0 * T1,
	    TIMER_K: 0 * T4,
	    TIMER_L: 64 * T1,
	    TIMER_M: 64 * T1,
	    TIMER_N: 64 * T1,
	    PROVISIONAL_RESPONSE_INTERVAL: 60000 // See RFC 3261 Section 13.3.1.1
	};
	});

	unwrapExports(Timers);
	var Timers_1 = Timers.Timers;

	var Transactions = createCommonjsModule(function (module, exports) {
	var __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	Object.defineProperty(exports, "__esModule", { value: true });




	// tslint:disable:max-classes-per-file
	// tslint:disable:no-empty-interface
	// FIXME & TODO Issues
	// - Unreliable transports are not supported; timers missing/wrong, IP address/port, other?
	// - UAS Provisional Retransmission Timer. See RFC 3261 Section 13.3.1.1. Per spec, should be handled by the UAS.
	// - 2xx response and ACK handling is not to spec. It works, but arguably should be handled by UAC.
	// - Transaction ID is currently the branch parameter value - not completely sufficient for transaction matching.
	// - Relationship between Request/Response/Message Classes and Transaction could be refactored/reworked.
	/** Transaction state. */
	var TransactionState;
	(function (TransactionState) {
	    TransactionState["Accepted"] = "Accepted";
	    TransactionState["Calling"] = "Calling";
	    TransactionState["Completed"] = "Completed";
	    TransactionState["Confirmed"] = "Confirmed";
	    TransactionState["Proceeding"] = "Proceeding";
	    TransactionState["Terminated"] = "Terminated";
	    TransactionState["Trying"] = "Trying";
	})(TransactionState = exports.TransactionState || (exports.TransactionState = {}));
	/**
	 * Transaction
	 *
	 * SIP is a transactional protocol: interactions between components take
	 * place in a series of independent message exchanges.  Specifically, a
	 * SIP transaction consists of a single request and any responses to
	 * that request, which include zero or more provisional responses and
	 * one or more final responses.  In the case of a transaction where the
	 * request was an INVITE (known as an INVITE transaction), the
	 * transaction also includes the ACK only if the final response was not
	 * a 2xx response.  If the response was a 2xx, the ACK is not considered
	 * part of the transaction.
	 * https://tools.ietf.org/html/rfc3261#section-17
	 */
	var Transaction = /** @class */ (function (_super) {
	    __extends(Transaction, _super);
	    function Transaction(_transport, _user, _id, _state, loggerCategory) {
	        var _this = _super.call(this) || this;
	        _this._transport = _transport;
	        _this._user = _user;
	        _this._id = _id;
	        _this._state = _state;
	        _this.logger = _user.loggerFactory.getLogger(loggerCategory, _id);
	        _this.logger.debug("Constructing " + _this.typeToString() + " with id " + _this.id + ".");
	        return _this;
	    }
	    /**
	     * Destructor.
	     * Once the transaction is in the "terminated" state, it is destroyed
	     * immediately and there is no need to call `dispose`. However, if a
	     * transaction needs to be ended prematurely, the transaction user may
	     * do so by calling this method (for example, perhaps the UA is shutting down).
	     * No state transition will occur upon calling this method, all outstanding
	     * transmission timers will be cancelled, and use of the transaction after
	     * calling `dispose` is undefined.
	     */
	    Transaction.prototype.dispose = function () {
	        this.logger.debug("Destroyed " + this.typeToString() + " with id " + this.id + ".");
	    };
	    Object.defineProperty(Transaction.prototype, "id", {
	        /** Transaction id. */
	        get: function () {
	            return this._id;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Transaction.prototype, "kind", {
	        /** Transaction kind. Deprecated. */
	        get: function () {
	            if (this instanceof InviteClientTransaction) {
	                return "ict";
	            }
	            else if (this instanceof NonInviteClientTransaction) {
	                return "nict";
	            }
	            else if (this instanceof InviteServerTransaction) {
	                return "ist";
	            }
	            else if (this instanceof NonInviteServerTransaction) {
	                return "nist";
	            }
	            throw new Error("Invalid kind.");
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Transaction.prototype, "state", {
	        /** Transaction state. */
	        get: function () {
	            return this._state;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Transaction.prototype, "transport", {
	        /** Transaction transport. */
	        get: function () {
	            return this._transport;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Transaction.prototype.on = function (name, callback) { return _super.prototype.on.call(this, name, callback); };
	    Transaction.prototype.logTransportError = function (error, message) {
	        this.logger.error(error.message);
	        this.logger.error("Transport error occurred in " + this.typeToString() + " with id " + this.id + ".");
	        this.logger.error(message);
	    };
	    /**
	     * Pass message to transport for transmission. If transport fails,
	     * the transaction user is notified by callback to onTransportError().
	     * @throws {TransportError} If transport fails.
	     */
	    Transaction.prototype.send = function (message) {
	        var _this = this;
	        return this.transport.send(message).catch(function (error) {
	            // FIXME: Transport is not, yet, typed and it is not clear
	            // yet what send() may or may not send our way. So for now,
	            // make sure we convert it to a TransportError if need be.
	            if (error instanceof Exceptions_1.Exceptions.TransportError) {
	                _this.onTransportError(error);
	                return;
	            }
	            var transportError;
	            if (error && typeof error.message === "string") {
	                transportError = new Exceptions_1.Exceptions.TransportError(error.message);
	            }
	            else {
	                transportError = new Exceptions_1.Exceptions.TransportError();
	            }
	            _this.onTransportError(transportError);
	            throw transportError;
	        });
	    };
	    Transaction.prototype.setState = function (state) {
	        this.logger.debug("State change to \"" + state + "\" on " + this.typeToString() + " with id " + this.id + ".");
	        this._state = state;
	        if (this._user.onStateChange) {
	            this._user.onStateChange(state);
	        }
	        this.emit("stateChanged");
	    };
	    Transaction.prototype.typeToString = function () {
	        var type = "UnknownType";
	        if (this instanceof InviteClientTransaction) {
	            type = "INVITE client transaction";
	        }
	        else if (this instanceof NonInviteClientTransaction) {
	            type = "non-INVITE client transaction";
	        }
	        else if (this instanceof InviteServerTransaction) {
	            type = "INVITE server transaction";
	        }
	        else if (this instanceof NonInviteServerTransaction) {
	            type = "non-INVITE server transaction";
	        }
	        return type;
	    };
	    return Transaction;
	}(events.EventEmitter));
	exports.Transaction = Transaction;
	/**
	 * Client Transaction
	 *
	 * The client transaction provides its functionality through the
	 * maintenance of a state machine.
	 *
	 * The TU communicates with the client transaction through a simple
	 * interface.  When the TU wishes to initiate a new transaction, it
	 * creates a client transaction and passes it the SIP request to send
	 * and an IP address, port, and transport to which to send it.  The
	 * client transaction begins execution of its state machine.  Valid
	 * responses are passed up to the TU from the client transaction.
	 * https://tools.ietf.org/html/rfc3261#section-17.1
	 */
	var ClientTransaction = /** @class */ (function (_super) {
	    __extends(ClientTransaction, _super);
	    function ClientTransaction(_request, transport, user, state, loggerCategory) {
	        var _this = _super.call(this, transport, user, ClientTransaction.makeId(_request), state, loggerCategory) || this;
	        _this._request = _request;
	        _this.user = user;
	        // The Via header field indicates the transport used for the transaction
	        // and identifies the location where the response is to be sent.  A Via
	        // header field value is added only after the transport that will be
	        // used to reach the next hop has been selected (which may involve the
	        // usage of the procedures in [4]).
	        // https://tools.ietf.org/html/rfc3261#section-8.1.1.7
	        _request.setViaHeader(_this.id, transport);
	        // FIXME: Bad hack. Potentially creating circular dependency. SIPMessage needs refactor.
	        // Set OutgoingRequest's transaction.
	        _request.transaction = _this;
	        return _this;
	    }
	    ClientTransaction.makeId = function (request) {
	        if (request.method === "CANCEL") {
	            if (!request.branch) {
	                throw new Error("Outgoing CANCEL request without a branch.");
	            }
	            return request.branch;
	        }
	        else {
	            return "z9hG4bK" + Math.floor(Math.random() * 10000000);
	        }
	    };
	    Object.defineProperty(ClientTransaction.prototype, "request", {
	        /** The outgoing request the transaction handling. */
	        get: function () {
	            return this._request;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * A 408 to non-INVITE will always arrive too late to be useful ([3]),
	     * The client already has full knowledge of the timeout. The only
	     * information this message would convey is whether or not the server
	     * believed the transaction timed out. However, with the current design
	     * of the NIT, a client cannot do anything with this knowledge. Thus,
	     * the 408 is simply wasting network resources and contributes to the
	     * response bombardment illustrated in [3].
	     * https://tools.ietf.org/html/rfc4320#section-4.1
	     */
	    ClientTransaction.prototype.onRequestTimeout = function () {
	        if (this.user.onRequestTimeout) {
	            this.user.onRequestTimeout();
	        }
	    };
	    return ClientTransaction;
	}(Transaction));
	exports.ClientTransaction = ClientTransaction;
	/**
	 * INVITE Client Transaction
	 *
	 * The INVITE transaction consists of a three-way handshake.  The client
	 * transaction sends an INVITE, the server transaction sends responses,
	 * and the client transaction sends an ACK.
	 * https://tools.ietf.org/html/rfc3261#section-17.1.1
	 */
	var InviteClientTransaction = /** @class */ (function (_super) {
	    __extends(InviteClientTransaction, _super);
	    /**
	     * Constructor.
	     * Upon construction, the outgoing request's Via header is updated by calling `setViaHeader`.
	     * Then `toString` is called on the outgoing request and the message is sent via the transport.
	     * After construction the transaction will be in the "calling" state and the transaction id
	     * will equal the branch parameter set in the Via header of the outgoing request.
	     * https://tools.ietf.org/html/rfc3261#section-17.1.1
	     * @param request The outgoing INVITE request.
	     * @param transport The transport.
	     * @param user The transaction user.
	     */
	    function InviteClientTransaction(request, transport, user) {
	        var _this = _super.call(this, request, transport, user, TransactionState.Calling, "sip.transaction.ict") || this;
	        /**
	         * Map of 2xx to-tag => ACK.
	         * If value is not undefined, value is the ACK which was sent.
	         * If key exists but value is undefined, a 2xx was received but the ACK not yet sent.
	         * Otherwise, a 2xx was not (yet) received for this transaction.
	         */
	        _this.ackRetransmissionCache = new Map();
	        // FIXME: Timer A for unreliable transport not implemented
	        //
	        // If an unreliable transport is being used, the client transaction
	        // MUST start timer A with a value of T1. If a reliable transport is being used,
	        // the client transaction SHOULD NOT start timer A (Timer A controls request retransmissions).
	        // For any transport, the client transaction MUST start timer B with a value
	        // of 64*T1 seconds (Timer B controls transaction timeouts).
	        // https://tools.ietf.org/html/rfc3261#section-17.1.1.2
	        //
	        // While not spelled out in the RFC, Timer B is the maximum amount of time that a sender
	        // will wait for an INVITE message to be acknowledged (a SIP response message is received).
	        // So Timer B should be cleared when the transaction state proceeds from "Calling".
	        _this.B = setTimeout(function () { return _this.timer_B(); }, Timers.Timers.TIMER_B);
	        _this.send(request.toString()).catch(function (error) {
	            _this.logTransportError(error, "Failed to send initial outgoing request.");
	        });
	        return _this;
	    }
	    /**
	     * Destructor.
	     */
	    InviteClientTransaction.prototype.dispose = function () {
	        if (this.B) {
	            clearTimeout(this.B);
	            this.B = undefined;
	        }
	        if (this.D) {
	            clearTimeout(this.D);
	            this.D = undefined;
	        }
	        if (this.M) {
	            clearTimeout(this.M);
	            this.M = undefined;
	        }
	        _super.prototype.dispose.call(this);
	    };
	    /**
	     * ACK a 2xx final response.
	     *
	     * The transaction includes the ACK only if the final response was not a 2xx response (the
	     * transaction will generate and send the ACK to the transport automagically). If the
	     * final response was a 2xx, the ACK is not considered part of the transaction (the
	     * transaction user needs to generate and send the ACK).
	     *
	     * This library is not strictly RFC compliant with regard to ACK handling for 2xx final
	     * responses. Specifically, retransmissions of ACKs to a 2xx final responses is handled
	     * by the transaction layer (instead of the UAC core). The "standard" approach is for
	     * the UAC core to receive all 2xx responses and manage sending ACK retransmissions to
	     * the transport directly. Herein the transaction layer manages sending ACKs to 2xx responses
	     * and any retransmissions of those ACKs as needed.
	     *
	     * @param ack The outgoing ACK request.
	     */
	    InviteClientTransaction.prototype.ackResponse = function (ack) {
	        var _this = this;
	        var toTag = ack.toTag;
	        if (!toTag) {
	            throw new Error("To tag undefined.");
	        }
	        var id = "z9hG4bK" + Math.floor(Math.random() * 10000000);
	        ack.setViaHeader(id, this.transport);
	        this.ackRetransmissionCache.set(toTag, ack); // Add to ACK retransmission cache
	        this.send(ack.toString()).catch(function (error) {
	            _this.logTransportError(error, "Failed to send ACK to 2xx response.");
	        });
	    };
	    /**
	     * Handler for incoming responses from the transport which match this transaction.
	     * @param response The incoming response.
	     */
	    InviteClientTransaction.prototype.receiveResponse = function (response) {
	        var _this = this;
	        var statusCode = response.statusCode;
	        if (!statusCode || statusCode < 100 || statusCode > 699) {
	            throw new Error("Invalid status code " + statusCode);
	        }
	        switch (this.state) {
	            case TransactionState.Calling:
	                // If the client transaction receives a provisional response while in
	                // the "Calling" state, it transitions to the "Proceeding" state. In the
	                // "Proceeding" state, the client transaction SHOULD NOT retransmit the
	                // request any longer. Furthermore, the provisional response MUST be
	                // passed to the TU.  Any further provisional responses MUST be passed
	                // up to the TU while in the "Proceeding" state.
	                // https://tools.ietf.org/html/rfc3261#section-17.1.1.2
	                if (statusCode >= 100 && statusCode <= 199) {
	                    this.stateTransition(TransactionState.Proceeding);
	                    if (this.user.receiveResponse) {
	                        this.user.receiveResponse(response);
	                    }
	                    return;
	                }
	                // When a 2xx response is received while in either the "Calling" or
	                // "Proceeding" states, the client transaction MUST transition to
	                // the "Accepted" state... The 2xx response MUST be passed up to the TU.
	                // The client transaction MUST NOT generate an ACK to the 2xx response -- its
	                // handling is delegated to the TU. A UAC core will send an ACK to
	                // the 2xx response using a new transaction.
	                // https://tools.ietf.org/html/rfc6026#section-8.4
	                if (statusCode >= 200 && statusCode <= 299) {
	                    this.ackRetransmissionCache.set(response.toTag, undefined); // Prime the ACK cache
	                    this.stateTransition(TransactionState.Accepted);
	                    if (this.user.receiveResponse) {
	                        this.user.receiveResponse(response);
	                    }
	                    return;
	                }
	                // When in either the "Calling" or "Proceeding" states, reception of
	                // a response with status code from 300-699 MUST cause the client
	                // transaction to transition to "Completed". The client transaction
	                // MUST pass the received response up to the TU, and the client
	                // transaction MUST generate an ACK request, even if the transport is
	                // reliable (guidelines for constructing the ACK from the response
	                // are given in Section 17.1.1.3), and then pass the ACK to the
	                // transport layer for transmission. The ACK MUST be sent to the
	                // same address, port, and transport to which the original request was sent.
	                // https://tools.ietf.org/html/rfc6026#section-8.4
	                if (statusCode >= 300 && statusCode <= 699) {
	                    this.stateTransition(TransactionState.Completed);
	                    this.ack(response);
	                    if (this.user.receiveResponse) {
	                        this.user.receiveResponse(response);
	                    }
	                    return;
	                }
	                break;
	            case TransactionState.Proceeding:
	                // In the "Proceeding" state, the client transaction SHOULD NOT retransmit the
	                // request any longer. Furthermore, the provisional response MUST be
	                // passed to the TU.  Any further provisional responses MUST be passed
	                // up to the TU while in the "Proceeding" state.
	                // https://tools.ietf.org/html/rfc3261#section-17.1.1.2
	                if (statusCode >= 100 && statusCode <= 199) {
	                    if (this.user.receiveResponse) {
	                        this.user.receiveResponse(response);
	                    }
	                    return;
	                }
	                // When a 2xx response is received while in either the "Calling" or "Proceeding" states,
	                // the client transaction MUST transition to the "Accepted" state...
	                // The 2xx response MUST be passed up to the TU. The client
	                // transaction MUST NOT generate an ACK to the 2xx response -- its
	                // handling is delegated to the TU. A UAC core will send an ACK to
	                // the 2xx response using a new transaction.
	                // https://tools.ietf.org/html/rfc6026#section-8.4
	                if (statusCode >= 200 && statusCode <= 299) {
	                    this.ackRetransmissionCache.set(response.toTag, undefined); // Prime the ACK cache
	                    this.stateTransition(TransactionState.Accepted);
	                    if (this.user.receiveResponse) {
	                        this.user.receiveResponse(response);
	                    }
	                    return;
	                }
	                // When in either the "Calling" or "Proceeding" states, reception of
	                // a response with status code from 300-699 MUST cause the client
	                // transaction to transition to "Completed". The client transaction
	                // MUST pass the received response up to the TU, and the client
	                // transaction MUST generate an ACK request, even if the transport is
	                // reliable (guidelines for constructing the ACK from the response
	                // are given in Section 17.1.1.3), and then pass the ACK to the
	                // transport layer for transmission. The ACK MUST be sent to the
	                // same address, port, and transport to which the original request was sent.
	                // https://tools.ietf.org/html/rfc6026#section-8.4
	                if (statusCode >= 300 && statusCode <= 699) {
	                    this.stateTransition(TransactionState.Completed);
	                    this.ack(response);
	                    if (this.user.receiveResponse) {
	                        this.user.receiveResponse(response);
	                    }
	                    return;
	                }
	                break;
	            case TransactionState.Accepted:
	                // The purpose of the "Accepted" state is to allow the client
	                // transaction to continue to exist to receive, and pass to the TU,
	                // any retransmissions of the 2xx response and any additional 2xx
	                // responses from other branches of the INVITE if it forked
	                // downstream. Timer M reflects the amount of time that the
	                // transaction user will wait for such messages.
	                //
	                // Any 2xx responses that match this client transaction and that are
	                // received while in the "Accepted" state MUST be passed up to the
	                // TU. The client transaction MUST NOT generate an ACK to the 2xx
	                // response. The client transaction takes no further action.
	                // https://tools.ietf.org/html/rfc6026#section-8.4
	                if (statusCode >= 200 && statusCode <= 299) {
	                    // NOTE: This implementation herein is intentionally not RFC compliant.
	                    // While the first 2xx response for a given branch is passed up to the TU,
	                    // retransmissions of 2xx responses are absorbed and the ACK associated
	                    // with the original response is resent. This approach is taken because
	                    // our current transaction users are not currently in a good position to
	                    // deal with 2xx retransmission. This SHOULD NOT cause any compliance issues - ;)
	                    //
	                    // If we don't have a cache hit, pass the response to the TU.
	                    if (!this.ackRetransmissionCache.has(response.toTag)) {
	                        this.ackRetransmissionCache.set(response.toTag, undefined); // Prime the ACK cache
	                        if (this.user.receiveResponse) {
	                            this.user.receiveResponse(response);
	                        }
	                        return;
	                    }
	                    // If we have a cache hit, try pulling the ACK from cache and retransmitting it.
	                    var ack = this.ackRetransmissionCache.get(response.toTag);
	                    if (ack) {
	                        this.send(ack.toString()).catch(function (error) {
	                            _this.logTransportError(error, "Failed to send retransmission of ACK to 2xx response.");
	                        });
	                        return;
	                    }
	                    // If an ACK was not found in cache then we have received a retransmitted 2xx
	                    // response before the TU responded to the original response (we don't have an ACK yet).
	                    // So discard this response under the assumption that the TU will eventually
	                    // get us a ACK for the original response.
	                    return;
	                }
	                break;
	            case TransactionState.Completed:
	                // Any retransmissions of a response with status code 300-699 that
	                // are received while in the "Completed" state MUST cause the ACK to
	                // be re-passed to the transport layer for retransmission, but the
	                // newly received response MUST NOT be passed up to the TU.
	                // https://tools.ietf.org/html/rfc6026#section-8.4
	                if (statusCode >= 300 && statusCode <= 699) {
	                    this.ack(response);
	                    return;
	                }
	                break;
	            case TransactionState.Terminated:
	                break;
	            default:
	                throw new Error("Invalid state " + this.state);
	        }
	        // Any response received that does not match an existing client
	        // transaction state machine is simply dropped. (Implementations are,
	        // of course, free to log or do other implementation-specific things
	        // with such responses, but the implementer should be sure to consider
	        // the impact of large numbers of malicious stray responses.)
	        // https://tools.ietf.org/html/rfc6026#section-7.2
	        var message = "Received unexpected " + statusCode + " response while in state " + this.state + ".";
	        this.logger.warn(message);
	        return;
	    };
	    /**
	     * The client transaction SHOULD inform the TU that a transport failure
	     * has occurred, and the client transaction SHOULD transition directly
	     * to the "Terminated" state.  The TU will handle the failover
	     * mechanisms described in [4].
	     * https://tools.ietf.org/html/rfc3261#section-17.1.4
	     * @param error The error.
	     */
	    InviteClientTransaction.prototype.onTransportError = function (error) {
	        if (this.user.onTransportError) {
	            this.user.onTransportError(error);
	        }
	        this.stateTransition(TransactionState.Terminated, true);
	    };
	    InviteClientTransaction.prototype.ack = function (response) {
	        var _this = this;
	        // The ACK request constructed by the client transaction MUST contain
	        // values for the Call-ID, From, and Request-URI that are equal to the
	        // values of those header fields in the request passed to the transport
	        // by the client transaction (call this the "original request"). The To
	        // header field in the ACK MUST equal the To header field in the
	        // response being acknowledged, and therefore will usually differ from
	        // the To header field in the original request by the addition of the
	        // tag parameter. The ACK MUST contain a single Via header field, and
	        // this MUST be equal to the top Via header field of the original
	        // request. The CSeq header field in the ACK MUST contain the same
	        // value for the sequence number as was present in the original request,
	        // but the method parameter MUST be equal to "ACK".
	        //
	        // If the INVITE request whose response is being acknowledged had Route
	        // header fields, those header fields MUST appear in the ACK. This is
	        // to ensure that the ACK can be routed properly through any downstream
	        // stateless proxies.
	        // https://tools.ietf.org/html/rfc3261#section-17.1.1.3
	        var ruri = this.request.ruri;
	        var callId = this.request.callId;
	        var cseq = this.request.cseq;
	        var from = this.request.getHeader("from");
	        var to = response.getHeader("to");
	        var via = this.request.getHeader("via");
	        var route = this.request.getHeader("route");
	        if (!from) {
	            throw new Error("From undefined.");
	        }
	        if (!to) {
	            throw new Error("To undefined.");
	        }
	        if (!via) {
	            throw new Error("Via undefined.");
	        }
	        var ack = "ACK " + ruri + " SIP/2.0\r\n";
	        if (route) {
	            ack += "Route: " + route + "\r\n";
	        }
	        ack += "Via: " + via + "\r\n";
	        ack += "To: " + to + "\r\n";
	        ack += "From: " + from + "\r\n";
	        ack += "Call-ID: " + callId + "\r\n";
	        ack += "CSeq: " + cseq + " ACK\r\n";
	        ack += "Max-Forwards: 70\r\n";
	        ack += "Content-Length: 0\r\n\r\n";
	        // TOOO: "User-Agent" header
	        this.send(ack).catch(function (error) {
	            _this.logTransportError(error, "Failed to send ACK to non-2xx response.");
	        });
	        return;
	    };
	    /**
	     * Execute a state transition.
	     * @param newState New state.
	     */
	    InviteClientTransaction.prototype.stateTransition = function (newState, dueToTransportError) {
	        var _this = this;
	        if (dueToTransportError === void 0) { dueToTransportError = false; }
	        // Assert valid state transitions.
	        var invalidStateTransition = function () {
	            throw new Error("Invalid state transition from " + _this.state + " to " + newState);
	        };
	        switch (newState) {
	            case TransactionState.Calling:
	                invalidStateTransition();
	                break;
	            case TransactionState.Proceeding:
	                if (this.state !== TransactionState.Calling) {
	                    invalidStateTransition();
	                }
	                break;
	            case TransactionState.Accepted:
	            case TransactionState.Completed:
	                if (this.state !== TransactionState.Calling &&
	                    this.state !== TransactionState.Proceeding) {
	                    invalidStateTransition();
	                }
	                break;
	            case TransactionState.Terminated:
	                if (this.state !== TransactionState.Calling &&
	                    this.state !== TransactionState.Accepted &&
	                    this.state !== TransactionState.Completed) {
	                    if (!dueToTransportError) {
	                        invalidStateTransition();
	                    }
	                }
	                break;
	            default:
	                invalidStateTransition();
	        }
	        // While not spelled out in the RFC, Timer B is the maximum amount of time that a sender
	        // will wait for an INVITE message to be acknowledged (a SIP response message is received).
	        // So Timer B should be cleared when the transaction state proceeds from "Calling".
	        if (this.B) {
	            clearTimeout(this.B);
	            this.B = undefined;
	        }
	        if (newState === TransactionState.Proceeding) ;
	        // The client transaction MUST start Timer D when it enters the "Completed" state
	        // for any reason, with a value of at least 32 seconds for unreliable transports,
	        // and a value of zero seconds for reliable transports.
	        // https://tools.ietf.org/html/rfc6026#section-8.4
	        if (newState === TransactionState.Completed) {
	            this.D = setTimeout(function () { return _this.timer_D(); }, Timers.Timers.TIMER_D);
	        }
	        // The client transaction MUST transition to the "Accepted" state,
	        // and Timer M MUST be started with a value of 64*T1.
	        // https://tools.ietf.org/html/rfc6026#section-8.4
	        if (newState === TransactionState.Accepted) {
	            this.M = setTimeout(function () { return _this.timer_M(); }, Timers.Timers.TIMER_M);
	        }
	        // Once the transaction is in the "Terminated" state, it MUST be destroyed immediately.
	        // https://tools.ietf.org/html/rfc6026#section-8.7
	        if (newState === TransactionState.Terminated) {
	            this.dispose();
	        }
	        // Update state.
	        this.setState(newState);
	    };
	    /**
	     * When timer A fires, the client transaction MUST retransmit the
	     * request by passing it to the transport layer, and MUST reset the
	     * timer with a value of 2*T1.
	     * When timer A fires 2*T1 seconds later, the request MUST be
	     * retransmitted again (assuming the client transaction is still in this
	     * state). This process MUST continue so that the request is
	     * retransmitted with intervals that double after each transmission.
	     * These retransmissions SHOULD only be done while the client
	     * transaction is in the "Calling" state.
	     * https://tools.ietf.org/html/rfc3261#section-17.1.1.2
	     */
	    InviteClientTransaction.prototype.timer_A = function () {
	        // TODO
	    };
	    /**
	     * If the client transaction is still in the "Calling" state when timer
	     * B fires, the client transaction SHOULD inform the TU that a timeout
	     * has occurred.  The client transaction MUST NOT generate an ACK.
	     * https://tools.ietf.org/html/rfc3261#section-17.1.1.2
	     */
	    InviteClientTransaction.prototype.timer_B = function () {
	        this.logger.debug("Timer B expired for INVITE client transaction " + this.id + ".");
	        if (this.state === TransactionState.Calling) {
	            this.onRequestTimeout();
	            this.stateTransition(TransactionState.Terminated);
	        }
	    };
	    /**
	     * If Timer D fires while the client transaction is in the "Completed" state,
	     * the client transaction MUST move to the "Terminated" state.
	     * https://tools.ietf.org/html/rfc6026#section-8.4
	     */
	    InviteClientTransaction.prototype.timer_D = function () {
	        this.logger.debug("Timer D expired for INVITE client transaction " + this.id + ".");
	        if (this.state === TransactionState.Completed) {
	            this.stateTransition(TransactionState.Terminated);
	        }
	    };
	    /**
	     * If Timer M fires while the client transaction is in the "Accepted"
	     * state, the client transaction MUST move to the "Terminated" state.
	     * https://tools.ietf.org/html/rfc6026#section-8.4
	     */
	    InviteClientTransaction.prototype.timer_M = function () {
	        this.logger.debug("Timer M expired for INVITE client transaction " + this.id + ".");
	        if (this.state === TransactionState.Accepted) {
	            this.stateTransition(TransactionState.Terminated);
	        }
	    };
	    return InviteClientTransaction;
	}(ClientTransaction));
	exports.InviteClientTransaction = InviteClientTransaction;
	/**
	 * Non-INVITE Client Transaction
	 *
	 * Non-INVITE transactions do not make use of ACK.
	 * They are simple request-response interactions.
	 * https://tools.ietf.org/html/rfc3261#section-17.1.2
	 */
	var NonInviteClientTransaction = /** @class */ (function (_super) {
	    __extends(NonInviteClientTransaction, _super);
	    /**
	     * Constructor
	     * Upon construction, the outgoing request's Via header is updated by calling `setViaHeader`.
	     * Then `toString` is called on the outgoing request and the message is sent via the transport.
	     * After construction the transaction will be in the "calling" state and the transaction id
	     * will equal the branch parameter set in the Via header of the outgoing request.
	     * https://tools.ietf.org/html/rfc3261#section-17.1.2
	     * @param request The outgoing Non-INVITE request.
	     * @param transport The transport.
	     * @param user The transaction user.
	     */
	    function NonInviteClientTransaction(request, transport, user) {
	        var _this = _super.call(this, request, transport, user, TransactionState.Trying, "sip.transaction.nict") || this;
	        // FIXME: Timer E for unreliable transports not implemented.
	        //
	        // The "Trying" state is entered when the TU initiates a new client
	        // transaction with a request.  When entering this state, the client
	        // transaction SHOULD set timer F to fire in 64*T1 seconds. The request
	        // MUST be passed to the transport layer for transmission.
	        // https://tools.ietf.org/html/rfc3261#section-17.1.2.2
	        _this.F = setTimeout(function () { return _this.timer_F(); }, Timers.Timers.TIMER_F);
	        _this.send(request.toString()).catch(function (error) {
	            _this.logTransportError(error, "Failed to send initial outgoing request.");
	        });
	        return _this;
	    }
	    /**
	     * Destructor.
	     */
	    NonInviteClientTransaction.prototype.dispose = function () {
	        if (this.F) {
	            clearTimeout(this.F);
	            this.F = undefined;
	        }
	        if (this.K) {
	            clearTimeout(this.K);
	            this.K = undefined;
	        }
	        _super.prototype.dispose.call(this);
	    };
	    /**
	     * Handler for incoming responses from the transport which match this transaction.
	     * @param response The incoming response.
	     */
	    NonInviteClientTransaction.prototype.receiveResponse = function (response) {
	        var statusCode = response.statusCode;
	        if (!statusCode || statusCode < 100 || statusCode > 699) {
	            throw new Error("Invalid status code " + statusCode);
	        }
	        switch (this.state) {
	            case TransactionState.Trying:
	                // If a provisional response is received while in the "Trying" state, the
	                // response MUST be passed to the TU, and then the client transaction
	                // SHOULD move to the "Proceeding" state.
	                // https://tools.ietf.org/html/rfc3261#section-17.1.2.2
	                if (statusCode >= 100 && statusCode <= 199) {
	                    this.stateTransition(TransactionState.Proceeding);
	                    if (this.user.receiveResponse) {
	                        this.user.receiveResponse(response);
	                    }
	                    return;
	                }
	                // If a final response (status codes 200-699) is received while in the
	                // "Trying" state, the response MUST be passed to the TU, and the
	                // client transaction MUST transition to the "Completed" state.
	                // https://tools.ietf.org/html/rfc3261#section-17.1.2.2
	                if (statusCode >= 200 && statusCode <= 699) {
	                    this.stateTransition(TransactionState.Completed);
	                    if (statusCode === 408) {
	                        this.onRequestTimeout();
	                        return;
	                    }
	                    if (this.user.receiveResponse) {
	                        this.user.receiveResponse(response);
	                    }
	                    return;
	                }
	                break;
	            case TransactionState.Proceeding:
	                // If a provisional response is received while in the "Proceeding" state,
	                // the response MUST be passed to the TU. (From Figure 6)
	                // https://tools.ietf.org/html/rfc3261#section-17.1.2.2
	                if (statusCode >= 100 && statusCode <= 199) {
	                    if (this.user.receiveResponse) {
	                        return this.user.receiveResponse(response);
	                    }
	                }
	                // If a final response (status codes 200-699) is received while in the
	                // "Proceeding" state, the response MUST be passed to the TU, and the
	                // client transaction MUST transition to the "Completed" state.
	                // https://tools.ietf.org/html/rfc3261#section-17.1.2.2
	                if (statusCode >= 200 && statusCode <= 699) {
	                    this.stateTransition(TransactionState.Completed);
	                    if (statusCode === 408) {
	                        this.onRequestTimeout();
	                        return;
	                    }
	                    if (this.user.receiveResponse) {
	                        this.user.receiveResponse(response);
	                    }
	                    return;
	                }
	            case TransactionState.Completed:
	                // The "Completed" state exists to buffer any additional response
	                // retransmissions that may be received (which is why the client
	                // transaction remains there only for unreliable transports).
	                // https://tools.ietf.org/html/rfc3261#section-17.1.2.2
	                return;
	            case TransactionState.Terminated:
	                // For good measure just absorb additional response retransmissions.
	                return;
	            default:
	                throw new Error("Invalid state " + this.state);
	        }
	        var message = "Non-INVITE client transaction received unexpected " + statusCode + " response while in state " + this.state + ".";
	        this.logger.warn(message);
	        return;
	    };
	    /**
	     * The client transaction SHOULD inform the TU that a transport failure has occurred,
	     * and the client transaction SHOULD transition directly to the "Terminated" state.
	     * The TU will handle the failover mechanisms described in [4].
	     * https://tools.ietf.org/html/rfc3261#section-17.1.4
	     * @param error Trasnsport error
	     */
	    NonInviteClientTransaction.prototype.onTransportError = function (error) {
	        if (this.user.onTransportError) {
	            this.user.onTransportError(error);
	        }
	        this.stateTransition(TransactionState.Terminated, true);
	    };
	    /**
	     * Execute a state transition.
	     * @param newState New state.
	     */
	    NonInviteClientTransaction.prototype.stateTransition = function (newState, dueToTransportError) {
	        var _this = this;
	        if (dueToTransportError === void 0) { dueToTransportError = false; }
	        // Assert valid state transitions.
	        var invalidStateTransition = function () {
	            throw new Error("Invalid state transition from " + _this.state + " to " + newState);
	        };
	        switch (newState) {
	            case TransactionState.Trying:
	                invalidStateTransition();
	                break;
	            case TransactionState.Proceeding:
	                if (this.state !== TransactionState.Trying) {
	                    invalidStateTransition();
	                }
	                break;
	            case TransactionState.Completed:
	                if (this.state !== TransactionState.Trying &&
	                    this.state !== TransactionState.Proceeding) {
	                    invalidStateTransition();
	                }
	                break;
	            case TransactionState.Terminated:
	                if (this.state !== TransactionState.Trying &&
	                    this.state !== TransactionState.Proceeding &&
	                    this.state !== TransactionState.Completed) {
	                    if (!dueToTransportError) {
	                        invalidStateTransition();
	                    }
	                }
	                break;
	            default:
	                invalidStateTransition();
	        }
	        // Once the client transaction enters the "Completed" state, it MUST set
	        // Timer K to fire in T4 seconds for unreliable transports, and zero
	        // seconds for reliable transports  The "Completed" state exists to
	        // buffer any additional response retransmissions that may be received
	        // (which is why the client transaction remains there only for unreliable transports).
	        // https://tools.ietf.org/html/rfc3261#section-17.1.2.2
	        if (newState === TransactionState.Completed) {
	            if (this.F) {
	                clearTimeout(this.F);
	                this.F = undefined;
	            }
	            this.K = setTimeout(function () { return _this.timer_K(); }, Timers.Timers.TIMER_K);
	        }
	        // Once the transaction is in the terminated state, it MUST be destroyed immediately.
	        // https://tools.ietf.org/html/rfc3261#section-17.1.2.2
	        if (newState === TransactionState.Terminated) {
	            this.dispose();
	        }
	        // Update state.
	        this.setState(newState);
	    };
	    /**
	     * If Timer F fires while the client transaction is still in the
	     * "Trying" state, the client transaction SHOULD inform the TU about the
	     * timeout, and then it SHOULD enter the "Terminated" state.
	     * If timer F fires while in the "Proceeding" state, the TU MUST be informed of
	     * a timeout, and the client transaction MUST transition to the terminated state.
	     * https://tools.ietf.org/html/rfc3261#section-17.1.2.2
	     */
	    NonInviteClientTransaction.prototype.timer_F = function () {
	        this.logger.debug("Timer F expired for non-INVITE client transaction " + this.id + ".");
	        if (this.state === TransactionState.Trying || this.state === TransactionState.Proceeding) {
	            this.onRequestTimeout();
	            this.stateTransition(TransactionState.Terminated);
	        }
	    };
	    /**
	     * If Timer K fires while in this (COMPLETED) state, the client transaction
	     * MUST transition to the "Terminated" state.
	     * https://tools.ietf.org/html/rfc3261#section-17.1.2.2
	     */
	    NonInviteClientTransaction.prototype.timer_K = function () {
	        if (this.state === TransactionState.Completed) {
	            this.stateTransition(TransactionState.Terminated);
	        }
	    };
	    return NonInviteClientTransaction;
	}(ClientTransaction));
	exports.NonInviteClientTransaction = NonInviteClientTransaction;
	/**
	 * Server Transaction
	 * The server transaction is responsible for the delivery of requests to
	 * the TU and the reliable transmission of responses.  It accomplishes
	 * this through a state machine.  Server transactions are created by the
	 * core when a request is received, and transaction handling is desired
	 * for that request (this is not always the case).
	 * https://tools.ietf.org/html/rfc3261#section-17.2
	 */
	var ServerTransaction = /** @class */ (function (_super) {
	    __extends(ServerTransaction, _super);
	    function ServerTransaction(_request, transport, user, state, loggerCategory) {
	        var _this = _super.call(this, transport, user, _request.viaBranch, state, loggerCategory) || this;
	        _this._request = _request;
	        _this.user = user;
	        // FIXME: Bad hack. Potentially creating circular dependency. SIPMessage needs refactor.
	        // Set IncomingRequest's transaction.
	        _request.transaction = _this;
	        return _this;
	    }
	    Object.defineProperty(ServerTransaction.prototype, "request", {
	        /** The incoming request the transaction handling. */
	        get: function () {
	            return this._request;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    return ServerTransaction;
	}(Transaction));
	exports.ServerTransaction = ServerTransaction;
	/**
	 * INVITE Server Transaction
	 * https://tools.ietf.org/html/rfc3261#section-17.2.1
	 */
	var InviteServerTransaction = /** @class */ (function (_super) {
	    __extends(InviteServerTransaction, _super);
	    /**
	     * Constructor.
	     * Upon construction, a "100 Trying" reply will be immediately sent.
	     * After construction the transaction will be in the "proceeding" state and the transaction
	     * `id` will equal the branch parameter set in the Via header of the incoming request.
	     * https://tools.ietf.org/html/rfc3261#section-17.2.1
	     * @param request Incoming INVITE request from the transport.
	     * @param transport The transport.
	     * @param user The transaction user.
	     */
	    function InviteServerTransaction(request, transport, user) {
	        var _this = _super.call(this, request, transport, user, TransactionState.Proceeding, "sip.transaction.ist") || this;
	        // FIXME: This is in the wrong place - UAS should trigger it.
	        // Results in this this.receiveResponse() being called.
	        // FIXME: Should be configurable. Only required if TU will not respond in 200ms.
	        // https://tools.ietf.org/html/rfc3261#section-17.2.1
	        request.reply(100);
	        return _this;
	    }
	    /**
	     * Destructor.
	     */
	    InviteServerTransaction.prototype.dispose = function () {
	        this.stopProgressExtensionTimer();
	        if (this.H) {
	            clearTimeout(this.H);
	            this.H = undefined;
	        }
	        if (this.I) {
	            clearTimeout(this.I);
	            this.I = undefined;
	        }
	        if (this.L) {
	            clearTimeout(this.L);
	            this.L = undefined;
	        }
	        _super.prototype.dispose.call(this);
	    };
	    /**
	     * Receive requests from transport matching this transaction.
	     * @param request Request matching this transaction.
	     */
	    InviteServerTransaction.prototype.receiveRequest = function (request) {
	        var _this = this;
	        switch (this.state) {
	            case TransactionState.Proceeding:
	                // If a request retransmission is received while in the "Proceeding" state, the most
	                // recent provisional response that was received from the TU MUST be passed to the
	                // transport layer for retransmission.
	                // https://tools.ietf.org/html/rfc3261#section-17.2.1
	                if (request.method === Constants.C.INVITE) {
	                    if (this.lastProvisionalResponse) {
	                        this.send(this.lastProvisionalResponse).catch(function (error) {
	                            _this.logTransportError(error, "Failed to send retransmission of provisional response.");
	                        });
	                    }
	                    return;
	                }
	                break;
	            case TransactionState.Accepted:
	                // While in the "Accepted" state, any retransmissions of the INVITE
	                // received will match this transaction state machine and will be
	                // absorbed by the machine without changing its state. These
	                // retransmissions are not passed onto the TU.
	                // https://tools.ietf.org/html/rfc6026#section-7.1
	                if (request.method === Constants.C.INVITE) {
	                    return;
	                }
	                break;
	            case TransactionState.Completed:
	                // Furthermore, while in the "Completed" state, if a request retransmission is
	                // received, the server SHOULD pass the response to the transport for retransmission.
	                // https://tools.ietf.org/html/rfc3261#section-17.2.1
	                if (request.method === Constants.C.INVITE) {
	                    if (!this.lastFinalResponse) {
	                        throw new Error("Last final response undefined.");
	                    }
	                    this.send(this.lastFinalResponse).catch(function (error) {
	                        _this.logTransportError(error, "Failed to send retransmission of final response.");
	                    });
	                    return;
	                }
	                // If an ACK is received while the server transaction is in the "Completed" state,
	                // the server transaction MUST transition to the "Confirmed" state.
	                // https://tools.ietf.org/html/rfc3261#section-17.2.1
	                if (request.method === Constants.C.ACK) {
	                    this.stateTransition(TransactionState.Confirmed);
	                    return;
	                }
	                break;
	            case TransactionState.Confirmed:
	                // The purpose of the "Confirmed" state is to absorb any additional ACK messages that arrive,
	                // triggered from retransmissions of the final response.
	                // https://tools.ietf.org/html/rfc3261#section-17.2.1
	                if (request.method === Constants.C.INVITE || request.method === Constants.C.ACK) {
	                    return;
	                }
	                break;
	            case TransactionState.Terminated:
	                // For good measure absorb any additional messages that arrive (should not happen).
	                if (request.method === Constants.C.INVITE || request.method === Constants.C.ACK) {
	                    return;
	                }
	                break;
	            default:
	                throw new Error("Invalid state " + this.state);
	        }
	        var message = "INVITE server transaction received unexpected " + request.method + " request while in state " + this.state + ".";
	        this.logger.warn(message);
	        return;
	    };
	    /**
	     * Receive responses from TU for this transaction.
	     * @param statusCode Status code of response.
	     * @param response Response.
	     */
	    InviteServerTransaction.prototype.receiveResponse = function (statusCode, response) {
	        var _this = this;
	        if (statusCode < 100 || statusCode > 699) {
	            throw new Error("Invalid status code " + statusCode);
	        }
	        switch (this.state) {
	            case TransactionState.Proceeding:
	                // The TU passes any number of provisional responses to the server
	                // transaction. So long as the server transaction is in the
	                // "Proceeding" state, each of these MUST be passed to the transport
	                // layer for transmission. They are not sent reliably by the
	                // transaction layer (they are not retransmitted by it) and do not cause
	                // a change in the state of the server transaction.
	                // https://tools.ietf.org/html/rfc3261#section-17.2.1
	                if (statusCode >= 100 && statusCode <= 199) {
	                    this.lastProvisionalResponse = response;
	                    // Start the progress extension timer only for a non-100 provisional response.
	                    if (statusCode > 100) {
	                        this.startProgressExtensionTimer(); // FIXME: remove
	                    }
	                    this.send(response).catch(function (error) {
	                        _this.logTransportError(error, "Failed to send 1xx response.");
	                    });
	                    return;
	                }
	                // If, while in the "Proceeding" state, the TU passes a 2xx response
	                // to the server transaction, the server transaction MUST pass this
	                // response to the transport layer for transmission. It is not
	                // retransmitted by the server transaction; retransmissions of 2xx
	                // responses are handled by the TU. The server transaction MUST then
	                // transition to the "Accepted" state.
	                // https://tools.ietf.org/html/rfc6026#section-8.5
	                if (statusCode >= 200 && statusCode <= 299) {
	                    this.lastFinalResponse = response;
	                    this.stateTransition(TransactionState.Accepted);
	                    this.send(response).catch(function (error) {
	                        _this.logTransportError(error, "Failed to send 2xx response.");
	                    });
	                    return;
	                }
	                // While in the "Proceeding" state, if the TU passes a response with
	                // status code from 300 to 699 to the server transaction, the response
	                // MUST be passed to the transport layer for transmission, and the state
	                // machine MUST enter the "Completed" state.
	                // https://tools.ietf.org/html/rfc3261#section-17.2.1
	                if (statusCode >= 300 && statusCode <= 699) {
	                    this.lastFinalResponse = response;
	                    this.stateTransition(TransactionState.Completed);
	                    this.send(response).catch(function (error) {
	                        _this.logTransportError(error, "Failed to send non-2xx final response.");
	                    });
	                    return;
	                }
	                break;
	            case TransactionState.Accepted:
	                // While in the "Accepted" state, if the TU passes a 2xx response,
	                // the server transaction MUST pass the response to the transport layer for transmission.
	                // https://tools.ietf.org/html/rfc6026#section-8.7
	                if (statusCode >= 200 && statusCode <= 299) {
	                    this.send(response).catch(function (error) {
	                        _this.logTransportError(error, "Failed to send 2xx response.");
	                    });
	                    return;
	                }
	                break;
	            case TransactionState.Completed:
	                break;
	            case TransactionState.Confirmed:
	                break;
	            case TransactionState.Terminated:
	                break;
	            default:
	                throw new Error("Invalid state " + this.state);
	        }
	        var message = "INVITE server transaction received unexpected " + statusCode + " response from TU while in state " + this.state + ".";
	        this.logger.error(message);
	        throw new Error(message);
	    };
	    /**
	     * First, the procedures in [4] are followed, which attempt to deliver the response to a backup.
	     * If those should all fail, based on the definition of failure in [4], the server transaction SHOULD
	     * inform the TU that a failure has occurred, and MUST remain in the current state.
	     * https://tools.ietf.org/html/rfc6026#section-8.8
	     */
	    InviteServerTransaction.prototype.onTransportError = function (error) {
	        if (this.user.onTransportError) {
	            this.user.onTransportError(error);
	        }
	    };
	    /**
	     * Execute a state transition.
	     * @param newState New state.
	     */
	    InviteServerTransaction.prototype.stateTransition = function (newState) {
	        var _this = this;
	        // Assert valid state transitions.
	        var invalidStateTransition = function () {
	            throw new Error("Invalid state transition from " + _this.state + " to " + newState);
	        };
	        switch (newState) {
	            case TransactionState.Proceeding:
	                invalidStateTransition();
	                break;
	            case TransactionState.Accepted:
	            case TransactionState.Completed:
	                if (this.state !== TransactionState.Proceeding) {
	                    invalidStateTransition();
	                }
	                break;
	            case TransactionState.Confirmed:
	                if (this.state !== TransactionState.Completed) {
	                    invalidStateTransition();
	                }
	                break;
	            case TransactionState.Terminated:
	                if (this.state !== TransactionState.Accepted &&
	                    this.state !== TransactionState.Completed &&
	                    this.state !== TransactionState.Confirmed) {
	                    invalidStateTransition();
	                }
	                break;
	            default:
	                invalidStateTransition();
	        }
	        // On any state transition, stop resending provisonal responses
	        this.stopProgressExtensionTimer();
	        // The purpose of the "Accepted" state is to absorb retransmissions of an accepted INVITE request.
	        // Any such retransmissions are absorbed entirely within the server transaction.
	        // They are not passed up to the TU since any downstream UAS cores that accepted the request have
	        // taken responsibility for reliability and will already retransmit their 2xx responses if necessary.
	        // https://tools.ietf.org/html/rfc6026#section-8.7
	        if (newState === TransactionState.Accepted) {
	            this.L = setTimeout(function () { return _this.timer_L(); }, Timers.Timers.TIMER_L);
	        }
	        // When the "Completed" state is entered, timer H MUST be set to fire in 64*T1 seconds for all transports.
	        // Timer H determines when the server transaction abandons retransmitting the response.
	        // If an ACK is received while the server transaction is in the "Completed" state,
	        // the server transaction MUST transition to the "Confirmed" state.
	        // https://tools.ietf.org/html/rfc3261#section-17.2.1
	        if (newState === TransactionState.Completed) {
	            // FIXME: Missing timer G for unreliable transports.
	            this.H = setTimeout(function () { return _this.timer_H(); }, Timers.Timers.TIMER_H);
	        }
	        // The purpose of the "Confirmed" state is to absorb any additional ACK messages that arrive,
	        // triggered from retransmissions of the final response. When this state is entered, timer I
	        // is set to fire in T4 seconds for unreliable transports, and zero seconds for reliable
	        // transports. Once timer I fires, the server MUST transition to the "Terminated" state.
	        // https://tools.ietf.org/html/rfc3261#section-17.2.1
	        if (newState === TransactionState.Confirmed) {
	            // FIXME: This timer is not getting set correctly for unreliable transports.
	            this.I = setTimeout(function () { return _this.timer_I(); }, Timers.Timers.TIMER_I);
	        }
	        // Once the transaction is in the "Terminated" state, it MUST be destroyed immediately.
	        // https://tools.ietf.org/html/rfc6026#section-8.7
	        if (newState === TransactionState.Terminated) {
	            this.dispose();
	        }
	        // Update state.
	        this.setState(newState);
	    };
	    /**
	     * FIXME: UAS Provisional Retransmission Timer. See RFC 3261 Section 13.3.1.1
	     * This is in the wrong place. This is not a transaction level thing. It's a UAS level thing.
	     */
	    InviteServerTransaction.prototype.startProgressExtensionTimer = function () {
	        var _this = this;
	        // Start the progress extension timer only for the first non-100 provisional response.
	        if (this.progressExtensionTimer === undefined) {
	            this.progressExtensionTimer = setInterval(function () {
	                _this.logger.debug("Progress extension timer expired for INVITE server transaction " + _this.id + ".");
	                if (!_this.lastProvisionalResponse) {
	                    throw new Error("Last provisional response undefined.");
	                }
	                _this.send(_this.lastProvisionalResponse).catch(function (error) {
	                    _this.logTransportError(error, "Failed to send retransmission of provisional response.");
	                });
	            }, Timers.Timers.PROVISIONAL_RESPONSE_INTERVAL);
	        }
	    };
	    /**
	     * FIXME: UAS Provisional Retransmission Timer id. See RFC 3261 Section 13.3.1.1
	     * This is in the wrong place. This is not a transaction level thing. It's a UAS level thing.
	     */
	    InviteServerTransaction.prototype.stopProgressExtensionTimer = function () {
	        if (this.progressExtensionTimer !== undefined) {
	            clearInterval(this.progressExtensionTimer);
	            this.progressExtensionTimer = undefined;
	        }
	    };
	    /**
	     * While in the "Proceeding" state, if the TU passes a response with status code
	     * from 300 to 699 to the server transaction, the response MUST be passed to the
	     * transport layer for transmission, and the state machine MUST enter the "Completed" state.
	     * For unreliable transports, timer G is set to fire in T1 seconds, and is not set to fire for
	     * reliable transports. If timer G fires, the response is passed to the transport layer once
	     * more for retransmission, and timer G is set to fire in MIN(2*T1, T2) seconds. From then on,
	     * when timer G fires, the response is passed to the transport again for transmission, and
	     * timer G is reset with a value that doubles, unless that value exceeds T2, in which case
	     * it is reset with the value of T2.
	     * https://tools.ietf.org/html/rfc3261#section-17.2.1
	     */
	    InviteServerTransaction.prototype.timer_G = function () {
	        // TODO
	    };
	    /**
	     * If timer H fires while in the "Completed" state, it implies that the ACK was never received.
	     * In this case, the server transaction MUST transition to the "Terminated" state, and MUST
	     * indicate to the TU that a transaction failure has occurred.
	     * https://tools.ietf.org/html/rfc3261#section-17.2.1
	     */
	    InviteServerTransaction.prototype.timer_H = function () {
	        this.logger.debug("Timer H expired for INVITE server transaction " + this.id + ".");
	        if (this.state === TransactionState.Completed) {
	            this.logger.warn("ACK to negative final response was never received, terminating transaction.");
	            this.stateTransition(TransactionState.Terminated);
	        }
	    };
	    /**
	     * Once timer I fires, the server MUST transition to the "Terminated" state.
	     * https://tools.ietf.org/html/rfc3261#section-17.2.1
	     */
	    InviteServerTransaction.prototype.timer_I = function () {
	        this.logger.debug("Timer I expired for INVITE server transaction " + this.id + ".");
	        this.stateTransition(TransactionState.Terminated);
	    };
	    /**
	     * When Timer L fires and the state machine is in the "Accepted" state, the machine MUST
	     * transition to the "Terminated" state. Once the transaction is in the "Terminated" state,
	     * it MUST be destroyed immediately. Timer L reflects the amount of time the server
	     * transaction could receive 2xx responses for retransmission from the
	     * TU while it is waiting to receive an ACK.
	     * https://tools.ietf.org/html/rfc6026#section-7.1
	     * https://tools.ietf.org/html/rfc6026#section-8.7
	     */
	    InviteServerTransaction.prototype.timer_L = function () {
	        this.logger.debug("Timer L expired for INVITE server transaction " + this.id + ".");
	        if (this.state === TransactionState.Accepted) {
	            this.stateTransition(TransactionState.Terminated);
	        }
	    };
	    return InviteServerTransaction;
	}(ServerTransaction));
	exports.InviteServerTransaction = InviteServerTransaction;
	/**
	 * Non-INVITE Server Transaction
	 * https://tools.ietf.org/html/rfc3261#section-17.2.2
	 */
	var NonInviteServerTransaction = /** @class */ (function (_super) {
	    __extends(NonInviteServerTransaction, _super);
	    /**
	     * Constructor.
	     * After construction the transaction will be in the "trying": state and the transaction
	     * `id` will equal the branch parameter set in the Via header of the incoming request.
	     * https://tools.ietf.org/html/rfc3261#section-17.2.2
	     * @param request Incoming Non-INVITE request from the transport.
	     * @param transport The transport.
	     * @param user The transaction user.
	     */
	    function NonInviteServerTransaction(request, transport, user) {
	        return _super.call(this, request, transport, user, TransactionState.Trying, "sip.transaction.nist") || this;
	    }
	    /**
	     * Destructor.
	     */
	    NonInviteServerTransaction.prototype.dispose = function () {
	        if (this.J) {
	            clearTimeout(this.J);
	            this.J = undefined;
	        }
	        _super.prototype.dispose.call(this);
	    };
	    /**
	     * Receive requests from transport matching this transaction.
	     * @param request Request matching this transaction.
	     */
	    NonInviteServerTransaction.prototype.receiveRequest = function (request) {
	        var _this = this;
	        switch (this.state) {
	            case TransactionState.Trying:
	                // Once in the "Trying" state, any further request retransmissions are discarded.
	                // https://tools.ietf.org/html/rfc3261#section-17.2.2
	                break;
	            case TransactionState.Proceeding:
	                // If a retransmission of the request is received while in the "Proceeding" state,
	                // the most recently sent provisional response MUST be passed to the transport layer for retransmission.
	                // https://tools.ietf.org/html/rfc3261#section-17.2.2
	                if (!this.lastResponse) {
	                    throw new Error("Last response undefined.");
	                }
	                this.send(this.lastResponse).catch(function (error) {
	                    _this.logTransportError(error, "Failed to send retransmission of provisional response.");
	                });
	                break;
	            case TransactionState.Completed:
	                // While in the "Completed" state, the server transaction MUST pass the final response to the transport
	                // layer for retransmission whenever a retransmission of the request is received. Any other final responses
	                // passed by the TU to the server transaction MUST be discarded while in the "Completed" state.
	                // https://tools.ietf.org/html/rfc3261#section-17.2.2
	                if (!this.lastResponse) {
	                    throw new Error("Last response undefined.");
	                }
	                this.send(this.lastResponse).catch(function (error) {
	                    _this.logTransportError(error, "Failed to send retransmission of final response.");
	                });
	                break;
	            case TransactionState.Terminated:
	                break;
	            default:
	                throw new Error("Invalid state " + this.state);
	        }
	    };
	    /**
	     * Receive responses from TU for this transaction.
	     * @param statusCode Status code of repsonse. 101-199 not allowed per RFC 4320.
	     * @param response Response to send.
	     */
	    NonInviteServerTransaction.prototype.receiveResponse = function (statusCode, response) {
	        var _this = this;
	        if (statusCode < 100 || statusCode > 699) {
	            throw new Error("Invalid status code " + statusCode);
	        }
	        // An SIP element MUST NOT send any provisional response with a
	        // Status-Code other than 100 to a non-INVITE request.
	        // An SIP element MUST NOT respond to a non-INVITE request with a
	        // Status-Code of 100 over any unreliable transport, such as UDP,
	        // before the amount of time it takes a client transaction's Timer E to be reset to T2.
	        // An SIP element MAY respond to a non-INVITE request with a
	        // Status-Code of 100 over a reliable transport at any time.
	        // https://tools.ietf.org/html/rfc4320#section-4.1
	        if (statusCode > 100 && statusCode <= 199) {
	            throw new Error("Provisional response other than 100 not allowed.");
	        }
	        switch (this.state) {
	            case TransactionState.Trying:
	                // While in the "Trying" state, if the TU passes a provisional response
	                // to the server transaction, the server transaction MUST enter the "Proceeding" state.
	                // The response MUST be passed to the transport layer for transmission.
	                // https://tools.ietf.org/html/rfc3261#section-17.2.2
	                this.lastResponse = response;
	                if (statusCode >= 100 && statusCode < 200) {
	                    this.stateTransition(TransactionState.Proceeding);
	                    this.send(response).catch(function (error) {
	                        _this.logTransportError(error, "Failed to send provisional response.");
	                    });
	                    return;
	                }
	                if (statusCode >= 200 && statusCode <= 699) {
	                    this.stateTransition(TransactionState.Completed);
	                    this.send(response).catch(function (error) {
	                        _this.logTransportError(error, "Failed to send final response.");
	                    });
	                    return;
	                }
	                break;
	            case TransactionState.Proceeding:
	                // Any further provisional responses that are received from the TU while
	                // in the "Proceeding" state MUST be passed to the transport layer for transmission.
	                // If the TU passes a final response (status codes 200-699) to the server while in
	                // the "Proceeding" state, the transaction MUST enter the "Completed" state, and
	                // the response MUST be passed to the transport layer for transmission.
	                // https://tools.ietf.org/html/rfc3261#section-17.2.2
	                this.lastResponse = response;
	                if (statusCode >= 200 && statusCode <= 699) {
	                    this.stateTransition(TransactionState.Completed);
	                    this.send(response).catch(function (error) {
	                        _this.logTransportError(error, "Failed to send final response.");
	                    });
	                    return;
	                }
	                break;
	            case TransactionState.Completed:
	                // Any other final responses passed by the TU to the server
	                // transaction MUST be discarded while in the "Completed" state.
	                // https://tools.ietf.org/html/rfc3261#section-17.2.2
	                return;
	            case TransactionState.Terminated:
	                break;
	            default:
	                throw new Error("Invalid state " + this.state);
	        }
	        var message = "Non-INVITE server transaction received unexpected " + statusCode + " response from TU while in state " + this.state + ".";
	        this.logger.error(message);
	        throw new Error(message);
	    };
	    /**
	     * First, the procedures in [4] are followed, which attempt to deliver the response to a backup.
	     * If those should all fail, based on the definition of failure in [4], the server transaction SHOULD
	     * inform the TU that a failure has occurred, and SHOULD transition to the terminated state.
	     * https://tools.ietf.org/html/rfc3261#section-17.2.4
	     */
	    NonInviteServerTransaction.prototype.onTransportError = function (error) {
	        if (this.user.onTransportError) {
	            this.user.onTransportError(error);
	        }
	        this.stateTransition(TransactionState.Terminated, true);
	    };
	    NonInviteServerTransaction.prototype.stateTransition = function (newState, dueToTransportError) {
	        var _this = this;
	        if (dueToTransportError === void 0) { dueToTransportError = false; }
	        // Assert valid state transitions.
	        var invalidStateTransition = function () {
	            throw new Error("Invalid state transition from " + _this.state + " to " + newState);
	        };
	        switch (newState) {
	            case TransactionState.Trying:
	                invalidStateTransition();
	                break;
	            case TransactionState.Proceeding:
	                if (this.state !== TransactionState.Trying) {
	                    invalidStateTransition();
	                }
	                break;
	            case TransactionState.Completed:
	                if (this.state !== TransactionState.Trying && this.state !== TransactionState.Proceeding) {
	                    invalidStateTransition();
	                }
	                break;
	            case TransactionState.Terminated:
	                if (this.state !== TransactionState.Proceeding && this.state !== TransactionState.Completed) {
	                    if (!dueToTransportError) {
	                        invalidStateTransition();
	                    }
	                }
	                break;
	            default:
	                invalidStateTransition();
	        }
	        // When the server transaction enters the "Completed" state, it MUST set Timer J to fire
	        // in 64*T1 seconds for unreliable transports, and zero seconds for reliable transports.
	        // https://tools.ietf.org/html/rfc3261#section-17.2.2
	        if (newState === TransactionState.Completed) {
	            this.J = setTimeout(function () { return _this.timer_J(); }, Timers.Timers.TIMER_J);
	        }
	        // The server transaction MUST be destroyed the instant it enters the "Terminated" state.
	        // https://tools.ietf.org/html/rfc3261#section-17.2.2
	        if (newState === TransactionState.Terminated) {
	            this.dispose();
	        }
	        this.setState(newState);
	    };
	    /**
	     * The server transaction remains in this state until Timer J fires,
	     * at which point it MUST transition to the "Terminated" state.
	     * https://tools.ietf.org/html/rfc3261#section-17.2.2
	     */
	    NonInviteServerTransaction.prototype.timer_J = function () {
	        this.logger.debug("Timer J expired for NON-INVITE server transaction " + this.id + ".");
	        if (this.state === TransactionState.Completed) {
	            this.stateTransition(TransactionState.Terminated);
	        }
	    };
	    return NonInviteServerTransaction;
	}(ServerTransaction));
	exports.NonInviteServerTransaction = NonInviteServerTransaction;
	});

	unwrapExports(Transactions);
	var Transactions_1 = Transactions.TransactionState;
	var Transactions_2 = Transactions.Transaction;
	var Transactions_3 = Transactions.ClientTransaction;
	var Transactions_4 = Transactions.InviteClientTransaction;
	var Transactions_5 = Transactions.NonInviteClientTransaction;
	var Transactions_6 = Transactions.ServerTransaction;
	var Transactions_7 = Transactions.InviteServerTransaction;
	var Transactions_8 = Transactions.NonInviteServerTransaction;

	var RequestSender_1 = createCommonjsModule(function (module, exports) {
	Object.defineProperty(exports, "__esModule", { value: true });



	/**
	 * @class Class creating a request sender.
	 * @param {Object} applicant
	 * @param {SIP.UA} ua
	 */
	var RequestSender = /** @class */ (function () {
	    function RequestSender(applicant, ua) {
	        this.type = Enums.TypeStrings.RequestSender;
	        this.logger = ua.getLogger("sip.requestsender");
	        this.loggerFactory = ua.getLoggerFactory();
	        this.ua = ua;
	        this.applicant = applicant;
	        this.method = applicant.request.method;
	        this.request = applicant.request;
	        this.credentials = undefined;
	        this.challenged = false;
	        this.staled = false;
	        // If ua is in closing process or even closed just allow sending Bye and ACK
	        if (ua.status === Enums.UAStatus.STATUS_USER_CLOSED && (this.method !== Constants.C.BYE && this.method !== Constants.C.ACK)) {
	            this.onTransportError();
	        }
	    }
	    /**
	     * Create the client transaction and send the message.
	     */
	    RequestSender.prototype.send = function () {
	        var _this = this;
	        var transport = this.ua.transport;
	        if (!transport) {
	            throw new Error("Transport undefined.");
	        }
	        var user = {
	            loggerFactory: this.ua.getLoggerFactory(),
	            onRequestTimeout: function () { return _this.onRequestTimeout(); },
	            onStateChange: function (newState) {
	                if (newState === Transactions.TransactionState.Terminated) {
	                    _this.ua.destroyTransaction(clientTransaction);
	                }
	            },
	            onTransportError: function (error) { return _this.onTransportError(); },
	            receiveResponse: function (response) { return _this.receiveResponse(response); }
	        };
	        var clientTransaction;
	        switch (this.method) {
	            case "INVITE":
	                clientTransaction = new Transactions.InviteClientTransaction(this.request, transport, user);
	                break;
	            case "ACK":
	                throw new Error("Cannot make client transaction for ACK method.");
	            default:
	                clientTransaction = new Transactions.NonInviteClientTransaction(this.request, transport, user);
	        }
	        this.clientTransaction = clientTransaction;
	        this.ua.newTransaction(clientTransaction);
	        return clientTransaction;
	    };
	    /**
	     * Callback fired when receiving a request timeout error from the client transaction.
	     * To be re-defined by the applicant.
	     * @event
	     */
	    RequestSender.prototype.onRequestTimeout = function () {
	        this.applicant.onRequestTimeout();
	    };
	    /**
	     * Callback fired when receiving a transport error from the client transaction.
	     * To be re-defined by the applicant.
	     * @event
	     */
	    RequestSender.prototype.onTransportError = function () {
	        this.applicant.onTransportError();
	    };
	    /**
	     * Called from client transaction when receiving a correct response to the request.
	     * Authenticate request if needed or pass the response back to the applicant.
	     * @param {SIP.IncomingResponse} response
	     */
	    RequestSender.prototype.receiveResponse = function (response) {
	        var statusCode = response && response.statusCode ? response.statusCode : 0;
	        /*
	        * Authentication
	        * Authenticate once. _challenged_ flag used to avoid infinite authentications.
	        */
	        if (statusCode === 401 || statusCode === 407) {
	            var challenge = void 0;
	            var authorizationHeaderName = void 0;
	            // Get and parse the appropriate WWW-Authenticate or Proxy-Authenticate header.
	            if (statusCode === 401) {
	                challenge = response.parseHeader("www-authenticate");
	                authorizationHeaderName = "authorization";
	            }
	            else {
	                challenge = response.parseHeader("proxy-authenticate");
	                authorizationHeaderName = "proxy-authorization";
	            }
	            // Verify it seems a valid challenge.
	            if (!challenge) {
	                this.logger.warn(statusCode + " with wrong or missing challenge, cannot authenticate");
	                this.applicant.receiveResponse(response);
	                return;
	            }
	            if (!this.challenged || (!this.staled && challenge.stale === true)) {
	                if (!this.credentials && this.ua.configuration.authenticationFactory) {
	                    this.credentials = this.ua.configuration.authenticationFactory(this.ua);
	                }
	                // Verify that the challenge is really valid.
	                if (!this.credentials.authenticate(this.request, challenge)) {
	                    this.applicant.receiveResponse(response);
	                    return;
	                }
	                this.challenged = true;
	                if (challenge.stale) {
	                    this.staled = true;
	                }
	                var cseq = void 0;
	                if (response.method === Constants.C.REGISTER) {
	                    cseq = this.applicant.cseq += 1;
	                }
	                else if (this.request.dialog) {
	                    cseq = this.request.dialog.localSeqnum += 1;
	                }
	                else {
	                    cseq = (this.request.cseq || 0) + 1;
	                    this.request.cseq = cseq;
	                }
	                this.request.setHeader("cseq", cseq + " " + this.method);
	                this.request.setHeader(authorizationHeaderName, this.credentials.toString());
	                this.send();
	            }
	            else {
	                this.applicant.receiveResponse(response);
	            }
	        }
	        else {
	            this.applicant.receiveResponse(response);
	        }
	    };
	    return RequestSender;
	}());
	exports.RequestSender = RequestSender;
	});

	unwrapExports(RequestSender_1);
	var RequestSender_2 = RequestSender_1.RequestSender;

	var URI_1 = createCommonjsModule(function (module, exports) {
	var __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	Object.defineProperty(exports, "__esModule", { value: true });


	var Parameters = /** @class */ (function () {
	    function Parameters(parameters) {
	        this.parameters = {};
	        this.type = Enums.TypeStrings.Parameters;
	        for (var param in parameters) {
	            if (parameters.hasOwnProperty(param)) {
	                this.setParam(param, parameters[param]);
	            }
	        }
	    }
	    Parameters.prototype.setParam = function (key, value) {
	        if (key) {
	            this.parameters[key.toLowerCase()] = (typeof value === "undefined" || value === null) ? null : value.toString();
	        }
	    };
	    Parameters.prototype.getParam = function (key) {
	        if (key) {
	            return this.parameters[key.toLowerCase()];
	        }
	    };
	    Parameters.prototype.hasParam = function (key) {
	        if (key) {
	            return !!this.parameters.hasOwnProperty(key.toLowerCase());
	        }
	        return false;
	    };
	    Parameters.prototype.deleteParam = function (parameter) {
	        parameter = parameter.toLowerCase();
	        if (this.parameters.hasOwnProperty(parameter)) {
	            var value = this.parameters[parameter];
	            delete this.parameters[parameter];
	            return value;
	        }
	    };
	    Parameters.prototype.clearParams = function () {
	        this.parameters = {};
	    };
	    return Parameters;
	}());
	exports.Parameters = Parameters;
	/**
	 * @class Class creating a SIP URI.
	 *
	 * @param {String} [scheme]
	 * @param {String} [user]
	 * @param {String} host
	 * @param {String} [port]
	 * @param {Object} [parameters]
	 * @param {Object} [headers]
	 *
	 */
	// tslint:disable-next-line:max-classes-per-file
	var URI = /** @class */ (function (_super) {
	    __extends(URI, _super);
	    function URI(scheme, user, host, port, parameters, headers) {
	        var _this = _super.call(this, parameters) || this;
	        _this.headers = {};
	        _this.type = Enums.TypeStrings.URI;
	        // Checks
	        if (!host) {
	            throw new TypeError('missing or invalid "host" parameter');
	        }
	        // Initialize parameters
	        scheme = scheme || Constants.C.SIP;
	        for (var header in headers) {
	            if (headers.hasOwnProperty(header)) {
	                _this.setHeader(header, headers[header]);
	            }
	        }
	        // Raw URI
	        _this.raw = {
	            scheme: scheme,
	            user: user,
	            host: host,
	            port: port
	        };
	        // Normalized URI
	        _this.normal = {
	            scheme: scheme.toLowerCase(),
	            user: user,
	            host: host.toLowerCase(),
	            port: port
	        };
	        return _this;
	    }
	    Object.defineProperty(URI.prototype, "_normal", {
	        get: function () { return this.normal; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(URI.prototype, "_raw", {
	        get: function () { return this.raw; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(URI.prototype, "scheme", {
	        get: function () { return this.normal.scheme; },
	        set: function (value) {
	            this.raw.scheme = value;
	            this.normal.scheme = value.toLowerCase();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(URI.prototype, "user", {
	        get: function () { return this.normal.user; },
	        set: function (value) {
	            this.normal.user = this.raw.user = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(URI.prototype, "host", {
	        get: function () { return this.normal.host; },
	        set: function (value) {
	            this.raw.host = value;
	            this.normal.host = value.toLowerCase();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(URI.prototype, "aor", {
	        get: function () { return this.normal.user + "@" + this.normal.host; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(URI.prototype, "port", {
	        get: function () { return this.normal.port; },
	        set: function (value) {
	            this.normal.port = this.raw.port = value === 0 ? value : value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    URI.prototype.setHeader = function (name, value) {
	        this.headers[this.headerize(name)] = (value instanceof Array) ? value : [value];
	    };
	    URI.prototype.getHeader = function (name) {
	        if (name) {
	            return this.headers[this.headerize(name)];
	        }
	    };
	    URI.prototype.hasHeader = function (name) {
	        return !!name && !!this.headers.hasOwnProperty(this.headerize(name));
	    };
	    URI.prototype.deleteHeader = function (header) {
	        header = this.headerize(header);
	        if (this.headers.hasOwnProperty(header)) {
	            var value = this.headers[header];
	            delete this.headers[header];
	            return value;
	        }
	    };
	    URI.prototype.clearHeaders = function () {
	        this.headers = {};
	    };
	    URI.prototype.clone = function () {
	        return new URI(this._raw.scheme, this._raw.user || "", this._raw.host, this._raw.port, JSON.parse(JSON.stringify(this.parameters)), JSON.parse(JSON.stringify(this.headers)));
	    };
	    URI.prototype.toRaw = function () {
	        return this._toString(this._raw);
	    };
	    URI.prototype.toString = function () {
	        return this._toString(this._normal);
	    };
	    URI.prototype._toString = function (uri) {
	        var uriString = uri.scheme + ":";
	        // add slashes if it's not a sip(s) URI
	        if (!uri.scheme.toLowerCase().match("^sips?$")) {
	            uriString += "//";
	        }
	        if (uri.user) {
	            uriString += this.escapeUser(uri.user) + "@";
	        }
	        uriString += uri.host;
	        if (uri.port || uri.port === 0) {
	            uriString += ":" + uri.port;
	        }
	        for (var parameter in this.parameters) {
	            if (this.parameters.hasOwnProperty(parameter)) {
	                uriString += ";" + parameter;
	                if (this.parameters[parameter] !== null) {
	                    uriString += "=" + this.parameters[parameter];
	                }
	            }
	        }
	        var headers = [];
	        for (var header in this.headers) {
	            if (this.headers.hasOwnProperty(header)) {
	                for (var idx in this.headers[header]) {
	                    if (this.headers[header].hasOwnProperty(idx)) {
	                        headers.push(header + "=" + this.headers[header][idx]);
	                    }
	                }
	            }
	        }
	        if (headers.length > 0) {
	            uriString += "?" + headers.join("&");
	        }
	        return uriString;
	    };
	    // The following two functions were copied from Utils to break a circular dependency
	    /*
	     * Hex-escape a SIP URI user.
	     * @private
	     * @param {String} user
	     */
	    URI.prototype.escapeUser = function (user) {
	        // Don't hex-escape ':' (%3A), '+' (%2B), '?' (%3F"), '/' (%2F).
	        return encodeURIComponent(decodeURIComponent(user))
	            .replace(/%3A/ig, ":")
	            .replace(/%2B/ig, "+")
	            .replace(/%3F/ig, "?")
	            .replace(/%2F/ig, "/");
	    };
	    URI.prototype.headerize = function (str) {
	        var exceptions = {
	            "Call-Id": "Call-ID",
	            "Cseq": "CSeq",
	            "Min-Se": "Min-SE",
	            "Rack": "RAck",
	            "Rseq": "RSeq",
	            "Www-Authenticate": "WWW-Authenticate",
	        };
	        var name = str.toLowerCase().replace(/_/g, "-").split("-");
	        var parts = name.length;
	        var hname = "";
	        for (var part = 0; part < parts; part++) {
	            if (part !== 0) {
	                hname += "-";
	            }
	            hname += name[part].charAt(0).toUpperCase() + name[part].substring(1);
	        }
	        if (exceptions[hname]) {
	            hname = exceptions[hname];
	        }
	        return hname;
	    };
	    return URI;
	}(Parameters));
	exports.URI = URI;
	});

	unwrapExports(URI_1);
	var URI_2 = URI_1.Parameters;
	var URI_3 = URI_1.URI;

	var NameAddrHeader_1 = createCommonjsModule(function (module, exports) {
	var __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	Object.defineProperty(exports, "__esModule", { value: true });


	/**
	 * @class Class creating a Name Address SIP header.
	 *
	 * @param {SIP.URI} uri
	 * @param {String} [displayName]
	 * @param {Object} [parameters]
	 *
	 */
	var NameAddrHeader = /** @class */ (function (_super) {
	    __extends(NameAddrHeader, _super);
	    function NameAddrHeader(uri, displayName, parameters) {
	        var _this = _super.call(this, parameters) || this;
	        _this.type = Enums.TypeStrings.NameAddrHeader;
	        // Checks
	        if (!uri || !(uri.type === Enums.TypeStrings.URI)) {
	            throw new TypeError('missing or invalid "uri" parameter');
	        }
	        _this.uri = uri;
	        _this._displayName = displayName;
	        return _this;
	    }
	    Object.defineProperty(NameAddrHeader.prototype, "friendlyName", {
	        get: function () {
	            return this.displayName || this.uri.aor;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(NameAddrHeader.prototype, "displayName", {
	        get: function () { return this._displayName; },
	        set: function (value) {
	            this._displayName = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    NameAddrHeader.prototype.clone = function () {
	        return new NameAddrHeader(this.uri.clone(), this._displayName, JSON.parse(JSON.stringify(this.parameters)));
	    };
	    NameAddrHeader.prototype.toString = function () {
	        var body = (this.displayName || this.displayName === "0") ? '"' + this.displayName + '" ' : "";
	        body += "<" + this.uri.toString() + ">";
	        for (var parameter in this.parameters) {
	            if (this.parameters.hasOwnProperty(parameter)) {
	                body += ";" + parameter;
	                if (this.parameters[parameter] !== null) {
	                    body += "=" + this.parameters[parameter];
	                }
	            }
	        }
	        return body;
	    };
	    return NameAddrHeader;
	}(URI_1.Parameters));
	exports.NameAddrHeader = NameAddrHeader;
	});

	unwrapExports(NameAddrHeader_1);
	var NameAddrHeader_2 = NameAddrHeader_1.NameAddrHeader;

	var Grammar = createCommonjsModule(function (module, exports) {
	// tslint:disable:interface-name
	// tslint:disable: trailing-comma
	// tslint:disable: object-literal-sort-keys
	// tslint:disable: max-line-length
	// tslint:disable: only-arrow-functions
	// tslint:disable: one-variable-per-declaration
	// tslint:disable: no-consecutive-blank-lines
	// tslint:disable: align
	// tslint:disable: radix
	// tslint:disable: quotemark
	// tslint:disable: semicolon
	// tslint:disable: object-literal-shorthand
	// tslint:disable: variable-name
	// tslint:disable: no-var-keyword
	// tslint:disable: whitespace
	// tslint:disable: curly
	// tslint:disable: prefer-const
	// tslint:disable: object-literal-key-quotes
	// tslint:disable: no-string-literal
	// tslint:disable: one-line
	// tslint:disable: no-unused-expression
	// tslint:disable: space-before-function-paren
	// tslint:disable: arrow-return-shorthand
	var __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	Object.defineProperty(exports, "__esModule", { value: true });
	// Generated by PEG.js v. 0.10.0 (ts-pegjs plugin v. 0.2.2 )
	//
	// https://pegjs.org/   https://github.com/metadevpro/ts-pegjs


	var SyntaxError = /** @class */ (function (_super) {
	    __extends(SyntaxError, _super);
	    function SyntaxError(message, expected, found, location) {
	        var _this = _super.call(this) || this;
	        _this.message = message;
	        _this.expected = expected;
	        _this.found = found;
	        _this.location = location;
	        _this.name = "SyntaxError";
	        if (typeof Error.captureStackTrace === "function") {
	            Error.captureStackTrace(_this, SyntaxError);
	        }
	        return _this;
	    }
	    SyntaxError.buildMessage = function (expected, found) {
	        function hex(ch) {
	            return ch.charCodeAt(0).toString(16).toUpperCase();
	        }
	        function literalEscape(s) {
	            return s
	                .replace(/\\/g, "\\\\")
	                .replace(/"/g, "\\\"")
	                .replace(/\0/g, "\\0")
	                .replace(/\t/g, "\\t")
	                .replace(/\n/g, "\\n")
	                .replace(/\r/g, "\\r")
	                .replace(/[\x00-\x0F]/g, function (ch) { return "\\x0" + hex(ch); })
	                .replace(/[\x10-\x1F\x7F-\x9F]/g, function (ch) { return "\\x" + hex(ch); });
	        }
	        function classEscape(s) {
	            return s
	                .replace(/\\/g, "\\\\")
	                .replace(/\]/g, "\\]")
	                .replace(/\^/g, "\\^")
	                .replace(/-/g, "\\-")
	                .replace(/\0/g, "\\0")
	                .replace(/\t/g, "\\t")
	                .replace(/\n/g, "\\n")
	                .replace(/\r/g, "\\r")
	                .replace(/[\x00-\x0F]/g, function (ch) { return "\\x0" + hex(ch); })
	                .replace(/[\x10-\x1F\x7F-\x9F]/g, function (ch) { return "\\x" + hex(ch); });
	        }
	        function describeExpectation(expectation) {
	            switch (expectation.type) {
	                case "literal":
	                    return "\"" + literalEscape(expectation.text) + "\"";
	                case "class":
	                    var escapedParts = expectation.parts.map(function (part) {
	                        return Array.isArray(part)
	                            ? classEscape(part[0]) + "-" + classEscape(part[1])
	                            : classEscape(part);
	                    });
	                    return "[" + (expectation.inverted ? "^" : "") + escapedParts + "]";
	                case "any":
	                    return "any character";
	                case "end":
	                    return "end of input";
	                case "other":
	                    return expectation.description;
	            }
	        }
	        function describeExpected(expected1) {
	            var descriptions = expected1.map(describeExpectation);
	            var i;
	            var j;
	            descriptions.sort();
	            if (descriptions.length > 0) {
	                for (i = 1, j = 1; i < descriptions.length; i++) {
	                    if (descriptions[i - 1] !== descriptions[i]) {
	                        descriptions[j] = descriptions[i];
	                        j++;
	                    }
	                }
	                descriptions.length = j;
	            }
	            switch (descriptions.length) {
	                case 1:
	                    return descriptions[0];
	                case 2:
	                    return descriptions[0] + " or " + descriptions[1];
	                default:
	                    return descriptions.slice(0, -1).join(", ")
	                        + ", or "
	                        + descriptions[descriptions.length - 1];
	            }
	        }
	        function describeFound(found1) {
	            return found1 ? "\"" + literalEscape(found1) + "\"" : "end of input";
	        }
	        return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
	    };
	    return SyntaxError;
	}(Error));
	exports.SyntaxError = SyntaxError;
	function peg$parse(input, options) {
	    options = options !== undefined ? options : {};
	    var peg$FAILED = {};
	    var peg$startRuleFunctions = { Contact: peg$parseContact, Name_Addr_Header: peg$parseName_Addr_Header, Record_Route: peg$parseRecord_Route, Request_Response: peg$parseRequest_Response, SIP_URI: peg$parseSIP_URI, Subscription_State: peg$parseSubscription_State, Supported: peg$parseSupported, Require: peg$parseRequire, Via: peg$parseVia, absoluteURI: peg$parseabsoluteURI, Call_ID: peg$parseCall_ID, Content_Disposition: peg$parseContent_Disposition, Content_Length: peg$parseContent_Length, Content_Type: peg$parseContent_Type, CSeq: peg$parseCSeq, displayName: peg$parsedisplayName, Event: peg$parseEvent, From: peg$parseFrom, host: peg$parsehost, Max_Forwards: peg$parseMax_Forwards, Min_SE: peg$parseMin_SE, Proxy_Authenticate: peg$parseProxy_Authenticate, quoted_string: peg$parsequoted_string, Refer_To: peg$parseRefer_To, Replaces: peg$parseReplaces, Session_Expires: peg$parseSession_Expires, stun_URI: peg$parsestun_URI, To: peg$parseTo, turn_URI: peg$parseturn_URI, uuid: peg$parseuuid, WWW_Authenticate: peg$parseWWW_Authenticate, challenge: peg$parsechallenge, sipfrag: peg$parsesipfrag, Referred_By: peg$parseReferred_By };
	    var peg$startRuleFunction = peg$parseContact;
	    var peg$c0 = "\r\n";
	    var peg$c1 = peg$literalExpectation("\r\n", false);
	    var peg$c2 = /^[0-9]/;
	    var peg$c3 = peg$classExpectation([["0", "9"]], false, false);
	    var peg$c4 = /^[a-zA-Z]/;
	    var peg$c5 = peg$classExpectation([["a", "z"], ["A", "Z"]], false, false);
	    var peg$c6 = /^[0-9a-fA-F]/;
	    var peg$c7 = peg$classExpectation([["0", "9"], ["a", "f"], ["A", "F"]], false, false);
	    var peg$c8 = /^[\0-\xFF]/;
	    var peg$c9 = peg$classExpectation([["\0", "\xFF"]], false, false);
	    var peg$c10 = /^["]/;
	    var peg$c11 = peg$classExpectation(["\""], false, false);
	    var peg$c12 = " ";
	    var peg$c13 = peg$literalExpectation(" ", false);
	    var peg$c14 = "\t";
	    var peg$c15 = peg$literalExpectation("\t", false);
	    var peg$c16 = /^[a-zA-Z0-9]/;
	    var peg$c17 = peg$classExpectation([["a", "z"], ["A", "Z"], ["0", "9"]], false, false);
	    var peg$c18 = ";";
	    var peg$c19 = peg$literalExpectation(";", false);
	    var peg$c20 = "/";
	    var peg$c21 = peg$literalExpectation("/", false);
	    var peg$c22 = "?";
	    var peg$c23 = peg$literalExpectation("?", false);
	    var peg$c24 = ":";
	    var peg$c25 = peg$literalExpectation(":", false);
	    var peg$c26 = "@";
	    var peg$c27 = peg$literalExpectation("@", false);
	    var peg$c28 = "&";
	    var peg$c29 = peg$literalExpectation("&", false);
	    var peg$c30 = "=";
	    var peg$c31 = peg$literalExpectation("=", false);
	    var peg$c32 = "+";
	    var peg$c33 = peg$literalExpectation("+", false);
	    var peg$c34 = "$";
	    var peg$c35 = peg$literalExpectation("$", false);
	    var peg$c36 = ",";
	    var peg$c37 = peg$literalExpectation(",", false);
	    var peg$c38 = "-";
	    var peg$c39 = peg$literalExpectation("-", false);
	    var peg$c40 = "_";
	    var peg$c41 = peg$literalExpectation("_", false);
	    var peg$c42 = ".";
	    var peg$c43 = peg$literalExpectation(".", false);
	    var peg$c44 = "!";
	    var peg$c45 = peg$literalExpectation("!", false);
	    var peg$c46 = "~";
	    var peg$c47 = peg$literalExpectation("~", false);
	    var peg$c48 = "*";
	    var peg$c49 = peg$literalExpectation("*", false);
	    var peg$c50 = "'";
	    var peg$c51 = peg$literalExpectation("'", false);
	    var peg$c52 = "(";
	    var peg$c53 = peg$literalExpectation("(", false);
	    var peg$c54 = ")";
	    var peg$c55 = peg$literalExpectation(")", false);
	    var peg$c56 = "%";
	    var peg$c57 = peg$literalExpectation("%", false);
	    var peg$c58 = function () { return " "; };
	    var peg$c59 = function () { return ':'; };
	    var peg$c62 = /^[\x80-\uFFFF]/;
	    var peg$c63 = peg$classExpectation([["\x80", "\uFFFF"]], false, false);
	    var peg$c64 = /^[\x80-\xBF]/;
	    var peg$c65 = peg$classExpectation([["\x80", "\xBF"]], false, false);
	    var peg$c68 = "`";
	    var peg$c69 = peg$literalExpectation("`", false);
	    var peg$c70 = "<";
	    var peg$c71 = peg$literalExpectation("<", false);
	    var peg$c72 = ">";
	    var peg$c73 = peg$literalExpectation(">", false);
	    var peg$c74 = "\\";
	    var peg$c75 = peg$literalExpectation("\\", false);
	    var peg$c76 = "[";
	    var peg$c77 = peg$literalExpectation("[", false);
	    var peg$c78 = "]";
	    var peg$c79 = peg$literalExpectation("]", false);
	    var peg$c80 = "{";
	    var peg$c81 = peg$literalExpectation("{", false);
	    var peg$c82 = "}";
	    var peg$c83 = peg$literalExpectation("}", false);
	    var peg$c84 = function () { return "*"; };
	    var peg$c85 = function () { return "/"; };
	    var peg$c86 = function () { return "="; };
	    var peg$c89 = function () { return ">"; };
	    var peg$c90 = function () { return "<"; };
	    var peg$c91 = function () { return ","; };
	    var peg$c92 = function () { return ";"; };
	    var peg$c93 = function () { return ":"; };
	    var peg$c94 = function () { return "\""; };
	    var peg$c99 = /^[\]-~]/;
	    var peg$c100 = peg$classExpectation([["]", "~"]], false, false);
	    var peg$c101 = function (contents) {
	        return contents;
	    };
	    var peg$c102 = /^[#-[]/;
	    var peg$c103 = peg$classExpectation([["#", "["]], false, false);
	    var peg$c104 = /^[\0-\t]/;
	    var peg$c105 = peg$classExpectation([["\0", "\t"]], false, false);
	    var peg$c106 = /^[\x0B-\f]/;
	    var peg$c107 = peg$classExpectation([["\x0B", "\f"]], false, false);
	    var peg$c108 = /^[\x0E-\x7F]/;
	    var peg$c109 = peg$classExpectation([["\x0E", "\x7F"]], false, false);
	    var peg$c110 = function () {
	        options = options || { data: {} };
	        options.data.uri = new URI_1.URI(options.data.scheme, options.data.user, options.data.host, options.data.port);
	        delete options.data.scheme;
	        delete options.data.user;
	        delete options.data.host;
	        delete options.data.host_type;
	        delete options.data.port;
	    };
	    var peg$c111 = function () {
	        options = options || { data: {} };
	        options.data.uri = new URI_1.URI(options.data.scheme, options.data.user, options.data.host, options.data.port, options.data.uri_params, options.data.uri_headers);
	        delete options.data.scheme;
	        delete options.data.user;
	        delete options.data.host;
	        delete options.data.host_type;
	        delete options.data.port;
	        delete options.data.uri_params;
	        if (options.startRule === 'SIP_URI') {
	            options.data = options.data.uri;
	        }
	    };
	    var peg$c112 = "sips";
	    var peg$c113 = peg$literalExpectation("sips", true);
	    var peg$c114 = "sip";
	    var peg$c115 = peg$literalExpectation("sip", true);
	    var peg$c116 = function (uri_scheme) {
	        options = options || { data: {} };
	        options.data.scheme = uri_scheme;
	    };
	    var peg$c117 = function () {
	        options = options || { data: {} };
	        options.data.user = decodeURIComponent(text().slice(0, -1));
	    };
	    var peg$c118 = function () {
	        options = options || { data: {} };
	        options.data.password = text();
	    };
	    var peg$c119 = function () {
	        options = options || { data: {} };
	        options.data.host = text();
	        return options.data.host;
	    };
	    var peg$c120 = function () {
	        options = options || { data: {} };
	        options.data.host_type = 'domain';
	        return text();
	    };
	    var peg$c121 = /^[a-zA-Z0-9_\-]/;
	    var peg$c122 = peg$classExpectation([["a", "z"], ["A", "Z"], ["0", "9"], "_", "-"], false, false);
	    var peg$c123 = /^[a-zA-Z0-9\-]/;
	    var peg$c124 = peg$classExpectation([["a", "z"], ["A", "Z"], ["0", "9"], "-"], false, false);
	    var peg$c125 = function () {
	        options = options || { data: {} };
	        options.data.host_type = 'IPv6';
	        return text();
	    };
	    var peg$c126 = "::";
	    var peg$c127 = peg$literalExpectation("::", false);
	    var peg$c128 = function () {
	        options = options || { data: {} };
	        options.data.host_type = 'IPv6';
	        return text();
	    };
	    var peg$c129 = function () {
	        options = options || { data: {} };
	        options.data.host_type = 'IPv4';
	        return text();
	    };
	    var peg$c130 = "25";
	    var peg$c131 = peg$literalExpectation("25", false);
	    var peg$c132 = /^[0-5]/;
	    var peg$c133 = peg$classExpectation([["0", "5"]], false, false);
	    var peg$c134 = "2";
	    var peg$c135 = peg$literalExpectation("2", false);
	    var peg$c136 = /^[0-4]/;
	    var peg$c137 = peg$classExpectation([["0", "4"]], false, false);
	    var peg$c138 = "1";
	    var peg$c139 = peg$literalExpectation("1", false);
	    var peg$c140 = /^[1-9]/;
	    var peg$c141 = peg$classExpectation([["1", "9"]], false, false);
	    var peg$c142 = function (port) {
	        options = options || { data: {} };
	        port = parseInt(port.join(''));
	        options.data.port = port;
	        return port;
	    };
	    var peg$c143 = "transport=";
	    var peg$c144 = peg$literalExpectation("transport=", true);
	    var peg$c145 = "udp";
	    var peg$c146 = peg$literalExpectation("udp", true);
	    var peg$c147 = "tcp";
	    var peg$c148 = peg$literalExpectation("tcp", true);
	    var peg$c149 = "sctp";
	    var peg$c150 = peg$literalExpectation("sctp", true);
	    var peg$c151 = "tls";
	    var peg$c152 = peg$literalExpectation("tls", true);
	    var peg$c153 = function (transport) {
	        options = options || { data: {} };
	        if (!options.data.uri_params)
	            options.data.uri_params = {};
	        options.data.uri_params['transport'] = transport.toLowerCase();
	    };
	    var peg$c154 = "user=";
	    var peg$c155 = peg$literalExpectation("user=", true);
	    var peg$c156 = "phone";
	    var peg$c157 = peg$literalExpectation("phone", true);
	    var peg$c158 = "ip";
	    var peg$c159 = peg$literalExpectation("ip", true);
	    var peg$c160 = function (user) {
	        options = options || { data: {} };
	        if (!options.data.uri_params)
	            options.data.uri_params = {};
	        options.data.uri_params['user'] = user.toLowerCase();
	    };
	    var peg$c161 = "method=";
	    var peg$c162 = peg$literalExpectation("method=", true);
	    var peg$c163 = function (method) {
	        options = options || { data: {} };
	        if (!options.data.uri_params)
	            options.data.uri_params = {};
	        options.data.uri_params['method'] = method;
	    };
	    var peg$c164 = "ttl=";
	    var peg$c165 = peg$literalExpectation("ttl=", true);
	    var peg$c166 = function (ttl) {
	        options = options || { data: {} };
	        if (!options.data.params)
	            options.data.params = {};
	        options.data.params['ttl'] = ttl;
	    };
	    var peg$c167 = "maddr=";
	    var peg$c168 = peg$literalExpectation("maddr=", true);
	    var peg$c169 = function (maddr) {
	        options = options || { data: {} };
	        if (!options.data.uri_params)
	            options.data.uri_params = {};
	        options.data.uri_params['maddr'] = maddr;
	    };
	    var peg$c170 = "lr";
	    var peg$c171 = peg$literalExpectation("lr", true);
	    var peg$c172 = function () {
	        options = options || { data: {} };
	        if (!options.data.uri_params)
	            options.data.uri_params = {};
	        options.data.uri_params['lr'] = undefined;
	    };
	    var peg$c173 = function (param, value) {
	        options = options || { data: {} };
	        if (!options.data.uri_params)
	            options.data.uri_params = {};
	        if (value === null) {
	            value = undefined;
	        }
	        else {
	            value = value[1];
	        }
	        options.data.uri_params[param.toLowerCase()] = value;
	    };
	    var peg$c174 = function (hname, hvalue) {
	        hname = hname.join('').toLowerCase();
	        hvalue = hvalue.join('');
	        options = options || { data: {} };
	        if (!options.data.uri_headers)
	            options.data.uri_headers = {};
	        if (!options.data.uri_headers[hname]) {
	            options.data.uri_headers[hname] = [hvalue];
	        }
	        else {
	            options.data.uri_headers[hname].push(hvalue);
	        }
	    };
	    var peg$c175 = function () {
	        options = options || { data: {} };
	        // lots of tests fail if this isn't guarded...
	        if (options.startRule === 'Refer_To') {
	            options.data.uri = new URI_1.URI(options.data.scheme, options.data.user, options.data.host, options.data.port, options.data.uri_params, options.data.uri_headers);
	            delete options.data.scheme;
	            delete options.data.user;
	            delete options.data.host;
	            delete options.data.host_type;
	            delete options.data.port;
	            delete options.data.uri_params;
	        }
	    };
	    var peg$c176 = "//";
	    var peg$c177 = peg$literalExpectation("//", false);
	    var peg$c178 = function () {
	        options = options || { data: {} };
	        options.data.scheme = text();
	    };
	    var peg$c179 = peg$literalExpectation("SIP", true);
	    var peg$c180 = function () {
	        options = options || { data: {} };
	        options.data.sip_version = text();
	    };
	    var peg$c181 = "INVITE";
	    var peg$c182 = peg$literalExpectation("INVITE", false);
	    var peg$c183 = "ACK";
	    var peg$c184 = peg$literalExpectation("ACK", false);
	    var peg$c187 = "OPTIONS";
	    var peg$c188 = peg$literalExpectation("OPTIONS", false);
	    var peg$c189 = "BYE";
	    var peg$c190 = peg$literalExpectation("BYE", false);
	    var peg$c191 = "CANCEL";
	    var peg$c192 = peg$literalExpectation("CANCEL", false);
	    var peg$c193 = "REGISTER";
	    var peg$c194 = peg$literalExpectation("REGISTER", false);
	    var peg$c195 = "SUBSCRIBE";
	    var peg$c196 = peg$literalExpectation("SUBSCRIBE", false);
	    var peg$c197 = "NOTIFY";
	    var peg$c198 = peg$literalExpectation("NOTIFY", false);
	    var peg$c199 = "REFER";
	    var peg$c200 = peg$literalExpectation("REFER", false);
	    var peg$c201 = "PUBLISH";
	    var peg$c202 = peg$literalExpectation("PUBLISH", false);
	    var peg$c203 = function () {
	        options = options || { data: {} };
	        options.data.method = text();
	        return options.data.method;
	    };
	    var peg$c204 = function (status_code) {
	        options = options || { data: {} };
	        options.data.status_code = parseInt(status_code.join(''));
	    };
	    var peg$c205 = function () {
	        options = options || { data: {} };
	        options.data.reason_phrase = text();
	    };
	    var peg$c206 = function () {
	        options = options || { data: {} };
	        options.data = text();
	    };
	    var peg$c207 = function () {
	        var idx, length;
	        options = options || { data: {} };
	        length = options.data.multi_header.length;
	        for (idx = 0; idx < length; idx++) {
	            if (options.data.multi_header[idx].parsed === null) {
	                options.data = null;
	                break;
	            }
	        }
	        if (options.data !== null) {
	            options.data = options.data.multi_header;
	        }
	        else {
	            options.data = -1;
	        }
	    };
	    var peg$c208 = function () {
	        var header;
	        options = options || { data: {} };
	        if (!options.data.multi_header)
	            options.data.multi_header = [];
	        try {
	            header = new NameAddrHeader_1.NameAddrHeader(options.data.uri, options.data.displayName, options.data.params);
	            delete options.data.uri;
	            delete options.data.displayName;
	            delete options.data.params;
	        }
	        catch (e) {
	            header = null;
	        }
	        options.data.multi_header.push({ 'position': peg$currPos,
	            'offset': location().start.offset,
	            'parsed': header
	        });
	    };
	    var peg$c209 = function (displayName) {
	        displayName = text().trim();
	        if (displayName[0] === '\"') {
	            displayName = displayName.substring(1, displayName.length - 1);
	        }
	        options = options || { data: {} };
	        options.data.displayName = displayName;
	    };
	    var peg$c210 = "q";
	    var peg$c211 = peg$literalExpectation("q", true);
	    var peg$c212 = function (q) {
	        options = options || { data: {} };
	        if (!options.data.params)
	            options.data.params = {};
	        options.data.params['q'] = q;
	    };
	    var peg$c213 = "expires";
	    var peg$c214 = peg$literalExpectation("expires", true);
	    var peg$c215 = function (expires) {
	        options = options || { data: {} };
	        if (!options.data.params)
	            options.data.params = {};
	        options.data.params['expires'] = expires;
	    };
	    var peg$c216 = function (delta_seconds) {
	        return parseInt(delta_seconds.join(''));
	    };
	    var peg$c217 = "0";
	    var peg$c218 = peg$literalExpectation("0", false);
	    var peg$c219 = function () {
	        return parseFloat(text());
	    };
	    var peg$c220 = function (param, value) {
	        options = options || { data: {} };
	        if (!options.data.params)
	            options.data.params = {};
	        if (value === null) {
	            value = undefined;
	        }
	        else {
	            value = value[1];
	        }
	        options.data.params[param.toLowerCase()] = value;
	    };
	    var peg$c221 = "render";
	    var peg$c222 = peg$literalExpectation("render", true);
	    var peg$c223 = "session";
	    var peg$c224 = peg$literalExpectation("session", true);
	    var peg$c225 = "icon";
	    var peg$c226 = peg$literalExpectation("icon", true);
	    var peg$c227 = "alert";
	    var peg$c228 = peg$literalExpectation("alert", true);
	    var peg$c229 = function () {
	        options = options || { data: {} };
	        if (options.startRule === 'Content_Disposition') {
	            options.data.type = text().toLowerCase();
	        }
	    };
	    var peg$c230 = "handling";
	    var peg$c231 = peg$literalExpectation("handling", true);
	    var peg$c232 = "optional";
	    var peg$c233 = peg$literalExpectation("optional", true);
	    var peg$c234 = "required";
	    var peg$c235 = peg$literalExpectation("required", true);
	    var peg$c236 = function (length) {
	        options = options || { data: {} };
	        options.data = parseInt(length.join(''));
	    };
	    var peg$c237 = function () {
	        options = options || { data: {} };
	        options.data = text();
	    };
	    var peg$c238 = "text";
	    var peg$c239 = peg$literalExpectation("text", true);
	    var peg$c240 = "image";
	    var peg$c241 = peg$literalExpectation("image", true);
	    var peg$c242 = "audio";
	    var peg$c243 = peg$literalExpectation("audio", true);
	    var peg$c244 = "video";
	    var peg$c245 = peg$literalExpectation("video", true);
	    var peg$c246 = "application";
	    var peg$c247 = peg$literalExpectation("application", true);
	    var peg$c248 = "message";
	    var peg$c249 = peg$literalExpectation("message", true);
	    var peg$c250 = "multipart";
	    var peg$c251 = peg$literalExpectation("multipart", true);
	    var peg$c252 = "x-";
	    var peg$c253 = peg$literalExpectation("x-", true);
	    var peg$c254 = function (cseq_value) {
	        options = options || { data: {} };
	        options.data.value = parseInt(cseq_value.join(''));
	    };
	    var peg$c256 = function (event_type) {
	        options = options || { data: {} };
	        options.data.event = event_type.toLowerCase();
	    };
	    var peg$c257 = function () {
	        options = options || { data: {} };
	        var tag = options.data.tag;
	        options.data = new NameAddrHeader_1.NameAddrHeader(options.data.uri, options.data.displayName, options.data.params);
	        if (tag) {
	            options.data.setParam('tag', tag);
	        }
	    };
	    var peg$c258 = "tag";
	    var peg$c259 = peg$literalExpectation("tag", true);
	    var peg$c260 = function (tag) { options = options || { data: {} }; options.data.tag = tag; };
	    var peg$c261 = function (forwards) {
	        options = options || { data: {} };
	        options.data = parseInt(forwards.join(''));
	    };
	    var peg$c263 = function () {
	        options = options || { data: {} };
	        options.data = new NameAddrHeader_1.NameAddrHeader(options.data.uri, options.data.displayName, options.data.params);
	    };
	    var peg$c264 = "digest";
	    var peg$c265 = peg$literalExpectation("Digest", true);
	    var peg$c266 = "realm";
	    var peg$c267 = peg$literalExpectation("realm", true);
	    var peg$c268 = function (realm) { options = options || { data: {} }; options.data.realm = realm; };
	    var peg$c269 = "domain";
	    var peg$c270 = peg$literalExpectation("domain", true);
	    var peg$c271 = "nonce";
	    var peg$c272 = peg$literalExpectation("nonce", true);
	    var peg$c273 = function (nonce) { options = options || { data: {} }; options.data.nonce = nonce; };
	    var peg$c274 = "opaque";
	    var peg$c275 = peg$literalExpectation("opaque", true);
	    var peg$c276 = function (opaque) { options = options || { data: {} }; options.data.opaque = opaque; };
	    var peg$c277 = "stale";
	    var peg$c278 = peg$literalExpectation("stale", true);
	    var peg$c279 = "true";
	    var peg$c280 = peg$literalExpectation("true", true);
	    var peg$c281 = function () { options = options || { data: {} }; options.data.stale = true; };
	    var peg$c282 = "false";
	    var peg$c283 = peg$literalExpectation("false", true);
	    var peg$c284 = function () { options = options || { data: {} }; options.data.stale = false; };
	    var peg$c285 = "algorithm";
	    var peg$c286 = peg$literalExpectation("algorithm", true);
	    var peg$c287 = "md5";
	    var peg$c288 = peg$literalExpectation("MD5", true);
	    var peg$c289 = "md5-sess";
	    var peg$c290 = peg$literalExpectation("MD5-sess", true);
	    var peg$c291 = function (algorithm) {
	        options = options || { data: {} };
	        options.data.algorithm = algorithm.toUpperCase();
	    };
	    var peg$c292 = "qop";
	    var peg$c293 = peg$literalExpectation("qop", true);
	    var peg$c294 = "auth-int";
	    var peg$c295 = peg$literalExpectation("auth-int", true);
	    var peg$c296 = "auth";
	    var peg$c297 = peg$literalExpectation("auth", true);
	    var peg$c298 = function (qop_value) {
	        options = options || { data: {} };
	        options.data.qop || (options.data.qop = []);
	        options.data.qop.push(qop_value.toLowerCase());
	    };
	    var peg$c300 = function () {
	        var idx, length;
	        options = options || { data: {} };
	        length = options.data.multi_header.length;
	        for (idx = 0; idx < length; idx++) {
	            if (options.data.multi_header[idx].parsed === null) {
	                options.data = null;
	                break;
	            }
	        }
	        if (options.data !== null) {
	            options.data = options.data.multi_header;
	        }
	        else {
	            options.data = -1;
	        }
	    };
	    var peg$c301 = function () {
	        var header;
	        options = options || { data: {} };
	        if (!options.data.multi_header)
	            options.data.multi_header = [];
	        try {
	            header = new NameAddrHeader_1.NameAddrHeader(options.data.uri, options.data.displayName, options.data.params);
	            delete options.data.uri;
	            delete options.data.displayName;
	            delete options.data.params;
	        }
	        catch (e) {
	            header = null;
	        }
	        options.data.multi_header.push({ 'position': peg$currPos,
	            'offset': location().start.offset,
	            'parsed': header
	        });
	    };
	    var peg$c302 = function () {
	        options = options || { data: {} };
	        options.data = new NameAddrHeader_1.NameAddrHeader(options.data.uri, options.data.displayName, options.data.params);
	    };
	    var peg$c303 = function () {
	        options = options || { data: {} };
	        if (!(options.data.replaces_from_tag && options.data.replaces_to_tag)) {
	            options.data = -1;
	        }
	    };
	    var peg$c304 = function () {
	        options = options || { data: {} };
	        options.data = {
	            call_id: options.data
	        };
	    };
	    var peg$c305 = "from-tag";
	    var peg$c306 = peg$literalExpectation("from-tag", true);
	    var peg$c307 = function (from_tag) {
	        options = options || { data: {} };
	        options.data.replaces_from_tag = from_tag;
	    };
	    var peg$c308 = "to-tag";
	    var peg$c309 = peg$literalExpectation("to-tag", true);
	    var peg$c310 = function (to_tag) {
	        options = options || { data: {} };
	        options.data.replaces_to_tag = to_tag;
	    };
	    var peg$c311 = "early-only";
	    var peg$c312 = peg$literalExpectation("early-only", true);
	    var peg$c313 = function () {
	        options = options || { data: {} };
	        options.data.early_only = true;
	    };
	    var peg$c314 = function (head, r) { return r; };
	    var peg$c315 = function (head, tail) { return list(head, tail); };
	    var peg$c316 = function (value) {
	        options = options || { data: {} };
	        if (options.startRule === 'Require') {
	            options.data = value || [];
	        }
	    };
	    var peg$c318 = "active";
	    var peg$c319 = peg$literalExpectation("active", true);
	    var peg$c320 = "pending";
	    var peg$c321 = peg$literalExpectation("pending", true);
	    var peg$c322 = "terminated";
	    var peg$c323 = peg$literalExpectation("terminated", true);
	    var peg$c324 = function () {
	        options = options || { data: {} };
	        options.data.state = text();
	    };
	    var peg$c325 = "reason";
	    var peg$c326 = peg$literalExpectation("reason", true);
	    var peg$c327 = function (reason) {
	        options = options || { data: {} };
	        if (typeof reason !== 'undefined')
	            options.data.reason = reason;
	    };
	    var peg$c328 = function (expires) {
	        options = options || { data: {} };
	        if (typeof expires !== 'undefined')
	            options.data.expires = expires;
	    };
	    var peg$c329 = "retry_after";
	    var peg$c330 = peg$literalExpectation("retry_after", true);
	    var peg$c331 = function (retry_after) {
	        options = options || { data: {} };
	        if (typeof retry_after !== 'undefined')
	            options.data.retry_after = retry_after;
	    };
	    var peg$c332 = "deactivated";
	    var peg$c333 = peg$literalExpectation("deactivated", true);
	    var peg$c334 = "probation";
	    var peg$c335 = peg$literalExpectation("probation", true);
	    var peg$c336 = "rejected";
	    var peg$c337 = peg$literalExpectation("rejected", true);
	    var peg$c338 = "timeout";
	    var peg$c339 = peg$literalExpectation("timeout", true);
	    var peg$c340 = "giveup";
	    var peg$c341 = peg$literalExpectation("giveup", true);
	    var peg$c342 = "noresource";
	    var peg$c343 = peg$literalExpectation("noresource", true);
	    var peg$c344 = "invariant";
	    var peg$c345 = peg$literalExpectation("invariant", true);
	    var peg$c346 = function (value) {
	        options = options || { data: {} };
	        if (options.startRule === 'Supported') {
	            options.data = value || [];
	        }
	    };
	    var peg$c347 = function () {
	        options = options || { data: {} };
	        var tag = options.data.tag;
	        options.data = new NameAddrHeader_1.NameAddrHeader(options.data.uri, options.data.displayName, options.data.params);
	        if (tag) {
	            options.data.setParam('tag', tag);
	        }
	    };
	    var peg$c348 = "ttl";
	    var peg$c349 = peg$literalExpectation("ttl", true);
	    var peg$c350 = function (via_ttl_value) {
	        options = options || { data: {} };
	        options.data.ttl = via_ttl_value;
	    };
	    var peg$c351 = "maddr";
	    var peg$c352 = peg$literalExpectation("maddr", true);
	    var peg$c353 = function (via_maddr) {
	        options = options || { data: {} };
	        options.data.maddr = via_maddr;
	    };
	    var peg$c354 = "received";
	    var peg$c355 = peg$literalExpectation("received", true);
	    var peg$c356 = function (via_received) {
	        options = options || { data: {} };
	        options.data.received = via_received;
	    };
	    var peg$c357 = "branch";
	    var peg$c358 = peg$literalExpectation("branch", true);
	    var peg$c359 = function (via_branch) {
	        options = options || { data: {} };
	        options.data.branch = via_branch;
	    };
	    var peg$c360 = "rport";
	    var peg$c361 = peg$literalExpectation("rport", true);
	    var peg$c362 = function (response_port) {
	        options = options || { data: {} };
	        if (typeof response_port !== 'undefined')
	            options.data.rport = response_port.join('');
	    };
	    var peg$c363 = function (via_protocol) {
	        options = options || { data: {} };
	        options.data.protocol = via_protocol;
	    };
	    var peg$c364 = peg$literalExpectation("UDP", true);
	    var peg$c365 = peg$literalExpectation("TCP", true);
	    var peg$c366 = peg$literalExpectation("TLS", true);
	    var peg$c367 = peg$literalExpectation("SCTP", true);
	    var peg$c368 = function (via_transport) {
	        options = options || { data: {} };
	        options.data.transport = via_transport;
	    };
	    var peg$c369 = function () {
	        options = options || { data: {} };
	        options.data.host = text();
	    };
	    var peg$c370 = function (via_sent_by_port) {
	        options = options || { data: {} };
	        options.data.port = parseInt(via_sent_by_port.join(''));
	    };
	    var peg$c371 = function (ttl) {
	        return parseInt(ttl.join(''));
	    };
	    var peg$c372 = function (deltaSeconds) {
	        options = options || { data: {} };
	        if (options.startRule === 'Session_Expires') {
	            options.data.deltaSeconds = deltaSeconds;
	        }
	    };
	    var peg$c373 = "refresher";
	    var peg$c374 = peg$literalExpectation("refresher", false);
	    var peg$c375 = "uas";
	    var peg$c376 = peg$literalExpectation("uas", false);
	    var peg$c377 = "uac";
	    var peg$c378 = peg$literalExpectation("uac", false);
	    var peg$c379 = function (endpoint) {
	        options = options || { data: {} };
	        if (options.startRule === 'Session_Expires') {
	            options.data.refresher = endpoint;
	        }
	    };
	    var peg$c380 = function (deltaSeconds) {
	        options = options || { data: {} };
	        if (options.startRule === 'Min_SE') {
	            options.data = deltaSeconds;
	        }
	    };
	    var peg$c381 = "stuns";
	    var peg$c382 = peg$literalExpectation("stuns", true);
	    var peg$c383 = "stun";
	    var peg$c384 = peg$literalExpectation("stun", true);
	    var peg$c385 = function (scheme) {
	        options = options || { data: {} };
	        options.data.scheme = scheme;
	    };
	    var peg$c386 = function (host) {
	        options = options || { data: {} };
	        options.data.host = host;
	    };
	    var peg$c387 = "?transport=";
	    var peg$c388 = peg$literalExpectation("?transport=", false);
	    var peg$c389 = "turns";
	    var peg$c390 = peg$literalExpectation("turns", true);
	    var peg$c391 = "turn";
	    var peg$c392 = peg$literalExpectation("turn", true);
	    var peg$c394 = function () {
	        options = options || { data: {} };
	        options.data = text();
	    };
	    var peg$c395 = "Referred-By";
	    var peg$c396 = peg$literalExpectation("Referred-By", false);
	    var peg$c397 = "b";
	    var peg$c398 = peg$literalExpectation("b", false);
	    var peg$c399 = "cid";
	    var peg$c400 = peg$literalExpectation("cid", false);
	    var peg$currPos = 0;
	    var peg$savedPos = 0;
	    var peg$posDetailsCache = [{ line: 1, column: 1 }];
	    var peg$maxFailPos = 0;
	    var peg$maxFailExpected = [];
	    var peg$result;
	    if (options.startRule !== undefined) {
	        if (!(options.startRule in peg$startRuleFunctions)) {
	            throw new Error("Can't start parsing from rule \"" + options.startRule + "\".");
	        }
	        peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
	    }
	    function text() {
	        return input.substring(peg$savedPos, peg$currPos);
	    }
	    function location() {
	        return peg$computeLocation(peg$savedPos, peg$currPos);
	    }
	    function peg$literalExpectation(text1, ignoreCase) {
	        return { type: "literal", text: text1, ignoreCase: ignoreCase };
	    }
	    function peg$classExpectation(parts, inverted, ignoreCase) {
	        return { type: "class", parts: parts, inverted: inverted, ignoreCase: ignoreCase };
	    }
	    function peg$endExpectation() {
	        return { type: "end" };
	    }
	    function peg$computePosDetails(pos) {
	        var details = peg$posDetailsCache[pos];
	        var p;
	        if (details) {
	            return details;
	        }
	        else {
	            p = pos - 1;
	            while (!peg$posDetailsCache[p]) {
	                p--;
	            }
	            details = peg$posDetailsCache[p];
	            details = {
	                line: details.line,
	                column: details.column
	            };
	            while (p < pos) {
	                if (input.charCodeAt(p) === 10) {
	                    details.line++;
	                    details.column = 1;
	                }
	                else {
	                    details.column++;
	                }
	                p++;
	            }
	            peg$posDetailsCache[pos] = details;
	            return details;
	        }
	    }
	    function peg$computeLocation(startPos, endPos) {
	        var startPosDetails = peg$computePosDetails(startPos);
	        var endPosDetails = peg$computePosDetails(endPos);
	        return {
	            start: {
	                offset: startPos,
	                line: startPosDetails.line,
	                column: startPosDetails.column
	            },
	            end: {
	                offset: endPos,
	                line: endPosDetails.line,
	                column: endPosDetails.column
	            }
	        };
	    }
	    function peg$fail(expected1) {
	        if (peg$currPos < peg$maxFailPos) {
	            return;
	        }
	        if (peg$currPos > peg$maxFailPos) {
	            peg$maxFailPos = peg$currPos;
	            peg$maxFailExpected = [];
	        }
	        peg$maxFailExpected.push(expected1);
	    }
	    function peg$buildStructuredError(expected1, found, location1) {
	        return new SyntaxError(SyntaxError.buildMessage(expected1, found), expected1, found, location1);
	    }
	    function peg$parseCRLF() {
	        var s0;
	        if (input.substr(peg$currPos, 2) === peg$c0) {
	            s0 = peg$c0;
	            peg$currPos += 2;
	        }
	        else {
	            s0 = peg$FAILED;
	            {
	                peg$fail(peg$c1);
	            }
	        }
	        return s0;
	    }
	    function peg$parseDIGIT() {
	        var s0;
	        if (peg$c2.test(input.charAt(peg$currPos))) {
	            s0 = input.charAt(peg$currPos);
	            peg$currPos++;
	        }
	        else {
	            s0 = peg$FAILED;
	            {
	                peg$fail(peg$c3);
	            }
	        }
	        return s0;
	    }
	    function peg$parseALPHA() {
	        var s0;
	        if (peg$c4.test(input.charAt(peg$currPos))) {
	            s0 = input.charAt(peg$currPos);
	            peg$currPos++;
	        }
	        else {
	            s0 = peg$FAILED;
	            {
	                peg$fail(peg$c5);
	            }
	        }
	        return s0;
	    }
	    function peg$parseHEXDIG() {
	        var s0;
	        if (peg$c6.test(input.charAt(peg$currPos))) {
	            s0 = input.charAt(peg$currPos);
	            peg$currPos++;
	        }
	        else {
	            s0 = peg$FAILED;
	            {
	                peg$fail(peg$c7);
	            }
	        }
	        return s0;
	    }
	    function peg$parseWSP() {
	        var s0;
	        s0 = peg$parseSP();
	        if (s0 === peg$FAILED) {
	            s0 = peg$parseHTAB();
	        }
	        return s0;
	    }
	    function peg$parseOCTET() {
	        var s0;
	        if (peg$c8.test(input.charAt(peg$currPos))) {
	            s0 = input.charAt(peg$currPos);
	            peg$currPos++;
	        }
	        else {
	            s0 = peg$FAILED;
	            {
	                peg$fail(peg$c9);
	            }
	        }
	        return s0;
	    }
	    function peg$parseDQUOTE() {
	        var s0;
	        if (peg$c10.test(input.charAt(peg$currPos))) {
	            s0 = input.charAt(peg$currPos);
	            peg$currPos++;
	        }
	        else {
	            s0 = peg$FAILED;
	            {
	                peg$fail(peg$c11);
	            }
	        }
	        return s0;
	    }
	    function peg$parseSP() {
	        var s0;
	        if (input.charCodeAt(peg$currPos) === 32) {
	            s0 = peg$c12;
	            peg$currPos++;
	        }
	        else {
	            s0 = peg$FAILED;
	            {
	                peg$fail(peg$c13);
	            }
	        }
	        return s0;
	    }
	    function peg$parseHTAB() {
	        var s0;
	        if (input.charCodeAt(peg$currPos) === 9) {
	            s0 = peg$c14;
	            peg$currPos++;
	        }
	        else {
	            s0 = peg$FAILED;
	            {
	                peg$fail(peg$c15);
	            }
	        }
	        return s0;
	    }
	    function peg$parsealphanum() {
	        var s0;
	        if (peg$c16.test(input.charAt(peg$currPos))) {
	            s0 = input.charAt(peg$currPos);
	            peg$currPos++;
	        }
	        else {
	            s0 = peg$FAILED;
	            {
	                peg$fail(peg$c17);
	            }
	        }
	        return s0;
	    }
	    function peg$parsereserved() {
	        var s0;
	        if (input.charCodeAt(peg$currPos) === 59) {
	            s0 = peg$c18;
	            peg$currPos++;
	        }
	        else {
	            s0 = peg$FAILED;
	            {
	                peg$fail(peg$c19);
	            }
	        }
	        if (s0 === peg$FAILED) {
	            if (input.charCodeAt(peg$currPos) === 47) {
	                s0 = peg$c20;
	                peg$currPos++;
	            }
	            else {
	                s0 = peg$FAILED;
	                {
	                    peg$fail(peg$c21);
	                }
	            }
	            if (s0 === peg$FAILED) {
	                if (input.charCodeAt(peg$currPos) === 63) {
	                    s0 = peg$c22;
	                    peg$currPos++;
	                }
	                else {
	                    s0 = peg$FAILED;
	                    {
	                        peg$fail(peg$c23);
	                    }
	                }
	                if (s0 === peg$FAILED) {
	                    if (input.charCodeAt(peg$currPos) === 58) {
	                        s0 = peg$c24;
	                        peg$currPos++;
	                    }
	                    else {
	                        s0 = peg$FAILED;
	                        {
	                            peg$fail(peg$c25);
	                        }
	                    }
	                    if (s0 === peg$FAILED) {
	                        if (input.charCodeAt(peg$currPos) === 64) {
	                            s0 = peg$c26;
	                            peg$currPos++;
	                        }
	                        else {
	                            s0 = peg$FAILED;
	                            {
	                                peg$fail(peg$c27);
	                            }
	                        }
	                        if (s0 === peg$FAILED) {
	                            if (input.charCodeAt(peg$currPos) === 38) {
	                                s0 = peg$c28;
	                                peg$currPos++;
	                            }
	                            else {
	                                s0 = peg$FAILED;
	                                {
	                                    peg$fail(peg$c29);
	                                }
	                            }
	                            if (s0 === peg$FAILED) {
	                                if (input.charCodeAt(peg$currPos) === 61) {
	                                    s0 = peg$c30;
	                                    peg$currPos++;
	                                }
	                                else {
	                                    s0 = peg$FAILED;
	                                    {
	                                        peg$fail(peg$c31);
	                                    }
	                                }
	                                if (s0 === peg$FAILED) {
	                                    if (input.charCodeAt(peg$currPos) === 43) {
	                                        s0 = peg$c32;
	                                        peg$currPos++;
	                                    }
	                                    else {
	                                        s0 = peg$FAILED;
	                                        {
	                                            peg$fail(peg$c33);
	                                        }
	                                    }
	                                    if (s0 === peg$FAILED) {
	                                        if (input.charCodeAt(peg$currPos) === 36) {
	                                            s0 = peg$c34;
	                                            peg$currPos++;
	                                        }
	                                        else {
	                                            s0 = peg$FAILED;
	                                            {
	                                                peg$fail(peg$c35);
	                                            }
	                                        }
	                                        if (s0 === peg$FAILED) {
	                                            if (input.charCodeAt(peg$currPos) === 44) {
	                                                s0 = peg$c36;
	                                                peg$currPos++;
	                                            }
	                                            else {
	                                                s0 = peg$FAILED;
	                                                {
	                                                    peg$fail(peg$c37);
	                                                }
	                                            }
	                                        }
	                                    }
	                                }
	                            }
	                        }
	                    }
	                }
	            }
	        }
	        return s0;
	    }
	    function peg$parseunreserved() {
	        var s0;
	        s0 = peg$parsealphanum();
	        if (s0 === peg$FAILED) {
	            s0 = peg$parsemark();
	        }
	        return s0;
	    }
	    function peg$parsemark() {
	        var s0;
	        if (input.charCodeAt(peg$currPos) === 45) {
	            s0 = peg$c38;
	            peg$currPos++;
	        }
	        else {
	            s0 = peg$FAILED;
	            {
	                peg$fail(peg$c39);
	            }
	        }
	        if (s0 === peg$FAILED) {
	            if (input.charCodeAt(peg$currPos) === 95) {
	                s0 = peg$c40;
	                peg$currPos++;
	            }
	            else {
	                s0 = peg$FAILED;
	                {
	                    peg$fail(peg$c41);
	                }
	            }
	            if (s0 === peg$FAILED) {
	                if (input.charCodeAt(peg$currPos) === 46) {
	                    s0 = peg$c42;
	                    peg$currPos++;
	                }
	                else {
	                    s0 = peg$FAILED;
	                    {
	                        peg$fail(peg$c43);
	                    }
	                }
	                if (s0 === peg$FAILED) {
	                    if (input.charCodeAt(peg$currPos) === 33) {
	                        s0 = peg$c44;
	                        peg$currPos++;
	                    }
	                    else {
	                        s0 = peg$FAILED;
	                        {
	                            peg$fail(peg$c45);
	                        }
	                    }
	                    if (s0 === peg$FAILED) {
	                        if (input.charCodeAt(peg$currPos) === 126) {
	                            s0 = peg$c46;
	                            peg$currPos++;
	                        }
	                        else {
	                            s0 = peg$FAILED;
	                            {
	                                peg$fail(peg$c47);
	                            }
	                        }
	                        if (s0 === peg$FAILED) {
	                            if (input.charCodeAt(peg$currPos) === 42) {
	                                s0 = peg$c48;
	                                peg$currPos++;
	                            }
	                            else {
	                                s0 = peg$FAILED;
	                                {
	                                    peg$fail(peg$c49);
	                                }
	                            }
	                            if (s0 === peg$FAILED) {
	                                if (input.charCodeAt(peg$currPos) === 39) {
	                                    s0 = peg$c50;
	                                    peg$currPos++;
	                                }
	                                else {
	                                    s0 = peg$FAILED;
	                                    {
	                                        peg$fail(peg$c51);
	                                    }
	                                }
	                                if (s0 === peg$FAILED) {
	                                    if (input.charCodeAt(peg$currPos) === 40) {
	                                        s0 = peg$c52;
	                                        peg$currPos++;
	                                    }
	                                    else {
	                                        s0 = peg$FAILED;
	                                        {
	                                            peg$fail(peg$c53);
	                                        }
	                                    }
	                                    if (s0 === peg$FAILED) {
	                                        if (input.charCodeAt(peg$currPos) === 41) {
	                                            s0 = peg$c54;
	                                            peg$currPos++;
	                                        }
	                                        else {
	                                            s0 = peg$FAILED;
	                                            {
	                                                peg$fail(peg$c55);
	                                            }
	                                        }
	                                    }
	                                }
	                            }
	                        }
	                    }
	                }
	            }
	        }
	        return s0;
	    }
	    function peg$parseescaped() {
	        var s0, s1, s2, s3, s4;
	        s0 = peg$currPos;
	        s1 = peg$currPos;
	        if (input.charCodeAt(peg$currPos) === 37) {
	            s2 = peg$c56;
	            peg$currPos++;
	        }
	        else {
	            s2 = peg$FAILED;
	            {
	                peg$fail(peg$c57);
	            }
	        }
	        if (s2 !== peg$FAILED) {
	            s3 = peg$parseHEXDIG();
	            if (s3 !== peg$FAILED) {
	                s4 = peg$parseHEXDIG();
	                if (s4 !== peg$FAILED) {
	                    s2 = [s2, s3, s4];
	                    s1 = s2;
	                }
	                else {
	                    peg$currPos = s1;
	                    s1 = peg$FAILED;
	                }
	            }
	            else {
	                peg$currPos = s1;
	                s1 = peg$FAILED;
	            }
	        }
	        else {
	            peg$currPos = s1;
	            s1 = peg$FAILED;
	        }
	        if (s1 !== peg$FAILED) {
	            s0 = input.substring(s0, peg$currPos);
	        }
	        else {
	            s0 = s1;
	        }
	        return s0;
	    }
	    function peg$parseLWS() {
	        var s0, s1, s2, s3;
	        s0 = peg$currPos;
	        s1 = peg$currPos;
	        s2 = [];
	        s3 = peg$parseWSP();
	        while (s3 !== peg$FAILED) {
	            s2.push(s3);
	            s3 = peg$parseWSP();
	        }
	        if (s2 !== peg$FAILED) {
	            s3 = peg$parseCRLF();
	            if (s3 !== peg$FAILED) {
	                s2 = [s2, s3];
	                s1 = s2;
	            }
	            else {
	                peg$currPos = s1;
	                s1 = peg$FAILED;
	            }
	        }
	        else {
	            peg$currPos = s1;
	            s1 = peg$FAILED;
	        }
	        if (s1 === peg$FAILED) {
	            s1 = null;
	        }
	        if (s1 !== peg$FAILED) {
	            s2 = [];
	            s3 = peg$parseWSP();
	            if (s3 !== peg$FAILED) {
	                while (s3 !== peg$FAILED) {
	                    s2.push(s3);
	                    s3 = peg$parseWSP();
	                }
	            }
	            else {
	                s2 = peg$FAILED;
	            }
	            if (s2 !== peg$FAILED) {
	                peg$savedPos = s0;
	                s1 = peg$c58();
	                s0 = s1;
	            }
	            else {
	                peg$currPos = s0;
	                s0 = peg$FAILED;
	            }
	        }
	        else {
	            peg$currPos = s0;
	            s0 = peg$FAILED;
	        }
	        return s0;
	    }
	    function peg$parseSWS() {
	        var s0;
	        s0 = peg$parseLWS();
	        if (s0 === peg$FAILED) {
	            s0 = null;
	        }
	        return s0;
	    }
	    function peg$parseHCOLON() {
	        var s0, s1, s2, s3;
	        s0 = peg$currPos;
	        s1 = [];
	        s2 = peg$parseSP();
	        if (s2 === peg$FAILED) {
	            s2 = peg$parseHTAB();
	        }
	        while (s2 !== peg$FAILED) {
	            s1.push(s2);
	            s2 = peg$parseSP();
	            if (s2 === peg$FAILED) {
	                s2 = peg$parseHTAB();
	            }
	        }
	        if (s1 !== peg$FAILED) {
	            if (input.charCodeAt(peg$currPos) === 58) {
	                s2 = peg$c24;
	                peg$currPos++;
	            }
	            else {
	                s2 = peg$FAILED;
	                {
	                    peg$fail(peg$c25);
	                }
	            }
	            if (s2 !== peg$FAILED) {
	                s3 = peg$parseSWS();
	                if (s3 !== peg$FAILED) {
	                    peg$savedPos = s0;
	                    s1 = peg$c59();
	                    s0 = s1;
	                }
	                else {
	                    peg$currPos = s0;
	                    s0 = peg$FAILED;
	                }
	            }
	            else {
	                peg$currPos = s0;
	                s0 = peg$FAILED;
	            }
	        }
	        else {
	            peg$currPos = s0;
	            s0 = peg$FAILED;
	        }
	        return s0;
	    }
	    function peg$parseUTF8_NONASCII() {
	        var s0;
	        if (peg$c62.test(input.charAt(peg$currPos))) {
	            s0 = input.charAt(peg$currPos);
	            peg$currPos++;
	        }
	        else {
	            s0 = peg$FAILED;
	            {
	                peg$fail(peg$c63);
	            }
	        }
	        return s0;
	    }
	    function peg$parseUTF8_CONT() {
	        var s0;
	        if (peg$c64.test(input.charAt(peg$currPos))) {
	            s0 = input.charAt(peg$currPos);
	            peg$currPos++;
	        }
	        else {
	            s0 = peg$FAILED;
	            {
	                peg$fail(peg$c65);
	            }
	        }
	        return s0;
	    }
	    function peg$parsetoken() {
	        var s0, s1, s2;
	        s0 = peg$currPos;
	        s1 = [];
	        s2 = peg$parsealphanum();
	        if (s2 === peg$FAILED) {
	            if (input.charCodeAt(peg$currPos) === 45) {
	                s2 = peg$c38;
	                peg$currPos++;
	            }
	            else {
	                s2 = peg$FAILED;
	                {
	                    peg$fail(peg$c39);
	                }
	            }
	            if (s2 === peg$FAILED) {
	                if (input.charCodeAt(peg$currPos) === 46) {
	                    s2 = peg$c42;
	                    peg$currPos++;
	                }
	                else {
	                    s2 = peg$FAILED;
	                    {
	                        peg$fail(peg$c43);
	                    }
	                }
	                if (s2 === peg$FAILED) {
	                    if (input.charCodeAt(peg$currPos) === 33) {
	                        s2 = peg$c44;
	                        peg$currPos++;
	                    }
	                    else {
	                        s2 = peg$FAILED;
	                        {
	                            peg$fail(peg$c45);
	                        }
	                    }
	                    if (s2 === peg$FAILED) {
	                        if (input.charCodeAt(peg$currPos) === 37) {
	                            s2 = peg$c56;
	                            peg$currPos++;
	                        }
	                        else {
	                            s2 = peg$FAILED;
	                            {
	                                peg$fail(peg$c57);
	                            }
	                        }
	                        if (s2 === peg$FAILED) {
	                            if (input.charCodeAt(peg$currPos) === 42) {
	                                s2 = peg$c48;
	                                peg$currPos++;
	                            }
	                            else {
	                                s2 = peg$FAILED;
	                                {
	                                    peg$fail(peg$c49);
	                                }
	                            }
	                            if (s2 === peg$FAILED) {
	                                if (input.charCodeAt(peg$currPos) === 95) {
	                                    s2 = peg$c40;
	                                    peg$currPos++;
	                                }
	                                else {
	                                    s2 = peg$FAILED;
	                                    {
	                                        peg$fail(peg$c41);
	                                    }
	                                }
	                                if (s2 === peg$FAILED) {
	                                    if (input.charCodeAt(peg$currPos) === 43) {
	                                        s2 = peg$c32;
	                                        peg$currPos++;
	                                    }
	                                    else {
	                                        s2 = peg$FAILED;
	                                        {
	                                            peg$fail(peg$c33);
	                                        }
	                                    }
	                                    if (s2 === peg$FAILED) {
	                                        if (input.charCodeAt(peg$currPos) === 96) {
	                                            s2 = peg$c68;
	                                            peg$currPos++;
	                                        }
	                                        else {
	                                            s2 = peg$FAILED;
	                                            {
	                                                peg$fail(peg$c69);
	                                            }
	                                        }
	                                        if (s2 === peg$FAILED) {
	                                            if (input.charCodeAt(peg$currPos) === 39) {
	                                                s2 = peg$c50;
	                                                peg$currPos++;
	                                            }
	                                            else {
	                                                s2 = peg$FAILED;
	                                                {
	                                                    peg$fail(peg$c51);
	                                                }
	                                            }
	                                            if (s2 === peg$FAILED) {
	                                                if (input.charCodeAt(peg$currPos) === 126) {
	                                                    s2 = peg$c46;
	                                                    peg$currPos++;
	                                                }
	                                                else {
	                                                    s2 = peg$FAILED;
	                                                    {
	                                                        peg$fail(peg$c47);
	                                                    }
	                                                }
	                                            }
	                                        }
	                                    }
	                                }
	                            }
	                        }
	                    }
	                }
	            }
	        }
	        if (s2 !== peg$FAILED) {
	            while (s2 !== peg$FAILED) {
	                s1.push(s2);
	                s2 = peg$parsealphanum();
	                if (s2 === peg$FAILED) {
	                    if (input.charCodeAt(peg$currPos) === 45) {
	                        s2 = peg$c38;
	                        peg$currPos++;
	                    }
	                    else {
	                        s2 = peg$FAILED;
	                        {
	                            peg$fail(peg$c39);
	                        }
	                    }
	                    if (s2 === peg$FAILED) {
	                        if (input.charCodeAt(peg$currPos) === 46) {
	                            s2 = peg$c42;
	                            peg$currPos++;
	                        }
	                        else {
	                            s2 = peg$FAILED;
	                            {
	                                peg$fail(peg$c43);
	                            }
	                        }
	                        if (s2 === peg$FAILED) {
	                            if (input.charCodeAt(peg$currPos) === 33) {
	                                s2 = peg$c44;
	                                peg$currPos++;
	                            }
	                            else {
	                                s2 = peg$FAILED;
	                                {
	                                    peg$fail(peg$c45);
	                                }
	                            }
	                            if (s2 === peg$FAILED) {
	                                if (input.charCodeAt(peg$currPos) === 37) {
	                                    s2 = peg$c56;
	                                    peg$currPos++;
	                                }
	                                else {
	                                    s2 = peg$FAILED;
	                                    {
	                                        peg$fail(peg$c57);
	                                    }
	                                }
	                                if (s2 === peg$FAILED) {
	                                    if (input.charCodeAt(peg$currPos) === 42) {
	                                        s2 = peg$c48;
	                                        peg$currPos++;
	                                    }
	                                    else {
	                                        s2 = peg$FAILED;
	                                        {
	                                            peg$fail(peg$c49);
	                                        }
	                                    }
	                                    if (s2 === peg$FAILED) {
	                                        if (input.charCodeAt(peg$currPos) === 95) {
	                                            s2 = peg$c40;
	                                            peg$currPos++;
	                                        }
	                                        else {
	                                            s2 = peg$FAILED;
	                                            {
	                                                peg$fail(peg$c41);
	                                            }
	                                        }
	                                        if (s2 === peg$FAILED) {
	                                            if (input.charCodeAt(peg$currPos) === 43) {
	                                                s2 = peg$c32;
	                                                peg$currPos++;
	                                            }
	                                            else {
	                                                s2 = peg$FAILED;
	                                                {
	                                                    peg$fail(peg$c33);
	                                                }
	                                            }
	                                            if (s2 === peg$FAILED) {
	                                                if (input.charCodeAt(peg$currPos) === 96) {
	                                                    s2 = peg$c68;
	                                                    peg$currPos++;
	                                                }
	                                                else {
	                                                    s2 = peg$FAILED;
	                                                    {
	                                                        peg$fail(peg$c69);
	                                                    }
	                                                }
	                                                if (s2 === peg$FAILED) {
	                                                    if (input.charCodeAt(peg$currPos) === 39) {
	                                                        s2 = peg$c50;
	                                                        peg$currPos++;
	                                                    }
	                                                    else {
	                                                        s2 = peg$FAILED;
	                                                        {
	                                                            peg$fail(peg$c51);
	                                                        }
	                                                    }
	                                                    if (s2 === peg$FAILED) {
	                                                        if (input.charCodeAt(peg$currPos) === 126) {
	                                                            s2 = peg$c46;
	                                                            peg$currPos++;
	                                                        }
	                                                        else {
	                                                            s2 = peg$FAILED;
	                                                            {
	                                                                peg$fail(peg$c47);
	                                                            }
	                                                        }
	                                                    }
	                                                }
	                                            }
	                                        }
	                                    }
	                                }
	                            }
	                        }
	                    }
	                }
	            }
	        }
	        else {
	            s1 = peg$FAILED;
	        }
	        if (s1 !== peg$FAILED) {
	            s0 = input.substring(s0, peg$currPos);
	        }
	        else {
	            s0 = s1;
	        }
	        return s0;
	    }
	    function peg$parsetoken_nodot() {
	        var s0, s1, s2;
	        s0 = peg$currPos;
	        s1 = [];
	        s2 = peg$parsealphanum();
	        if (s2 === peg$FAILED) {
	            if (input.charCodeAt(peg$currPos) === 45) {
	                s2 = peg$c38;
	                peg$currPos++;
	            }
	            else {
	                s2 = peg$FAILED;
	                {
	                    peg$fail(peg$c39);
	                }
	            }
	            if (s2 === peg$FAILED) {
	                if (input.charCodeAt(peg$currPos) === 33) {
	                    s2 = peg$c44;
	                    peg$currPos++;
	                }
	                else {
	                    s2 = peg$FAILED;
	                    {
	                        peg$fail(peg$c45);
	                    }
	                }
	                if (s2 === peg$FAILED) {
	                    if (input.charCodeAt(peg$currPos) === 37) {
	                        s2 = peg$c56;
	                        peg$currPos++;
	                    }
	                    else {
	                        s2 = peg$FAILED;
	                        {
	                            peg$fail(peg$c57);
	                        }
	                    }
	                    if (s2 === peg$FAILED) {
	                        if (input.charCodeAt(peg$currPos) === 42) {
	                            s2 = peg$c48;
	                            peg$currPos++;
	                        }
	                        else {
	                            s2 = peg$FAILED;
	                            {
	                                peg$fail(peg$c49);
	                            }
	                        }
	                        if (s2 === peg$FAILED) {
	                            if (input.charCodeAt(peg$currPos) === 95) {
	                                s2 = peg$c40;
	                                peg$currPos++;
	                            }
	                            else {
	                                s2 = peg$FAILED;
	                                {
	                                    peg$fail(peg$c41);
	                                }
	                            }
	                            if (s2 === peg$FAILED) {
	                                if (input.charCodeAt(peg$currPos) === 43) {
	                                    s2 = peg$c32;
	                                    peg$currPos++;
	                                }
	                                else {
	                                    s2 = peg$FAILED;
	                                    {
	                                        peg$fail(peg$c33);
	                                    }
	                                }
	                                if (s2 === peg$FAILED) {
	                                    if (input.charCodeAt(peg$currPos) === 96) {
	                                        s2 = peg$c68;
	                                        peg$currPos++;
	                                    }
	                                    else {
	                                        s2 = peg$FAILED;
	                                        {
	                                            peg$fail(peg$c69);
	                                        }
	                                    }
	                                    if (s2 === peg$FAILED) {
	                                        if (input.charCodeAt(peg$currPos) === 39) {
	                                            s2 = peg$c50;
	                                            peg$currPos++;
	                                        }
	                                        else {
	                                            s2 = peg$FAILED;
	                                            {
	                                                peg$fail(peg$c51);
	                                            }
	                                        }
	                                        if (s2 === peg$FAILED) {
	                                            if (input.charCodeAt(peg$currPos) === 126) {
	                                                s2 = peg$c46;
	                                                peg$currPos++;
	                                            }
	                                            else {
	                                                s2 = peg$FAILED;
	                                                {
	                                                    peg$fail(peg$c47);
	                                                }
	                                            }
	                                        }
	                                    }
	                                }
	                            }
	                        }
	                    }
	                }
	            }
	        }
	        if (s2 !== peg$FAILED) {
	            while (s2 !== peg$FAILED) {
	                s1.push(s2);
	                s2 = peg$parsealphanum();
	                if (s2 === peg$FAILED) {
	                    if (input.charCodeAt(peg$currPos) === 45) {
	                        s2 = peg$c38;
	                        peg$currPos++;
	                    }
	                    else {
	                        s2 = peg$FAILED;
	                        {
	                            peg$fail(peg$c39);
	                        }
	                    }
	                    if (s2 === peg$FAILED) {
	                        if (input.charCodeAt(peg$currPos) === 33) {
	                            s2 = peg$c44;
	                            peg$currPos++;
	                        }
	                        else {
	                            s2 = peg$FAILED;
	                            {
	                                peg$fail(peg$c45);
	                            }
	                        }
	                        if (s2 === peg$FAILED) {
	                            if (input.charCodeAt(peg$currPos) === 37) {
	                                s2 = peg$c56;
	                                peg$currPos++;
	                            }
	                            else {
	                                s2 = peg$FAILED;
	                                {
	                                    peg$fail(peg$c57);
	                                }
	                            }
	                            if (s2 === peg$FAILED) {
	                                if (input.charCodeAt(peg$currPos) === 42) {
	                                    s2 = peg$c48;
	                                    peg$currPos++;
	                                }
	                                else {
	                                    s2 = peg$FAILED;
	                                    {
	                                        peg$fail(peg$c49);
	                                    }
	                                }
	                                if (s2 === peg$FAILED) {
	                                    if (input.charCodeAt(peg$currPos) === 95) {
	                                        s2 = peg$c40;
	                                        peg$currPos++;
	                                    }
	                                    else {
	                                        s2 = peg$FAILED;
	                                        {
	                                            peg$fail(peg$c41);
	                                        }
	                                    }
	                                    if (s2 === peg$FAILED) {
	                                        if (input.charCodeAt(peg$currPos) === 43) {
	                                            s2 = peg$c32;
	                                            peg$currPos++;
	                                        }
	                                        else {
	                                            s2 = peg$FAILED;
	                                            {
	                                                peg$fail(peg$c33);
	                                            }
	                                        }
	                                        if (s2 === peg$FAILED) {
	                                            if (input.charCodeAt(peg$currPos) === 96) {
	                                                s2 = peg$c68;
	                                                peg$currPos++;
	                                            }
	                                            else {
	                                                s2 = peg$FAILED;
	                                                {
	                                                    peg$fail(peg$c69);
	                                                }
	                                            }
	                                            if (s2 === peg$FAILED) {
	                                                if (input.charCodeAt(peg$currPos) === 39) {
	                                                    s2 = peg$c50;
	                                                    peg$currPos++;
	                                                }
	                                                else {
	                                                    s2 = peg$FAILED;
	                                                    {
	                                                        peg$fail(peg$c51);
	                                                    }
	                                                }
	                                                if (s2 === peg$FAILED) {
	                                                    if (input.charCodeAt(peg$currPos) === 126) {
	                                                        s2 = peg$c46;
	                                                        peg$currPos++;
	                                                    }
	                                                    else {
	                                                        s2 = peg$FAILED;
	                                                        {
	                                                            peg$fail(peg$c47);
	                                                        }
	                                                    }
	                                                }
	                                            }
	                                        }
	                                    }
	                                }
	                            }
	                        }
	                    }
	                }
	            }
	        }
	        else {
	            s1 = peg$FAILED;
	        }
	        if (s1 !== peg$FAILED) {
	            s0 = input.substring(s0, peg$currPos);
	        }
	        else {
	            s0 = s1;
	        }
	        return s0;
	    }
	    function peg$parseword() {
	        var s0, s1, s2;
	        s0 = peg$currPos;
	        s1 = [];
	        s2 = peg$parsealphanum();
	        if (s2 === peg$FAILED) {
	            if (input.charCodeAt(peg$currPos) === 45) {
	                s2 = peg$c38;
	                peg$currPos++;
	            }
	            else {
	                s2 = peg$FAILED;
	                {
	                    peg$fail(peg$c39);
	                }
	            }
	            if (s2 === peg$FAILED) {
	                if (input.charCodeAt(peg$currPos) === 46) {
	                    s2 = peg$c42;
	                    peg$currPos++;
	                }
	                else {
	                    s2 = peg$FAILED;
	                    {
	                        peg$fail(peg$c43);
	                    }
	                }
	                if (s2 === peg$FAILED) {
	                    if (input.charCodeAt(peg$currPos) === 33) {
	                        s2 = peg$c44;
	                        peg$currPos++;
	                    }
	                    else {
	                        s2 = peg$FAILED;
	                        {
	                            peg$fail(peg$c45);
	                        }
	                    }
	                    if (s2 === peg$FAILED) {
	                        if (input.charCodeAt(peg$currPos) === 37) {
	                            s2 = peg$c56;
	                            peg$currPos++;
	                        }
	                        else {
	                            s2 = peg$FAILED;
	                            {
	                                peg$fail(peg$c57);
	                            }
	                        }
	                        if (s2 === peg$FAILED) {
	                            if (input.charCodeAt(peg$currPos) === 42) {
	                                s2 = peg$c48;
	                                peg$currPos++;
	                            }
	                            else {
	                                s2 = peg$FAILED;
	                                {
	                                    peg$fail(peg$c49);
	                                }
	                            }
	                            if (s2 === peg$FAILED) {
	                                if (input.charCodeAt(peg$currPos) === 95) {
	                                    s2 = peg$c40;
	                                    peg$currPos++;
	                                }
	                                else {
	                                    s2 = peg$FAILED;
	                                    {
	                                        peg$fail(peg$c41);
	                                    }
	                                }
	                                if (s2 === peg$FAILED) {
	                                    if (input.charCodeAt(peg$currPos) === 43) {
	                                        s2 = peg$c32;
	                                        peg$currPos++;
	                                    }
	                                    else {
	                                        s2 = peg$FAILED;
	                                        {
	                                            peg$fail(peg$c33);
	                                        }
	                                    }
	                                    if (s2 === peg$FAILED) {
	                                        if (input.charCodeAt(peg$currPos) === 96) {
	                                            s2 = peg$c68;
	                                            peg$currPos++;
	                                        }
	                                        else {
	                                            s2 = peg$FAILED;
	                                            {
	                                                peg$fail(peg$c69);
	                                            }
	                                        }
	                                        if (s2 === peg$FAILED) {
	                                            if (input.charCodeAt(peg$currPos) === 39) {
	                                                s2 = peg$c50;
	                                                peg$currPos++;
	                                            }
	                                            else {
	                                                s2 = peg$FAILED;
	                                                {
	                                                    peg$fail(peg$c51);
	                                                }
	                                            }
	                                            if (s2 === peg$FAILED) {
	                                                if (input.charCodeAt(peg$currPos) === 126) {
	                                                    s2 = peg$c46;
	                                                    peg$currPos++;
	                                                }
	                                                else {
	                                                    s2 = peg$FAILED;
	                                                    {
	                                                        peg$fail(peg$c47);
	                                                    }
	                                                }
	                                                if (s2 === peg$FAILED) {
	                                                    if (input.charCodeAt(peg$currPos) === 40) {
	                                                        s2 = peg$c52;
	                                                        peg$currPos++;
	                                                    }
	                                                    else {
	                                                        s2 = peg$FAILED;
	                                                        {
	                                                            peg$fail(peg$c53);
	                                                        }
	                                                    }
	                                                    if (s2 === peg$FAILED) {
	                                                        if (input.charCodeAt(peg$currPos) === 41) {
	                                                            s2 = peg$c54;
	                                                            peg$currPos++;
	                                                        }
	                                                        else {
	                                                            s2 = peg$FAILED;
	                                                            {
	                                                                peg$fail(peg$c55);
	                                                            }
	                                                        }
	                                                        if (s2 === peg$FAILED) {
	                                                            if (input.charCodeAt(peg$currPos) === 60) {
	                                                                s2 = peg$c70;
	                                                                peg$currPos++;
	                                                            }
	                                                            else {
	                                                                s2 = peg$FAILED;
	                                                                {
	                                                                    peg$fail(peg$c71);
	                                                                }
	                                                            }
	                                                            if (s2 === peg$FAILED) {
	                                                                if (input.charCodeAt(peg$currPos) === 62) {
	                                                                    s2 = peg$c72;
	                                                                    peg$currPos++;
	                                                                }
	                                                                else {
	                                                                    s2 = peg$FAILED;
	                                                                    {
	                                                                        peg$fail(peg$c73);
	                                                                    }
	                                                                }
	                                                                if (s2 === peg$FAILED) {
	                                                                    if (input.charCodeAt(peg$currPos) === 58) {
	                                                                        s2 = peg$c24;
	                                                                        peg$currPos++;
	                                                                    }
	                                                                    else {
	                                                                        s2 = peg$FAILED;
	                                                                        {
	                                                                            peg$fail(peg$c25);
	                                                                        }
	                                                                    }
	                                                                    if (s2 === peg$FAILED) {
	                                                                        if (input.charCodeAt(peg$currPos) === 92) {
	                                                                            s2 = peg$c74;
	                                                                            peg$currPos++;
	                                                                        }
	                                                                        else {
	                                                                            s2 = peg$FAILED;
	                                                                            {
	                                                                                peg$fail(peg$c75);
	                                                                            }
	                                                                        }
	                                                                        if (s2 === peg$FAILED) {
	                                                                            s2 = peg$parseDQUOTE();
	                                                                            if (s2 === peg$FAILED) {
	                                                                                if (input.charCodeAt(peg$currPos) === 47) {
	                                                                                    s2 = peg$c20;
	                                                                                    peg$currPos++;
	                                                                                }
	                                                                                else {
	                                                                                    s2 = peg$FAILED;
	                                                                                    {
	                                                                                        peg$fail(peg$c21);
	                                                                                    }
	                                                                                }
	                                                                                if (s2 === peg$FAILED) {
	                                                                                    if (input.charCodeAt(peg$currPos) === 91) {
	                                                                                        s2 = peg$c76;
	                                                                                        peg$currPos++;
	                                                                                    }
	                                                                                    else {
	                                                                                        s2 = peg$FAILED;
	                                                                                        {
	                                                                                            peg$fail(peg$c77);
	                                                                                        }
	                                                                                    }
	                                                                                    if (s2 === peg$FAILED) {
	                                                                                        if (input.charCodeAt(peg$currPos) === 93) {
	                                                                                            s2 = peg$c78;
	                                                                                            peg$currPos++;
	                                                                                        }
	                                                                                        else {
	                                                                                            s2 = peg$FAILED;
	                                                                                            {
	                                                                                                peg$fail(peg$c79);
	                                                                                            }
	                                                                                        }
	                                                                                        if (s2 === peg$FAILED) {
	                                                                                            if (input.charCodeAt(peg$currPos) === 63) {
	                                                                                                s2 = peg$c22;
	                                                                                                peg$currPos++;
	                                                                                            }
	                                                                                            else {
	                                                                                                s2 = peg$FAILED;
	                                                                                                {
	                                                                                                    peg$fail(peg$c23);
	                                                                                                }
	                                                                                            }
	                                                                                            if (s2 === peg$FAILED) {
	                                                                                                if (input.charCodeAt(peg$currPos) === 123) {
	                                                                                                    s2 = peg$c80;
	                                                                                                    peg$currPos++;
	                                                                                                }
	                                                                                                else {
	                                                                                                    s2 = peg$FAILED;
	                                                                                                    {
	                                                                                                        peg$fail(peg$c81);
	                                                                                                    }
	                                                                                                }
	                                                                                                if (s2 === peg$FAILED) {
	                                                                                                    if (input.charCodeAt(peg$currPos) === 125) {
	                                                                                                        s2 = peg$c82;
	                                                                                                        peg$currPos++;
	                                                                                                    }
	                                                                                                    else {
	                                                                                                        s2 = peg$FAILED;
	                                                                                                        {
	                                                                                                            peg$fail(peg$c83);
	                                                                                                        }
	                                                                                                    }
	                                                                                                }
	                                                                                            }
	                                                                                        }
	                                                                                    }
	                                                                                }
	                                                                            }
	                                                                        }
	                                                                    }
	                                                                }
	                                                            }
	                                                        }
	                                                    }
	                                                }
	                                            }
	                                        }
	                                    }
	                                }
	                            }
	                        }
	                    }
	                }
	            }
	        }
	        if (s2 !== peg$FAILED) {
	            while (s2 !== peg$FAILED) {
	                s1.push(s2);
	                s2 = peg$parsealphanum();
	                if (s2 === peg$FAILED) {
	                    if (input.charCodeAt(peg$currPos) === 45) {
	                        s2 = peg$c38;
	                        peg$currPos++;
	                    }
	                    else {
	                        s2 = peg$FAILED;
	                        {
	                            peg$fail(peg$c39);
	                        }
	                    }
	                    if (s2 === peg$FAILED) {
	                        if (input.charCodeAt(peg$currPos) === 46) {
	                            s2 = peg$c42;
	                            peg$currPos++;
	                        }
	                        else {
	                            s2 = peg$FAILED;
	                            {
	                                peg$fail(peg$c43);
	                            }
	                        }
	                        if (s2 === peg$FAILED) {
	                            if (input.charCodeAt(peg$currPos) === 33) {
	                                s2 = peg$c44;
	                                peg$currPos++;
	                            }
	                            else {
	                                s2 = peg$FAILED;
	                                {
	                                    peg$fail(peg$c45);
	                                }
	                            }
	                            if (s2 === peg$FAILED) {
	                                if (input.charCodeAt(peg$currPos) === 37) {
	                                    s2 = peg$c56;
	                                    peg$currPos++;
	                                }
	                                else {
	                                    s2 = peg$FAILED;
	                                    {
	                                        peg$fail(peg$c57);
	                                    }
	                                }
	                                if (s2 === peg$FAILED) {
	                                    if (input.charCodeAt(peg$currPos) === 42) {
	                                        s2 = peg$c48;
	                                        peg$currPos++;
	                                    }
	                                    else {
	                                        s2 = peg$FAILED;
	                                        {
	                                            peg$fail(peg$c49);
	                                        }
	                                    }
	                                    if (s2 === peg$FAILED) {
	                                        if (input.charCodeAt(peg$currPos) === 95) {
	                                            s2 = peg$c40;
	                                            peg$currPos++;
	                                        }
	                                        else {
	                                            s2 = peg$FAILED;
	                                            {
	                                                peg$fail(peg$c41);
	                                            }
	                                        }
	                                        if (s2 === peg$FAILED) {
	                                            if (input.charCodeAt(peg$currPos) === 43) {
	                                                s2 = peg$c32;
	                                                peg$currPos++;
	                                            }
	                                            else {
	                                                s2 = peg$FAILED;
	                                                {
	                                                    peg$fail(peg$c33);
	                                                }
	                                            }
	                                            if (s2 === peg$FAILED) {
	                                                if (input.charCodeAt(peg$currPos) === 96) {
	                                                    s2 = peg$c68;
	                                                    peg$currPos++;
	                                                }
	                                                else {
	                                                    s2 = peg$FAILED;
	                                                    {
	                                                        peg$fail(peg$c69);
	                                                    }
	                                                }
	                                                if (s2 === peg$FAILED) {
	                                                    if (input.charCodeAt(peg$currPos) === 39) {
	                                                        s2 = peg$c50;
	                                                        peg$currPos++;
	                                                    }
	                                                    else {
	                                                        s2 = peg$FAILED;
	                                                        {
	                                                            peg$fail(peg$c51);
	                                                        }
	                                                    }
	                                                    if (s2 === peg$FAILED) {
	                                                        if (input.charCodeAt(peg$currPos) === 126) {
	                                                            s2 = peg$c46;
	                                                            peg$currPos++;
	                                                        }
	                                                        else {
	                                                            s2 = peg$FAILED;
	                                                            {
	                                                                peg$fail(peg$c47);
	                                                            }
	                                                        }
	                                                        if (s2 === peg$FAILED) {
	                                                            if (input.charCodeAt(peg$currPos) === 40) {
	                                                                s2 = peg$c52;
	                                                                peg$currPos++;
	                                                            }
	                                                            else {
	                                                                s2 = peg$FAILED;
	                                                                {
	                                                                    peg$fail(peg$c53);
	                                                                }
	                                                            }
	                                                            if (s2 === peg$FAILED) {
	                                                                if (input.charCodeAt(peg$currPos) === 41) {
	                                                                    s2 = peg$c54;
	                                                                    peg$currPos++;
	                                                                }
	                                                                else {
	                                                                    s2 = peg$FAILED;
	                                                                    {
	                                                                        peg$fail(peg$c55);
	                                                                    }
	                                                                }
	                                                                if (s2 === peg$FAILED) {
	                                                                    if (input.charCodeAt(peg$currPos) === 60) {
	                                                                        s2 = peg$c70;
	                                                                        peg$currPos++;
	                                                                    }
	                                                                    else {
	                                                                        s2 = peg$FAILED;
	                                                                        {
	                                                                            peg$fail(peg$c71);
	                                                                        }
	                                                                    }
	                                                                    if (s2 === peg$FAILED) {
	                                                                        if (input.charCodeAt(peg$currPos) === 62) {
	                                                                            s2 = peg$c72;
	                                                                            peg$currPos++;
	                                                                        }
	                                                                        else {
	                                                                            s2 = peg$FAILED;
	                                                                            {
	                                                                                peg$fail(peg$c73);
	                                                                            }
	                                                                        }
	                                                                        if (s2 === peg$FAILED) {
	                                                                            if (input.charCodeAt(peg$currPos) === 58) {
	                                                                                s2 = peg$c24;
	                                                                                peg$currPos++;
	                                                                            }
	                                                                            else {
	                                                                                s2 = peg$FAILED;
	                                                                                {
	                                                                                    peg$fail(peg$c25);
	                                                                                }
	                                                                            }
	                                                                            if (s2 === peg$FAILED) {
	                                                                                if (input.charCodeAt(peg$currPos) === 92) {
	                                                                                    s2 = peg$c74;
	                                                                                    peg$currPos++;
	                                                                                }
	                                                                                else {
	                                                                                    s2 = peg$FAILED;
	                                                                                    {
	                                                                                        peg$fail(peg$c75);
	                                                                                    }
	                                                                                }
	                                                                                if (s2 === peg$FAILED) {
	                                                                                    s2 = peg$parseDQUOTE();
	                                                                                    if (s2 === peg$FAILED) {
	                                                                                        if (input.charCodeAt(peg$currPos) === 47) {
	                                                                                            s2 = peg$c20;
	                                                                                            peg$currPos++;
	                                                                                        }
	                                                                                        else {
	                                                                                            s2 = peg$FAILED;
	                                                                                            {
	                                                                                                peg$fail(peg$c21);
	                                                                                            }
	                                                                                        }
	                                                                                        if (s2 === peg$FAILED) {
	                                                                                            if (input.charCodeAt(peg$currPos) === 91) {
	                                                                                                s2 = peg$c76;
	                                                                                                peg$currPos++;
	                                                                                            }
	                                                                                            else {
	                                                                                                s2 = peg$FAILED;
	                                                                                                {
	                                                                                                    peg$fail(peg$c77);
	                                                                                                }
	                                                                                            }
	                                                                                            if (s2 === peg$FAILED) {
	                                                                                                if (input.charCodeAt(peg$currPos) === 93) {
	                                                                                                    s2 = peg$c78;
	                                                                                                    peg$currPos++;
	                                                                                                }
	                                                                                                else {
	                                                                                                    s2 = peg$FAILED;
	                                                                                                    {
	                                                                                                        peg$fail(peg$c79);
	                                                                                                    }
	                                                                                                }
	                                                                                                if (s2 === peg$FAILED) {
	                                                                                                    if (input.charCodeAt(peg$currPos) === 63) {
	                                                                                                        s2 = peg$c22;
	                                                                                                        peg$currPos++;
	                                                                                                    }
	                                                                                                    else {
	                                                                                                        s2 = peg$FAILED;
	                                                                                                        {
	                                                                                                            peg$fail(peg$c23);
	                                                                                                        }
	                                                                                                    }
	                                                                                                    if (s2 === peg$FAILED) {
	                                                                                                        if (input.charCodeAt(peg$currPos) === 123) {
	                                                                                                            s2 = peg$c80;
	                                                                                                            peg$currPos++;
	                                                                                                        }
	                                                                                                        else {
	                                                                                                            s2 = peg$FAILED;
	                                                                                                            {
	                                                                                                                peg$fail(peg$c81);
	                                                                                                            }
	                                                                                                        }
	                                                                                                        if (s2 === peg$FAILED) {
	                                                                                                            if (input.charCodeAt(peg$currPos) === 125) {
	                                                                                                                s2 = peg$c82;
	                                                                                                                peg$currPos++;
	                                                                                                            }
	                                                                                                            else {
	                                                                                                                s2 = peg$FAILED;
	                                                                                                                {
	                                                                                                                    peg$fail(peg$c83);
	                                                                                                                }
	                                                                                                            }
	                                                                                                        }
	                                                                                                    }
	                                                                                                }
	                                                                                            }
	                                                                                        }
	                                                                                    }
	                                                                                }
	                                                                            }
	                                                                        }
	                                                                    }
	                                                                }
	                                                            }
	                                                        }
	                                                    }
	                                                }
	                                            }
	                                        }
	                                    }
	                                }
	                            }
	                        }
	                    }
	                }
	            }
	        }
	        else {
	            s1 = peg$FAILED;
	        }
	        if (s1 !== peg$FAILED) {
	            s0 = input.substring(s0, peg$currPos);
	        }
	        else {
	            s0 = s1;
	        }
	        return s0;
	    }
	    function peg$parseSTAR() {
	        var s0, s1, s2, s3;
	        s0 = peg$currPos;
	        s1 = peg$parseSWS();
	        if (s1 !== peg$FAILED) {
	            if (input.charCodeAt(peg$currPos) === 42) {
	                s2 = peg$c48;
	                peg$currPos++;
	            }
	            else {
	                s2 = peg$FAILED;
	                {
	                    peg$fail(peg$c49);
	                }
	            }
	            if (s2 !== peg$FAILED) {
	                s3 = peg$parseSWS();
	                if (s3 !== peg$FAILED) {
	                    peg$savedPos = s0;
	                    s1 = peg$c84();
	                    s0 = s1;
	                }
	                else {
	                    peg$currPos = s0;
	                    s0 = peg$FAILED;
	                }
	            }
	            else {
	                peg$currPos = s0;
	                s0 = peg$FAILED;
	            }
	        }
	        else {
	            peg$currPos = s0;
	            s0 = peg$FAILED;
	        }
	        return s0;
	    }
	    function peg$parseSLASH() {
	        var s0, s1, s2, s3;
	        s0 = peg$currPos;
	        s1 = peg$parseSWS();
	        if (s1 !== peg$FAILED) {
	            if (input.charCodeAt(peg$currPos) === 47) {
	                s2 = peg$c20;
	                peg$currPos++;
	            }
	            else {
	                s2 = peg$FAILED;
	                {
	                    peg$fail(peg$c21);
	                }
	            }
	            if (s2 !== peg$FAILED) {
	                s3 = peg$parseSWS();
	                if (s3 !== peg$FAILED) {
	                    peg$savedPos = s0;
	                    s1 = peg$c85();
	                    s0 = s1;
	                }
	                else {
	                    peg$currPos = s0;
	                    s0 = peg$FAILED;
	                }
	            }
	            else {
	                peg$currPos = s0;
	                s0 = peg$FAILED;
	            }
	        }
	        else {
	            peg$currPos = s0;
	            s0 = peg$FAILED;
	        }
	        return s0;
	    }
	    function peg$parseEQUAL() {
	        var s0, s1, s2, s3;
	        s0 = peg$currPos;
	        s1 = peg$parseSWS();
	        if (s1 !== peg$FAILED) {
	            if (input.charCodeAt(peg$currPos) === 61) {
	                s2 = peg$c30;
	                peg$currPos++;
	            }
	            else {
	                s2 = peg$FAILED;
	                {
	                    peg$fail(peg$c31);
	                }
	            }
	            if (s2 !== peg$FAILED) {
	                s3 = peg$parseSWS();
	                if (s3 !== peg$FAILED) {
	                    peg$savedPos = s0;
	                    s1 = peg$c86();
	                    s0 = s1;
	                }
	                else {
	                    peg$currPos = s0;
	                    s0 = peg$FAILED;
	                }
	            }
	            else {
	                peg$currPos = s0;
	                s0 = peg$FAILED;
	            }
	        }
	        else {
	            peg$currPos = s0;
	            s0 = peg$FAILED;
	        }
	        return s0;
	    }
	    function peg$parseRAQUOT() {
	        var s0, s1, s2;
	        s0 = peg$currPos;
	        if (input.charCodeAt(peg$currPos) === 62) {
	            s1 = peg$c72;
	            peg$currPos++;
	        }
	        else {
	            s1 = peg$FAILED;
	            {
	                peg$fail(peg$c73);
	            }
	        }
	        if (s1 !== peg$FAILED) {
	            s2 = peg$parseSWS();
	            if (s2 !== peg$FAILED) {
	                peg$savedPos = s0;
	                s1 = peg$c89();
	                s0 = s1;
	            }
	            else {
	                peg$currPos = s0;
	                s0 = peg$FAILED;
	            }
	        }
	        else {
	            peg$currPos = s0;
	            s0 = peg$FAILED;
	        }
	        return s0;
	    }
	    function peg$parseLAQUOT() {
	        var s0, s1, s2;
	        s0 = peg$currPos;
	        s1 = peg$parseSWS();
	        if (s1 !== peg$FAILED) {
	            if (input.charCodeAt(peg$currPos) === 60) {
	                s2 = peg$c70;
	                peg$currPos++;
	            }
	            else {
	                s2 = peg$FAILED;
	                {
	                    peg$fail(peg$c71);
	                }
	            }
	            if (s2 !== peg$FAILED) {
	                peg$savedPos = s0;
	                s1 = peg$c90();
	                s0 = s1;
	            }
	            else {
	                peg$currPos = s0;
	                s0 = peg$FAILED;
	            }
	        }
	        else {
	            peg$currPos = s0;
	            s0 = peg$FAILED;
	        }
	        return s0;
	    }
	    function peg$parseCOMMA() {
	        var s0, s1, s2, s3;
	        s0 = peg$currPos;
	        s1 = peg$parseSWS();
	        if (s1 !== peg$FAILED) {
	            if (input.charCodeAt(peg$currPos) === 44) {
	                s2 = peg$c36;
	                peg$currPos++;
	            }
	            else {
	                s2 = peg$FAILED;
	                {
	                    peg$fail(peg$c37);
	                }
	            }
	            if (s2 !== peg$FAILED) {
	                s3 = peg$parseSWS();
	                if (s3 !== peg$FAILED) {
	                    peg$savedPos = s0;
	                    s1 = peg$c91();
	                    s0 = s1;
	                }
	                else {
	                    peg$currPos = s0;
	                    s0 = peg$FAILED;
	                }
	            }
	            else {
	                peg$currPos = s0;
	                s0 = peg$FAILED;
	            }
	        }
	        else {
	            peg$currPos = s0;
	            s0 = peg$FAILED;
	        }
	        return s0;
	    }
	    function peg$parseSEMI() {
	        var s0, s1, s2, s3;
	        s0 = peg$currPos;
	        s1 = peg$parseSWS();
	        if (s1 !== peg$FAILED) {
	            if (input.charCodeAt(peg$currPos) === 59) {
	                s2 = peg$c18;
	                peg$currPos++;
	            }
	            else {
	                s2 = peg$FAILED;
	                {
	                    peg$fail(peg$c19);
	                }
	            }
	            if (s2 !== peg$FAILED) {
	                s3 = peg$parseSWS();
	                if (s3 !== peg$FAILED) {
	                    peg$savedPos = s0;
	                    s1 = peg$c92();
	                    s0 = s1;
	                }
	                else {
	                    peg$currPos = s0;
	                    s0 = peg$FAILED;
	                }
	            }
	            else {
	                peg$currPos = s0;
	                s0 = peg$FAILED;
	            }
	        }
	        else {
	            peg$currPos = s0;
	            s0 = peg$FAILED;
	        }
	        return s0;
	    }
	    function peg$parseCOLON() {
	        var s0, s1, s2, s3;
	        s0 = peg$currPos;
	        s1 = peg$parseSWS();
	        if (s1 !== peg$FAILED) {
	            if (input.charCodeAt(peg$currPos) === 58) {
	                s2 = peg$c24;
	                peg$currPos++;
	            }
	            else {
	                s2 = peg$FAILED;
	                {
	                    peg$fail(peg$c25);
	                }
	            }
	            if (s2 !== peg$FAILED) {
	                s3 = peg$parseSWS();
	                if (s3 !== peg$FAILED) {
	                    peg$savedPos = s0;
	                    s1 = peg$c93();
	                    s0 = s1;
	                }
	                else {
	                    peg$currPos = s0;
	                    s0 = peg$FAILED;
	                }
	            }
	            else {
	                peg$currPos = s0;
	                s0 = peg$FAILED;
	            }
	        }
	        else {
	            peg$currPos = s0;
	            s0 = peg$FAILED;
	        }
	        return s0;
	    }
	    function peg$parseLDQUOT() {
	        var s0, s1, s2;
	        s0 = peg$currPos;
	        s1 = peg$parseSWS();
	        if (s1 !== peg$FAILED) {
	            s2 = peg$parseDQUOTE();
	            if (s2 !== peg$FAILED) {
	                peg$savedPos = s0;
	                s1 = peg$c94();
	                s0 = s1;
	            }
	            else {
	                peg$currPos = s0;
	                s0 = peg$FAILED;
	            }
	        }
	        else {
	            peg$currPos = s0;
	            s0 = peg$FAILED;
	        }
	        return s0;
	    }
	    function peg$parseRDQUOT() {
	        var s0, s1, s2;
	        s0 = peg$currPos;
	        s1 = peg$parseDQUOTE();
	        if (s1 !== peg$FAILED) {
	            s2 = peg$parseSWS();
	            if (s2 !== peg$FAILED) {
	                peg$savedPos = s0;
	                s1 = peg$c94();
	                s0 = s1;
	            }
	            else {
	                peg$currPos = s0;
	                s0 = peg$FAILED;
	            }
	        }
	        else {
	            peg$currPos = s0;
	            s0 = peg$FAILED;
	        }
	        return s0;
	    }
	    function peg$parsequoted_string() {
	        var s0, s1, s2, s3, s4, s5;
	        s0 = peg$currPos;
	        s1 = peg$currPos;
	        s2 = peg$parseSWS();
	        if (s2 !== peg$FAILED) {
	            s3 = peg$parseDQUOTE();
	            if (s3 !== peg$FAILED) {
	                s4 = [];
	                s5 = peg$parseqdtext();
	                if (s5 === peg$FAILED) {
	                    s5 = peg$parsequoted_pair();
	                }
	                while (s5 !== peg$FAILED) {
	                    s4.push(s5);
	                    s5 = peg$parseqdtext();
	                    if (s5 === peg$FAILED) {
	                        s5 = peg$parsequoted_pair();
	                    }
	                }
	                if (s4 !== peg$FAILED) {
	                    s5 = peg$parseDQUOTE();
	                    if (s5 !== peg$FAILED) {
	                        s2 = [s2, s3, s4, s5];
	                        s1 = s2;
	                    }
	                    else {
	                        peg$currPos = s1;
	                        s1 = peg$FAILED;
	                    }
	                }
	                else {
	                    peg$currPos = s1;
	                    s1 = peg$FAILED;
	                }
	            }
	            else {
	                peg$currPos = s1;
	                s1 = peg$FAILED;
	            }
	        }
	        else {
	            peg$currPos = s1;
	            s1 = peg$FAILED;
	        }
	        if (s1 !== peg$FAILED) {
	            s0 = input.substring(s0, peg$currPos);
	        }
	        else {
	            s0 = s1;
	        }
	        return s0;
	    }
	    function peg$parsequoted_string_clean() {
	        var s0, s1, s2, s3, s4, s5;
	        s0 = peg$currPos;
	        s1 = peg$parseSWS();
	        if (s1 !== peg$FAILED) {
	            s2 = peg$parseDQUOTE();
	            if (s2 !== peg$FAILED) {
	                s3 = peg$currPos;
	                s4 = [];
	                s5 = peg$parseqdtext();
	                if (s5 === peg$FAILED) {
	                    s5 = peg$parsequoted_pair();
	                }
	                while (s5 !== peg$FAILED) {
	                    s4.push(s5);
	                    s5 = peg$parseqdtext();
	                    if (s5 === peg$FAILED) {
	                        s5 = peg$parsequoted_pair();
	                    }
	                }
	                if (s4 !== peg$FAILED) {
	                    s3 = input.substring(s3, peg$currPos);
	                }
	                else {
	                    s3 = s4;
	                }
	                if (s3 !== peg$FAILED) {
	                    s4 = peg$parseDQUOTE();
	                    if (s4 !== peg$FAILED) {
	                        peg$savedPos = s0;
	                        s1 = peg$c101(s3);
	                        s0 = s1;
	                    }
	                    else {
	                        peg$currPos = s0;
	                        s0 = peg$FAILED;
	                    }
	                }
	                else {
	                    peg$currPos = s0;
	                    s0 = peg$FAILED;
	                }
	            }
	            else {
	                peg$currPos = s0;
	                s0 = peg$FAILED;
	            }
	        }
	        else {
	            peg$currPos = s0;
	            s0 = peg$FAILED;
	        }
	        return s0;
	    }
	    function peg$parseqdtext() {
	        var s0;
	        s0 = peg$parseLWS();
	        if (s0 === peg$FAILED) {
	            if (input.charCodeAt(peg$currPos) === 33) {
	                s0 = peg$c44;
	                peg$currPos++;
	            }
	            else {
	                s0 = peg$FAILED;
	                {
	                    peg$fail(peg$c45);
	                }
	            }
	            if (s0 === peg$FAILED) {
	                if (peg$c102.test(input.charAt(peg$currPos))) {
	                    s0 = input.charAt(peg$currPos);
	                    peg$currPos++;
	                }
	                else {
	                    s0 = peg$FAILED;
	                    {
	                        peg$fail(peg$c103);
	                    }
	                }
	                if (s0 === peg$FAILED) {
	                    if (peg$c99.test(input.charAt(peg$currPos))) {
	                        s0 = input.charAt(peg$currPos);
	                        peg$currPos++;
	                    }
	                    else {
	                        s0 = peg$FAILED;
	                        {
	                            peg$fail(peg$c100);
	                        }
	                    }
	                    if (s0 === peg$FAILED) {
	                        s0 = peg$parseUTF8_NONASCII();
	                    }
	                }
	            }
	        }
	        return s0;
	    }
	    function peg$parsequoted_pair() {
	        var s0, s1, s2;
	        s0 = peg$currPos;
	        if (input.charCodeAt(peg$currPos) === 92) {
	            s1 = peg$c74;
	            peg$currPos++;
	        }
	        else {
	            s1 = peg$FAILED;
	            {
	                peg$fail(peg$c75);
	            }
	        }
	        if (s1 !== peg$FAILED) {
	            if (peg$c104.test(input.charAt(peg$currPos))) {
	                s2 = input.charAt(peg$currPos);
	                peg$currPos++;
	            }
	            else {
	                s2 = peg$FAILED;
	                {
	                    peg$fail(peg$c105);
	                }
	            }
	            if (s2 === peg$FAILED) {
	                if (peg$c106.test(input.charAt(peg$currPos))) {
	                    s2 = input.charAt(peg$currPos);
	                    peg$currPos++;
	                }
	                else {
	                    s2 = peg$FAILED;
	                    {
	                        peg$fail(peg$c107);
	                    }
	                }
	                if (s2 === peg$FAILED) {
	                    if (peg$c108.test(input.charAt(peg$currPos))) {
	                        s2 = input.charAt(peg$currPos);
	                        peg$currPos++;
	                    }
	                    else {
	                        s2 = peg$FAILED;
	                        {
	                            peg$fail(peg$c109);
	                        }
	                    }
	                }
	            }
	            if (s2 !== peg$FAILED) {
	                s1 = [s1, s2];
	                s0 = s1;
	            }
	            else {
	                peg$currPos = s0;
	                s0 = peg$FAILED;
	            }
	        }
	        else {
	            peg$currPos = s0;
	            s0 = peg$FAILED;
	        }
	        return s0;
	    }
	    function peg$parseSIP_URI_noparams() {
	        var s0, s1, s2, s3, s4;
	        s0 = peg$currPos;
	        s1 = peg$parseuri_scheme();
	        if (s1 !== peg$FAILED) {
	            if (input.charCodeAt(peg$currPos) === 58) {
	                s2 = peg$c24;
	                peg$currPos++;
	            }
	            else {
	                s2 = peg$FAILED;
	                {
	                    peg$fail(peg$c25);
	                }
	            }
	            if (s2 !== peg$FAILED) {
	                s3 = peg$parseuserinfo();
	                if (s3 === peg$FAILED) {
	                    s3 = null;
	                }
	                if (s3 !== peg$FAILED) {
	                    s4 = peg$parsehostport();
	                    if (s4 !== peg$FAILED) {
	                        peg$savedPos = s0;
	                        s1 = peg$c110();
	                        s0 = s1;
	                    }
	                    else {
	                        peg$currPos = s0;
	                        s0 = peg$FAILED;
	                    }
	                }
	                else {
	                    peg$currPos = s0;
	                    s0 = peg$FAILED;
	                }
	            }
	            else {
	                peg$currPos = s0;
	                s0 = peg$FAILED;
	            }
	        }
	        else {
	            peg$currPos = s0;
	            s0 = peg$FAILED;
	        }
	        return s0;
	    }
	    function peg$parseSIP_URI() {
	        var s0, s1, s2, s3, s4, s5, s6;
	        s0 = peg$currPos;
	        s1 = peg$parseuri_scheme();
	        if (s1 !== peg$FAILED) {
	            if (input.charCodeAt(peg$currPos) === 58) {
	                s2 = peg$c24;
	                peg$currPos++;
	            }
	            else {
	                s2 = peg$FAILED;
	                {
	                    peg$fail(peg$c25);
	                }
	            }
	            if (s2 !== peg$FAILED) {
	                s3 = peg$parseuserinfo();
	                if (s3 === peg$FAILED) {
	                    s3 = null;
	                }
	                if (s3 !== peg$FAILED) {
	                    s4 = peg$parsehostport();
	                    if (s4 !== peg$FAILED) {
	                        s5 = peg$parseuri_parameters();
	                        if (s5 !== peg$FAILED) {
	                            s6 = peg$parseheaders();
	                            if (s6 === peg$FAILED) {
	                                s6 = null;
	                            }
	                            if (s6 !== peg$FAILED) {
	                                peg$savedPos = s0;
	                                s1 = peg$c111();
	                                s0 = s1;
	                            }
	                            else {
	                                peg$currPos = s0;
	                                s0 = peg$FAILED;
	                            }
	                        }
	                        else {
	                            peg$currPos = s0;
	                            s0 = peg$FAILED;
	                        }
	                    }
	                    else {
	                        peg$currPos = s0;
	                        s0 = peg$FAILED;
	                    }
	                }
	                else {
	                    peg$currPos = s0;
	                    s0 = peg$FAILED;
	                }
	            }
	            else {
	                peg$currPos = s0;
	                s0 = peg$FAILED;
	            }
	        }
	        else {
	            peg$currPos = s0;
	            s0 = peg$FAILED;
	        }
	        return s0;
	    }
	    function peg$parseuri_scheme() {
	        var s0, s1;
	        s0 = peg$currPos;
	        if (input.substr(peg$currPos, 4).toLowerCase() === peg$c112) {
	            s1 = input.substr(peg$currPos, 4);
	            peg$currPos += 4;
	        }
	        else {
	            s1 = peg$FAILED;
	            {
	                peg$fail(peg$c113);
	            }
	        }
	        if (s1 === peg$FAILED) {
	            if (input.substr(peg$currPos, 3).toLowerCase() === peg$c114) {
	                s1 = input.substr(peg$currPos, 3);
	                peg$currPos += 3;
	            }
	            else {
	                s1 = peg$FAILED;
	                {
	                    peg$fail(peg$c115);
	                }
	            }
	        }
	        if (s1 !== peg$FAILED) {
	            peg$savedPos = s0;
	            s1 = peg$c116(s1);
	        }
	        s0 = s1;
	        return s0;
	    }
	    function peg$parseuserinfo() {
	        var s0, s1, s2, s3, s4;
	        s0 = peg$currPos;
	        s1 = peg$parseuser();
	        if (s1 !== peg$FAILED) {
	            s2 = peg$currPos;
	            if (input.charCodeAt(peg$currPos) === 58) {
	                s3 = peg$c24;
	                peg$currPos++;
	            }
	            else {
	                s3 = peg$FAILED;
	                {
	                    peg$fail(peg$c25);
	                }
	            }
	            if (s3 !== peg$FAILED) {
	                s4 = peg$parsepassword();
	                if (s4 !== peg$FAILED) {
	                    s3 = [s3, s4];
	                    s2 = s3;
	                }
	                else {
	                    peg$currPos = s2;
	                    s2 = peg$FAILED;
	                }
	            }
	            else {
	                peg$currPos = s2;
	                s2 = peg$FAILED;
	            }
	            if (s2 === peg$FAILED) {
	                s2 = null;
	            }
	            if (s2 !== peg$FAILED) {
	                if (input.charCodeAt(peg$currPos) === 64) {
	                    s3 = peg$c26;
	                    peg$currPos++;
	                }
	                else {
	                    s3 = peg$FAILED;
	                    {
	                        peg$fail(peg$c27);
	                    }
	                }
	                if (s3 !== peg$FAILED) {
	                    peg$savedPos = s0;
	                    s1 = peg$c117();
	                    s0 = s1;
	                }
	                else {
	                    peg$currPos = s0;
	                    s0 = peg$FAILED;
	                }
	            }
	            else {
	                peg$currPos = s0;
	                s0 = peg$FAILED;
	            }
	        }
	        else {
	            peg$currPos = s0;
	            s0 = peg$FAILED;
	        }
	        return s0;
	    }
	    function peg$parseuser() {
	        var s0, s1;
	        s0 = [];
	        s1 = peg$parseunreserved();
	        if (s1 === peg$FAILED) {
	            s1 = peg$parseescaped();
	            if (s1 === peg$FAILED) {
	                s1 = peg$parseuser_unreserved();
	            }
	        }
	        if (s1 !== peg$FAILED) {
	            while (s1 !== peg$FAILED) {
	                s0.push(s1);
	                s1 = peg$parseunreserved();
	                if (s1 === peg$FAILED) {
	                    s1 = peg$parseescaped();
	                    if (s1 === peg$FAILED) {
	                        s1 = peg$parseuser_unreserved();
	                    }
	                }
	            }
	        }
	        else {
	            s0 = peg$FAILED;
	        }
	        return s0;
	    }
	    function peg$parseuser_unreserved() {
	        var s0;
	        if (input.charCodeAt(peg$currPos) === 38) {
	            s0 = peg$c28;
	            peg$currPos++;
	        }
	        else {
	            s0 = peg$FAILED;
	            {
	                peg$fail(peg$c29);
	            }
	        }
	        if (s0 === peg$FAILED) {
	            if (input.charCodeAt(peg$currPos) === 61) {
	                s0 = peg$c30;
	                peg$currPos++;
	            }
	            else {
	                s0 = peg$FAILED;
	                {
	                    peg$fail(peg$c31);
	                }
	            }
	            if (s0 === peg$FAILED) {
	                if (input.charCodeAt(peg$currPos) === 43) {
	                    s0 = peg$c32;
	                    peg$currPos++;
	                }
	                else {
	                    s0 = peg$FAILED;
	                    {
	                        peg$fail(peg$c33);
	                    }
	                }
	                if (s0 === peg$FAILED) {
	                    if (input.charCodeAt(peg$currPos) === 36) {
	                        s0 = peg$c34;
	                        peg$currPos++;
	                    }
	                    else {
	                        s0 = peg$FAILED;
	                        {
	                            peg$fail(peg$c35);
	                        }
	                    }
	                    if (s0 === peg$FAILED) {
	                        if (input.charCodeAt(peg$currPos) === 44) {
	                            s0 = peg$c36;
	                            peg$currPos++;
	                        }
	                        else {
	                            s0 = peg$FAILED;
	                            {
	                                peg$fail(peg$c37);
	                            }
	                        }
	                        if (s0 === peg$FAILED) {
	                            if (input.charCodeAt(peg$currPos) === 59) {
	                                s0 = peg$c18;
	                                peg$currPos++;
	                            }
	                            else {
	                                s0 = peg$FAILED;
	                                {
	                                    peg$fail(peg$c19);
	                                }
	                            }
	                            if (s0 === peg$FAILED) {
	                                if (input.charCodeAt(peg$currPos) === 63) {
	                                    s0 = peg$c22;
	                                    peg$currPos++;
	                                }
	                                else {
	                                    s0 = peg$FAILED;
	                                    {
	                                        peg$fail(peg$c23);
	                                    }
	                                }
	                                if (s0 === peg$FAILED) {
	                                    if (input.charCodeAt(peg$currPos) === 47) {
	                                        s0 = peg$c20;
	                                        peg$currPos++;
	                                    }
	                                    else {
	                                        s0 = peg$FAILED;
	                                        {
	                                            peg$fail(peg$c21);
	                                        }
	                                    }
	                                }
	                            }
	                        }
	                    }
	                }
	            }
	        }
	        return s0;
	    }
	    function peg$parsepassword() {
	        var s0, s1, s2;
	        s0 = peg$currPos;
	        s1 = [];
	        s2 = peg$parseunreserved();
	        if (s2 === peg$FAILED) {
	            s2 = peg$parseescaped();
	            if (s2 === peg$FAILED) {
	                if (input.charCodeAt(peg$currPos) === 38) {
	                    s2 = peg$c28;
	                    peg$currPos++;
	                }
	                else {
	                    s2 = peg$FAILED;
	                    {
	                        peg$fail(peg$c29);
	                    }
	                }
	                if (s2 === peg$FAILED) {
	                    if (input.charCodeAt(peg$currPos) === 61) {
	                        s2 = peg$c30;
	                        peg$currPos++;
	                    }
	                    else {
	                        s2 = peg$FAILED;
	                        {
	                            peg$fail(peg$c31);
	                        }
	                    }
	                    if (s2 === peg$FAILED) {
	                        if (input.charCodeAt(peg$currPos) === 43) {
	                            s2 = peg$c32;
	                            peg$currPos++;
	                        }
	                        else {
	                            s2 = peg$FAILED;
	                            {
	                                peg$fail(peg$c33);
	                            }
	                        }
	                        if (s2 === peg$FAILED) {
	                            if (input.charCodeAt(peg$currPos) === 36) {
	                                s2 = peg$c34;
	                                peg$currPos++;
	                            }
	                            else {
	                                s2 = peg$FAILED;
	                                {
	                                    peg$fail(peg$c35);
	                                }
	                            }
	                            if (s2 === peg$FAILED) {
	                                if (input.charCodeAt(peg$currPos) === 44) {
	                                    s2 = peg$c36;
	                                    peg$currPos++;
	                                }
	                                else {
	                                    s2 = peg$FAILED;
	                                    {
	                                        peg$fail(peg$c37);
	                                    }
	                                }
	                            }
	                        }
	                    }
	                }
	            }
	        }
	        while (s2 !== peg$FAILED) {
	            s1.push(s2);
	            s2 = peg$parseunreserved();
	            if (s2 === peg$FAILED) {
	                s2 = peg$parseescaped();
	                if (s2 === peg$FAILED) {
	                    if (input.charCodeAt(peg$currPos) === 38) {
	                        s2 = peg$c28;
	                        peg$currPos++;
	                    }
	                    else {
	                        s2 = peg$FAILED;
	                        {
	                            peg$fail(peg$c29);
	                        }
	                    }
	                    if (s2 === peg$FAILED) {
	                        if (input.charCodeAt(peg$currPos) === 61) {
	                            s2 = peg$c30;
	                            peg$currPos++;
	                        }
	                        else {
	                            s2 = peg$FAILED;
	                            {
	                                peg$fail(peg$c31);
	                            }
	                        }
	                        if (s2 === peg$FAILED) {
	                            if (input.charCodeAt(peg$currPos) === 43) {
	                                s2 = peg$c32;
	                                peg$currPos++;
	                            }
	                            else {
	                                s2 = peg$FAILED;
	                                {
	                                    peg$fail(peg$c33);
	                                }
	                            }
	                            if (s2 === peg$FAILED) {
	                                if (input.charCodeAt(peg$currPos) === 36) {
	                                    s2 = peg$c34;
	                                    peg$currPos++;
	                                }
	                                else {
	                                    s2 = peg$FAILED;
	                                    {
	                                        peg$fail(peg$c35);
	                                    }
	                                }
	                                if (s2 === peg$FAILED) {
	                                    if (input.charCodeAt(peg$currPos) === 44) {
	                                        s2 = peg$c36;
	                                        peg$currPos++;
	                                    }
	                                    else {
	                                        s2 = peg$FAILED;
	                                        {
	                                            peg$fail(peg$c37);
	                                        }
	                                    }
	                                }
	                            }
	                        }
	                    }
	                }
	            }
	        }
	        if (s1 !== peg$FAILED) {
	            peg$savedPos = s0;
	            s1 = peg$c118();
	        }
	        s0 = s1;
	        return s0;
	    }
	    function peg$parsehostport() {
	        var s0, s1, s2, s3, s4;
	        s0 = peg$currPos;
	        s1 = peg$parsehost();
	        if (s1 !== peg$FAILED) {
	            s2 = peg$currPos;
	            if (input.charCodeAt(peg$currPos) === 58) {
	                s3 = peg$c24;
	                peg$currPos++;
	            }
	            else {
	                s3 = peg$FAILED;
	                {
	                    peg$fail(peg$c25);
	                }
	            }
	            if (s3 !== peg$FAILED) {
	                s4 = peg$parseport();
	                if (s4 !== peg$FAILED) {
	                    s3 = [s3, s4];
	                    s2 = s3;
	                }
	                else {
	                    peg$currPos = s2;
	                    s2 = peg$FAILED;
	                }
	            }
	            else {
	                peg$currPos = s2;
	                s2 = peg$FAILED;
	            }
	            if (s2 === peg$FAILED) {
	                s2 = null;
	            }
	            if (s2 !== peg$FAILED) {
	                s1 = [s1, s2];
	                s0 = s1;
	            }
	            else {
	                peg$currPos = s0;
	                s0 = peg$FAILED;
	            }
	        }
	        else {
	            peg$currPos = s0;
	            s0 = peg$FAILED;
	        }
	        return s0;
	    }
	    function peg$parsehost() {
	        var s0, s1;
	        s0 = peg$currPos;
	        s1 = peg$parsehostname();
	        if (s1 === peg$FAILED) {
	            s1 = peg$parseIPv4address();
	            if (s1 === peg$FAILED) {
	                s1 = peg$parseIPv6reference();
	            }
	        }
	        if (s1 !== peg$FAILED) {
	            peg$savedPos = s0;
	            s1 = peg$c119();
	        }
	        s0 = s1;
	        return s0;
	    }
	    function peg$parsehostname() {
	        var s0, s1, s2, s3, s4;
	        s0 = peg$currPos;
	        s1 = [];
	        s2 = peg$currPos;
	        s3 = peg$parsedomainlabel();
	        if (s3 !== peg$FAILED) {
	            if (input.charCodeAt(peg$currPos) === 46) {
	                s4 = peg$c42;
	                peg$currPos++;
	            }
	            else {
	                s4 = peg$FAILED;
	                {
	                    peg$fail(peg$c43);
	                }
	            }
	            if (s4 !== peg$FAILED) {
	                s3 = [s3, s4];
	                s2 = s3;
	            }
	            else {
	                peg$currPos = s2;
	                s2 = peg$FAILED;
	            }
	        }
	        else {
	            peg$currPos = s2;
	            s2 = peg$FAILED;
	        }
	        while (s2 !== peg$FAILED) {
	            s1.push(s2);
	            s2 = peg$currPos;
	            s3 = peg$parsedomainlabel();
	            if (s3 !== peg$FAILED) {
	                if (input.charCodeAt(peg$currPos) === 46) {
	                    s4 = peg$c42;
	                    peg$currPos++;
	                }
	                else {
	                    s4 = peg$FAILED;
	                    {
	                        peg$fail(peg$c43);
	                    }
	                }
	                if (s4 !== peg$FAILED) {
	                    s3 = [s3, s4];
	                    s2 = s3;
	                }
	                else {
	                    peg$currPos = s2;
	                    s2 = peg$FAILED;
	                }
	            }
	            else {
	                peg$currPos = s2;
	                s2 = peg$FAILED;
	            }
	        }
	        if (s1 !== peg$FAILED) {
	            s2 = peg$parsetoplabel();
	            if (s2 !== peg$FAILED) {
	                if (input.charCodeAt(peg$currPos) === 46) {
	                    s3 = peg$c42;
	                    peg$currPos++;
	                }
	                else {
	                    s3 = peg$FAILED;
	                    {
	                        peg$fail(peg$c43);
	                    }
	                }
	                if (s3 === peg$FAILED) {
	                    s3 = null;
	                }
	                if (s3 !== peg$FAILED) {
	                    peg$savedPos = s0;
	                    s1 = peg$c120();
	                    s0 = s1;
	                }
	                else {
	                    peg$currPos = s0;
	                    s0 = peg$FAILED;
	                }
	            }
	            else {
	                peg$currPos = s0;
	                s0 = peg$FAILED;
	            }
	        }
	        else {
	            peg$currPos = s0;
	            s0 = peg$FAILED;
	        }
	        return s0;
	    }
	    function peg$parsedomainlabel() {
	        var s0, s1;
	        s0 = [];
	        if (peg$c121.test(input.charAt(peg$currPos))) {
	            s1 = input.charAt(peg$currPos);
	            peg$currPos++;
	        }
	        else {
	            s1 = peg$FAILED;
	            {
	                peg$fail(peg$c122);
	            }
	        }
	        if (s1 !== peg$FAILED) {
	            while (s1 !== peg$FAILED) {
	                s0.push(s1);
	                if (peg$c121.test(input.charAt(peg$currPos))) {
	                    s1 = input.charAt(peg$currPos);
	                    peg$currPos++;
	                }
	                else {
	                    s1 = peg$FAILED;
	                    {
	                        peg$fail(peg$c122);
	                    }
	                }
	            }
	        }
	        else {
	            s0 = peg$FAILED;
	        }
	        return s0;
	    }
	    function peg$parsetoplabel() {
	        var s0, s1, s2, s3;
	        s0 = peg$currPos;
	        if (peg$c4.test(input.charAt(peg$currPos))) {
	            s1 = input.charAt(peg$currPos);
	            peg$currPos++;
	        }
	        else {
	            s1 = peg$FAILED;
	            {
	                peg$fail(peg$c5);
	            }
	        }
	        if (s1 !== peg$FAILED) {
	            s2 = [];
	            if (peg$c123.test(input.charAt(peg$currPos))) {
	                s3 = input.charAt(peg$currPos);
	                peg$currPos++;
	            }
	            else {
	                s3 = peg$FAILED;
	                {
	                    peg$fail(peg$c124);
	                }
	            }
	            while (s3 !== peg$FAILED) {
	                s2.push(s3);
	                if (peg$c123.test(input.charAt(peg$currPos))) {
	                    s3 = input.charAt(peg$currPos);
	                    peg$currPos++;
	                }
	                else {
	                    s3 = peg$FAILED;
	                    {
	                        peg$fail(peg$c124);
	                    }
	                }
	            }
	            if (s2 !== peg$FAILED) {
	                s1 = [s1, s2];
	                s0 = s1;
	            }
	            else {
	                peg$currPos = s0;
	                s0 = peg$FAILED;
	            }
	        }
	        else {
	            peg$currPos = s0;
	            s0 = peg$FAILED;
	        }
	        return s0;
	    }
	    function peg$parseIPv6reference() {
	        var s0, s1, s2, s3;
	        s0 = peg$currPos;
	        if (input.charCodeAt(peg$currPos) === 91) {
	            s1 = peg$c76;
	            peg$currPos++;
	        }
	        else {
	            s1 = peg$FAILED;
	            {
	                peg$fail(peg$c77);
	            }
	        }
	        if (s1 !== peg$FAILED) {
	            s2 = peg$parseIPv6address();
	            if (s2 !== peg$FAILED) {
	                if (input.charCodeAt(peg$currPos) === 93) {
	                    s3 = peg$c78;
	                    peg$currPos++;
	                }
	                else {
	                    s3 = peg$FAILED;
	                    {
	                        peg$fail(peg$c79);
	                    }
	                }
	                if (s3 !== peg$FAILED) {
	                    peg$savedPos = s0;
	                    s1 = peg$c125();
	                    s0 = s1;
	                }
	                else {
	                    peg$currPos = s0;
	                    s0 = peg$FAILED;
	                }
	            }
	            else {
	                peg$currPos = s0;
	                s0 = peg$FAILED;
	            }
	        }
	        else {
	            peg$currPos = s0;
	            s0 = peg$FAILED;
	        }
	        return s0;
	    }
	    function peg$parseIPv6address() {
	        var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13, s14;
	        s0 = peg$currPos;
	        s1 = peg$currPos;
	        s2 = peg$parseh16();
	        if (s2 !== peg$FAILED) {
	            if (input.charCodeAt(peg$currPos) === 58) {
	                s3 = peg$c24;
	                peg$currPos++;
	            }
	            else {
	                s3 = peg$FAILED;
	                {
	                    peg$fail(peg$c25);
	                }
	            }
	            if (s3 !== peg$FAILED) {
	                s4 = peg$parseh16();
	                if (s4 !== peg$FAILED) {
	                    if (input.charCodeAt(peg$currPos) === 58) {
	                        s5 = peg$c24;
	                        peg$currPos++;
	                    }
	                    else {
	                        s5 = peg$FAILED;
	                        {
	                            peg$fail(peg$c25);
	                        }
	                    }
	                    if (s5 !== peg$FAILED) {
	                        s6 = peg$parseh16();
	                        if (s6 !== peg$FAILED) {
	                            if (input.charCodeAt(peg$currPos) === 58) {
	                                s7 = peg$c24;
	                                peg$currPos++;
	                            }
	                            else {
	                                s7 = peg$FAILED;
	                                {
	                                    peg$fail(peg$c25);
	                                }
	                            }
	                            if (s7 !== peg$FAILED) {
	                                s8 = peg$parseh16();
	                                if (s8 !== peg$FAILED) {
	                                    if (input.charCodeAt(peg$currPos) === 58) {
	                                        s9 = peg$c24;
	                                        peg$currPos++;
	                                    }
	                                    else {
	                                        s9 = peg$FAILED;
	                                        {
	                                            peg$fail(peg$c25);
	                                        }
	                                    }
	                                    if (s9 !== peg$FAILED) {
	                                        s10 = peg$parseh16();
	                                        if (s10 !== peg$FAILED) {
	                                            if (input.charCodeAt(peg$currPos) === 58) {
	                                                s11 = peg$c24;
	                                                peg$currPos++;
	                                            }
	                                            else {
	                                                s11 = peg$FAILED;
	                                                {
	                                                    peg$fail(peg$c25);
	                                                }
	                                            }
	                                            if (s11 !== peg$FAILED) {
	                                                s12 = peg$parseh16();
	                                                if (s12 !== peg$FAILED) {
	                                                    if (input.charCodeAt(peg$currPos) === 58) {
	                                                        s13 = peg$c24;
	                                                        peg$currPos++;
	                                                    }
	                                                    else {
	                                                        s13 = peg$FAILED;
	                                                        {
	                                                            peg$fail(peg$c25);
	                                                        }
	                                                    }
	                                                    if (s13 !== peg$FAILED) {
	                                                        s14 = peg$parsels32();
	                                                        if (s14 !== peg$FAILED) {
	                                                            s2 = [s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13, s14];
	                                                            s1 = s2;
	                                                        }
	                                                        else {
	                                                            peg$currPos = s1;
	                                                            s1 = peg$FAILED;
	                                                        }
	                                                    }
	                                                    else {
	                                                        peg$currPos = s1;
	                                                        s1 = peg$FAILED;
	                                                    }
	                                                }
	                                                else {
	                                                    peg$currPos = s1;
	                                                    s1 = peg$FAILED;
	                                                }
	                                            }
	                                            else {
	                                                peg$currPos = s1;
	                                                s1 = peg$FAILED;
	                                            }
	                                        }
	                                        else {
	                                            peg$currPos = s1;
	                                            s1 = peg$FAILED;
	                                        }
	                                    }
	                                    else {
	                                        peg$currPos = s1;
	                                        s1 = peg$FAILED;
	                                    }
	                                }
	                                else {
	                                    peg$currPos = s1;
	                                    s1 = peg$FAILED;
	                                }
	                            }
	                            else {
	                                peg$currPos = s1;
	                                s1 = peg$FAILED;
	                            }
	                        }
	                        else {
	                            peg$currPos = s1;
	                            s1 = peg$FAILED;
	                        }
	                    }
	                    else {
	                        peg$currPos = s1;
	                        s1 = peg$FAILED;
	                    }
	                }
	                else {
	                    peg$currPos = s1;
	                    s1 = peg$FAILED;
	                }
	            }
	            else {
	                peg$currPos = s1;
	                s1 = peg$FAILED;
	            }
	        }
	        else {
	            peg$currPos = s1;
	            s1 = peg$FAILED;
	        }
	        if (s1 === peg$FAILED) {
	            s1 = peg$currPos;
	            if (input.substr(peg$currPos, 2) === peg$c126) {
	                s2 = peg$c126;
	                peg$currPos += 2;
	            }
	            else {
	                s2 = peg$FAILED;
	                {
	                    peg$fail(peg$c127);
	                }
	            }
	            if (s2 !== peg$FAILED) {
	                s3 = peg$parseh16();
	                if (s3 !== peg$FAILED) {
	                    if (input.charCodeAt(peg$currPos) === 58) {
	                        s4 = peg$c24;
	                        peg$currPos++;
	                    }
	                    else {
	                        s4 = peg$FAILED;
	                        {
	                            peg$fail(peg$c25);
	                        }
	                    }
	                    if (s4 !== peg$FAILED) {
	                        s5 = peg$parseh16();
	                        if (s5 !== peg$FAILED) {
	                            if (input.charCodeAt(peg$currPos) === 58) {
	                                s6 = peg$c24;
	                                peg$currPos++;
	                            }
	                            else {
	                                s6 = peg$FAILED;
	                                {
	                                    peg$fail(peg$c25);
	                                }
	                            }
	                            if (s6 !== peg$FAILED) {
	                                s7 = peg$parseh16();
	                                if (s7 !== peg$FAILED) {
	                                    if (input.charCodeAt(peg$currPos) === 58) {
	                                        s8 = peg$c24;
	                                        peg$currPos++;
	                                    }
	                                    else {
	                                        s8 = peg$FAILED;
	                                        {
	                                            peg$fail(peg$c25);
	                                        }
	                                    }
	                                    if (s8 !== peg$FAILED) {
	                                        s9 = peg$parseh16();
	                                        if (s9 !== peg$FAILED) {
	                                            if (input.charCodeAt(peg$currPos) === 58) {
	                                                s10 = peg$c24;
	                                                peg$currPos++;
	                                            }
	                                            else {
	                                                s10 = peg$FAILED;
	                                                {
	                                                    peg$fail(peg$c25);
	                                                }
	                                            }
	                                            if (s10 !== peg$FAILED) {
	                                                s11 = peg$parseh16();
	                                                if (s11 !== peg$FAILED) {
	                                                    if (input.charCodeAt(peg$currPos) === 58) {
	                                                        s12 = peg$c24;
	                                                        peg$currPos++;
	                                                    }
	                                                    else {
	                                                        s12 = peg$FAILED;
	                                                        {
	                                                            peg$fail(peg$c25);
	                                                        }
	                                                    }
	                                                    if (s12 !== peg$FAILED) {
	                                                        s13 = peg$parsels32();
	                                                        if (s13 !== peg$FAILED) {
	                                                            s2 = [s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13];
	                                                            s1 = s2;
	                                                        }
	                                                        else {
	                                                            peg$currPos = s1;
	                                                            s1 = peg$FAILED;
	                                                        }
	                                                    }
	                                                    else {
	                                                        peg$currPos = s1;
	                                                        s1 = peg$FAILED;
	                                                    }
	                                                }
	                                                else {
	                                                    peg$currPos = s1;
	                                                    s1 = peg$FAILED;
	                                                }
	                                            }
	                                            else {
	                                                peg$currPos = s1;
	                                                s1 = peg$FAILED;
	                                            }
	                                        }
	                                        else {
	                                            peg$currPos = s1;
	                                            s1 = peg$FAILED;
	                                        }
	                                    }
	                                    else {
	                                        peg$currPos = s1;
	                                        s1 = peg$FAILED;
	                                    }
	                                }
	                                else {
	                                    peg$currPos = s1;
	                                    s1 = peg$FAILED;
	                                }
	                            }
	                            else {
	                                peg$currPos = s1;
	                                s1 = peg$FAILED;
	                            }
	                        }
	                        else {
	                            peg$currPos = s1;
	                            s1 = peg$FAILED;
	                        }
	                    }
	                    else {
	                        peg$currPos = s1;
	                        s1 = peg$FAILED;
	                    }
	                }
	                else {
	                    peg$currPos = s1;
	                    s1 = peg$FAILED;
	                }
	            }
	            else {
	                peg$currPos = s1;
	                s1 = peg$FAILED;
	            }
	            if (s1 === peg$FAILED) {
	                s1 = peg$currPos;
	                if (input.substr(peg$currPos, 2) === peg$c126) {
	                    s2 = peg$c126;
	                    peg$currPos += 2;
	                }
	                else {
	                    s2 = peg$FAILED;
	                    {
	                        peg$fail(peg$c127);
	                    }
	                }
	                if (s2 !== peg$FAILED) {
	                    s3 = peg$parseh16();
	                    if (s3 !== peg$FAILED) {
	                        if (input.charCodeAt(peg$currPos) === 58) {
	                            s4 = peg$c24;
	                            peg$currPos++;
	                        }
	                        else {
	                            s4 = peg$FAILED;
	                            {
	                                peg$fail(peg$c25);
	                            }
	                        }
	                        if (s4 !== peg$FAILED) {
	                            s5 = peg$parseh16();
	                            if (s5 !== peg$FAILED) {
	                                if (input.charCodeAt(peg$currPos) === 58) {
	                                    s6 = peg$c24;
	                                    peg$currPos++;
	                                }
	                                else {
	                                    s6 = peg$FAILED;
	                                    {
	                                        peg$fail(peg$c25);
	                                    }
	                                }
	                                if (s6 !== peg$FAILED) {
	                                    s7 = peg$parseh16();
	                                    if (s7 !== peg$FAILED) {
	                                        if (input.charCodeAt(peg$currPos) === 58) {
	                                            s8 = peg$c24;
	                                            peg$currPos++;
	                                        }
	                                        else {
	                                            s8 = peg$FAILED;
	                                            {
	                                                peg$fail(peg$c25);
	                                            }
	                                        }
	                                        if (s8 !== peg$FAILED) {
	                                            s9 = peg$parseh16();
	                                            if (s9 !== peg$FAILED) {
	                                                if (input.charCodeAt(peg$currPos) === 58) {
	                                                    s10 = peg$c24;
	                                                    peg$currPos++;
	                                                }
	                                                else {
	                                                    s10 = peg$FAILED;
	                                                    {
	                                                        peg$fail(peg$c25);
	                                                    }
	                                                }
	                                                if (s10 !== peg$FAILED) {
	                                                    s11 = peg$parsels32();
	                                                    if (s11 !== peg$FAILED) {
	                                                        s2 = [s2, s3, s4, s5, s6, s7, s8, s9, s10, s11];
	                                                        s1 = s2;
	                                                    }
	                                                    else {
	                                                        peg$currPos = s1;
	                                                        s1 = peg$FAILED;
	                                                    }
	                                                }
	                                                else {
	                                                    peg$currPos = s1;
	                                                    s1 = peg$FAILED;
	                                                }
	                                            }
	                                            else {
	                                                peg$currPos = s1;
	                                                s1 = peg$FAILED;
	                                            }
	                                        }
	                                        else {
	                                            peg$currPos = s1;
	                                            s1 = peg$FAILED;
	                                        }
	                                    }
	                                    else {
	                                        peg$currPos = s1;
	                                        s1 = peg$FAILED;
	                                    }
	                                }
	                                else {
	                                    peg$currPos = s1;
	                                    s1 = peg$FAILED;
	                                }
	                            }
	                            else {
	                                peg$currPos = s1;
	                                s1 = peg$FAILED;
	                            }
	                        }
	                        else {
	                            peg$currPos = s1;
	                            s1 = peg$FAILED;
	                        }
	                    }
	                    else {
	                        peg$currPos = s1;
	                        s1 = peg$FAILED;
	                    }
	                }
	                else {
	                    peg$currPos = s1;
	                    s1 = peg$FAILED;
	                }
	                if (s1 === peg$FAILED) {
	                    s1 = peg$currPos;
	                    if (input.substr(peg$currPos, 2) === peg$c126) {
	                        s2 = peg$c126;
	                        peg$currPos += 2;
	                    }
	                    else {
	                        s2 = peg$FAILED;
	                        {
	                            peg$fail(peg$c127);
	                        }
	                    }
	                    if (s2 !== peg$FAILED) {
	                        s3 = peg$parseh16();
	                        if (s3 !== peg$FAILED) {
	                            if (input.charCodeAt(peg$currPos) === 58) {
	                                s4 = peg$c24;
	                                peg$currPos++;
	                            }
	                            else {
	                                s4 = peg$FAILED;
	                                {
	                                    peg$fail(peg$c25);
	                                }
	                            }
	                            if (s4 !== peg$FAILED) {
	                                s5 = peg$parseh16();
	                                if (s5 !== peg$FAILED) {
	                                    if (input.charCodeAt(peg$currPos) === 58) {
	                                        s6 = peg$c24;
	                                        peg$currPos++;
	                                    }
	                                    else {
	                                        s6 = peg$FAILED;
	                                        {
	                                            peg$fail(peg$c25);
	                                        }
	                                    }
	                                    if (s6 !== peg$FAILED) {
	                                        s7 = peg$parseh16();
	                                        if (s7 !== peg$FAILED) {
	                                            if (input.charCodeAt(peg$currPos) === 58) {
	                                                s8 = peg$c24;
	                                                peg$currPos++;
	                                            }
	                                            else {
	                                                s8 = peg$FAILED;
	                                                {
	                                                    peg$fail(peg$c25);
	                                                }
	                                            }
	                                            if (s8 !== peg$FAILED) {
	                                                s9 = peg$parsels32();
	                                                if (s9 !== peg$FAILED) {
	                                                    s2 = [s2, s3, s4, s5, s6, s7, s8, s9];
	                                                    s1 = s2;
	                                                }
	                                                else {
	                                                    peg$currPos = s1;
	                                                    s1 = peg$FAILED;
	                                                }
	                                            }
	                                            else {
	                                                peg$currPos = s1;
	                                                s1 = peg$FAILED;
	                                            }
	                                        }
	                                        else {
	                                            peg$currPos = s1;
	                                            s1 = peg$FAILED;
	                                        }
	                                    }
	                                    else {
	                                        peg$currPos = s1;
	                                        s1 = peg$FAILED;
	                                    }
	                                }
	                                else {
	                                    peg$currPos = s1;
	                                    s1 = peg$FAILED;
	                                }
	                            }
	                            else {
	                                peg$currPos = s1;
	                                s1 = peg$FAILED;
	                            }
	                        }
	                        else {
	                            peg$currPos = s1;
	                            s1 = peg$FAILED;
	                        }
	                    }
	                    else {
	                        peg$currPos = s1;
	                        s1 = peg$FAILED;
	                    }
	                    if (s1 === peg$FAILED) {
	                        s1 = peg$currPos;
	                        if (input.substr(peg$currPos, 2) === peg$c126) {
	                            s2 = peg$c126;
	                            peg$currPos += 2;
	                        }
	                        else {
	                            s2 = peg$FAILED;
	                            {
	                                peg$fail(peg$c127);
	                            }
	                        }
	                        if (s2 !== peg$FAILED) {
	                            s3 = peg$parseh16();
	                            if (s3 !== peg$FAILED) {
	                                if (input.charCodeAt(peg$currPos) === 58) {
	                                    s4 = peg$c24;
	                                    peg$currPos++;
	                                }
	                                else {
	                                    s4 = peg$FAILED;
	                                    {
	                                        peg$fail(peg$c25);
	                                    }
	                                }
	                                if (s4 !== peg$FAILED) {
	                                    s5 = peg$parseh16();
	                                    if (s5 !== peg$FAILED) {
	                                        if (input.charCodeAt(peg$currPos) === 58) {
	                                            s6 = peg$c24;
	                                            peg$currPos++;
	                                        }
	                                        else {
	                                            s6 = peg$FAILED;
	                                            {
	                                                peg$fail(peg$c25);
	                                            }
	                                        }
	                                        if (s6 !== peg$FAILED) {
	                                            s7 = peg$parsels32();
	                                            if (s7 !== peg$FAILED) {
	                                                s2 = [s2, s3, s4, s5, s6, s7];
	                                                s1 = s2;
	                                            }
	                                            else {
	                                                peg$currPos = s1;
	                                                s1 = peg$FAILED;
	                                            }
	                                        }
	                                        else {
	                                            peg$currPos = s1;
	                                            s1 = peg$FAILED;
	                                        }
	                                    }
	                                    else {
	                                        peg$currPos = s1;
	                                        s1 = peg$FAILED;
	                                    }
	                                }
	                                else {
	                                    peg$currPos = s1;
	                                    s1 = peg$FAILED;
	                                }
	                            }
	                            else {
	                                peg$currPos = s1;
	                                s1 = peg$FAILED;
	                            }
	                        }
	                        else {
	                            peg$currPos = s1;
	                            s1 = peg$FAILED;
	                        }
	                        if (s1 === peg$FAILED) {
	                            s1 = peg$currPos;
	                            if (input.substr(peg$currPos, 2) === peg$c126) {
	                                s2 = peg$c126;
	                                peg$currPos += 2;
	                            }
	                            else {
	                                s2 = peg$FAILED;
	                                {
	                                    peg$fail(peg$c127);
	                                }
	                            }
	                            if (s2 !== peg$FAILED) {
	                                s3 = peg$parseh16();
	                                if (s3 !== peg$FAILED) {
	                                    if (input.charCodeAt(peg$currPos) === 58) {
	                                        s4 = peg$c24;
	                                        peg$currPos++;
	                                    }
	                                    else {
	                                        s4 = peg$FAILED;
	                                        {
	                                            peg$fail(peg$c25);
	                                        }
	                                    }
	                                    if (s4 !== peg$FAILED) {
	                                        s5 = peg$parsels32();
	                                        if (s5 !== peg$FAILED) {
	                                            s2 = [s2, s3, s4, s5];
	                                            s1 = s2;
	                                        }
	                                        else {
	                                            peg$currPos = s1;
	                                            s1 = peg$FAILED;
	                                        }
	                                    }
	                                    else {
	                                        peg$currPos = s1;
	                                        s1 = peg$FAILED;
	                                    }
	                                }
	                                else {
	                                    peg$currPos = s1;
	                                    s1 = peg$FAILED;
	                                }
	                            }
	                            else {
	                                peg$currPos = s1;
	                                s1 = peg$FAILED;
	                            }
	                            if (s1 === peg$FAILED) {
	                                s1 = peg$currPos;
	                                if (input.substr(peg$currPos, 2) === peg$c126) {
	                                    s2 = peg$c126;
	                                    peg$currPos += 2;
	                                }
	                                else {
	                                    s2 = peg$FAILED;
	                                    {
	                                        peg$fail(peg$c127);
	                                    }
	                                }
	                                if (s2 !== peg$FAILED) {
	                                    s3 = peg$parsels32();
	                                    if (s3 !== peg$FAILED) {
	                                        s2 = [s2, s3];
	                                        s1 = s2;
	                                    }
	                                    else {
	                                        peg$currPos = s1;
	                                        s1 = peg$FAILED;
	                                    }
	                                }
	                                else {
	                                    peg$currPos = s1;
	                                    s1 = peg$FAILED;
	                                }
	                                if (s1 === peg$FAILED) {
	                                    s1 = peg$currPos;
	                                    if (input.substr(peg$currPos, 2) === peg$c126) {
	                                        s2 = peg$c126;
	                                        peg$currPos += 2;
	                                    }
	                                    else {
	                                        s2 = peg$FAILED;
	                                        {
	                                            peg$fail(peg$c127);
	                                        }
	                                    }
	                                    if (s2 !== peg$FAILED) {
	                                        s3 = peg$parseh16();
	                                        if (s3 !== peg$FAILED) {
	                                            s2 = [s2, s3];
	                                            s1 = s2;
	                                        }
	                                        else {
	                                            peg$currPos = s1;
	                                            s1 = peg$FAILED;
	                                        }
	                                    }
	                                    else {
	                                        peg$currPos = s1;
	                                        s1 = peg$FAILED;
	                                    }
	                                    if (s1 === peg$FAILED) {
	                                        s1 = peg$currPos;
	                                        s2 = peg$parseh16();
	                                        if (s2 !== peg$FAILED) {
	                                            if (input.substr(peg$currPos, 2) === peg$c126) {
	                                                s3 = peg$c126;
	                                                peg$currPos += 2;
	                                            }
	                                            else {
	                                                s3 = peg$FAILED;
	                                                {
	                                                    peg$fail(peg$c127);
	                                                }
	                                            }
	                                            if (s3 !== peg$FAILED) {
	                                                s4 = peg$parseh16();
	                                                if (s4 !== peg$FAILED) {
	                                                    if (input.charCodeAt(peg$currPos) === 58) {
	                                                        s5 = peg$c24;
	                                                        peg$currPos++;
	                                                    }
	                                                    else {
	                                                        s5 = peg$FAILED;
	                                                        {
	                                                            peg$fail(peg$c25);
	                                                        }
	                                                    }
	                                                    if (s5 !== peg$FAILED) {
	                                                        s6 = peg$parseh16();
	                                                        if (s6 !== peg$FAILED) {
	                                                            if (input.charCodeAt(peg$currPos) === 58) {
	                                                                s7 = peg$c24;
	                                                                peg$currPos++;
	                                                            }
	                                                            else {
	                                                                s7 = peg$FAILED;
	                                                                {
	                                                                    peg$fail(peg$c25);
	                                                                }
	                                                            }
	                                                            if (s7 !== peg$FAILED) {
	                                                                s8 = peg$parseh16();
	                                                                if (s8 !== peg$FAILED) {
	                                                                    if (input.charCodeAt(peg$currPos) === 58) {
	                                                                        s9 = peg$c24;
	                                                                        peg$currPos++;
	                                                                    }
	                                                                    else {
	                                                                        s9 = peg$FAILED;
	                                                                        {
	                                                                            peg$fail(peg$c25);
	                                                                        }
	                                                                    }
	                                                                    if (s9 !== peg$FAILED) {
	                                                                        s10 = peg$parseh16();
	                                                                        if (s10 !== peg$FAILED) {
	                                                                            if (input.charCodeAt(peg$currPos) === 58) {
	                                                                                s11 = peg$c24;
	                                                                                peg$currPos++;
	                                                                            }
	                                                                            else {
	                                                                                s11 = peg$FAILED;
	                                                                                {
	                                                                                    peg$fail(peg$c25);
	                                                                                }
	                                                                            }
	                                                                            if (s11 !== peg$FAILED) {
	                                                                                s12 = peg$parsels32();
	                                                                                if (s12 !== peg$FAILED) {
	                                                                                    s2 = [s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12];
	                                                                                    s1 = s2;
	                                                                                }
	                                                                                else {
	                                                                                    peg$currPos = s1;
	                                                                                    s1 = peg$FAILED;
	                                                                                }
	                                                                            }
	                                                                            else {
	                                                                                peg$currPos = s1;
	                                                                                s1 = peg$FAILED;
	                                                                            }
	                                                                        }
	                                                                        else {
	                                                                            peg$currPos = s1;
	                                                                            s1 = peg$FAILED;
	                                                                        }
	                                                                    }
	                                                                    else {
	                                                                        peg$currPos = s1;
	                                                                        s1 = peg$FAILED;
	                                                                    }
	                                                                }
	                                                                else {
	                                                                    peg$currPos = s1;
	                                                                    s1 = peg$FAILED;
	                                                                }
	                                                            }
	                                                            else {
	                                                                peg$currPos = s1;
	                                                                s1 = peg$FAILED;
	                                                            }
	                                                        }
	                                                        else {
	                                                            peg$currPos = s1;
	                                                            s1 = peg$FAILED;
	                                                        }
	                                                    }
	                                                    else {
	                                                        peg$currPos = s1;
	                                                        s1 = peg$FAILED;
	                                                    }
	                                                }
	                                                else {
	                                                    peg$currPos = s1;
	                                                    s1 = peg$FAILED;
	                                                }
	                                            }
	                                            else {
	                                                peg$currPos = s1;
	                                                s1 = peg$FAILED;
	                                            }
	                                        }
	                                        else {
	                                            peg$currPos = s1;
	                                            s1 = peg$FAILED;
	                                        }
	                                        if (s1 === peg$FAILED) {
	                                            s1 = peg$currPos;
	                                            s2 = peg$parseh16();
	                                            if (s2 !== peg$FAILED) {
	                                                s3 = peg$currPos;
	                                                if (input.charCodeAt(peg$currPos) === 58) {
	                                                    s4 = peg$c24;
	                                                    peg$currPos++;
	                                                }
	                                                else {
	                                                    s4 = peg$FAILED;
	                                                    {
	                                                        peg$fail(peg$c25);
	                                                    }
	                                                }
	                                                if (s4 !== peg$FAILED) {
	                                                    s5 = peg$parseh16();
	                                                    if (s5 !== peg$FAILED) {
	                                                        s4 = [s4, s5];
	                                                        s3 = s4;
	                                                    }
	                                                    else {
	                                                        peg$currPos = s3;
	                                                        s3 = peg$FAILED;
	                                                    }
	                                                }
	                                                else {
	                                                    peg$currPos = s3;
	                                                    s3 = peg$FAILED;
	                                                }
	                                                if (s3 === peg$FAILED) {
	                                                    s3 = null;
	                                                }
	                                                if (s3 !== peg$FAILED) {
	                                                    if (input.substr(peg$currPos, 2) === peg$c126) {
	                                                        s4 = peg$c126;
	                                                        peg$currPos += 2;
	                                                    }
	                                                    else {
	                                                        s4 = peg$FAILED;
	                                                        {
	                                                            peg$fail(peg$c127);
	                                                        }
	                                                    }
	                                                    if (s4 !== peg$FAILED) {
	                                                        s5 = peg$parseh16();
	                                                        if (s5 !== peg$FAILED) {
	                                                            if (input.charCodeAt(peg$currPos) === 58) {
	                                                                s6 = peg$c24;
	                                                                peg$currPos++;
	                                                            }
	                                                            else {
	                                                                s6 = peg$FAILED;
	                                                                {
	                                                                    peg$fail(peg$c25);
	                                                                }
	                                                            }
	                                                            if (s6 !== peg$FAILED) {
	                                                                s7 = peg$parseh16();
	                                                                if (s7 !== peg$FAILED) {
	                                                                    if (input.charCodeAt(peg$currPos) === 58) {
	                                                                        s8 = peg$c24;
	                                                                        peg$currPos++;
	                                                                    }
	                                                                    else {
	                                                                        s8 = peg$FAILED;
	                                                                        {
	                                                                            peg$fail(peg$c25);
	                                                                        }
	                                                                    }
	                                                                    if (s8 !== peg$FAILED) {
	                                                                        s9 = peg$parseh16();
	                                                                        if (s9 !== peg$FAILED) {
	                                                                            if (input.charCodeAt(peg$currPos) === 58) {
	                                                                                s10 = peg$c24;
	                                                                                peg$currPos++;
	                                                                            }
	                                                                            else {
	                                                                                s10 = peg$FAILED;
	                                                                                {
	                                                                                    peg$fail(peg$c25);
	                                                                                }
	                                                                            }
	                                                                            if (s10 !== peg$FAILED) {
	                                                                                s11 = peg$parsels32();
	                                                                                if (s11 !== peg$FAILED) {
	                                                                                    s2 = [s2, s3, s4, s5, s6, s7, s8, s9, s10, s11];
	                                                                                    s1 = s2;
	                                                                                }
	                                                                                else {
	                                                                                    peg$currPos = s1;
	                                                                                    s1 = peg$FAILED;
	                                                                                }
	                                                                            }
	                                                                            else {
	                                                                                peg$currPos = s1;
	                                                                                s1 = peg$FAILED;
	                                                                            }
	                                                                        }
	                                                                        else {
	                                                                            peg$currPos = s1;
	                                                                            s1 = peg$FAILED;
	                                                                        }
	                                                                    }
	                                                                    else {
	                                                                        peg$currPos = s1;
	                                                                        s1 = peg$FAILED;
	                                                                    }
	                                                                }
	                                                                else {
	                                                                    peg$currPos = s1;
	                                                                    s1 = peg$FAILED;
	                                                                }
	                                                            }
	                                                            else {
	                                                                peg$currPos = s1;
	                                                                s1 = peg$FAILED;
	                                                            }
	                                                        }
	                                                        else {
	                                                            peg$currPos = s1;
	                                                            s1 = peg$FAILED;
	                                                        }
	                                                    }
	                                                    else {
	                                                        peg$currPos = s1;
	                                                        s1 = peg$FAILED;
	                                                    }
	                                                }
	                                                else {
	                                                    peg$currPos = s1;
	                                                    s1 = peg$FAILED;
	                                                }
	                                            }
	                                            else {
	                                                peg$currPos = s1;
	                                                s1 = peg$FAILED;
	                                            }
	                                            if (s1 === peg$FAILED) {
	                                                s1 = peg$currPos;
	                                                s2 = peg$parseh16();
	                                                if (s2 !== peg$FAILED) {
	                                                    s3 = peg$currPos;
	                                                    if (input.charCodeAt(peg$currPos) === 58) {
	                                                        s4 = peg$c24;
	                                                        peg$currPos++;
	                                                    }
	                                                    else {
	                                                        s4 = peg$FAILED;
	                                                        {
	                                                            peg$fail(peg$c25);
	                                                        }
	                                                    }
	                                                    if (s4 !== peg$FAILED) {
	                                                        s5 = peg$parseh16();
	                                                        if (s5 !== peg$FAILED) {
	                                                            s4 = [s4, s5];
	                                                            s3 = s4;
	                                                        }
	                                                        else {
	                                                            peg$currPos = s3;
	                                                            s3 = peg$FAILED;
	                                                        }
	                                                    }
	                                                    else {
	                                                        peg$currPos = s3;
	                                                        s3 = peg$FAILED;
	                                                    }
	                                                    if (s3 === peg$FAILED) {
	                                                        s3 = null;
	                                                    }
	                                                    if (s3 !== peg$FAILED) {
	                                                        s4 = peg$currPos;
	                                                        if (input.charCodeAt(peg$currPos) === 58) {
	                                                            s5 = peg$c24;
	                                                            peg$currPos++;
	                                                        }
	                                                        else {
	                                                            s5 = peg$FAILED;
	                                                            {
	                                                                peg$fail(peg$c25);
	                                                            }
	                                                        }
	                                                        if (s5 !== peg$FAILED) {
	                                                            s6 = peg$parseh16();
	                                                            if (s6 !== peg$FAILED) {
	                                                                s5 = [s5, s6];
	                                                                s4 = s5;
	                                                            }
	                                                            else {
	                                                                peg$currPos = s4;
	                                                                s4 = peg$FAILED;
	                                                            }
	                                                        }
	                                                        else {
	                                                            peg$currPos = s4;
	                                                            s4 = peg$FAILED;
	                                                        }
	                                                        if (s4 === peg$FAILED) {
	                                                            s4 = null;
	                                                        }
	                                                        if (s4 !== peg$FAILED) {
	                                                            if (input.substr(peg$currPos, 2) === peg$c126) {
	                                                                s5 = peg$c126;
	                                                                peg$currPos += 2;
	                                                            }
	                                                            else {
	                                                                s5 = peg$FAILED;
	                                                                {
	                                                                    peg$fail(peg$c127);
	                                                                }
	                                                            }
	                                                            if (s5 !== peg$FAILED) {
	                                                                s6 = peg$parseh16();
	                                                                if (s6 !== peg$FAILED) {
	                                                                    if (input.charCodeAt(peg$currPos) === 58) {
	                                                                        s7 = peg$c24;
	                                                                        peg$currPos++;
	                                                                    }
	                                                                    else {
	                                                                        s7 = peg$FAILED;
	                                                                        {
	                                                                            peg$fail(peg$c25);
	                                                                        }
	                                                                    }
	                                                                    if (s7 !== peg$FAILED) {
	                                                                        s8 = peg$parseh16();
	                                                                        if (s8 !== peg$FAILED) {
	                                                                            if (input.charCodeAt(peg$currPos) === 58) {
	                                                                                s9 = peg$c24;
	                                                                                peg$currPos++;
	                                                                            }
	                                                                            else {
	                                                                                s9 = peg$FAILED;
	                                                                                {
	                                                                                    peg$fail(peg$c25);
	                                                                                }
	                                                                            }
	                                                                            if (s9 !== peg$FAILED) {
	                                                                                s10 = peg$parsels32();
	                                                                                if (s10 !== peg$FAILED) {
	                                                                                    s2 = [s2, s3, s4, s5, s6, s7, s8, s9, s10];
	                                                                                    s1 = s2;
	                                                                                }
	                                                                                else {
	                                                                                    peg$currPos = s1;
	                                                                                    s1 = peg$FAILED;
	                                                                                }
	                                                                            }
	                                                                            else {
	                                                                                peg$currPos = s1;
	                                                                                s1 = peg$FAILED;
	                                                                            }
	                                                                        }
	                                                                        else {
	                                                                            peg$currPos = s1;
	                                                                            s1 = peg$FAILED;
	                                                                        }
	                                                                    }
	                                                                    else {
	                                                                        peg$currPos = s1;
	                                                                        s1 = peg$FAILED;
	                                                                    }
	                                                                }
	                                                                else {
	                                                                    peg$currPos = s1;
	                                                                    s1 = peg$FAILED;
	                                                                }
	                                                            }
	                                                            else {
	                                                                peg$currPos = s1;
	                                                                s1 = peg$FAILED;
	                                                            }
	                                                        }
	                                                        else {
	                                                            peg$currPos = s1;
	                                                            s1 = peg$FAILED;
	                                                        }
	                                                    }
	                                                    else {
	                                                        peg$currPos = s1;
	                                                        s1 = peg$FAILED;
	                                                    }
	                                                }
	                                                else {
	                                                    peg$currPos = s1;
	                                                    s1 = peg$FAILED;
	                                                }
	                                                if (s1 === peg$FAILED) {
	                                                    s1 = peg$currPos;
	                                                    s2 = peg$parseh16();
	                                                    if (s2 !== peg$FAILED) {
	                                                        s3 = peg$currPos;
	                                                        if (input.charCodeAt(peg$currPos) === 58) {
	                                                            s4 = peg$c24;
	                                                            peg$currPos++;
	                                                        }
	                                                        else {
	                                                            s4 = peg$FAILED;
	                                                            {
	                                                                peg$fail(peg$c25);
	                                                            }
	                                                        }
	                                                        if (s4 !== peg$FAILED) {
	                                                            s5 = peg$parseh16();
	                                                            if (s5 !== peg$FAILED) {
	                                                                s4 = [s4, s5];
	                                                                s3 = s4;
	                                                            }
	                                                            else {
	                                                                peg$currPos = s3;
	                                                                s3 = peg$FAILED;
	                                                            }
	                                                        }
	                                                        else {
	                                                            peg$currPos = s3;
	                                                            s3 = peg$FAILED;
	                                                        }
	                                                        if (s3 === peg$FAILED) {
	                                                            s3 = null;
	                                                        }
	                                                        if (s3 !== peg$FAILED) {
	                                                            s4 = peg$currPos;
	                                                            if (input.charCodeAt(peg$currPos) === 58) {
	                                                                s5 = peg$c24;
	                                                                peg$currPos++;
	                                                            }
	                                                            else {
	                                                                s5 = peg$FAILED;
	                                                                {
	                                                                    peg$fail(peg$c25);
	                                                                }
	                                                            }
	                                                            if (s5 !== peg$FAILED) {
	                                                                s6 = peg$parseh16();
	                                                                if (s6 !== peg$FAILED) {
	                                                                    s5 = [s5, s6];
	                                                                    s4 = s5;
	                                                                }
	                                                                else {
	                                                                    peg$currPos = s4;
	                                                                    s4 = peg$FAILED;
	                                                                }
	                                                            }
	                                                            else {
	                                                                peg$currPos = s4;
	                                                                s4 = peg$FAILED;
	                                                            }
	                                                            if (s4 === peg$FAILED) {
	                                                                s4 = null;
	                                                            }
	                                                            if (s4 !== peg$FAILED) {
	                                                                s5 = peg$currPos;
	                                                                if (input.charCodeAt(peg$currPos) === 58) {
	                                                                    s6 = peg$c24;
	                                                                    peg$currPos++;
	                                                                }
	                                                                else {
	                                                                    s6 = peg$FAILED;
	                                                                    {
	                                                                        peg$fail(peg$c25);
	                                                                    }
	                                                                }
	                                                                if (s6 !== peg$FAILED) {
	                                                                    s7 = peg$parseh16();
	                                                                    if (s7 !== peg$FAILED) {
	                                                                        s6 = [s6, s7];
	                                                                        s5 = s6;
	                                                                    }
	                                                                    else {
	                                                                        peg$currPos = s5;
	                                                                        s5 = peg$FAILED;
	                                                                    }
	                                                                }
	                                                                else {
	                                                                    peg$currPos = s5;
	                                                                    s5 = peg$FAILED;
	                                                                }
	                                                                if (s5 === peg$FAILED) {
	                                                                    s5 = null;
	                                                                }
	                                                                if (s5 !== peg$FAILED) {
	                                                                    if (input.substr(peg$currPos, 2) === peg$c126) {
	                                                                        s6 = peg$c126;
	                                                                        peg$currPos += 2;
	                                                                    }
	                                                                    else {
	                                                                        s6 = peg$FAILED;
	                                                                        {
	                                                                            peg$fail(peg$c127);
	                                                                        }
	                                                                    }
	                                                                    if (s6 !== peg$FAILED) {
	                                                                        s7 = peg$parseh16();
	                                                                        if (s7 !== peg$FAILED) {
	                                                                            if (input.charCodeAt(peg$currPos) === 58) {
	                                                                                s8 = peg$c24;
	                                                                                peg$currPos++;
	                                                                            }
	                                                                            else {
	                                                                                s8 = peg$FAILED;
	                                                                                {
	                                                                                    peg$fail(peg$c25);
	                                                                                }
	                                                                            }
	                                                                            if (s8 !== peg$FAILED) {
	                                                                                s9 = peg$parsels32();
	                                                                                if (s9 !== peg$FAILED) {
	                                                                                    s2 = [s2, s3, s4, s5, s6, s7, s8, s9];
	                                                                                    s1 = s2;
	                                                                                }
	                                                                                else {
	                                                                                    peg$currPos = s1;
	                                                                                    s1 = peg$FAILED;
	                                                                                }
	                                                                            }
	                                                                            else {
	                                                                                peg$currPos = s1;
	                                                                                s1 = peg$FAILED;
	                                                                            }
	                                                                        }
	                                                                        else {
	                                                                            peg$currPos = s1;
	                                                                            s1 = peg$FAILED;
	                                                                        }
	                                                                    }
	                                                                    else {
	                                                                        peg$currPos = s1;
	                                                                        s1 = peg$FAILED;
	                                                                    }
	                                                                }
	                                                                else {
	                                                                    peg$currPos = s1;
	                                                                    s1 = peg$FAILED;
	                                                                }
	                                                            }
	                                                            else {
	                                                                peg$currPos = s1;
	                                                                s1 = peg$FAILED;
	                                                            }
	                                                        }
	                                                        else {
	                                                            peg$currPos = s1;
	                                                            s1 = peg$FAILED;
	                                                        }
	                                                    }
	                                                    else {
	                                                        peg$currPos = s1;
	                                                        s1 = peg$FAILED;
	                                                    }
	                                                    if (s1 === peg$FAILED) {
	                                                        s1 = peg$currPos;
	                                                        s2 = peg$parseh16();
	                                                        if (s2 !== peg$FAILED) {
	                                                            s3 = peg$currPos;
	                                                            if (input.charCodeAt(peg$currPos) === 58) {
	                                                                s4 = peg$c24;
	                                                                peg$currPos++;
	                                                            }
	                                                            else {
	                                                                s4 = peg$FAILED;
	                                                                {
	                                                                    peg$fail(peg$c25);
	                                                                }
	                                                            }
	                                                            if (s4 !== peg$FAILED) {
	                                                                s5 = peg$parseh16();
	                                                                if (s5 !== peg$FAILED) {
	                                                                    s4 = [s4, s5];
	                                                                    s3 = s4;
	                                                                }
	                                                                else {
	                                                                    peg$currPos = s3;
	                                                                    s3 = peg$FAILED;
	                                                                }
	                                                            }
	                                                            else {
	                                                                peg$currPos = s3;
	                                                                s3 = peg$FAILED;
	                                                            }
	                                                            if (s3 === peg$FAILED) {
	                                                                s3 = null;
	                                                            }
	                                                            if (s3 !== peg$FAILED) {
	                                                                s4 = peg$currPos;
	                                                                if (input.charCodeAt(peg$currPos) === 58) {
	                                                                    s5 = peg$c24;
	                                                                    peg$currPos++;
	                                                                }
	                                                                else {
	                                                                    s5 = peg$FAILED;
	                                                                    {
	                                                                        peg$fail(peg$c25);
	                                                                    }
	                                                                }
	                                                                if (s5 !== peg$FAILED) {
	                                                                    s6 = peg$parseh16();
	                                                                    if (s6 !== peg$FAILED) {
	                                                                        s5 = [s5, s6];
	                                                                        s4 = s5;
	                                                                    }
	                                                                    else {
	                                                                        peg$currPos = s4;
	                                                                        s4 = peg$FAILED;
	                                                                    }
	                                                                }
	                                                                else {
	                                                                    peg$currPos = s4;
	                                                                    s4 = peg$FAILED;
	                                                                }
	                                                                if (s4 === peg$FAILED) {
	                                                                    s4 = null;
	                                                                }
	                                                                if (s4 !== peg$FAILED) {
	                                                                    s5 = peg$currPos;
	                                                                    if (input.charCodeAt(peg$currPos) === 58) {
	                                                                        s6 = peg$c24;
	                                                                        peg$currPos++;
	                                                                    }
	                                                                    else {
	                                                                        s6 = peg$FAILED;
	                                                                        {
	                                                                            peg$fail(peg$c25);
	                                                                        }
	                                                                    }
	                                                                    if (s6 !== peg$FAILED) {
	                                                                        s7 = peg$parseh16();
	                                                                        if (s7 !== peg$FAILED) {
	                                                                            s6 = [s6, s7];
	                                                                            s5 = s6;
	                                                                        }
	                                                                        else {
	                                                                            peg$currPos = s5;
	                                                                            s5 = peg$FAILED;
	                                                                        }
	                                                                    }
	                                                                    else {
	                                                                        peg$currPos = s5;
	                                                                        s5 = peg$FAILED;
	                                                                    }
	                                                                    if (s5 === peg$FAILED) {
	                                                                        s5 = null;
	                                                                    }
	                                                                    if (s5 !== peg$FAILED) {
	                                                                        s6 = peg$currPos;
	                                                                        if (input.charCodeAt(peg$currPos) === 58) {
	                                                                            s7 = peg$c24;
	                                                                            peg$currPos++;
	                                                                        }
	                                                                        else {
	                                                                            s7 = peg$FAILED;
	                                                                            {
	                                                                                peg$fail(peg$c25);
	                                                                            }
	                                                                        }
	                                                                        if (s7 !== peg$FAILED) {
	                                                                            s8 = peg$parseh16();
	                                                                            if (s8 !== peg$FAILED) {
	                                                                                s7 = [s7, s8];
	                                                                                s6 = s7;
	                                                                            }
	                                                                            else {
	                                                                                peg$currPos = s6;
	                                                                                s6 = peg$FAILED;
	                                                                            }
	                                                                        }
	                                                                        else {
	                                                                            peg$currPos = s6;
	                                                                            s6 = peg$FAILED;
	                                                                        }
	                                                                        if (s6 === peg$FAILED) {
	                                                                            s6 = null;
	                                                                        }
	                                                                        if (s6 !== peg$FAILED) {
	                                                                            if (input.substr(peg$currPos, 2) === peg$c126) {
	                                                                                s7 = peg$c126;
	                                                                                peg$currPos += 2;
	                                                                            }
	                                                                            else {
	                                                                                s7 = peg$FAILED;
	                                                                                {
	                                                                                    peg$fail(peg$c127);
	                                                                                }
	                                                                            }
	                                                                            if (s7 !== peg$FAILED) {
	                                                                                s8 = peg$parsels32();
	                                                                                if (s8 !== peg$FAILED) {
	                                                                                    s2 = [s2, s3, s4, s5, s6, s7, s8];
	                                                                                    s1 = s2;
	                                                                                }
	                                                                                else {
	                                                                                    peg$currPos = s1;
	                                                                                    s1 = peg$FAILED;
	                                                                                }
	                                                                            }
	                                                                            else {
	                                                                                peg$currPos = s1;
	                                                                                s1 = peg$FAILED;
	                                                                            }
	                                                                        }
	                                                                        else {
	                                                                            peg$currPos = s1;
	                                                                            s1 = peg$FAILED;
	                                                                        }
	                                                                    }
	                                                                    else {
	                                                                        peg$currPos = s1;
	                                                                        s1 = peg$FAILED;
	                                                                    }
	                                                                }
	                                                                else {
	                                                                    peg$currPos = s1;
	                                                                    s1 = peg$FAILED;
	                                                                }
	                                                            }
	                                                            else {
	                                                                peg$currPos = s1;
	                                                                s1 = peg$FAILED;
	                                                            }
	                                                        }
	                                                        else {
	                                                            peg$currPos = s1;
	                                                            s1 = peg$FAILED;
	                                                        }
	                                                        if (s1 === peg$FAILED) {
	                                                            s1 = peg$currPos;
	                                                            s2 = peg$parseh16();
	                                                            if (s2 !== peg$FAILED) {
	                                                                s3 = peg$currPos;
	                                                                if (input.charCodeAt(peg$currPos) === 58) {
	                                                                    s4 = peg$c24;
	                                                                    peg$currPos++;
	                                                                }
	                                                                else {
	                                                                    s4 = peg$FAILED;
	                                                                    {
	                                                                        peg$fail(peg$c25);
	                                                                    }
	                                                                }
	                                                                if (s4 !== peg$FAILED) {
	                                                                    s5 = peg$parseh16();
	                                                                    if (s5 !== peg$FAILED) {
	                                                                        s4 = [s4, s5];
	                                                                        s3 = s4;
	                                                                    }
	                                                                    else {
	                                                                        peg$currPos = s3;
	                                                                        s3 = peg$FAILED;
	                                                                    }
	                                                                }
	                                                                else {
	                                                                    peg$currPos = s3;
	                                                                    s3 = peg$FAILED;
	                                                                }
	                                                                if (s3 === peg$FAILED) {
	                                                                    s3 = null;
	                                                                }
	                                                                if (s3 !== peg$FAILED) {
	                                                                    s4 = peg$currPos;
	                                                                    if (input.charCodeAt(peg$currPos) === 58) {
	                                                                        s5 = peg$c24;
	                                                                        peg$currPos++;
	                                                                    }
	                                                                    else {
	                                                                        s5 = peg$FAILED;
	                                                                        {
	                                                                            peg$fail(peg$c25);
	                                                                        }
	                                                                    }
	                                                                    if (s5 !== peg$FAILED) {
	                                                                        s6 = peg$parseh16();
	                                                                        if (s6 !== peg$FAILED) {
	                                                                            s5 = [s5, s6];
	                                                                            s4 = s5;
	                                                                        }
	                                                                        else {
	                                                                            peg$currPos = s4;
	                                                                            s4 = peg$FAILED;
	                                                                        }
	                                                                    }
	                                                                    else {
	                                                                        peg$currPos = s4;
	                                                                        s4 = peg$FAILED;
	                                                                    }
	                                                                    if (s4 === peg$FAILED) {
	                                                                        s4 = null;
	                                                                    }
	                                                                    if (s4 !== peg$FAILED) {
	                                                                        s5 = peg$currPos;
	                                                                        if (input.charCodeAt(peg$currPos) === 58) {
	                                                                            s6 = peg$c24;
	                                                                            peg$currPos++;
	                                                                        }
	                                                                        else {
	                                                                            s6 = peg$FAILED;
	                                                                            {
	                                                                                peg$fail(peg$c25);
	                                                                            }
	                                                                        }
	                                                                        if (s6 !== peg$FAILED) {
	                                                                            s7 = peg$parseh16();
	                                                                            if (s7 !== peg$FAILED) {
	                                                                                s6 = [s6, s7];
	                                                                                s5 = s6;
	                                                                            }
	                                                                            else {
	                                                                                peg$currPos = s5;
	                                                                                s5 = peg$FAILED;
	                                                                            }
	                                                                        }
	                                                                        else {
	                                                                            peg$currPos = s5;
	                                                                            s5 = peg$FAILED;
	                                                                        }
	                                                                        if (s5 === peg$FAILED) {
	                                                                            s5 = null;
	                                                                        }
	                                                                        if (s5 !== peg$FAILED) {
	                                                                            s6 = peg$currPos;
	                                                                            if (input.charCodeAt(peg$currPos) === 58) {
	                                                                                s7 = peg$c24;
	                                                                                peg$currPos++;
	                                                                            }
	                                                                            else {
	                                                                                s7 = peg$FAILED;
	                                                                                {
	                                                                                    peg$fail(peg$c25);
	                                                                                }
	                                                                            }
	                                                                            if (s7 !== peg$FAILED) {
	                                                                                s8 = peg$parseh16();
	                                                                                if (s8 !== peg$FAILED) {
	                                                                                    s7 = [s7, s8];
	                                                                                    s6 = s7;
	                                                                                }
	                                                                                else {
	                                                                                    peg$currPos = s6;
	                                                                                    s6 = peg$FAILED;
	                                                                                }
	                                                                            }
	                                                                            else {
	                                                                                peg$currPos = s6;
	                                                                                s6 = peg$FAILED;
	                                                                            }
	                                                                            if (s6 === peg$FAILED) {
	                                                                                s6 = null;
	                                                                            }
	                                                                            if (s6 !== peg$FAILED) {
	                                                                                s7 = peg$currPos;
	                                                                                if (input.charCodeAt(peg$currPos) === 58) {
	                                                                                    s8 = peg$c24;
	                                                                                    peg$currPos++;
	                                                                                }
	                                                                                else {
	                                                                                    s8 = peg$FAILED;
	                                                                                    {
	                                                                                        peg$fail(peg$c25);
	                                                                                    }
	                                                                                }
	                                                                                if (s8 !== peg$FAILED) {
	                                                                                    s9 = peg$parseh16();
	                                                                                    if (s9 !== peg$FAILED) {
	                                                                                        s8 = [s8, s9];
	                                                                                        s7 = s8;
	                                                                                    }
	                                                                                    else {
	                                                                                        peg$currPos = s7;
	                                                                                        s7 = peg$FAILED;
	                                                                                    }
	                                                                                }
	                                                                                else {
	                                                                                    peg$currPos = s7;
	                                                                                    s7 = peg$FAILED;
	                                                                                }
	                                                                                if (s7 === peg$FAILED) {
	                                                                                    s7 = null;
	                                                                                }
	                                                                                if (s7 !== peg$FAILED) {
	                                                                                    if (input.substr(peg$currPos, 2) === peg$c126) {
	                                                                                        s8 = peg$c126;
	                                                                                        peg$currPos += 2;
	                                                                                    }
	                                                                                    else {
	                                                                                        s8 = peg$FAILED;
	                                                                                        {
	                                                                                            peg$fail(peg$c127);
	                                                                                        }
	                                                                                    }
	                                                                                    if (s8 !== peg$FAILED) {
	                                                                                        s9 = peg$parseh16();
	                                                                                        if (s9 !== peg$FAILED) {
	                                                                                            s2 = [s2, s3, s4, s5, s6, s7, s8, s9];
	                                                                                            s1 = s2;
	                                                                                        }
	                                                                                        else {
	                                                                                            peg$currPos = s1;
	                                                                                            s1 = peg$FAILED;
	                                                                                        }
	                                                                                    }
	                                                                                    else {
	                                                                                        peg$currPos = s1;
	                                                                                        s1 = peg$FAILED;
	                                                                                    }
	                                                                                }
	                                                                                else {
	                                                                                    peg$currPos = s1;
	                                                                                    s1 = peg$FAILED;
	                                                                                }
	                                                                            }
	                                                                            else {
	                                                                                peg$currPos = s1;
	                                                                                s1 = peg$FAILED;
	                                                                            }
	                                                                        }
	                                                                        else {
	                                                                            peg$currPos = s1;
	                                                                            s1 = peg$FAILED;
	                                                                        }
	                                                                    }
	                                                                    else {
	                                                                        peg$currPos = s1;
	                                                                        s1 = peg$FAILED;
	                                                                    }
	                                                                }
	                                                                else {
	                                                                    peg$currPos = s1;
	                                                                    s1 = peg$FAILED;
	                                                                }
	                                                            }
	                                                            else {
	                                                                peg$currPos = s1;
	                                                                s1 = peg$FAILED;
	                                                            }
	                                                            if (s1 === peg$FAILED) {
	                                                                s1 = peg$currPos;
	                                                                s2 = peg$parseh16();
	                                                                if (s2 !== peg$FAILED) {
	                                                                    s3 = peg$currPos;
	                                                                    if (input.charCodeAt(peg$currPos) === 58) {
	                                                                        s4 = peg$c24;
	                                                                        peg$currPos++;
	                                                                    }
	                                                                    else {
	                                                                        s4 = peg$FAILED;
	                                                                        {
	                                                                            peg$fail(peg$c25);
	                                                                        }
	                                                                    }
	                                                                    if (s4 !== peg$FAILED) {
	                                                                        s5 = peg$parseh16();
	                                                                        if (s5 !== peg$FAILED) {
	                                                                            s4 = [s4, s5];
	                                                                            s3 = s4;
	                                                                        }
	                                                                        else {
	                                                                            peg$currPos = s3;
	                                                                            s3 = peg$FAILED;
	                                                                        }
	                                                                    }
	                                                                    else {
	                                                                        peg$currPos = s3;
	                                                                        s3 = peg$FAILED;
	                                                                    }
	                                                                    if (s3 === peg$FAILED) {
	                                                                        s3 = null;
	                                                                    }
	                                                                    if (s3 !== peg$FAILED) {
	                                                                        s4 = peg$currPos;
	                                                                        if (input.charCodeAt(peg$currPos) === 58) {
	                                                                            s5 = peg$c24;
	                                                                            peg$currPos++;
	                                                                        }
	                                                                        else {
	                                                                            s5 = peg$FAILED;
	                                                                            {
	                                                                                peg$fail(peg$c25);
	                                                                            }
	                                                                        }
	                                                                        if (s5 !== peg$FAILED) {
	                                                                            s6 = peg$parseh16();
	                                                                            if (s6 !== peg$FAILED) {
	                                                                                s5 = [s5, s6];
	                                                                                s4 = s5;
	                                                                            }
	                                                                            else {
	                                                                                peg$currPos = s4;
	                                                                                s4 = peg$FAILED;
	                                                                            }
	                                                                        }
	                                                                        else {
	                                                                            peg$currPos = s4;
	                                                                            s4 = peg$FAILED;
	                                                                        }
	                                                                        if (s4 === peg$FAILED) {
	                                                                            s4 = null;
	                                                                        }
	                                                                        if (s4 !== peg$FAILED) {
	                                                                            s5 = peg$currPos;
	                                                                            if (input.charCodeAt(peg$currPos) === 58) {
	                                                                                s6 = peg$c24;
	                                                                                peg$currPos++;
	                                                                            }
	                                                                            else {
	                                                                                s6 = peg$FAILED;
	                                                                                {
	                                                                                    peg$fail(peg$c25);
	                                                                                }
	                                                                            }
	                                                                            if (s6 !== peg$FAILED) {
	                                                                                s7 = peg$parseh16();
	                                                                                if (s7 !== peg$FAILED) {
	                                                                                    s6 = [s6, s7];
	                                                                                    s5 = s6;
	                                                                                }
	                                                                                else {
	                                                                                    peg$currPos = s5;
	                                                                                    s5 = peg$FAILED;
	                                                                                }
	                                                                            }
	                                                                            else {
	                                                                                peg$currPos = s5;
	                                                                                s5 = peg$FAILED;
	                                                                            }
	                                                                            if (s5 === peg$FAILED) {
	                                                                                s5 = null;
	                                                                            }
	                                                                            if (s5 !== peg$FAILED) {
	                                                                                s6 = peg$currPos;
	                                                                                if (input.charCodeAt(peg$currPos) === 58) {
	                                                                                    s7 = peg$c24;
	                                                                                    peg$currPos++;
	                                                                                }
	                                                                                else {
	                                                                                    s7 = peg$FAILED;
	                                                                                    {
	                                                                                        peg$fail(peg$c25);
	                                                                                    }
	                                                                                }
	                                                                                if (s7 !== peg$FAILED) {
	                                                                                    s8 = peg$parseh16();
	                                                                                    if (s8 !== peg$FAILED) {
	                                                                                        s7 = [s7, s8];
	                                                                                        s6 = s7;
	                                                                                    }
	                                                                                    else {
	                                                                                        peg$currPos = s6;
	                                                                                        s6 = peg$FAILED;
	                                                                                    }
	                                                                                }
	                                                                                else {
	                                                                                    peg$currPos = s6;
	                                                                                    s6 = peg$FAILED;
	                                                                                }
	                                                                                if (s6 === peg$FAILED) {
	                                                                                    s6 = null;
	                                                                                }
	                                                                                if (s6 !== peg$FAILED) {
	                                                                                    s7 = peg$currPos;
	                                                                                    if (input.charCodeAt(peg$currPos) === 58) {
	                                                                                        s8 = peg$c24;
	                                                                                        peg$currPos++;
	                                                                                    }
	                                                                                    else {
	                                                                                        s8 = peg$FAILED;
	                                                                                        {
	                                                                                            peg$fail(peg$c25);
	                                                                                        }
	                                                                                    }
	                                                                                    if (s8 !== peg$FAILED) {
	                                                                                        s9 = peg$parseh16();
	                                                                                        if (s9 !== peg$FAILED) {
	                                                                                            s8 = [s8, s9];
	                                                                                            s7 = s8;
	                                                                                        }
	                                                                                        else {
	                                                                                            peg$currPos = s7;
	                                                                                            s7 = peg$FAILED;
	                                                                                        }
	                                                                                    }
	                                                                                    else {
	                                                                                        peg$currPos = s7;
	                                                                                        s7 = peg$FAILED;
	                                                                                    }
	                                                                                    if (s7 === peg$FAILED) {
	                                                                                        s7 = null;
	                                                                                    }
	                                                                                    if (s7 !== peg$FAILED) {
	                                                                                        s8 = peg$currPos;
	                                                                                        if (input.charCodeAt(peg$currPos) === 58) {
	                                                                                            s9 = peg$c24;
	                                                                                            peg$currPos++;
	                                                                                        }
	                                                                                        else {
	                                                                                            s9 = peg$FAILED;
	                                                                                            {
	                                                                                                peg$fail(peg$c25);
	                                                                                            }
	                                                                                        }
	                                                                                        if (s9 !== peg$FAILED) {
	                                                                                            s10 = peg$parseh16();
	                                                                                            if (s10 !== peg$FAILED) {
	                                                                                                s9 = [s9, s10];
	                                                                                                s8 = s9;
	                                                                                            }
	                                                                                            else {
	                                                                                                peg$currPos = s8;
	                                                                                                s8 = peg$FAILED;
	                                                                                            }
	                                                                                        }
	                                                                                        else {
	                                                                                            peg$currPos = s8;
	                                                                                            s8 = peg$FAILED;
	                                                                                        }
	                                                                                        if (s8 === peg$FAILED) {
	                                                                                            s8 = null;
	                                                                                        }
	                                                                                        if (s8 !== peg$FAILED) {
	                                                                                            if (input.substr(peg$currPos, 2) === peg$c126) {
	                                                                                                s9 = peg$c126;
	                                                                                                peg$currPos += 2;
	                                                                                            }
	                                                                                            else {
	                                                                                                s9 = peg$FAILED;
	                                                                                                {
	                                                                                                    peg$fail(peg$c127);
	                                                                                                }
	                                                                                            }
	                                                                                            if (s9 !== peg$FAILED) {
	                                                                                                s2 = [s2, s3, s4, s5, s6, s7, s8, s9];
	                                                                                                s1 = s2;
	                                                                                            }
	                                                                                            else {
	                                                                                                peg$currPos = s1;
	                                                                                                s1 = peg$FAILED;
	                                                                                            }
	                                                                                        }
	                                                                                        else {
	                                                                                            peg$currPos = s1;
	                                                                                            s1 = peg$FAILED;
	                                                                                        }
	                                                                                    }
	                                                                                    else {
	                                                                                        peg$currPos = s1;
	                                                                                        s1 = peg$FAILED;
	                                                                                    }
	                                                                                }
	                                                                                else {
	                                                                                    peg$currPos = s1;
	                                                                                    s1 = peg$FAILED;
	                                                                                }
	                                                                            }
	                                                                            else {
	                                                                                peg$currPos = s1;
	                                                                                s1 = peg$FAILED;
	                                                                            }
	                                                                        }
	                                                                        else {
	                                                                            peg$currPos = s1;
	                                                                            s1 = peg$FAILED;
	                                                                        }
	                                                                    }
	                                                                    else {
	                                                                        peg$currPos = s1;
	                                                                        s1 = peg$FAILED;
	                                                                    }
	                                                                }
	                                                                else {
	                                                                    peg$currPos = s1;
	                                                                    s1 = peg$FAILED;
	                                                                }
	                                                            }
	                                                        }
	                                                    }
	                                                }
	                                            }
	                                        }
	                                    }
	                                }
	                            }
	                        }
	                    }
	                }
	            }
	        }
	        if (s1 !== peg$FAILED) {
	            peg$savedPos = s0;
	            s1 = peg$c128();
	        }
	        s0 = s1;
	        return s0;
	    }
	    function peg$parseh16() {
	        var s0, s1, s2, s3, s4;
	        s0 = peg$currPos;
	        s1 = peg$parseHEXDIG();
	        if (s1 !== peg$FAILED) {
	            s2 = peg$parseHEXDIG();
	            if (s2 === peg$FAILED) {
	                s2 = null;
	            }
	            if (s2 !== peg$FAILED) {
	                s3 = peg$parseHEXDIG();
	                if (s3 === peg$FAILED) {
	                    s3 = null;
	                }
	                if (s3 !== peg$FAILED) {
	                    s4 = peg$parseHEXDIG();
	                    if (s4 === peg$FAILED) {
	                        s4 = null;
	                    }
	                    if (s4 !== peg$FAILED) {
	                        s1 = [s1, s2, s3, s4];
	                        s0 = s1;
	                    }
	                    else {
	                        peg$currPos = s0;
	                        s0 = peg$FAILED;
	                    }
	                }
	                else {
	                    peg$currPos = s0;
	                    s0 = peg$FAILED;
	                }
	            }
	            else {
	                peg$currPos = s0;
	                s0 = peg$FAILED;
	            }
	        }
	        else {
	            peg$currPos = s0;
	            s0 = peg$FAILED;
	        }
	        return s0;
	    }
	    function peg$parsels32() {
	        var s0, s1, s2, s3;
	        s0 = peg$currPos;
	        s1 = peg$parseh16();
	        if (s1 !== peg$FAILED) {
	            if (input.charCodeAt(peg$currPos) === 58) {
	                s2 = peg$c24;
	                peg$currPos++;
	            }
	            else {
	                s2 = peg$FAILED;
	                {
	                    peg$fail(peg$c25);
	                }
	            }
	            if (s2 !== peg$FAILED) {
	                s3 = peg$parseh16();
	                if (s3 !== peg$FAILED) {
	                    s1 = [s1, s2, s3];
	                    s0 = s1;
	                }
	                else {
	                    peg$currPos = s0;
	                    s0 = peg$FAILED;
	                }
	            }
	            else {
	                peg$currPos = s0;
	                s0 = peg$FAILED;
	            }
	        }
	        else {
	            peg$currPos = s0;
	            s0 = peg$FAILED;
	        }
	        if (s0 === peg$FAILED) {
	            s0 = peg$parseIPv4address();
	        }
	        return s0;
	    }
	    function peg$parseIPv4address() {
	        var s0, s1, s2, s3, s4, s5, s6, s7;
	        s0 = peg$currPos;
	        s1 = peg$parsedec_octet();
	        if (s1 !== peg$FAILED) {
	            if (input.charCodeAt(peg$currPos) === 46) {
	                s2 = peg$c42;
	                peg$currPos++;
	            }
	            else {
	                s2 = peg$FAILED;
	                {
	                    peg$fail(peg$c43);
	                }
	            }
	            if (s2 !== peg$FAILED) {
	                s3 = peg$parsedec_octet();
	                if (s3 !== peg$FAILED) {
	                    if (input.charCodeAt(peg$currPos) === 46) {
	                        s4 = peg$c42;
	                        peg$currPos++;
	                    }
	                    else {
	                        s4 = peg$FAILED;
	                        {
	                            peg$fail(peg$c43);
	                        }
	                    }
	                    if (s4 !== peg$FAILED) {
	                        s5 = peg$parsedec_octet();
	                        if (s5 !== peg$FAILED) {
	                            if (input.charCodeAt(peg$currPos) === 46) {
	                                s6 = peg$c42;
	                                peg$currPos++;
	                            }
	                            else {
	                                s6 = peg$FAILED;
	                                {
	                                    peg$fail(peg$c43);
	                                }
	                            }
	                            if (s6 !== peg$FAILED) {
	                                s7 = peg$parsedec_octet();
	                                if (s7 !== peg$FAILED) {
	                                    peg$savedPos = s0;
	                                    s1 = peg$c129();
	                                    s0 = s1;
	                                }
	                                else {
	                                    peg$currPos = s0;
	                                    s0 = peg$FAILED;
	                                }
	                            }
	                            else {
	                                peg$currPos = s0;
	                                s0 = peg$FAILED;
	                            }
	                        }
	                        else {
	                            peg$currPos = s0;
	                            s0 = peg$FAILED;
	                        }
	                    }
	                    else {
	                        peg$currPos = s0;
	                        s0 = peg$FAILED;
	                    }
	                }
	                else {
	                    peg$currPos = s0;
	                    s0 = peg$FAILED;
	                }
	            }
	            else {
	                peg$currPos = s0;
	                s0 = peg$FAILED;
	            }
	        }
	        else {
	            peg$currPos = s0;
	            s0 = peg$FAILED;
	        }
	        return s0;
	    }
	    function peg$parsedec_octet() {
	        var s0, s1, s2, s3;
	        s0 = peg$currPos;
	        if (input.substr(peg$currPos, 2) === peg$c130) {
	            s1 = peg$c130;
	            peg$currPos += 2;
	        }
	        else {
	            s1 = peg$FAILED;
	            {
	                peg$fail(peg$c131);
	            }
	        }
	        if (s1 !== peg$FAILED) {
	            if (peg$c132.test(input.charAt(peg$currPos))) {
	                s2 = input.charAt(peg$currPos);
	                peg$currPos++;
	            }
	            else {
	                s2 = peg$FAILED;
	                {
	                    peg$fail(peg$c133);
	                }
	            }
	            if (s2 !== peg$FAILED) {
	                s1 = [s1, s2];
	                s0 = s1;
	            }
	            else {
	                peg$currPos = s0;
	                s0 = peg$FAILED;
	            }
	        }
	        else {
	            peg$currPos = s0;
	            s0 = peg$FAILED;
	        }
	        if (s0 === peg$FAILED) {
	            s0 = peg$currPos;
	            if (input.charCodeAt(peg$currPos) === 50) {
	                s1 = peg$c134;
	                peg$currPos++;
	            }
	            else {
	                s1 = peg$FAILED;
	                {
	                    peg$fail(peg$c135);
	                }
	            }
	            if (s1 !== peg$FAILED) {
	                if (peg$c136.test(input.charAt(peg$currPos))) {
	                    s2 = input.charAt(peg$currPos);
	                    peg$currPos++;
	                }
	                else {
	                    s2 = peg$FAILED;
	                    {
	                        peg$fail(peg$c137);
	                    }
	                }
	                if (s2 !== peg$FAILED) {
	                    s3 = peg$parseDIGIT();
	                    if (s3 !== peg$FAILED) {
	                        s1 = [s1, s2, s3];
	                        s0 = s1;
	                    }
	                    else {
	                        peg$currPos = s0;
	                        s0 = peg$FAILED;
	                    }
	                }
	                else {
	                    peg$currPos = s0;
	                    s0 = peg$FAILED;
	                }
	            }
	            else {
	                peg$currPos = s0;
	                s0 = peg$FAILED;
	            }
	            if (s0 === peg$FAILED) {
	                s0 = peg$currPos;
	                if (input.charCodeAt(peg$currPos) === 49) {
	                    s1 = peg$c138;
	                    peg$currPos++;
	                }
	                else {
	                    s1 = peg$FAILED;
	                    {
	                        peg$fail(peg$c139);
	                    }
	                }
	                if (s1 !== peg$FAILED) {
	                    s2 = peg$parseDIGIT();
	                    if (s2 !== peg$FAILED) {
	                        s3 = peg$parseDIGIT();
	                        if (s3 !== peg$FAILED) {
	                            s1 = [s1, s2, s3];
	                            s0 = s1;
	                        }
	                        else {
	                            peg$currPos = s0;
	                            s0 = peg$FAILED;
	                        }
	                    }
	                    else {
	                        peg$currPos = s0;
	                        s0 = peg$FAILED;
	                    }
	                }
	                else {
	                    peg$currPos = s0;
	                    s0 = peg$FAILED;
	                }
	                if (s0 === peg$FAILED) {
	                    s0 = peg$currPos;
	                    if (peg$c140.test(input.charAt(peg$currPos))) {
	                        s1 = input.charAt(peg$currPos);
	                        peg$currPos++;
	                    }
	                    else {
	                        s1 = peg$FAILED;
	                        {
	                            peg$fail(peg$c141);
	                        }
	                    }
	                    if (s1 !== peg$FAILED) {
	                        s2 = peg$parseDIGIT();
	                        if (s2 !== peg$FAILED) {
	                            s1 = [s1, s2];
	                            s0 = s1;
	                        }
	                        else {
	                            peg$currPos = s0;
	                            s0 = peg$FAILED;
	                        }
	                    }
	                    else {
	                        peg$currPos = s0;
	                        s0 = peg$FAILED;
	                    }
	                    if (s0 === peg$FAILED) {
	                        s0 = peg$parseDIGIT();
	                    }
	                }
	            }
	        }
	        return s0;
	    }
	    function peg$parseport() {
	        var s0, s1, s2, s3, s4, s5, s6;
	        s0 = peg$currPos;
	        s1 = peg$currPos;
	        s2 = peg$parseDIGIT();
	        if (s2 === peg$FAILED) {
	            s2 = null;
	        }
	        if (s2 !== peg$FAILED) {
	            s3 = peg$parseDIGIT();
	            if (s3 === peg$FAILED) {
	                s3 = null;
	            }
	            if (s3 !== peg$FAILED) {
	                s4 = peg$parseDIGIT();
	                if (s4 === peg$FAILED) {
	                    s4 = null;
	                }
	                if (s4 !== peg$FAILED) {
	                    s5 = peg$parseDIGIT();
	                    if (s5 === peg$FAILED) {
	                        s5 = null;
	                    }
	                    if (s5 !== peg$FAILED) {
	                        s6 = peg$parseDIGIT();
	                        if (s6 === peg$FAILED) {
	                            s6 = null;
	                        }
	                        if (s6 !== peg$FAILED) {
	                            s2 = [s2, s3, s4, s5, s6];
	                            s1 = s2;
	                        }
	                        else {
	                            peg$currPos = s1;
	                            s1 = peg$FAILED;
	                        }
	                    }
	                    else {
	                        peg$currPos = s1;
	                        s1 = peg$FAILED;
	                    }
	                }
	                else {
	                    peg$currPos = s1;
	                    s1 = peg$FAILED;
	                }
	            }
	            else {
	                peg$currPos = s1;
	                s1 = peg$FAILED;
	            }
	        }
	        else {
	            peg$currPos = s1;
	            s1 = peg$FAILED;
	        }
	        if (s1 !== peg$FAILED) {
	            peg$savedPos = s0;
	            s1 = peg$c142(s1);
	        }
	        s0 = s1;
	        return s0;
	    }
	    function peg$parseuri_parameters() {
	        var s0, s1, s2, s3;
	        s0 = [];
	        s1 = peg$currPos;
	        if (input.charCodeAt(peg$currPos) === 59) {
	            s2 = peg$c18;
	            peg$currPos++;
	        }
	        else {
	            s2 = peg$FAILED;
	            {
	                peg$fail(peg$c19);
	            }
	        }
	        if (s2 !== peg$FAILED) {
	            s3 = peg$parseuri_parameter();
	            if (s3 !== peg$FAILED) {
	                s2 = [s2, s3];
	                s1 = s2;
	            }
	            else {
	                peg$currPos = s1;
	                s1 = peg$FAILED;
	            }
	        }
	        else {
	            peg$currPos = s1;
	            s1 = peg$FAILED;
	        }
	        while (s1 !== peg$FAILED) {
	            s0.push(s1);
	            s1 = peg$currPos;
	            if (input.charCodeAt(peg$currPos) === 59) {
	                s2 = peg$c18;
	                peg$currPos++;
	            }
	            else {
	                s2 = peg$FAILED;
	                {
	                    peg$fail(peg$c19);
	                }
	            }
	            if (s2 !== peg$FAILED) {
	                s3 = peg$parseuri_parameter();
	                if (s3 !== peg$FAILED) {
	                    s2 = [s2, s3];
	                    s1 = s2;
	                }
	                else {
	                    peg$currPos = s1;
	                    s1 = peg$FAILED;
	                }
	            }
	            else {
	                peg$currPos = s1;
	                s1 = peg$FAILED;
	            }
	        }
	        return s0;
	    }
	    function peg$parseuri_parameter() {
	        var s0;
	        s0 = peg$parsetransport_param();
	        if (s0 === peg$FAILED) {
	            s0 = peg$parseuser_param();
	            if (s0 === peg$FAILED) {
	                s0 = peg$parsemethod_param();
	                if (s0 === peg$FAILED) {
	                    s0 = peg$parsettl_param();
	                    if (s0 === peg$FAILED) {
	                        s0 = peg$parsemaddr_param();
	                        if (s0 === peg$FAILED) {
	                            s0 = peg$parselr_param();
	                            if (s0 === peg$FAILED) {
	                                s0 = peg$parseother_param();
	                            }
	                        }
	                    }
	                }
	            }
	        }
	        return s0;
	    }
	    function peg$parsetransport_param() {
	        var s0, s1, s2;
	        s0 = peg$currPos;
	        if (input.substr(peg$currPos, 10).toLowerCase() === peg$c143) {
	            s1 = input.substr(peg$currPos, 10);
	            peg$currPos += 10;
	        }
	        else {
	            s1 = peg$FAILED;
	            {
	                peg$fail(peg$c144);
	            }
	        }
	        if (s1 !== peg$FAILED) {
	            if (input.substr(peg$currPos, 3).toLowerCase() === peg$c145) {
	                s2 = input.substr(peg$currPos, 3);
	                peg$currPos += 3;
	            }
	            else {
	                s2 = peg$FAILED;
	                {
	                    peg$fail(peg$c146);
	                }
	            }
	            if (s2 === peg$FAILED) {
	                if (input.substr(peg$currPos, 3).toLowerCase() === peg$c147) {
	                    s2 = input.substr(peg$currPos, 3);
	                    peg$currPos += 3;
	                }
	                else {
	                    s2 = peg$FAILED;
	                    {
	                        peg$fail(peg$c148);
	                    }
	                }
	                if (s2 === peg$FAILED) {
	                    if (input.substr(peg$currPos, 4).toLowerCase() === peg$c149) {
	                        s2 = input.substr(peg$currPos, 4);
	                        peg$currPos += 4;
	                    }
	                    else {
	                        s2 = peg$FAILED;
	                        {
	                            peg$fail(peg$c150);
	                        }
	                    }
	                    if (s2 === peg$FAILED) {
	                        if (input.substr(peg$currPos, 3).toLowerCase() === peg$c151) {
	                            s2 = input.substr(peg$currPos, 3);
	                            peg$currPos += 3;
	                        }
	                        else {
	                            s2 = peg$FAILED;
	                            {
	                                peg$fail(peg$c152);
	                            }
	                        }
	                        if (s2 === peg$FAILED) {
	                            s2 = peg$parsetoken();
	                        }
	                    }
	                }
	            }
	            if (s2 !== peg$FAILED) {
	                peg$savedPos = s0;
	                s1 = peg$c153(s2);
	                s0 = s1;
	            }
	            else {
	                peg$currPos = s0;
	                s0 = peg$FAILED;
	            }
	        }
	        else {
	            peg$currPos = s0;
	            s0 = peg$FAILED;
	        }
	        return s0;
	    }
	    function peg$parseuser_param() {
	        var s0, s1, s2;
	        s0 = peg$currPos;
	        if (input.substr(peg$currPos, 5).toLowerCase() === peg$c154) {
	            s1 = input.substr(peg$currPos, 5);
	            peg$currPos += 5;
	        }
	        else {
	            s1 = peg$FAILED;
	            {
	                peg$fail(peg$c155);
	            }
	        }
	        if (s1 !== peg$FAILED) {
	            if (input.substr(peg$currPos, 5).toLowerCase() === peg$c156) {
	                s2 = input.substr(peg$currPos, 5);
	                peg$currPos += 5;
	            }
	            else {
	                s2 = peg$FAILED;
	                {
	                    peg$fail(peg$c157);
	                }
	            }
	            if (s2 === peg$FAILED) {
	                if (input.substr(peg$currPos, 2).toLowerCase() === peg$c158) {
	                    s2 = input.substr(peg$currPos, 2);
	                    peg$currPos += 2;
	                }
	                else {
	                    s2 = peg$FAILED;
	                    {
	                        peg$fail(peg$c159);
	                    }
	                }
	                if (s2 === peg$FAILED) {
	                    s2 = peg$parsetoken();
	                }
	            }
	            if (s2 !== peg$FAILED) {
	                peg$savedPos = s0;
	                s1 = peg$c160(s2);
	                s0 = s1;
	            }
	            else {
	                peg$currPos = s0;
	                s0 = peg$FAILED;
	            }
	        }
	        else {
	            peg$currPos = s0;
	            s0 = peg$FAILED;
	        }
	        return s0;
	    }
	    function peg$parsemethod_param() {
	        var s0, s1, s2;
	        s0 = peg$currPos;
	        if (input.substr(peg$currPos, 7).toLowerCase() === peg$c161) {
	            s1 = input.substr(peg$currPos, 7);
	            peg$currPos += 7;
	        }
	        else {
	            s1 = peg$FAILED;
	            {
	                peg$fail(peg$c162);
	            }
	        }
	        if (s1 !== peg$FAILED) {
	            s2 = peg$parseMethod();
	            if (s2 !== peg$FAILED) {
	                peg$savedPos = s0;
	                s1 = peg$c163(s2);
	                s0 = s1;
	            }
	            else {
	                peg$currPos = s0;
	                s0 = peg$FAILED;
	            }
	        }
	        else {
	            peg$currPos = s0;
	            s0 = peg$FAILED;
	        }
	        return s0;
	    }
	    function peg$parsettl_param() {
	        var s0, s1, s2;
	        s0 = peg$currPos;
	        if (input.substr(peg$currPos, 4).toLowerCase() === peg$c164) {
	            s1 = input.substr(peg$currPos, 4);
	            peg$currPos += 4;
	        }
	        else {
	            s1 = peg$FAILED;
	            {
	                peg$fail(peg$c165);
	            }
	        }
	        if (s1 !== peg$FAILED) {
	            s2 = peg$parsettl();
	            if (s2 !== peg$FAILED) {
	                peg$savedPos = s0;
	                s1 = peg$c166(s2);
	                s0 = s1;
	            }
	            else {
	                peg$currPos = s0;
	                s0 = peg$FAILED;
	            }
	        }
	        else {
	            peg$currPos = s0;
	            s0 = peg$FAILED;
	        }
	        return s0;
	    }
	    function peg$parsemaddr_param() {
	        var s0, s1, s2;
	        s0 = peg$currPos;
	        if (input.substr(peg$currPos, 6).toLowerCase() === peg$c167) {
	            s1 = input.substr(peg$currPos, 6);
	            peg$currPos += 6;
	        }
	        else {
	            s1 = peg$FAILED;
	            {
	                peg$fail(peg$c168);
	            }
	        }
	        if (s1 !== peg$FAILED) {
	            s2 = peg$parsehost();
	            if (s2 !== peg$FAILED) {
	                peg$savedPos = s0;
	                s1 = peg$c169(s2);
	                s0 = s1;
	            }
	            else {
	                peg$currPos = s0;
	                s0 = peg$FAILED;
	            }
	        }
	        else {
	            peg$currPos = s0;
	            s0 = peg$FAILED;
	        }
	        return s0;
	    }
	    function peg$parselr_param() {
	        var s0, s1, s2, s3, s4;
	        s0 = peg$currPos;
	        if (input.substr(peg$currPos, 2).toLowerCase() === peg$c170) {
	            s1 = input.substr(peg$currPos, 2);
	            peg$currPos += 2;
	        }
	        else {
	            s1 = peg$FAILED;
	            {
	                peg$fail(peg$c171);
	            }
	        }
	        if (s1 !== peg$FAILED) {
	            s2 = peg$currPos;
	            if (input.charCodeAt(peg$currPos) === 61) {
	                s3 = peg$c30;
	                peg$currPos++;
	            }
	            else {
	                s3 = peg$FAILED;
	                {
	                    peg$fail(peg$c31);
	                }
	            }
	            if (s3 !== peg$FAILED) {
	                s4 = peg$parsetoken();
	                if (s4 !== peg$FAILED) {
	                    s3 = [s3, s4];
	                    s2 = s3;
	                }
	                else {
	                    peg$currPos = s2;
	                    s2 = peg$FAILED;
	                }
	            }
	            else {
	                peg$currPos = s2;
	                s2 = peg$FAILED;
	            }
	            if (s2 === peg$FAILED) {
	                s2 = null;
	            }
	            if (s2 !== peg$FAILED) {
	                peg$savedPos = s0;
	                s1 = peg$c172();
	                s0 = s1;
	            }
	            else {
	                peg$currPos = s0;
	                s0 = peg$FAILED;
	            }
	        }
	        else {
	            peg$currPos = s0;
	            s0 = peg$FAILED;
	        }
	        return s0;
	    }
	    function peg$parseother_param() {
	        var s0, s1, s2, s3, s4;
	        s0 = peg$currPos;
	        s1 = peg$parsepname();
	        if (s1 !== peg$FAILED) {
	            s2 = peg$currPos;
	            if (input.charCodeAt(peg$currPos) === 61) {
	                s3 = peg$c30;
	                peg$currPos++;
	            }
	            else {
	                s3 = peg$FAILED;
	                {
	                    peg$fail(peg$c31);
	                }
	            }
	            if (s3 !== peg$FAILED) {
	                s4 = peg$parsepvalue();
	                if (s4 !== peg$FAILED) {
	                    s3 = [s3, s4];
	                    s2 = s3;
	                }
	                else {
	                    peg$currPos = s2;
	                    s2 = peg$FAILED;
	                }
	            }
	            else {
	                peg$currPos = s2;
	                s2 = peg$FAILED;
	            }
	            if (s2 === peg$FAILED) {
	                s2 = null;
	            }
	            if (s2 !== peg$FAILED) {
	                peg$savedPos = s0;
	                s1 = peg$c173(s1, s2);
	                s0 = s1;
	            }
	            else {
	                peg$currPos = s0;
	                s0 = peg$FAILED;
	            }
	        }
	        else {
	            peg$currPos = s0;
	            s0 = peg$FAILED;
	        }
	        return s0;
	    }
	    function peg$parsepname() {
	        var s0, s1, s2;
	        s0 = peg$currPos;
	        s1 = [];
	        s2 = peg$parseparamchar();
	        if (s2 !== peg$FAILED) {
	            while (s2 !== peg$FAILED) {
	                s1.push(s2);
	                s2 = peg$parseparamchar();
	            }
	        }
	        else {
	            s1 = peg$FAILED;
	        }
	        if (s1 !== peg$FAILED) {
	            s0 = input.substring(s0, peg$currPos);
	        }
	        else {
	            s0 = s1;
	        }
	        return s0;
	    }
	    function peg$parsepvalue() {
	        var s0, s1, s2;
	        s0 = peg$currPos;
	        s1 = [];
	        s2 = peg$parseparamchar();
	        if (s2 !== peg$FAILED) {
	            while (s2 !== peg$FAILED) {
	                s1.push(s2);
	                s2 = peg$parseparamchar();
	            }
	        }
	        else {
	            s1 = peg$FAILED;
	        }
	        if (s1 !== peg$FAILED) {
	            s0 = input.substring(s0, peg$currPos);
	        }
	        else {
	            s0 = s1;
	        }
	        return s0;
	    }
	    function peg$parseparamchar() {
	        var s0;
	        s0 = peg$parseparam_unreserved();
	        if (s0 === peg$FAILED) {
	            s0 = peg$parseunreserved();
	            if (s0 === peg$FAILED) {
	                s0 = peg$parseescaped();
	            }
	        }
	        return s0;
	    }
	    function peg$parseparam_unreserved() {
	        var s0;
	        if (input.charCodeAt(peg$currPos) === 91) {
	            s0 = peg$c76;
	            peg$currPos++;
	        }
	        else {
	            s0 = peg$FAILED;
	            {
	                peg$fail(peg$c77);
	            }
	        }
	        if (s0 === peg$FAILED) {
	            if (input.charCodeAt(peg$currPos) === 93) {
	                s0 = peg$c78;
	                peg$currPos++;
	            }
	            else {
	                s0 = peg$FAILED;
	                {
	                    peg$fail(peg$c79);
	                }
	            }
	            if (s0 === peg$FAILED) {
	                if (input.charCodeAt(peg$currPos) === 47) {
	                    s0 = peg$c20;
	                    peg$currPos++;
	                }
	                else {
	                    s0 = peg$FAILED;
	                    {
	                        peg$fail(peg$c21);
	                    }
	                }
	                if (s0 === peg$FAILED) {
	                    if (input.charCodeAt(peg$currPos) === 58) {
	                        s0 = peg$c24;
	                        peg$currPos++;
	                    }
	                    else {
	                        s0 = peg$FAILED;
	                        {
	                            peg$fail(peg$c25);
	                        }
	                    }
	                    if (s0 === peg$FAILED) {
	                        if (input.charCodeAt(peg$currPos) === 38) {
	                            s0 = peg$c28;
	                            peg$currPos++;
	                        }
	                        else {
	                            s0 = peg$FAILED;
	                            {
	                                peg$fail(peg$c29);
	                            }
	                        }
	                        if (s0 === peg$FAILED) {
	                            if (input.charCodeAt(peg$currPos) === 43) {
	                                s0 = peg$c32;
	                                peg$currPos++;
	                            }
	                            else {
	                                s0 = peg$FAILED;
	                                {
	                                    peg$fail(peg$c33);
	                                }
	                            }
	                            if (s0 === peg$FAILED) {
	                                if (input.charCodeAt(peg$currPos) === 36) {
	                                    s0 = peg$c34;
	                                    peg$currPos++;
	                                }
	                                else {
	                                    s0 = peg$FAILED;
	                                    {
	                                        peg$fail(peg$c35);
	                                    }
	                                }
	                            }
	                        }
	                    }
	                }
	            }
	        }
	        return s0;
	    }
	    function peg$parseheaders() {
	        var s0, s1, s2, s3, s4, s5, s6;
	        s0 = peg$currPos;
	        if (input.charCodeAt(peg$currPos) === 63) {
	            s1 = peg$c22;
	            peg$currPos++;
	        }
	        else {
	            s1 = peg$FAILED;
	            {
	                peg$fail(peg$c23);
	            }
	        }
	        if (s1 !== peg$FAILED) {
	            s2 = peg$parseheader();
	            if (s2 !== peg$FAILED) {
	                s3 = [];
	                s4 = peg$currPos;
	                if (input.charCodeAt(peg$currPos) === 38) {
	                    s5 = peg$c28;
	                    peg$currPos++;
	                }
	                else {
	                    s5 = peg$FAILED;
	                    {
	                        peg$fail(peg$c29);
	                    }
	                }
	                if (s5 !== peg$FAILED) {
	                    s6 = peg$parseheader();
	                    if (s6 !== peg$FAILED) {
	                        s5 = [s5, s6];
	                        s4 = s5;
	                    }
	                    else {
	                        peg$currPos = s4;
	                        s4 = peg$FAILED;
	                    }
	                }
	                else {
	                    peg$currPos = s4;
	                    s4 = peg$FAILED;
	                }
	                while (s4 !== peg$FAILED) {
	                    s3.push(s4);
	                    s4 = peg$currPos;
	                    if (input.charCodeAt(peg$currPos) === 38) {
	                        s5 = peg$c28;
	                        peg$currPos++;
	                    }
	                    else {
	                        s5 = peg$FAILED;
	                        {
	                            peg$fail(peg$c29);
	                        }
	                    }
	                    if (s5 !== peg$FAILED) {
	                        s6 = peg$parseheader();
	                        if (s6 !== peg$FAILED) {
	                            s5 = [s5, s6];
	                            s4 = s5;
	                        }
	                        else {
	                            peg$currPos = s4;
	                            s4 = peg$FAILED;
	                        }
	                    }
	                    else {
	                        peg$currPos = s4;
	                        s4 = peg$FAILED;
	                    }
	                }
	                if (s3 !== peg$FAILED) {
	                    s1 = [s1, s2, s3];
	                    s0 = s1;
	                }
	                else {
	                    peg$currPos = s0;
	                    s0 = peg$FAILED;
	                }
	            }
	            else {
	                peg$currPos = s0;
	                s0 = peg$FAILED;
	            }
	        }
	        else {
	            peg$currPos = s0;
	            s0 = peg$FAILED;
	        }
	        return s0;
	    }
	    function peg$parseheader() {
	        var s0, s1, s2, s3;
	        s0 = peg$currPos;
	        s1 = peg$parsehname();
	        if (s1 !== peg$FAILED) {
	            if (input.charCodeAt(peg$currPos) === 61) {
	                s2 = peg$c30;
	                peg$currPos++;
	            }
	            else {
	                s2 = peg$FAILED;
	                {
	                    peg$fail(peg$c31);
	                }
	            }
	            if (s2 !== peg$FAILED) {
	                s3 = peg$parsehvalue();
	                if (s3 !== peg$FAILED) {
	                    peg$savedPos = s0;
	                    s1 = peg$c174(s1, s3);
	                    s0 = s1;
	                }
	                else {
	                    peg$currPos = s0;
	                    s0 = peg$FAILED;
	                }
	            }
	            else {
	                peg$currPos = s0;
	                s0 = peg$FAILED;
	            }
	        }
	        else {
	            peg$currPos = s0;
	            s0 = peg$FAILED;
	        }
	        return s0;
	    }
	    function peg$parsehname() {
	        var s0, s1;
	        s0 = [];
	        s1 = peg$parsehnv_unreserved();
	        if (s1 === peg$FAILED) {
	            s1 = peg$parseunreserved();
	            if (s1 === peg$FAILED) {
	                s1 = peg$parseescaped();
	            }
	        }
	        if (s1 !== peg$FAILED) {
	            while (s1 !== peg$FAILED) {
	                s0.push(s1);
	                s1 = peg$parsehnv_unreserved();
	                if (s1 === peg$FAILED) {
	                    s1 = peg$parseunreserved();
	                    if (s1 === peg$FAILED) {
	                        s1 = peg$parseescaped();
	                    }
	                }
	            }
	        }
	        else {
	            s0 = peg$FAILED;
	        }
	        return s0;
	    }
	    function peg$parsehvalue() {
	        var s0, s1;
	        s0 = [];
	        s1 = peg$parsehnv_unreserved();
	        if (s1 === peg$FAILED) {
	            s1 = peg$parseunreserved();
	            if (s1 === peg$FAILED) {
	                s1 = peg$parseescaped();
	            }
	        }
	        while (s1 !== peg$FAILED) {
	            s0.push(s1);
	            s1 = peg$parsehnv_unreserved();
	            if (s1 === peg$FAILED) {
	                s1 = peg$parseunreserved();
	                if (s1 === peg$FAILED) {
	                    s1 = peg$parseescaped();
	                }
	            }
	        }
	        return s0;
	    }
	    function peg$parsehnv_unreserved() {
	        var s0;
	        if (input.charCodeAt(peg$currPos) === 91) {
	            s0 = peg$c76;
	            peg$currPos++;
	        }
	        else {
	            s0 = peg$FAILED;
	            {
	                peg$fail(peg$c77);
	            }
	        }
	        if (s0 === peg$FAILED) {
	            if (input.charCodeAt(peg$currPos) === 93) {
	                s0 = peg$c78;
	                peg$currPos++;
	            }
	            else {
	                s0 = peg$FAILED;
	                {
	                    peg$fail(peg$c79);
	                }
	            }
	            if (s0 === peg$FAILED) {
	                if (input.charCodeAt(peg$currPos) === 47) {
	                    s0 = peg$c20;
	                    peg$currPos++;
	                }
	                else {
	                    s0 = peg$FAILED;
	                    {
	                        peg$fail(peg$c21);
	                    }
	                }
	                if (s0 === peg$FAILED) {
	                    if (input.charCodeAt(peg$currPos) === 63) {
	                        s0 = peg$c22;
	                        peg$currPos++;
	                    }
	                    else {
	                        s0 = peg$FAILED;
	                        {
	                            peg$fail(peg$c23);
	                        }
	                    }
	                    if (s0 === peg$FAILED) {
	                        if (input.charCodeAt(peg$currPos) === 58) {
	                            s0 = peg$c24;
	                            peg$currPos++;
	                        }
	                        else {
	                            s0 = peg$FAILED;
	                            {
	                                peg$fail(peg$c25);
	                            }
	                        }
	                        if (s0 === peg$FAILED) {
	                            if (input.charCodeAt(peg$currPos) === 43) {
	                                s0 = peg$c32;
	                                peg$currPos++;
	                            }
	                            else {
	                                s0 = peg$FAILED;
	                                {
	                                    peg$fail(peg$c33);
	                                }
	                            }
	                            if (s0 === peg$FAILED) {
	                                if (input.charCodeAt(peg$currPos) === 36) {
	                                    s0 = peg$c34;
	                                    peg$currPos++;
	                                }
	                                else {
	                                    s0 = peg$FAILED;
	                                    {
	                                        peg$fail(peg$c35);
	                                    }
	                                }
	                            }
	                        }
	                    }
	                }
	            }
	        }
	        return s0;
	    }
	    function peg$parseRequest_Response() {
	        var s0;
	        s0 = peg$parseStatus_Line();
	        if (s0 === peg$FAILED) {
	            s0 = peg$parseRequest_Line();
	        }
	        return s0;
	    }
	    function peg$parseRequest_Line() {
	        var s0, s1, s2, s3, s4, s5;
	        s0 = peg$currPos;
	        s1 = peg$parseMethod();
	        if (s1 !== peg$FAILED) {
	            s2 = peg$parseSP();
	            if (s2 !== peg$FAILED) {
	                s3 = peg$parseRequest_URI();
	                if (s3 !== peg$FAILED) {
	                    s4 = peg$parseSP();
	                    if (s4 !== peg$FAILED) {
	                        s5 = peg$parseSIP_Version();
	                        if (s5 !== peg$FAILED) {
	                            s1 = [s1, s2, s3, s4, s5];
	                            s0 = s1;
	                        }
	                        else {
	                            peg$currPos = s0;
	                            s0 = peg$FAILED;
	                        }
	                    }
	                    else {
	                        peg$currPos = s0;
	                        s0 = peg$FAILED;
	                    }
	                }
	                else {
	                    peg$currPos = s0;
	                    s0 = peg$FAILED;
	                }
	            }
	            else {
	                peg$currPos = s0;
	                s0 = peg$FAILED;
	            }
	        }
	        else {
	            peg$currPos = s0;
	            s0 = peg$FAILED;
	        }
	        return s0;
	    }
	    function peg$parseRequest_URI() {
	        var s0;
	        s0 = peg$parseSIP_URI();
	        if (s0 === peg$FAILED) {
	            s0 = peg$parseabsoluteURI();
	        }
	        return s0;
	    }
	    function peg$parseabsoluteURI() {
	        var s0, s1, s2, s3;
	        s0 = peg$currPos;
	        s1 = peg$parsescheme();
	        if (s1 !== peg$FAILED) {
	            if (input.charCodeAt(peg$currPos) === 58) {
	                s2 = peg$c24;
	                peg$currPos++;
	            }
	            else {
	                s2 = peg$FAILED;
	                {
	                    peg$fail(peg$c25);
	                }
	            }
	            if (s2 !== peg$FAILED) {
	                s3 = peg$parsehier_part();
	                if (s3 === peg$FAILED) {
	                    s3 = peg$parseopaque_part();
	                }
	                if (s3 !== peg$FAILED) {
	                    peg$savedPos = s0;
	                    s1 = peg$c175();
	                    s0 = s1;
	                }
	                else {
	                    peg$currPos = s0;
	                    s0 = peg$FAILED;
	                }
	            }
	            else {
	                peg$currPos = s0;
	                s0 = peg$FAILED;
	            }
	        }
	        else {
	            peg$currPos = s0;
	            s0 = peg$FAILED;
	        }
	        return s0;
	    }
	    function peg$parsehier_part() {
	        var s0, s1, s2, s3, s4;
	        s0 = peg$currPos;
	        s1 = peg$parsenet_path();
	        if (s1 === peg$FAILED) {
	            s1 = peg$parseabs_path();
	        }
	        if (s1 !== peg$FAILED) {
	            s2 = peg$currPos;
	            if (input.charCodeAt(peg$currPos) === 63) {
	                s3 = peg$c22;
	                peg$currPos++;
	            }
	            else {
	                s3 = peg$FAILED;
	                {
	                    peg$fail(peg$c23);
	                }
	            }
	            if (s3 !== peg$FAILED) {
	                s4 = peg$parsequery();
	                if (s4 !== peg$FAILED) {
	                    s3 = [s3, s4];
	                    s2 = s3;
	                }
	                else {
	                    peg$currPos = s2;
	                    s2 = peg$FAILED;
	                }
	            }
	            else {
	                peg$currPos = s2;
	                s2 = peg$FAILED;
	            }
	            if (s2 === peg$FAILED) {
	                s2 = null;
	            }
	            if (s2 !== peg$FAILED) {
	                s1 = [s1, s2];
	                s0 = s1;
	            }
	            else {
	                peg$currPos = s0;
	                s0 = peg$FAILED;
	            }
	        }
	        else {
	            peg$currPos = s0;
	            s0 = peg$FAILED;
	        }
	        return s0;
	    }
	    function peg$parsenet_path() {
	        var s0, s1, s2, s3;
	        s0 = peg$currPos;
	        if (input.substr(peg$currPos, 2) === peg$c176) {
	            s1 = peg$c176;
	            peg$currPos += 2;
	        }
	        else {
	            s1 = peg$FAILED;
	            {
	                peg$fail(peg$c177);
	            }
	        }
	        if (s1 !== peg$FAILED) {
	            s2 = peg$parseauthority();
	            if (s2 !== peg$FAILED) {
	                s3 = peg$parseabs_path();
	                if (s3 === peg$FAILED) {
	                    s3 = null;
	                }
	                if (s3 !== peg$FAILED) {
	                    s1 = [s1, s2, s3];
	                    s0 = s1;
	                }
	                else {
	                    peg$currPos = s0;
	                    s0 = peg$FAILED;
	                }
	            }
	            else {
	                peg$currPos = s0;
	                s0 = peg$FAILED;
	            }
	        }
	        else {
	            peg$currPos = s0;
	            s0 = peg$FAILED;
	        }
	        return s0;
	    }
	    function peg$parseabs_path() {
	        var s0, s1, s2;
	        s0 = peg$currPos;
	        if (input.charCodeAt(peg$currPos) === 47) {
	            s1 = peg$c20;
	            peg$currPos++;
	        }
	        else {
	            s1 = peg$FAILED;
	            {
	                peg$fail(peg$c21);
	            }
	        }
	        if (s1 !== peg$FAILED) {
	            s2 = peg$parsepath_segments();
	            if (s2 !== peg$FAILED) {
	                s1 = [s1, s2];
	                s0 = s1;
	            }
	            else {
	                peg$currPos = s0;
	                s0 = peg$FAILED;
	            }
	        }
	        else {
	            peg$currPos = s0;
	            s0 = peg$FAILED;
	        }
	        return s0;
	    }
	    function peg$parseopaque_part() {
	        var s0, s1, s2, s3;
	        s0 = peg$currPos;
	        s1 = peg$parseuric_no_slash();
	        if (s1 !== peg$FAILED) {
	            s2 = [];
	            s3 = peg$parseuric();
	            while (s3 !== peg$FAILED) {
	                s2.push(s3);
	                s3 = peg$parseuric();
	            }
	            if (s2 !== peg$FAILED) {
	                s1 = [s1, s2];
	                s0 = s1;
	            }
	            else {
	                peg$currPos = s0;
	                s0 = peg$FAILED;
	            }
	        }
	        else {
	            peg$currPos = s0;
	            s0 = peg$FAILED;
	        }
	        return s0;
	    }
	    function peg$parseuric() {
	        var s0;
	        s0 = peg$parsereserved();
	        if (s0 === peg$FAILED) {
	            s0 = peg$parseunreserved();
	            if (s0 === peg$FAILED) {
	                s0 = peg$parseescaped();
	            }
	        }
	        return s0;
	    }
	    function peg$parseuric_no_slash() {
	        var s0;
	        s0 = peg$parseunreserved();
	        if (s0 === peg$FAILED) {
	            s0 = peg$parseescaped();
	            if (s0 === peg$FAILED) {
	                if (input.charCodeAt(peg$currPos) === 59) {
	                    s0 = peg$c18;
	                    peg$currPos++;
	                }
	                else {
	                    s0 = peg$FAILED;
	                    {
	                        peg$fail(peg$c19);
	                    }
	                }
	                if (s0 === peg$FAILED) {
	                    if (input.charCodeAt(peg$currPos) === 63) {
	                        s0 = peg$c22;
	                        peg$currPos++;
	                    }
	                    else {
	                        s0 = peg$FAILED;
	                        {
	                            peg$fail(peg$c23);
	                        }
	                    }
	                    if (s0 === peg$FAILED) {
	                        if (input.charCodeAt(peg$currPos) === 58) {
	                            s0 = peg$c24;
	                            peg$currPos++;
	                        }
	                        else {
	                            s0 = peg$FAILED;
	                            {
	                                peg$fail(peg$c25);
	                            }
	                        }
	                        if (s0 === peg$FAILED) {
	                            if (input.charCodeAt(peg$currPos) === 64) {
	                                s0 = peg$c26;
	                                peg$currPos++;
	                            }
	                            else {
	                                s0 = peg$FAILED;
	                                {
	                                    peg$fail(peg$c27);
	                                }
	                            }
	                            if (s0 === peg$FAILED) {
	                                if (input.charCodeAt(peg$currPos) === 38) {
	                                    s0 = peg$c28;
	                                    peg$currPos++;
	                                }
	                                else {
	                                    s0 = peg$FAILED;
	                                    {
	                                        peg$fail(peg$c29);
	                                    }
	                                }
	                                if (s0 === peg$FAILED) {
	                                    if (input.charCodeAt(peg$currPos) === 61) {
	                                        s0 = peg$c30;
	                                        peg$currPos++;
	                                    }
	                                    else {
	                                        s0 = peg$FAILED;
	                                        {
	                                            peg$fail(peg$c31);
	                                        }
	                                    }
	                                    if (s0 === peg$FAILED) {
	                                        if (input.charCodeAt(peg$currPos) === 43) {
	                                            s0 = peg$c32;
	                                            peg$currPos++;
	                                        }
	                                        else {
	                                            s0 = peg$FAILED;
	                                            {
	                                                peg$fail(peg$c33);
	                                            }
	                                        }
	                                        if (s0 === peg$FAILED) {
	                                            if (input.charCodeAt(peg$currPos) === 36) {
	                                                s0 = peg$c34;
	                                                peg$currPos++;
	                                            }
	                                            else {
	                                                s0 = peg$FAILED;
	                                                {
	                                                    peg$fail(peg$c35);
	                                                }
	                                            }
	                                            if (s0 === peg$FAILED) {
	                                                if (input.charCodeAt(peg$currPos) === 44) {
	                                                    s0 = peg$c36;
	                                                    peg$currPos++;
	                                                }
	                                                else {
	                                                    s0 = peg$FAILED;
	                                                    {
	                                                        peg$fail(peg$c37);
	                                                    }
	                                                }
	                                            }
	                                        }
	                                    }
	                                }
	                            }
	                        }
	                    }
	                }
	            }
	        }
	        return s0;
	    }
	    function peg$parsepath_segments() {
	        var s0, s1, s2, s3, s4, s5;
	        s0 = peg$currPos;
	        s1 = peg$parsesegment();
	        if (s1 !== peg$FAILED) {
	            s2 = [];
	            s3 = peg$currPos;
	            if (input.charCodeAt(peg$currPos) === 47) {
	                s4 = peg$c20;
	                peg$currPos++;
	            }
	            else {
	                s4 = peg$FAILED;
	                {
	                    peg$fail(peg$c21);
	                }
	            }
	            if (s4 !== peg$FAILED) {
	                s5 = peg$parsesegment();
	                if (s5 !== peg$FAILED) {
	                    s4 = [s4, s5];
	                    s3 = s4;
	                }
	                else {
	                    peg$currPos = s3;
	                    s3 = peg$FAILED;
	                }
	            }
	            else {
	                peg$currPos = s3;
	                s3 = peg$FAILED;
	            }
	            while (s3 !== peg$FAILED) {
	                s2.push(s3);
	                s3 = peg$currPos;
	                if (input.charCodeAt(peg$currPos) === 47) {
	                    s4 = peg$c20;
	                    peg$currPos++;
	                }
	                else {
	                    s4 = peg$FAILED;
	                    {
	                        peg$fail(peg$c21);
	                    }
	                }
	                if (s4 !== peg$FAILED) {
	                    s5 = peg$parsesegment();
	                    if (s5 !== peg$FAILED) {
	                        s4 = [s4, s5];
	                        s3 = s4;
	                    }
	                    else {
	                        peg$currPos = s3;
	                        s3 = peg$FAILED;
	                    }
	                }
	                else {
	                    peg$currPos = s3;
	                    s3 = peg$FAILED;
	                }
	            }
	            if (s2 !== peg$FAILED) {
	                s1 = [s1, s2];
	                s0 = s1;
	            }
	            else {
	                peg$currPos = s0;
	                s0 = peg$FAILED;
	            }
	        }
	        else {
	            peg$currPos = s0;
	            s0 = peg$FAILED;
	        }
	        return s0;
	    }
	    function peg$parsesegment() {
	        var s0, s1, s2, s3, s4, s5;
	        s0 = peg$currPos;
	        s1 = [];
	        s2 = peg$parsepchar();
	        while (s2 !== peg$FAILED) {
	            s1.push(s2);
	            s2 = peg$parsepchar();
	        }
	        if (s1 !== peg$FAILED) {
	            s2 = [];
	            s3 = peg$currPos;
	            if (input.charCodeAt(peg$currPos) === 59) {
	                s4 = peg$c18;
	                peg$currPos++;
	            }
	            else {
	                s4 = peg$FAILED;
	                {
	                    peg$fail(peg$c19);
	                }
	            }
	            if (s4 !== peg$FAILED) {
	                s5 = peg$parseparam();
	                if (s5 !== peg$FAILED) {
	                    s4 = [s4, s5];
	                    s3 = s4;
	                }
	                else {
	                    peg$currPos = s3;
	                    s3 = peg$FAILED;
	                }
	            }
	            else {
	                peg$currPos = s3;
	                s3 = peg$FAILED;
	            }
	            while (s3 !== peg$FAILED) {
	                s2.push(s3);
	                s3 = peg$currPos;
	                if (input.charCodeAt(peg$currPos) === 59) {
	                    s4 = peg$c18;
	                    peg$currPos++;
	                }
	                else {
	                    s4 = peg$FAILED;
	                    {
	                        peg$fail(peg$c19);
	                    }
	                }
	                if (s4 !== peg$FAILED) {
	                    s5 = peg$parseparam();
	                    if (s5 !== peg$FAILED) {
	                        s4 = [s4, s5];
	                        s3 = s4;
	                    }
	                    else {
	                        peg$currPos = s3;
	                        s3 = peg$FAILED;
	                    }
	                }
	                else {
	                    peg$currPos = s3;
	                    s3 = peg$FAILED;
	                }
	            }
	            if (s2 !== peg$FAILED) {
	                s1 = [s1, s2];
	                s0 = s1;
	            }
	            else {
	                peg$currPos = s0;
	                s0 = peg$FAILED;
	            }
	        }
	        else {
	            peg$currPos = s0;
	            s0 = peg$FAILED;
	        }
	        return s0;
	    }
	    function peg$parseparam() {
	        var s0, s1;
	        s0 = [];
	        s1 = peg$parsepchar();
	        while (s1 !== peg$FAILED) {
	            s0.push(s1);
	            s1 = peg$parsepchar();
	        }
	        return s0;
	    }
	    function peg$parsepchar() {
	        var s0;
	        s0 = peg$parseunreserved();
	        if (s0 === peg$FAILED) {
	            s0 = peg$parseescaped();
	            if (s0 === peg$FAILED) {
	                if (input.charCodeAt(peg$currPos) === 58) {
	                    s0 = peg$c24;
	                    peg$currPos++;
	                }
	                else {
	                    s0 = peg$FAILED;
	                    {
	                        peg$fail(peg$c25);
	                    }
	                }
	                if (s0 === peg$FAILED) {
	                    if (input.charCodeAt(peg$currPos) === 64) {
	                        s0 = peg$c26;
	                        peg$currPos++;
	                    }
	                    else {
	                        s0 = peg$FAILED;
	                        {
	                            peg$fail(peg$c27);
	                        }
	                    }
	                    if (s0 === peg$FAILED) {
	                        if (input.charCodeAt(peg$currPos) === 38) {
	                            s0 = peg$c28;
	                            peg$currPos++;
	                        }
	                        else {
	                            s0 = peg$FAILED;
	                            {
	                                peg$fail(peg$c29);
	                            }
	                        }
	                        if (s0 === peg$FAILED) {
	                            if (input.charCodeAt(peg$currPos) === 61) {
	                                s0 = peg$c30;
	                                peg$currPos++;
	                            }
	                            else {
	                                s0 = peg$FAILED;
	                                {
	                                    peg$fail(peg$c31);
	                                }
	                            }
	                            if (s0 === peg$FAILED) {
	                                if (input.charCodeAt(peg$currPos) === 43) {
	                                    s0 = peg$c32;
	                                    peg$currPos++;
	                                }
	                                else {
	                                    s0 = peg$FAILED;
	                                    {
	                                        peg$fail(peg$c33);
	                                    }
	                                }
	                                if (s0 === peg$FAILED) {
	                                    if (input.charCodeAt(peg$currPos) === 36) {
	                                        s0 = peg$c34;
	                                        peg$currPos++;
	                                    }
	                                    else {
	                                        s0 = peg$FAILED;
	                                        {
	                                            peg$fail(peg$c35);
	                                        }
	                                    }
	                                    if (s0 === peg$FAILED) {
	                                        if (input.charCodeAt(peg$currPos) === 44) {
	                                            s0 = peg$c36;
	                                            peg$currPos++;
	                                        }
	                                        else {
	                                            s0 = peg$FAILED;
	                                            {
	                                                peg$fail(peg$c37);
	                                            }
	                                        }
	                                    }
	                                }
	                            }
	                        }
	                    }
	                }
	            }
	        }
	        return s0;
	    }
	    function peg$parsescheme() {
	        var s0, s1, s2, s3, s4;
	        s0 = peg$currPos;
	        s1 = peg$currPos;
	        s2 = peg$parseALPHA();
	        if (s2 !== peg$FAILED) {
	            s3 = [];
	            s4 = peg$parseALPHA();
	            if (s4 === peg$FAILED) {
	                s4 = peg$parseDIGIT();
	                if (s4 === peg$FAILED) {
	                    if (input.charCodeAt(peg$currPos) === 43) {
	                        s4 = peg$c32;
	                        peg$currPos++;
	                    }
	                    else {
	                        s4 = peg$FAILED;
	                        {
	                            peg$fail(peg$c33);
	                        }
	                    }
	                    if (s4 === peg$FAILED) {
	                        if (input.charCodeAt(peg$currPos) === 45) {
	                            s4 = peg$c38;
	                            peg$currPos++;
	                        }
	                        else {
	                            s4 = peg$FAILED;
	                            {
	                                peg$fail(peg$c39);
	                            }
	                        }
	                        if (s4 === peg$FAILED) {
	                            if (input.charCodeAt(peg$currPos) === 46) {
	                                s4 = peg$c42;
	                                peg$currPos++;
	                            }
	                            else {
	                                s4 = peg$FAILED;
	                                {
	                                    peg$fail(peg$c43);
	                                }
	                            }
	                        }
	                    }
	                }
	            }
	            while (s4 !== peg$FAILED) {
	                s3.push(s4);
	                s4 = peg$parseALPHA();
	                if (s4 === peg$FAILED) {
	                    s4 = peg$parseDIGIT();
	                    if (s4 === peg$FAILED) {
	                        if (input.charCodeAt(peg$currPos) === 43) {
	                            s4 = peg$c32;
	                            peg$currPos++;
	                        }
	                        else {
	                            s4 = peg$FAILED;
	                            {
	                                peg$fail(peg$c33);
	                            }
	                        }
	                        if (s4 === peg$FAILED) {
	                            if (input.charCodeAt(peg$currPos) === 45) {
	                                s4 = peg$c38;
	                                peg$currPos++;
	                            }
	                            else {
	                                s4 = peg$FAILED;
	                                {
	                                    peg$fail(peg$c39);
	                                }
	                            }
	                            if (s4 === peg$FAILED) {
	                                if (input.charCodeAt(peg$currPos) === 46) {
	                                    s4 = peg$c42;
	                                    peg$currPos++;
	                                }
	                                else {
	                                    s4 = peg$FAILED;
	                                    {
	                                        peg$fail(peg$c43);
	                                    }
	                                }
	                            }
	                        }
	                    }
	                }
	            }
	            if (s3 !== peg$FAILED) {
	                s2 = [s2, s3];
	                s1 = s2;
	            }
	            else {
	                peg$currPos = s1;
	                s1 = peg$FAILED;
	            }
	        }
	        else {
	            peg$currPos = s1;
	            s1 = peg$FAILED;
	        }
	        if (s1 !== peg$FAILED) {
	            peg$savedPos = s0;
	            s1 = peg$c178();
	        }
	        s0 = s1;
	        return s0;
	    }
	    function peg$parseauthority() {
	        var s0;
	        s0 = peg$parsesrvr();
	        if (s0 === peg$FAILED) {
	            s0 = peg$parsereg_name();
	        }
	        return s0;
	    }
	    function peg$parsesrvr() {
	        var s0, s1, s2, s3;
	        s0 = peg$currPos;
	        s1 = peg$currPos;
	        s2 = peg$parseuserinfo();
	        if (s2 !== peg$FAILED) {
	            if (input.charCodeAt(peg$currPos) === 64) {
	                s3 = peg$c26;
	                peg$currPos++;
	            }
	            else {
	                s3 = peg$FAILED;
	                {
	                    peg$fail(peg$c27);
	                }
	            }
	            if (s3 !== peg$FAILED) {
	                s2 = [s2, s3];
	                s1 = s2;
	            }
	            else {
	                peg$currPos = s1;
	                s1 = peg$FAILED;
	            }
	        }
	        else {
	            peg$currPos = s1;
	            s1 = peg$FAILED;
	        }
	        if (s1 === peg$FAILED) {
	            s1 = null;
	        }
	        if (s1 !== peg$FAILED) {
	            s2 = peg$parsehostport();
	            if (s2 !== peg$FAILED) {
	                s1 = [s1, s2];
	                s0 = s1;
	            }
	            else {
	                peg$currPos = s0;
	                s0 = peg$FAILED;
	            }
	        }
	        else {
	            peg$currPos = s0;
	            s0 = peg$FAILED;
	        }
	        if (s0 === peg$FAILED) {
	            s0 = null;
	        }
	        return s0;
	    }
	    function peg$parsereg_name() {
	        var s0, s1;
	        s0 = [];
	        s1 = peg$parseunreserved();
	        if (s1 === peg$FAILED) {
	            s1 = peg$parseescaped();
	            if (s1 === peg$FAILED) {
	                if (input.charCodeAt(peg$currPos) === 36) {
	                    s1 = peg$c34;
	                    peg$currPos++;
	                }
	                else {
	                    s1 = peg$FAILED;
	                    {
	                        peg$fail(peg$c35);
	                    }
	                }
	                if (s1 === peg$FAILED) {
	                    if (input.charCodeAt(peg$currPos) === 44) {
	                        s1 = peg$c36;
	                        peg$currPos++;
	                    }
	                    else {
	                        s1 = peg$FAILED;
	                        {
	                            peg$fail(peg$c37);
	                        }
	                    }
	                    if (s1 === peg$FAILED) {
	                        if (input.charCodeAt(peg$currPos) === 59) {
	                            s1 = peg$c18;
	                            peg$currPos++;
	                        }
	                        else {
	                            s1 = peg$FAILED;
	                            {
	                                peg$fail(peg$c19);
	                            }
	                        }
	                        if (s1 === peg$FAILED) {
	                            if (input.charCodeAt(peg$currPos) === 58) {
	                                s1 = peg$c24;
	                                peg$currPos++;
	                            }
	                            else {
	                                s1 = peg$FAILED;
	                                {
	                                    peg$fail(peg$c25);
	                                }
	                            }
	                            if (s1 === peg$FAILED) {
	                                if (input.charCodeAt(peg$currPos) === 64) {
	                                    s1 = peg$c26;
	                                    peg$currPos++;
	                                }
	                                else {
	                                    s1 = peg$FAILED;
	                                    {
	                                        peg$fail(peg$c27);
	                                    }
	                                }
	                                if (s1 === peg$FAILED) {
	                                    if (input.charCodeAt(peg$currPos) === 38) {
	                                        s1 = peg$c28;
	                                        peg$currPos++;
	                                    }
	                                    else {
	                                        s1 = peg$FAILED;
	                                        {
	                                            peg$fail(peg$c29);
	                                        }
	                                    }
	                                    if (s1 === peg$FAILED) {
	                                        if (input.charCodeAt(peg$currPos) === 61) {
	                                            s1 = peg$c30;
	                                            peg$currPos++;
	                                        }
	                                        else {
	                                            s1 = peg$FAILED;
	                                            {
	                                                peg$fail(peg$c31);
	                                            }
	                                        }
	                                        if (s1 === peg$FAILED) {
	                                            if (input.charCodeAt(peg$currPos) === 43) {
	                                                s1 = peg$c32;
	                                                peg$currPos++;
	                                            }
	                                            else {
	                                                s1 = peg$FAILED;
	                                                {
	                                                    peg$fail(peg$c33);
	                                                }
	                                            }
	                                        }
	                                    }
	                                }
	                            }
	                        }
	                    }
	                }
	            }
	        }
	        if (s1 !== peg$FAILED) {
	            while (s1 !== peg$FAILED) {
	                s0.push(s1);
	                s1 = peg$parseunreserved();
	                if (s1 === peg$FAILED) {
	                    s1 = peg$parseescaped();
	                    if (s1 === peg$FAILED) {
	                        if (input.charCodeAt(peg$currPos) === 36) {
	                            s1 = peg$c34;
	                            peg$currPos++;
	                        }
	                        else {
	                            s1 = peg$FAILED;
	                            {
	                                peg$fail(peg$c35);
	                            }
	                        }
	                        if (s1 === peg$FAILED) {
	                            if (input.charCodeAt(peg$currPos) === 44) {
	                                s1 = peg$c36;
	                                peg$currPos++;
	                            }
	                            else {
	                                s1 = peg$FAILED;
	                                {
	                                    peg$fail(peg$c37);
	                                }
	                            }
	                            if (s1 === peg$FAILED) {
	                                if (input.charCodeAt(peg$currPos) === 59) {
	                                    s1 = peg$c18;
	                                    peg$currPos++;
	                                }
	                                else {
	                                    s1 = peg$FAILED;
	                                    {
	                                        peg$fail(peg$c19);
	                                    }
	                                }
	                                if (s1 === peg$FAILED) {
	                                    if (input.charCodeAt(peg$currPos) === 58) {
	                                        s1 = peg$c24;
	                                        peg$currPos++;
	                                    }
	                                    else {
	                                        s1 = peg$FAILED;
	                                        {
	                                            peg$fail(peg$c25);
	                                        }
	                                    }
	                                    if (s1 === peg$FAILED) {
	                                        if (input.charCodeAt(peg$currPos) === 64) {
	                                            s1 = peg$c26;
	                                            peg$currPos++;
	                                        }
	                                        else {
	                                            s1 = peg$FAILED;
	                                            {
	                                                peg$fail(peg$c27);
	                                            }
	                                        }
	                                        if (s1 === peg$FAILED) {
	                                            if (input.charCodeAt(peg$currPos) === 38) {
	                                                s1 = peg$c28;
	                                                peg$currPos++;
	                                            }
	                                            else {
	                                                s1 = peg$FAILED;
	                                                {
	                                                    peg$fail(peg$c29);
	                                                }
	                                            }
	                                            if (s1 === peg$FAILED) {
	                                                if (input.charCodeAt(peg$currPos) === 61) {
	                                                    s1 = peg$c30;
	                                                    peg$currPos++;
	                                                }
	                                                else {
	                                                    s1 = peg$FAILED;
	                                                    {
	                                                        peg$fail(peg$c31);
	                                                    }
	                                                }
	                                                if (s1 === peg$FAILED) {
	                                                    if (input.charCodeAt(peg$currPos) === 43) {
	                                                        s1 = peg$c32;
	                                                        peg$currPos++;
	                                                    }
	                                                    else {
	                                                        s1 = peg$FAILED;
	                                                        {
	                                                            peg$fail(peg$c33);
	                                                        }
	                                                    }
	                                                }
	                                            }
	                                        }
	                                    }
	                                }
	                            }
	                        }
	                    }
	                }
	            }
	        }
	        else {
	            s0 = peg$FAILED;
	        }
	        return s0;
	    }
	    function peg$parsequery() {
	        var s0, s1;
	        s0 = [];
	        s1 = peg$parseuric();
	        while (s1 !== peg$FAILED) {
	            s0.push(s1);
	            s1 = peg$parseuric();
	        }
	        return s0;
	    }
	    function peg$parseSIP_Version() {
	        var s0, s1, s2, s3, s4, s5, s6;
	        s0 = peg$currPos;
	        if (input.substr(peg$currPos, 3).toLowerCase() === peg$c114) {
	            s1 = input.substr(peg$currPos, 3);
	            peg$currPos += 3;
	        }
	        else {
	            s1 = peg$FAILED;
	            {
	                peg$fail(peg$c179);
	            }
	        }
	        if (s1 !== peg$FAILED) {
	            if (input.charCodeAt(peg$currPos) === 47) {
	                s2 = peg$c20;
	                peg$currPos++;
	            }
	            else {
	                s2 = peg$FAILED;
	                {
	                    peg$fail(peg$c21);
	                }
	            }
	            if (s2 !== peg$FAILED) {
	                s3 = [];
	                s4 = peg$parseDIGIT();
	                if (s4 !== peg$FAILED) {
	                    while (s4 !== peg$FAILED) {
	                        s3.push(s4);
	                        s4 = peg$parseDIGIT();
	                    }
	                }
	                else {
	                    s3 = peg$FAILED;
	                }
	                if (s3 !== peg$FAILED) {
	                    if (input.charCodeAt(peg$currPos) === 46) {
	                        s4 = peg$c42;
	                        peg$currPos++;
	                    }
	                    else {
	                        s4 = peg$FAILED;
	                        {
	                            peg$fail(peg$c43);
	                        }
	                    }
	                    if (s4 !== peg$FAILED) {
	                        s5 = [];
	                        s6 = peg$parseDIGIT();
	                        if (s6 !== peg$FAILED) {
	                            while (s6 !== peg$FAILED) {
	                                s5.push(s6);
	                                s6 = peg$parseDIGIT();
	                            }
	                        }
	                        else {
	                            s5 = peg$FAILED;
	                        }
	                        if (s5 !== peg$FAILED) {
	                            peg$savedPos = s0;
	                            s1 = peg$c180();
	                            s0 = s1;
	                        }
	                        else {
	                            peg$currPos = s0;
	                            s0 = peg$FAILED;
	                        }
	                    }
	                    else {
	                        peg$currPos = s0;
	                        s0 = peg$FAILED;
	                    }
	                }
	                else {
	                    peg$currPos = s0;
	                    s0 = peg$FAILED;
	                }
	            }
	            else {
	                peg$currPos = s0;
	                s0 = peg$FAILED;
	            }
	        }
	        else {
	            peg$currPos = s0;
	            s0 = peg$FAILED;
	        }
	        return s0;
	    }
	    function peg$parseINVITEm() {
	        var s0;
	        if (input.substr(peg$currPos, 6) === peg$c181) {
	            s0 = peg$c181;
	            peg$currPos += 6;
	        }
	        else {
	            s0 = peg$FAILED;
	            {
	                peg$fail(peg$c182);
	            }
	        }
	        return s0;
	    }
	    function peg$parseACKm() {
	        var s0;
	        if (input.substr(peg$currPos, 3) === peg$c183) {
	            s0 = peg$c183;
	            peg$currPos += 3;
	        }
	        else {
	            s0 = peg$FAILED;
	            {
	                peg$fail(peg$c184);
	            }
	        }
	        return s0;
	    }
	    function peg$parseOPTIONSm() {
	        var s0;
	        if (input.substr(peg$currPos, 7) === peg$c187) {
	            s0 = peg$c187;
	            peg$currPos += 7;
	        }
	        else {
	            s0 = peg$FAILED;
	            {
	                peg$fail(peg$c188);
	            }
	        }
	        return s0;
	    }
	    function peg$parseBYEm() {
	        var s0;
	        if (input.substr(peg$currPos, 3) === peg$c189) {
	            s0 = peg$c189;
	            peg$currPos += 3;
	        }
	        else {
	            s0 = peg$FAILED;
	            {
	                peg$fail(peg$c190);
	            }
	        }
	        return s0;
	    }
	    function peg$parseCANCELm() {
	        var s0;
	        if (input.substr(peg$currPos, 6) === peg$c191) {
	            s0 = peg$c191;
	            peg$currPos += 6;
	        }
	        else {
	            s0 = peg$FAILED;
	            {
	                peg$fail(peg$c192);
	            }
	        }
	        return s0;
	    }
	    function peg$parseREGISTERm() {
	        var s0;
	        if (input.substr(peg$currPos, 8) === peg$c193) {
	            s0 = peg$c193;
	            peg$currPos += 8;
	        }
	        else {
	            s0 = peg$FAILED;
	            {
	                peg$fail(peg$c194);
	            }
	        }
	        return s0;
	    }
	    function peg$parseSUBSCRIBEm() {
	        var s0;
	        if (input.substr(peg$currPos, 9) === peg$c195) {
	            s0 = peg$c195;
	            peg$currPos += 9;
	        }
	        else {
	            s0 = peg$FAILED;
	            {
	                peg$fail(peg$c196);
	            }
	        }
	        return s0;
	    }
	    function peg$parseNOTIFYm() {
	        var s0;
	        if (input.substr(peg$currPos, 6) === peg$c197) {
	            s0 = peg$c197;
	            peg$currPos += 6;
	        }
	        else {
	            s0 = peg$FAILED;
	            {
	                peg$fail(peg$c198);
	            }
	        }
	        return s0;
	    }
	    function peg$parseREFERm() {
	        var s0;
	        if (input.substr(peg$currPos, 5) === peg$c199) {
	            s0 = peg$c199;
	            peg$currPos += 5;
	        }
	        else {
	            s0 = peg$FAILED;
	            {
	                peg$fail(peg$c200);
	            }
	        }
	        return s0;
	    }
	    function peg$parsePUBLISHm() {
	        var s0;
	        if (input.substr(peg$currPos, 7) === peg$c201) {
	            s0 = peg$c201;
	            peg$currPos += 7;
	        }
	        else {
	            s0 = peg$FAILED;
	            {
	                peg$fail(peg$c202);
	            }
	        }
	        return s0;
	    }
	    function peg$parseMethod() {
	        var s0, s1;
	        s0 = peg$currPos;
	        s1 = peg$parseINVITEm();
	        if (s1 === peg$FAILED) {
	            s1 = peg$parseACKm();
	            if (s1 === peg$FAILED) {
	                s1 = peg$parseOPTIONSm();
	                if (s1 === peg$FAILED) {
	                    s1 = peg$parseBYEm();
	                    if (s1 === peg$FAILED) {
	                        s1 = peg$parseCANCELm();
	                        if (s1 === peg$FAILED) {
	                            s1 = peg$parseREGISTERm();
	                            if (s1 === peg$FAILED) {
	                                s1 = peg$parseSUBSCRIBEm();
	                                if (s1 === peg$FAILED) {
	                                    s1 = peg$parsePUBLISHm();
	                                    if (s1 === peg$FAILED) {
	                                        s1 = peg$parseNOTIFYm();
	                                        if (s1 === peg$FAILED) {
	                                            s1 = peg$parseREFERm();
	                                            if (s1 === peg$FAILED) {
	                                                s1 = peg$parsetoken();
	                                            }
	                                        }
	                                    }
	                                }
	                            }
	                        }
	                    }
	                }
	            }
	        }
	        if (s1 !== peg$FAILED) {
	            peg$savedPos = s0;
	            s1 = peg$c203();
	        }
	        s0 = s1;
	        return s0;
	    }
	    function peg$parseStatus_Line() {
	        var s0, s1, s2, s3, s4, s5;
	        s0 = peg$currPos;
	        s1 = peg$parseSIP_Version();
	        if (s1 !== peg$FAILED) {
	            s2 = peg$parseSP();
	            if (s2 !== peg$FAILED) {
	                s3 = peg$parseStatus_Code();
	                if (s3 !== peg$FAILED) {
	                    s4 = peg$parseSP();
	                    if (s4 !== peg$FAILED) {
	                        s5 = peg$parseReason_Phrase();
	                        if (s5 !== peg$FAILED) {
	                            s1 = [s1, s2, s3, s4, s5];
	                            s0 = s1;
	                        }
	                        else {
	                            peg$currPos = s0;
	                            s0 = peg$FAILED;
	                        }
	                    }
	                    else {
	                        peg$currPos = s0;
	                        s0 = peg$FAILED;
	                    }
	                }
	                else {
	                    peg$currPos = s0;
	                    s0 = peg$FAILED;
	                }
	            }
	            else {
	                peg$currPos = s0;
	                s0 = peg$FAILED;
	            }
	        }
	        else {
	            peg$currPos = s0;
	            s0 = peg$FAILED;
	        }
	        return s0;
	    }
	    function peg$parseStatus_Code() {
	        var s0, s1;
	        s0 = peg$currPos;
	        s1 = peg$parseextension_code();
	        if (s1 !== peg$FAILED) {
	            peg$savedPos = s0;
	            s1 = peg$c204(s1);
	        }
	        s0 = s1;
	        return s0;
	    }
	    function peg$parseextension_code() {
	        var s0, s1, s2, s3;
	        s0 = peg$currPos;
	        s1 = peg$parseDIGIT();
	        if (s1 !== peg$FAILED) {
	            s2 = peg$parseDIGIT();
	            if (s2 !== peg$FAILED) {
	                s3 = peg$parseDIGIT();
	                if (s3 !== peg$FAILED) {
	                    s1 = [s1, s2, s3];
	                    s0 = s1;
	                }
	                else {
	                    peg$currPos = s0;
	                    s0 = peg$FAILED;
	                }
	            }
	            else {
	                peg$currPos = s0;
	                s0 = peg$FAILED;
	            }
	        }
	        else {
	            peg$currPos = s0;
	            s0 = peg$FAILED;
	        }
	        return s0;
	    }
	    function peg$parseReason_Phrase() {
	        var s0, s1, s2;
	        s0 = peg$currPos;
	        s1 = [];
	        s2 = peg$parsereserved();
	        if (s2 === peg$FAILED) {
	            s2 = peg$parseunreserved();
	            if (s2 === peg$FAILED) {
	                s2 = peg$parseescaped();
	                if (s2 === peg$FAILED) {
	                    s2 = peg$parseUTF8_NONASCII();
	                    if (s2 === peg$FAILED) {
	                        s2 = peg$parseUTF8_CONT();
	                        if (s2 === peg$FAILED) {
	                            s2 = peg$parseSP();
	                            if (s2 === peg$FAILED) {
	                                s2 = peg$parseHTAB();
	                            }
	                        }
	                    }
	                }
	            }
	        }
	        while (s2 !== peg$FAILED) {
	            s1.push(s2);
	            s2 = peg$parsereserved();
	            if (s2 === peg$FAILED) {
	                s2 = peg$parseunreserved();
	                if (s2 === peg$FAILED) {
	                    s2 = peg$parseescaped();
	                    if (s2 === peg$FAILED) {
	                        s2 = peg$parseUTF8_NONASCII();
	                        if (s2 === peg$FAILED) {
	                            s2 = peg$parseUTF8_CONT();
	                            if (s2 === peg$FAILED) {
	                                s2 = peg$parseSP();
	                                if (s2 === peg$FAILED) {
	                                    s2 = peg$parseHTAB();
	                                }
	                            }
	                        }
	                    }
	                }
	            }
	        }
	        if (s1 !== peg$FAILED) {
	            peg$savedPos = s0;
	            s1 = peg$c205();
	        }
	        s0 = s1;
	        return s0;
	    }
	    function peg$parseCall_ID() {
	        var s0, s1, s2, s3, s4;
	        s0 = peg$currPos;
	        s1 = peg$parseword();
	        if (s1 !== peg$FAILED) {
	            s2 = peg$currPos;
	            if (input.charCodeAt(peg$currPos) === 64) {
	                s3 = peg$c26;
	                peg$currPos++;
	            }
	            else {
	                s3 = peg$FAILED;
	                {
	                    peg$fail(peg$c27);
	                }
	            }
	            if (s3 !== peg$FAILED) {
	                s4 = peg$parseword();
	                if (s4 !== peg$FAILED) {
	                    s3 = [s3, s4];
	                    s2 = s3;
	                }
	                else {
	                    peg$currPos = s2;
	                    s2 = peg$FAILED;
	                }
	            }
	            else {
	                peg$currPos = s2;
	                s2 = peg$FAILED;
	            }
	            if (s2 === peg$FAILED) {
	                s2 = null;
	            }
	            if (s2 !== peg$FAILED) {
	                peg$savedPos = s0;
	                s1 = peg$c206();
	                s0 = s1;
	            }
	            else {
	                peg$currPos = s0;
	                s0 = peg$FAILED;
	            }
	        }
	        else {
	            peg$currPos = s0;
	            s0 = peg$FAILED;
	        }
	        return s0;
	    }
	    function peg$parseContact() {
	        var s0, s1, s2, s3, s4, s5, s6;
	        s0 = peg$currPos;
	        s1 = peg$parseSTAR();
	        if (s1 === peg$FAILED) {
	            s1 = peg$currPos;
	            s2 = peg$parsecontact_param();
	            if (s2 !== peg$FAILED) {
	                s3 = [];
	                s4 = peg$currPos;
	                s5 = peg$parseCOMMA();
	                if (s5 !== peg$FAILED) {
	                    s6 = peg$parsecontact_param();
	                    if (s6 !== peg$FAILED) {
	                        s5 = [s5, s6];
	                        s4 = s5;
	                    }
	                    else {
	                        peg$currPos = s4;
	                        s4 = peg$FAILED;
	                    }
	                }
	                else {
	                    peg$currPos = s4;
	                    s4 = peg$FAILED;
	                }
	                while (s4 !== peg$FAILED) {
	                    s3.push(s4);
	                    s4 = peg$currPos;
	                    s5 = peg$parseCOMMA();
	                    if (s5 !== peg$FAILED) {
	                        s6 = peg$parsecontact_param();
	                        if (s6 !== peg$FAILED) {
	                            s5 = [s5, s6];
	                            s4 = s5;
	                        }
	                        else {
	                            peg$currPos = s4;
	                            s4 = peg$FAILED;
	                        }
	                    }
	                    else {
	                        peg$currPos = s4;
	                        s4 = peg$FAILED;
	                    }
	                }
	                if (s3 !== peg$FAILED) {
	                    s2 = [s2, s3];
	                    s1 = s2;
	                }
	                else {
	                    peg$currPos = s1;
	                    s1 = peg$FAILED;
	                }
	            }
	            else {
	                peg$currPos = s1;
	                s1 = peg$FAILED;
	            }
	        }
	        if (s1 !== peg$FAILED) {
	            peg$savedPos = s0;
	            s1 = peg$c207();
	        }
	        s0 = s1;
	        return s0;
	    }
	    function peg$parsecontact_param() {
	        var s0, s1, s2, s3, s4, s5;
	        s0 = peg$currPos;
	        s1 = peg$parseSIP_URI_noparams();
	        if (s1 === peg$FAILED) {
	            s1 = peg$parsename_addr();
	        }
	        if (s1 !== peg$FAILED) {
	            s2 = [];
	            s3 = peg$currPos;
	            s4 = peg$parseSEMI();
	            if (s4 !== peg$FAILED) {
	                s5 = peg$parsecontact_params();
	                if (s5 !== peg$FAILED) {
	                    s4 = [s4, s5];
	                    s3 = s4;
	                }
	                else {
	                    peg$currPos = s3;
	                    s3 = peg$FAILED;
	                }
	            }
	            else {
	                peg$currPos = s3;
	                s3 = peg$FAILED;
	            }
	            while (s3 !== peg$FAILED) {
	                s2.push(s3);
	                s3 = peg$currPos;
	                s4 = peg$parseSEMI();
	                if (s4 !== peg$FAILED) {
	                    s5 = peg$parsecontact_params();
	                    if (s5 !== peg$FAILED) {
	                        s4 = [s4, s5];
	                        s3 = s4;
	                    }
	                    else {
	                        peg$currPos = s3;
	                        s3 = peg$FAILED;
	                    }
	                }
	                else {
	                    peg$currPos = s3;
	                    s3 = peg$FAILED;
	                }
	            }
	            if (s2 !== peg$FAILED) {
	                peg$savedPos = s0;
	                s1 = peg$c208();
	                s0 = s1;
	            }
	            else {
	                peg$currPos = s0;
	                s0 = peg$FAILED;
	            }
	        }
	        else {
	            peg$currPos = s0;
	            s0 = peg$FAILED;
	        }
	        return s0;
	    }
	    function peg$parsename_addr() {
	        var s0, s1, s2, s3, s4;
	        s0 = peg$currPos;
	        s1 = peg$parsedisplayName();
	        if (s1 === peg$FAILED) {
	            s1 = null;
	        }
	        if (s1 !== peg$FAILED) {
	            s2 = peg$parseLAQUOT();
	            if (s2 !== peg$FAILED) {
	                s3 = peg$parseSIP_URI();
	                if (s3 !== peg$FAILED) {
	                    s4 = peg$parseRAQUOT();
	                    if (s4 !== peg$FAILED) {
	                        s1 = [s1, s2, s3, s4];
	                        s0 = s1;
	                    }
	                    else {
	                        peg$currPos = s0;
	                        s0 = peg$FAILED;
	                    }
	                }
	                else {
	                    peg$currPos = s0;
	                    s0 = peg$FAILED;
	                }
	            }
	            else {
	                peg$currPos = s0;
	                s0 = peg$FAILED;
	            }
	        }
	        else {
	            peg$currPos = s0;
	            s0 = peg$FAILED;
	        }
	        return s0;
	    }
	    function peg$parsedisplayName() {
	        var s0, s1, s2, s3, s4, s5, s6;
	        s0 = peg$currPos;
	        s1 = peg$currPos;
	        s2 = peg$parsetoken();
	        if (s2 !== peg$FAILED) {
	            s3 = [];
	            s4 = peg$currPos;
	            s5 = peg$parseLWS();
	            if (s5 !== peg$FAILED) {
	                s6 = peg$parsetoken();
	                if (s6 !== peg$FAILED) {
	                    s5 = [s5, s6];
	                    s4 = s5;
	                }
	                else {
	                    peg$currPos = s4;
	                    s4 = peg$FAILED;
	                }
	            }
	            else {
	                peg$currPos = s4;
	                s4 = peg$FAILED;
	            }
	            while (s4 !== peg$FAILED) {
	                s3.push(s4);
	                s4 = peg$currPos;
	                s5 = peg$parseLWS();
	                if (s5 !== peg$FAILED) {
	                    s6 = peg$parsetoken();
	                    if (s6 !== peg$FAILED) {
	                        s5 = [s5, s6];
	                        s4 = s5;
	                    }
	                    else {
	                        peg$currPos = s4;
	                        s4 = peg$FAILED;
	                    }
	                }
	                else {
	                    peg$currPos = s4;
	                    s4 = peg$FAILED;
	                }
	            }
	            if (s3 !== peg$FAILED) {
	                s2 = [s2, s3];
	                s1 = s2;
	            }
	            else {
	                peg$currPos = s1;
	                s1 = peg$FAILED;
	            }
	        }
	        else {
	            peg$currPos = s1;
	            s1 = peg$FAILED;
	        }
	        if (s1 === peg$FAILED) {
	            s1 = peg$parsequoted_string();
	        }
	        if (s1 !== peg$FAILED) {
	            peg$savedPos = s0;
	            s1 = peg$c209(s1);
	        }
	        s0 = s1;
	        return s0;
	    }
	    function peg$parsecontact_params() {
	        var s0;
	        s0 = peg$parsec_p_q();
	        if (s0 === peg$FAILED) {
	            s0 = peg$parsec_p_expires();
	            if (s0 === peg$FAILED) {
	                s0 = peg$parsegeneric_param();
	            }
	        }
	        return s0;
	    }
	    function peg$parsec_p_q() {
	        var s0, s1, s2, s3;
	        s0 = peg$currPos;
	        if (input.substr(peg$currPos, 1).toLowerCase() === peg$c210) {
	            s1 = input.charAt(peg$currPos);
	            peg$currPos++;
	        }
	        else {
	            s1 = peg$FAILED;
	            {
	                peg$fail(peg$c211);
	            }
	        }
	        if (s1 !== peg$FAILED) {
	            s2 = peg$parseEQUAL();
	            if (s2 !== peg$FAILED) {
	                s3 = peg$parseqvalue();
	                if (s3 !== peg$FAILED) {
	                    peg$savedPos = s0;
	                    s1 = peg$c212(s3);
	                    s0 = s1;
	                }
	                else {
	                    peg$currPos = s0;
	                    s0 = peg$FAILED;
	                }
	            }
	            else {
	                peg$currPos = s0;
	                s0 = peg$FAILED;
	            }
	        }
	        else {
	            peg$currPos = s0;
	            s0 = peg$FAILED;
	        }
	        return s0;
	    }
	    function peg$parsec_p_expires() {
	        var s0, s1, s2, s3;
	        s0 = peg$currPos;
	        if (input.substr(peg$currPos, 7).toLowerCase() === peg$c213) {
	            s1 = input.substr(peg$currPos, 7);
	            peg$currPos += 7;
	        }
	        else {
	            s1 = peg$FAILED;
	            {
	                peg$fail(peg$c214);
	            }
	        }
	        if (s1 !== peg$FAILED) {
	            s2 = peg$parseEQUAL();
	            if (s2 !== peg$FAILED) {
	                s3 = peg$parsedelta_seconds();
	                if (s3 !== peg$FAILED) {
	                    peg$savedPos = s0;
	                    s1 = peg$c215(s3);
	                    s0 = s1;
	                }
	                else {
	                    peg$currPos = s0;
	                    s0 = peg$FAILED;
	                }
	            }
	            else {
	                peg$currPos = s0;
	                s0 = peg$FAILED;
	            }
	        }
	        else {
	            peg$currPos = s0;
	            s0 = peg$FAILED;
	        }
	        return s0;
	    }
	    function peg$parsedelta_seconds() {
	        var s0, s1, s2;
	        s0 = peg$currPos;
	        s1 = [];
	        s2 = peg$parseDIGIT();
	        if (s2 !== peg$FAILED) {
	            while (s2 !== peg$FAILED) {
	                s1.push(s2);
	                s2 = peg$parseDIGIT();
	            }
	        }
	        else {
	            s1 = peg$FAILED;
	        }
	        if (s1 !== peg$FAILED) {
	            peg$savedPos = s0;
	            s1 = peg$c216(s1);
	        }
	        s0 = s1;
	        return s0;
	    }
	    function peg$parseqvalue() {
	        var s0, s1, s2, s3, s4, s5, s6;
	        s0 = peg$currPos;
	        if (input.charCodeAt(peg$currPos) === 48) {
	            s1 = peg$c217;
	            peg$currPos++;
	        }
	        else {
	            s1 = peg$FAILED;
	            {
	                peg$fail(peg$c218);
	            }
	        }
	        if (s1 !== peg$FAILED) {
	            s2 = peg$currPos;
	            if (input.charCodeAt(peg$currPos) === 46) {
	                s3 = peg$c42;
	                peg$currPos++;
	            }
	            else {
	                s3 = peg$FAILED;
	                {
	                    peg$fail(peg$c43);
	                }
	            }
	            if (s3 !== peg$FAILED) {
	                s4 = peg$parseDIGIT();
	                if (s4 === peg$FAILED) {
	                    s4 = null;
	                }
	                if (s4 !== peg$FAILED) {
	                    s5 = peg$parseDIGIT();
	                    if (s5 === peg$FAILED) {
	                        s5 = null;
	                    }
	                    if (s5 !== peg$FAILED) {
	                        s6 = peg$parseDIGIT();
	                        if (s6 === peg$FAILED) {
	                            s6 = null;
	                        }
	                        if (s6 !== peg$FAILED) {
	                            s3 = [s3, s4, s5, s6];
	                            s2 = s3;
	                        }
	                        else {
	                            peg$currPos = s2;
	                            s2 = peg$FAILED;
	                        }
	                    }
	                    else {
	                        peg$currPos = s2;
	                        s2 = peg$FAILED;
	                    }
	                }
	                else {
	                    peg$currPos = s2;
	                    s2 = peg$FAILED;
	                }
	            }
	            else {
	                peg$currPos = s2;
	                s2 = peg$FAILED;
	            }
	            if (s2 === peg$FAILED) {
	                s2 = null;
	            }
	            if (s2 !== peg$FAILED) {
	                peg$savedPos = s0;
	                s1 = peg$c219();
	                s0 = s1;
	            }
	            else {
	                peg$currPos = s0;
	                s0 = peg$FAILED;
	            }
	        }
	        else {
	            peg$currPos = s0;
	            s0 = peg$FAILED;
	        }
	        return s0;
	    }
	    function peg$parsegeneric_param() {
	        var s0, s1, s2, s3, s4;
	        s0 = peg$currPos;
	        s1 = peg$parsetoken();
	        if (s1 !== peg$FAILED) {
	            s2 = peg$currPos;
	            s3 = peg$parseEQUAL();
	            if (s3 !== peg$FAILED) {
	                s4 = peg$parsegen_value();
	                if (s4 !== peg$FAILED) {
	                    s3 = [s3, s4];
	                    s2 = s3;
	                }
	                else {
	                    peg$currPos = s2;
	                    s2 = peg$FAILED;
	                }
	            }
	            else {
	                peg$currPos = s2;
	                s2 = peg$FAILED;
	            }
	            if (s2 === peg$FAILED) {
	                s2 = null;
	            }
	            if (s2 !== peg$FAILED) {
	                peg$savedPos = s0;
	                s1 = peg$c220(s1, s2);
	                s0 = s1;
	            }
	            else {
	                peg$currPos = s0;
	                s0 = peg$FAILED;
	            }
	        }
	        else {
	            peg$currPos = s0;
	            s0 = peg$FAILED;
	        }
	        return s0;
	    }
	    function peg$parsegen_value() {
	        var s0;
	        s0 = peg$parsetoken();
	        if (s0 === peg$FAILED) {
	            s0 = peg$parsehost();
	            if (s0 === peg$FAILED) {
	                s0 = peg$parsequoted_string();
	            }
	        }
	        return s0;
	    }
	    function peg$parseContent_Disposition() {
	        var s0, s1, s2, s3, s4, s5;
	        s0 = peg$currPos;
	        s1 = peg$parsedisp_type();
	        if (s1 !== peg$FAILED) {
	            s2 = [];
	            s3 = peg$currPos;
	            s4 = peg$parseSEMI();
	            if (s4 !== peg$FAILED) {
	                s5 = peg$parsedisp_param();
	                if (s5 !== peg$FAILED) {
	                    s4 = [s4, s5];
	                    s3 = s4;
	                }
	                else {
	                    peg$currPos = s3;
	                    s3 = peg$FAILED;
	                }
	            }
	            else {
	                peg$currPos = s3;
	                s3 = peg$FAILED;
	            }
	            while (s3 !== peg$FAILED) {
	                s2.push(s3);
	                s3 = peg$currPos;
	                s4 = peg$parseSEMI();
	                if (s4 !== peg$FAILED) {
	                    s5 = peg$parsedisp_param();
	                    if (s5 !== peg$FAILED) {
	                        s4 = [s4, s5];
	                        s3 = s4;
	                    }
	                    else {
	                        peg$currPos = s3;
	                        s3 = peg$FAILED;
	                    }
	                }
	                else {
	                    peg$currPos = s3;
	                    s3 = peg$FAILED;
	                }
	            }
	            if (s2 !== peg$FAILED) {
	                s1 = [s1, s2];
	                s0 = s1;
	            }
	            else {
	                peg$currPos = s0;
	                s0 = peg$FAILED;
	            }
	        }
	        else {
	            peg$currPos = s0;
	            s0 = peg$FAILED;
	        }
	        return s0;
	    }
	    function peg$parsedisp_type() {
	        var s0, s1;
	        s0 = peg$currPos;
	        if (input.substr(peg$currPos, 6).toLowerCase() === peg$c221) {
	            s1 = input.substr(peg$currPos, 6);
	            peg$currPos += 6;
	        }
	        else {
	            s1 = peg$FAILED;
	            {
	                peg$fail(peg$c222);
	            }
	        }
	        if (s1 === peg$FAILED) {
	            if (input.substr(peg$currPos, 7).toLowerCase() === peg$c223) {
	                s1 = input.substr(peg$currPos, 7);
	                peg$currPos += 7;
	            }
	            else {
	                s1 = peg$FAILED;
	                {
	                    peg$fail(peg$c224);
	                }
	            }
	            if (s1 === peg$FAILED) {
	                if (input.substr(peg$currPos, 4).toLowerCase() === peg$c225) {
	                    s1 = input.substr(peg$currPos, 4);
	                    peg$currPos += 4;
	                }
	                else {
	                    s1 = peg$FAILED;
	                    {
	                        peg$fail(peg$c226);
	                    }
	                }
	                if (s1 === peg$FAILED) {
	                    if (input.substr(peg$currPos, 5).toLowerCase() === peg$c227) {
	                        s1 = input.substr(peg$currPos, 5);
	                        peg$currPos += 5;
	                    }
	                    else {
	                        s1 = peg$FAILED;
	                        {
	                            peg$fail(peg$c228);
	                        }
	                    }
	                    if (s1 === peg$FAILED) {
	                        s1 = peg$parsetoken();
	                    }
	                }
	            }
	        }
	        if (s1 !== peg$FAILED) {
	            peg$savedPos = s0;
	            s1 = peg$c229();
	        }
	        s0 = s1;
	        return s0;
	    }
	    function peg$parsedisp_param() {
	        var s0;
	        s0 = peg$parsehandling_param();
	        if (s0 === peg$FAILED) {
	            s0 = peg$parsegeneric_param();
	        }
	        return s0;
	    }
	    function peg$parsehandling_param() {
	        var s0, s1, s2, s3;
	        s0 = peg$currPos;
	        if (input.substr(peg$currPos, 8).toLowerCase() === peg$c230) {
	            s1 = input.substr(peg$currPos, 8);
	            peg$currPos += 8;
	        }
	        else {
	            s1 = peg$FAILED;
	            {
	                peg$fail(peg$c231);
	            }
	        }
	        if (s1 !== peg$FAILED) {
	            s2 = peg$parseEQUAL();
	            if (s2 !== peg$FAILED) {
	                if (input.substr(peg$currPos, 8).toLowerCase() === peg$c232) {
	                    s3 = input.substr(peg$currPos, 8);
	                    peg$currPos += 8;
	                }
	                else {
	                    s3 = peg$FAILED;
	                    {
	                        peg$fail(peg$c233);
	                    }
	                }
	                if (s3 === peg$FAILED) {
	                    if (input.substr(peg$currPos, 8).toLowerCase() === peg$c234) {
	                        s3 = input.substr(peg$currPos, 8);
	                        peg$currPos += 8;
	                    }
	                    else {
	                        s3 = peg$FAILED;
	                        {
	                            peg$fail(peg$c235);
	                        }
	                    }
	                    if (s3 === peg$FAILED) {
	                        s3 = peg$parsetoken();
	                    }
	                }
	                if (s3 !== peg$FAILED) {
	                    s1 = [s1, s2, s3];
	                    s0 = s1;
	                }
	                else {
	                    peg$currPos = s0;
	                    s0 = peg$FAILED;
	                }
	            }
	            else {
	                peg$currPos = s0;
	                s0 = peg$FAILED;
	            }
	        }
	        else {
	            peg$currPos = s0;
	            s0 = peg$FAILED;
	        }
	        return s0;
	    }
	    function peg$parseContent_Length() {
	        var s0, s1, s2;
	        s0 = peg$currPos;
	        s1 = [];
	        s2 = peg$parseDIGIT();
	        if (s2 !== peg$FAILED) {
	            while (s2 !== peg$FAILED) {
	                s1.push(s2);
	                s2 = peg$parseDIGIT();
	            }
	        }
	        else {
	            s1 = peg$FAILED;
	        }
	        if (s1 !== peg$FAILED) {
	            peg$savedPos = s0;
	            s1 = peg$c236(s1);
	        }
	        s0 = s1;
	        return s0;
	    }
	    function peg$parseContent_Type() {
	        var s0, s1;
	        s0 = peg$currPos;
	        s1 = peg$parsemedia_type();
	        if (s1 !== peg$FAILED) {
	            peg$savedPos = s0;
	            s1 = peg$c237();
	        }
	        s0 = s1;
	        return s0;
	    }
	    function peg$parsemedia_type() {
	        var s0, s1, s2, s3, s4, s5, s6, s7;
	        s0 = peg$currPos;
	        s1 = peg$parsem_type();
	        if (s1 !== peg$FAILED) {
	            s2 = peg$parseSLASH();
	            if (s2 !== peg$FAILED) {
	                s3 = peg$parsem_subtype();
	                if (s3 !== peg$FAILED) {
	                    s4 = [];
	                    s5 = peg$currPos;
	                    s6 = peg$parseSEMI();
	                    if (s6 !== peg$FAILED) {
	                        s7 = peg$parsem_parameter();
	                        if (s7 !== peg$FAILED) {
	                            s6 = [s6, s7];
	                            s5 = s6;
	                        }
	                        else {
	                            peg$currPos = s5;
	                            s5 = peg$FAILED;
	                        }
	                    }
	                    else {
	                        peg$currPos = s5;
	                        s5 = peg$FAILED;
	                    }
	                    while (s5 !== peg$FAILED) {
	                        s4.push(s5);
	                        s5 = peg$currPos;
	                        s6 = peg$parseSEMI();
	                        if (s6 !== peg$FAILED) {
	                            s7 = peg$parsem_parameter();
	                            if (s7 !== peg$FAILED) {
	                                s6 = [s6, s7];
	                                s5 = s6;
	                            }
	                            else {
	                                peg$currPos = s5;
	                                s5 = peg$FAILED;
	                            }
	                        }
	                        else {
	                            peg$currPos = s5;
	                            s5 = peg$FAILED;
	                        }
	                    }
	                    if (s4 !== peg$FAILED) {
	                        s1 = [s1, s2, s3, s4];
	                        s0 = s1;
	                    }
	                    else {
	                        peg$currPos = s0;
	                        s0 = peg$FAILED;
	                    }
	                }
	                else {
	                    peg$currPos = s0;
	                    s0 = peg$FAILED;
	                }
	            }
	            else {
	                peg$currPos = s0;
	                s0 = peg$FAILED;
	            }
	        }
	        else {
	            peg$currPos = s0;
	            s0 = peg$FAILED;
	        }
	        return s0;
	    }
	    function peg$parsem_type() {
	        var s0;
	        s0 = peg$parsediscrete_type();
	        if (s0 === peg$FAILED) {
	            s0 = peg$parsecomposite_type();
	        }
	        return s0;
	    }
	    function peg$parsediscrete_type() {
	        var s0;
	        if (input.substr(peg$currPos, 4).toLowerCase() === peg$c238) {
	            s0 = input.substr(peg$currPos, 4);
	            peg$currPos += 4;
	        }
	        else {
	            s0 = peg$FAILED;
	            {
	                peg$fail(peg$c239);
	            }
	        }
	        if (s0 === peg$FAILED) {
	            if (input.substr(peg$currPos, 5).toLowerCase() === peg$c240) {
	                s0 = input.substr(peg$currPos, 5);
	                peg$currPos += 5;
	            }
	            else {
	                s0 = peg$FAILED;
	                {
	                    peg$fail(peg$c241);
	                }
	            }
	            if (s0 === peg$FAILED) {
	                if (input.substr(peg$currPos, 5).toLowerCase() === peg$c242) {
	                    s0 = input.substr(peg$currPos, 5);
	                    peg$currPos += 5;
	                }
	                else {
	                    s0 = peg$FAILED;
	                    {
	                        peg$fail(peg$c243);
	                    }
	                }
	                if (s0 === peg$FAILED) {
	                    if (input.substr(peg$currPos, 5).toLowerCase() === peg$c244) {
	                        s0 = input.substr(peg$currPos, 5);
	                        peg$currPos += 5;
	                    }
	                    else {
	                        s0 = peg$FAILED;
	                        {
	                            peg$fail(peg$c245);
	                        }
	                    }
	                    if (s0 === peg$FAILED) {
	                        if (input.substr(peg$currPos, 11).toLowerCase() === peg$c246) {
	                            s0 = input.substr(peg$currPos, 11);
	                            peg$currPos += 11;
	                        }
	                        else {
	                            s0 = peg$FAILED;
	                            {
	                                peg$fail(peg$c247);
	                            }
	                        }
	                        if (s0 === peg$FAILED) {
	                            s0 = peg$parseextension_token();
	                        }
	                    }
	                }
	            }
	        }
	        return s0;
	    }
	    function peg$parsecomposite_type() {
	        var s0;
	        if (input.substr(peg$currPos, 7).toLowerCase() === peg$c248) {
	            s0 = input.substr(peg$currPos, 7);
	            peg$currPos += 7;
	        }
	        else {
	            s0 = peg$FAILED;
	            {
	                peg$fail(peg$c249);
	            }
	        }
	        if (s0 === peg$FAILED) {
	            if (input.substr(peg$currPos, 9).toLowerCase() === peg$c250) {
	                s0 = input.substr(peg$currPos, 9);
	                peg$currPos += 9;
	            }
	            else {
	                s0 = peg$FAILED;
	                {
	                    peg$fail(peg$c251);
	                }
	            }
	            if (s0 === peg$FAILED) {
	                s0 = peg$parseextension_token();
	            }
	        }
	        return s0;
	    }
	    function peg$parseextension_token() {
	        var s0;
	        s0 = peg$parsetoken();
	        if (s0 === peg$FAILED) {
	            s0 = peg$parsex_token();
	        }
	        return s0;
	    }
	    function peg$parsex_token() {
	        var s0, s1, s2;
	        s0 = peg$currPos;
	        if (input.substr(peg$currPos, 2).toLowerCase() === peg$c252) {
	            s1 = input.substr(peg$currPos, 2);
	            peg$currPos += 2;
	        }
	        else {
	            s1 = peg$FAILED;
	            {
	                peg$fail(peg$c253);
	            }
	        }
	        if (s1 !== peg$FAILED) {
	            s2 = peg$parsetoken();
	            if (s2 !== peg$FAILED) {
	                s1 = [s1, s2];
	                s0 = s1;
	            }
	            else {
	                peg$currPos = s0;
	                s0 = peg$FAILED;
	            }
	        }
	        else {
	            peg$currPos = s0;
	            s0 = peg$FAILED;
	        }
	        return s0;
	    }
	    function peg$parsem_subtype() {
	        var s0;
	        s0 = peg$parseextension_token();
	        if (s0 === peg$FAILED) {
	            s0 = peg$parsetoken();
	        }
	        return s0;
	    }
	    function peg$parsem_parameter() {
	        var s0, s1, s2, s3;
	        s0 = peg$currPos;
	        s1 = peg$parsetoken();
	        if (s1 !== peg$FAILED) {
	            s2 = peg$parseEQUAL();
	            if (s2 !== peg$FAILED) {
	                s3 = peg$parsem_value();
	                if (s3 !== peg$FAILED) {
	                    s1 = [s1, s2, s3];
	                    s0 = s1;
	                }
	                else {
	                    peg$currPos = s0;
	                    s0 = peg$FAILED;
	                }
	            }
	            else {
	                peg$currPos = s0;
	                s0 = peg$FAILED;
	            }
	        }
	        else {
	            peg$currPos = s0;
	            s0 = peg$FAILED;
	        }
	        return s0;
	    }
	    function peg$parsem_value() {
	        var s0;
	        s0 = peg$parsetoken();
	        if (s0 === peg$FAILED) {
	            s0 = peg$parsequoted_string();
	        }
	        return s0;
	    }
	    function peg$parseCSeq() {
	        var s0, s1, s2, s3;
	        s0 = peg$currPos;
	        s1 = peg$parseCSeq_value();
	        if (s1 !== peg$FAILED) {
	            s2 = peg$parseLWS();
	            if (s2 !== peg$FAILED) {
	                s3 = peg$parseMethod();
	                if (s3 !== peg$FAILED) {
	                    s1 = [s1, s2, s3];
	                    s0 = s1;
	                }
	                else {
	                    peg$currPos = s0;
	                    s0 = peg$FAILED;
	                }
	            }
	            else {
	                peg$currPos = s0;
	                s0 = peg$FAILED;
	            }
	        }
	        else {
	            peg$currPos = s0;
	            s0 = peg$FAILED;
	        }
	        return s0;
	    }
	    function peg$parseCSeq_value() {
	        var s0, s1, s2;
	        s0 = peg$currPos;
	        s1 = [];
	        s2 = peg$parseDIGIT();
	        if (s2 !== peg$FAILED) {
	            while (s2 !== peg$FAILED) {
	                s1.push(s2);
	                s2 = peg$parseDIGIT();
	            }
	        }
	        else {
	            s1 = peg$FAILED;
	        }
	        if (s1 !== peg$FAILED) {
	            peg$savedPos = s0;
	            s1 = peg$c254(s1);
	        }
	        s0 = s1;
	        return s0;
	    }
	    function peg$parseEvent() {
	        var s0, s1, s2, s3, s4, s5;
	        s0 = peg$currPos;
	        s1 = peg$parseevent_type();
	        if (s1 !== peg$FAILED) {
	            s2 = [];
	            s3 = peg$currPos;
	            s4 = peg$parseSEMI();
	            if (s4 !== peg$FAILED) {
	                s5 = peg$parsegeneric_param();
	                if (s5 !== peg$FAILED) {
	                    s4 = [s4, s5];
	                    s3 = s4;
	                }
	                else {
	                    peg$currPos = s3;
	                    s3 = peg$FAILED;
	                }
	            }
	            else {
	                peg$currPos = s3;
	                s3 = peg$FAILED;
	            }
	            while (s3 !== peg$FAILED) {
	                s2.push(s3);
	                s3 = peg$currPos;
	                s4 = peg$parseSEMI();
	                if (s4 !== peg$FAILED) {
	                    s5 = peg$parsegeneric_param();
	                    if (s5 !== peg$FAILED) {
	                        s4 = [s4, s5];
	                        s3 = s4;
	                    }
	                    else {
	                        peg$currPos = s3;
	                        s3 = peg$FAILED;
	                    }
	                }
	                else {
	                    peg$currPos = s3;
	                    s3 = peg$FAILED;
	                }
	            }
	            if (s2 !== peg$FAILED) {
	                peg$savedPos = s0;
	                s1 = peg$c256(s1);
	                s0 = s1;
	            }
	            else {
	                peg$currPos = s0;
	                s0 = peg$FAILED;
	            }
	        }
	        else {
	            peg$currPos = s0;
	            s0 = peg$FAILED;
	        }
	        return s0;
	    }
	    function peg$parseevent_type() {
	        var s0, s1, s2, s3, s4, s5, s6;
	        s0 = peg$currPos;
	        s1 = peg$currPos;
	        s2 = peg$parsetoken_nodot();
	        if (s2 !== peg$FAILED) {
	            s3 = [];
	            s4 = peg$currPos;
	            if (input.charCodeAt(peg$currPos) === 46) {
	                s5 = peg$c42;
	                peg$currPos++;
	            }
	            else {
	                s5 = peg$FAILED;
	                {
	                    peg$fail(peg$c43);
	                }
	            }
	            if (s5 !== peg$FAILED) {
	                s6 = peg$parsetoken_nodot();
	                if (s6 !== peg$FAILED) {
	                    s5 = [s5, s6];
	                    s4 = s5;
	                }
	                else {
	                    peg$currPos = s4;
	                    s4 = peg$FAILED;
	                }
	            }
	            else {
	                peg$currPos = s4;
	                s4 = peg$FAILED;
	            }
	            while (s4 !== peg$FAILED) {
	                s3.push(s4);
	                s4 = peg$currPos;
	                if (input.charCodeAt(peg$currPos) === 46) {
	                    s5 = peg$c42;
	                    peg$currPos++;
	                }
	                else {
	                    s5 = peg$FAILED;
	                    {
	                        peg$fail(peg$c43);
	                    }
	                }
	                if (s5 !== peg$FAILED) {
	                    s6 = peg$parsetoken_nodot();
	                    if (s6 !== peg$FAILED) {
	                        s5 = [s5, s6];
	                        s4 = s5;
	                    }
	                    else {
	                        peg$currPos = s4;
	                        s4 = peg$FAILED;
	                    }
	                }
	                else {
	                    peg$currPos = s4;
	                    s4 = peg$FAILED;
	                }
	            }
	            if (s3 !== peg$FAILED) {
	                s2 = [s2, s3];
	                s1 = s2;
	            }
	            else {
	                peg$currPos = s1;
	                s1 = peg$FAILED;
	            }
	        }
	        else {
	            peg$currPos = s1;
	            s1 = peg$FAILED;
	        }
	        if (s1 !== peg$FAILED) {
	            s0 = input.substring(s0, peg$currPos);
	        }
	        else {
	            s0 = s1;
	        }
	        return s0;
	    }
	    function peg$parseFrom() {
	        var s0, s1, s2, s3, s4, s5;
	        s0 = peg$currPos;
	        s1 = peg$parseSIP_URI_noparams();
	        if (s1 === peg$FAILED) {
	            s1 = peg$parsename_addr();
	        }
	        if (s1 !== peg$FAILED) {
	            s2 = [];
	            s3 = peg$currPos;
	            s4 = peg$parseSEMI();
	            if (s4 !== peg$FAILED) {
	                s5 = peg$parsefrom_param();
	                if (s5 !== peg$FAILED) {
	                    s4 = [s4, s5];
	                    s3 = s4;
	                }
	                else {
	                    peg$currPos = s3;
	                    s3 = peg$FAILED;
	                }
	            }
	            else {
	                peg$currPos = s3;
	                s3 = peg$FAILED;
	            }
	            while (s3 !== peg$FAILED) {
	                s2.push(s3);
	                s3 = peg$currPos;
	                s4 = peg$parseSEMI();
	                if (s4 !== peg$FAILED) {
	                    s5 = peg$parsefrom_param();
	                    if (s5 !== peg$FAILED) {
	                        s4 = [s4, s5];
	                        s3 = s4;
	                    }
	                    else {
	                        peg$currPos = s3;
	                        s3 = peg$FAILED;
	                    }
	                }
	                else {
	                    peg$currPos = s3;
	                    s3 = peg$FAILED;
	                }
	            }
	            if (s2 !== peg$FAILED) {
	                peg$savedPos = s0;
	                s1 = peg$c257();
	                s0 = s1;
	            }
	            else {
	                peg$currPos = s0;
	                s0 = peg$FAILED;
	            }
	        }
	        else {
	            peg$currPos = s0;
	            s0 = peg$FAILED;
	        }
	        return s0;
	    }
	    function peg$parsefrom_param() {
	        var s0;
	        s0 = peg$parsetag_param();
	        if (s0 === peg$FAILED) {
	            s0 = peg$parsegeneric_param();
	        }
	        return s0;
	    }
	    function peg$parsetag_param() {
	        var s0, s1, s2, s3;
	        s0 = peg$currPos;
	        if (input.substr(peg$currPos, 3).toLowerCase() === peg$c258) {
	            s1 = input.substr(peg$currPos, 3);
	            peg$currPos += 3;
	        }
	        else {
	            s1 = peg$FAILED;
	            {
	                peg$fail(peg$c259);
	            }
	        }
	        if (s1 !== peg$FAILED) {
	            s2 = peg$parseEQUAL();
	            if (s2 !== peg$FAILED) {
	                s3 = peg$parsetoken();
	                if (s3 !== peg$FAILED) {
	                    peg$savedPos = s0;
	                    s1 = peg$c260(s3);
	                    s0 = s1;
	                }
	                else {
	                    peg$currPos = s0;
	                    s0 = peg$FAILED;
	                }
	            }
	            else {
	                peg$currPos = s0;
	                s0 = peg$FAILED;
	            }
	        }
	        else {
	            peg$currPos = s0;
	            s0 = peg$FAILED;
	        }
	        return s0;
	    }
	    function peg$parseMax_Forwards() {
	        var s0, s1, s2;
	        s0 = peg$currPos;
	        s1 = [];
	        s2 = peg$parseDIGIT();
	        if (s2 !== peg$FAILED) {
	            while (s2 !== peg$FAILED) {
	                s1.push(s2);
	                s2 = peg$parseDIGIT();
	            }
	        }
	        else {
	            s1 = peg$FAILED;
	        }
	        if (s1 !== peg$FAILED) {
	            peg$savedPos = s0;
	            s1 = peg$c261(s1);
	        }
	        s0 = s1;
	        return s0;
	    }
	    function peg$parseName_Addr_Header() {
	        var s0, s1, s2, s3, s4, s5, s6, s7, s8;
	        s0 = peg$currPos;
	        s1 = [];
	        s2 = peg$parsedisplayName();
	        while (s2 !== peg$FAILED) {
	            s1.push(s2);
	            s2 = peg$parsedisplayName();
	        }
	        if (s1 !== peg$FAILED) {
	            s2 = peg$parseLAQUOT();
	            if (s2 !== peg$FAILED) {
	                s3 = peg$parseSIP_URI();
	                if (s3 !== peg$FAILED) {
	                    s4 = peg$parseRAQUOT();
	                    if (s4 !== peg$FAILED) {
	                        s5 = [];
	                        s6 = peg$currPos;
	                        s7 = peg$parseSEMI();
	                        if (s7 !== peg$FAILED) {
	                            s8 = peg$parsegeneric_param();
	                            if (s8 !== peg$FAILED) {
	                                s7 = [s7, s8];
	                                s6 = s7;
	                            }
	                            else {
	                                peg$currPos = s6;
	                                s6 = peg$FAILED;
	                            }
	                        }
	                        else {
	                            peg$currPos = s6;
	                            s6 = peg$FAILED;
	                        }
	                        while (s6 !== peg$FAILED) {
	                            s5.push(s6);
	                            s6 = peg$currPos;
	                            s7 = peg$parseSEMI();
	                            if (s7 !== peg$FAILED) {
	                                s8 = peg$parsegeneric_param();
	                                if (s8 !== peg$FAILED) {
	                                    s7 = [s7, s8];
	                                    s6 = s7;
	                                }
	                                else {
	                                    peg$currPos = s6;
	                                    s6 = peg$FAILED;
	                                }
	                            }
	                            else {
	                                peg$currPos = s6;
	                                s6 = peg$FAILED;
	                            }
	                        }
	                        if (s5 !== peg$FAILED) {
	                            peg$savedPos = s0;
	                            s1 = peg$c263();
	                            s0 = s1;
	                        }
	                        else {
	                            peg$currPos = s0;
	                            s0 = peg$FAILED;
	                        }
	                    }
	                    else {
	                        peg$currPos = s0;
	                        s0 = peg$FAILED;
	                    }
	                }
	                else {
	                    peg$currPos = s0;
	                    s0 = peg$FAILED;
	                }
	            }
	            else {
	                peg$currPos = s0;
	                s0 = peg$FAILED;
	            }
	        }
	        else {
	            peg$currPos = s0;
	            s0 = peg$FAILED;
	        }
	        return s0;
	    }
	    function peg$parseProxy_Authenticate() {
	        var s0;
	        s0 = peg$parsechallenge();
	        return s0;
	    }
	    function peg$parsechallenge() {
	        var s0, s1, s2, s3, s4, s5, s6, s7;
	        s0 = peg$currPos;
	        if (input.substr(peg$currPos, 6).toLowerCase() === peg$c264) {
	            s1 = input.substr(peg$currPos, 6);
	            peg$currPos += 6;
	        }
	        else {
	            s1 = peg$FAILED;
	            {
	                peg$fail(peg$c265);
	            }
	        }
	        if (s1 !== peg$FAILED) {
	            s2 = peg$parseLWS();
	            if (s2 !== peg$FAILED) {
	                s3 = peg$parsedigest_cln();
	                if (s3 !== peg$FAILED) {
	                    s4 = [];
	                    s5 = peg$currPos;
	                    s6 = peg$parseCOMMA();
	                    if (s6 !== peg$FAILED) {
	                        s7 = peg$parsedigest_cln();
	                        if (s7 !== peg$FAILED) {
	                            s6 = [s6, s7];
	                            s5 = s6;
	                        }
	                        else {
	                            peg$currPos = s5;
	                            s5 = peg$FAILED;
	                        }
	                    }
	                    else {
	                        peg$currPos = s5;
	                        s5 = peg$FAILED;
	                    }
	                    while (s5 !== peg$FAILED) {
	                        s4.push(s5);
	                        s5 = peg$currPos;
	                        s6 = peg$parseCOMMA();
	                        if (s6 !== peg$FAILED) {
	                            s7 = peg$parsedigest_cln();
	                            if (s7 !== peg$FAILED) {
	                                s6 = [s6, s7];
	                                s5 = s6;
	                            }
	                            else {
	                                peg$currPos = s5;
	                                s5 = peg$FAILED;
	                            }
	                        }
	                        else {
	                            peg$currPos = s5;
	                            s5 = peg$FAILED;
	                        }
	                    }
	                    if (s4 !== peg$FAILED) {
	                        s1 = [s1, s2, s3, s4];
	                        s0 = s1;
	                    }
	                    else {
	                        peg$currPos = s0;
	                        s0 = peg$FAILED;
	                    }
	                }
	                else {
	                    peg$currPos = s0;
	                    s0 = peg$FAILED;
	                }
	            }
	            else {
	                peg$currPos = s0;
	                s0 = peg$FAILED;
	            }
	        }
	        else {
	            peg$currPos = s0;
	            s0 = peg$FAILED;
	        }
	        if (s0 === peg$FAILED) {
	            s0 = peg$parseother_challenge();
	        }
	        return s0;
	    }
	    function peg$parseother_challenge() {
	        var s0, s1, s2, s3, s4, s5, s6, s7;
	        s0 = peg$currPos;
	        s1 = peg$parsetoken();
	        if (s1 !== peg$FAILED) {
	            s2 = peg$parseLWS();
	            if (s2 !== peg$FAILED) {
	                s3 = peg$parseauth_param();
	                if (s3 !== peg$FAILED) {
	                    s4 = [];
	                    s5 = peg$currPos;
	                    s6 = peg$parseCOMMA();
	                    if (s6 !== peg$FAILED) {
	                        s7 = peg$parseauth_param();
	                        if (s7 !== peg$FAILED) {
	                            s6 = [s6, s7];
	                            s5 = s6;
	                        }
	                        else {
	                            peg$currPos = s5;
	                            s5 = peg$FAILED;
	                        }
	                    }
	                    else {
	                        peg$currPos = s5;
	                        s5 = peg$FAILED;
	                    }
	                    while (s5 !== peg$FAILED) {
	                        s4.push(s5);
	                        s5 = peg$currPos;
	                        s6 = peg$parseCOMMA();
	                        if (s6 !== peg$FAILED) {
	                            s7 = peg$parseauth_param();
	                            if (s7 !== peg$FAILED) {
	                                s6 = [s6, s7];
	                                s5 = s6;
	                            }
	                            else {
	                                peg$currPos = s5;
	                                s5 = peg$FAILED;
	                            }
	                        }
	                        else {
	                            peg$currPos = s5;
	                            s5 = peg$FAILED;
	                        }
	                    }
	                    if (s4 !== peg$FAILED) {
	                        s1 = [s1, s2, s3, s4];
	                        s0 = s1;
	                    }
	                    else {
	                        peg$currPos = s0;
	                        s0 = peg$FAILED;
	                    }
	                }
	                else {
	                    peg$currPos = s0;
	                    s0 = peg$FAILED;
	                }
	            }
	            else {
	                peg$currPos = s0;
	                s0 = peg$FAILED;
	            }
	        }
	        else {
	            peg$currPos = s0;
	            s0 = peg$FAILED;
	        }
	        return s0;
	    }
	    function peg$parseauth_param() {
	        var s0, s1, s2, s3;
	        s0 = peg$currPos;
	        s1 = peg$parsetoken();
	        if (s1 !== peg$FAILED) {
	            s2 = peg$parseEQUAL();
	            if (s2 !== peg$FAILED) {
	                s3 = peg$parsetoken();
	                if (s3 === peg$FAILED) {
	                    s3 = peg$parsequoted_string();
	                }
	                if (s3 !== peg$FAILED) {
	                    s1 = [s1, s2, s3];
	                    s0 = s1;
	                }
	                else {
	                    peg$currPos = s0;
	                    s0 = peg$FAILED;
	                }
	            }
	            else {
	                peg$currPos = s0;
	                s0 = peg$FAILED;
	            }
	        }
	        else {
	            peg$currPos = s0;
	            s0 = peg$FAILED;
	        }
	        return s0;
	    }
	    function peg$parsedigest_cln() {
	        var s0;
	        s0 = peg$parserealm();
	        if (s0 === peg$FAILED) {
	            s0 = peg$parsedomain();
	            if (s0 === peg$FAILED) {
	                s0 = peg$parsenonce();
	                if (s0 === peg$FAILED) {
	                    s0 = peg$parseopaque();
	                    if (s0 === peg$FAILED) {
	                        s0 = peg$parsestale();
	                        if (s0 === peg$FAILED) {
	                            s0 = peg$parsealgorithm();
	                            if (s0 === peg$FAILED) {
	                                s0 = peg$parseqop_options();
	                                if (s0 === peg$FAILED) {
	                                    s0 = peg$parseauth_param();
	                                }
	                            }
	                        }
	                    }
	                }
	            }
	        }
	        return s0;
	    }
	    function peg$parserealm() {
	        var s0, s1, s2, s3;
	        s0 = peg$currPos;
	        if (input.substr(peg$currPos, 5).toLowerCase() === peg$c266) {
	            s1 = input.substr(peg$currPos, 5);
	            peg$currPos += 5;
	        }
	        else {
	            s1 = peg$FAILED;
	            {
	                peg$fail(peg$c267);
	            }
	        }
	        if (s1 !== peg$FAILED) {
	            s2 = peg$parseEQUAL();
	            if (s2 !== peg$FAILED) {
	                s3 = peg$parserealm_value();
	                if (s3 !== peg$FAILED) {
	                    s1 = [s1, s2, s3];
	                    s0 = s1;
	                }
	                else {
	                    peg$currPos = s0;
	                    s0 = peg$FAILED;
	                }
	            }
	            else {
	                peg$currPos = s0;
	                s0 = peg$FAILED;
	            }
	        }
	        else {
	            peg$currPos = s0;
	            s0 = peg$FAILED;
	        }
	        return s0;
	    }
	    function peg$parserealm_value() {
	        var s0, s1;
	        s0 = peg$currPos;
	        s1 = peg$parsequoted_string_clean();
	        if (s1 !== peg$FAILED) {
	            peg$savedPos = s0;
	            s1 = peg$c268(s1);
	        }
	        s0 = s1;
	        return s0;
	    }
	    function peg$parsedomain() {
	        var s0, s1, s2, s3, s4, s5, s6, s7, s8;
	        s0 = peg$currPos;
	        if (input.substr(peg$currPos, 6).toLowerCase() === peg$c269) {
	            s1 = input.substr(peg$currPos, 6);
	            peg$currPos += 6;
	        }
	        else {
	            s1 = peg$FAILED;
	            {
	                peg$fail(peg$c270);
	            }
	        }
	        if (s1 !== peg$FAILED) {
	            s2 = peg$parseEQUAL();
	            if (s2 !== peg$FAILED) {
	                s3 = peg$parseLDQUOT();
	                if (s3 !== peg$FAILED) {
	                    s4 = peg$parseURI();
	                    if (s4 !== peg$FAILED) {
	                        s5 = [];
	                        s6 = peg$currPos;
	                        s7 = [];
	                        s8 = peg$parseSP();
	                        if (s8 !== peg$FAILED) {
	                            while (s8 !== peg$FAILED) {
	                                s7.push(s8);
	                                s8 = peg$parseSP();
	                            }
	                        }
	                        else {
	                            s7 = peg$FAILED;
	                        }
	                        if (s7 !== peg$FAILED) {
	                            s8 = peg$parseURI();
	                            if (s8 !== peg$FAILED) {
	                                s7 = [s7, s8];
	                                s6 = s7;
	                            }
	                            else {
	                                peg$currPos = s6;
	                                s6 = peg$FAILED;
	                            }
	                        }
	                        else {
	                            peg$currPos = s6;
	                            s6 = peg$FAILED;
	                        }
	                        while (s6 !== peg$FAILED) {
	                            s5.push(s6);
	                            s6 = peg$currPos;
	                            s7 = [];
	                            s8 = peg$parseSP();
	                            if (s8 !== peg$FAILED) {
	                                while (s8 !== peg$FAILED) {
	                                    s7.push(s8);
	                                    s8 = peg$parseSP();
	                                }
	                            }
	                            else {
	                                s7 = peg$FAILED;
	                            }
	                            if (s7 !== peg$FAILED) {
	                                s8 = peg$parseURI();
	                                if (s8 !== peg$FAILED) {
	                                    s7 = [s7, s8];
	                                    s6 = s7;
	                                }
	                                else {
	                                    peg$currPos = s6;
	                                    s6 = peg$FAILED;
	                                }
	                            }
	                            else {
	                                peg$currPos = s6;
	                                s6 = peg$FAILED;
	                            }
	                        }
	                        if (s5 !== peg$FAILED) {
	                            s6 = peg$parseRDQUOT();
	                            if (s6 !== peg$FAILED) {
	                                s1 = [s1, s2, s3, s4, s5, s6];
	                                s0 = s1;
	                            }
	                            else {
	                                peg$currPos = s0;
	                                s0 = peg$FAILED;
	                            }
	                        }
	                        else {
	                            peg$currPos = s0;
	                            s0 = peg$FAILED;
	                        }
	                    }
	                    else {
	                        peg$currPos = s0;
	                        s0 = peg$FAILED;
	                    }
	                }
	                else {
	                    peg$currPos = s0;
	                    s0 = peg$FAILED;
	                }
	            }
	            else {
	                peg$currPos = s0;
	                s0 = peg$FAILED;
	            }
	        }
	        else {
	            peg$currPos = s0;
	            s0 = peg$FAILED;
	        }
	        return s0;
	    }
	    function peg$parseURI() {
	        var s0;
	        s0 = peg$parseabsoluteURI();
	        if (s0 === peg$FAILED) {
	            s0 = peg$parseabs_path();
	        }
	        return s0;
	    }
	    function peg$parsenonce() {
	        var s0, s1, s2, s3;
	        s0 = peg$currPos;
	        if (input.substr(peg$currPos, 5).toLowerCase() === peg$c271) {
	            s1 = input.substr(peg$currPos, 5);
	            peg$currPos += 5;
	        }
	        else {
	            s1 = peg$FAILED;
	            {
	                peg$fail(peg$c272);
	            }
	        }
	        if (s1 !== peg$FAILED) {
	            s2 = peg$parseEQUAL();
	            if (s2 !== peg$FAILED) {
	                s3 = peg$parsenonce_value();
	                if (s3 !== peg$FAILED) {
	                    s1 = [s1, s2, s3];
	                    s0 = s1;
	                }
	                else {
	                    peg$currPos = s0;
	                    s0 = peg$FAILED;
	                }
	            }
	            else {
	                peg$currPos = s0;
	                s0 = peg$FAILED;
	            }
	        }
	        else {
	            peg$currPos = s0;
	            s0 = peg$FAILED;
	        }
	        return s0;
	    }
	    function peg$parsenonce_value() {
	        var s0, s1;
	        s0 = peg$currPos;
	        s1 = peg$parsequoted_string_clean();
	        if (s1 !== peg$FAILED) {
	            peg$savedPos = s0;
	            s1 = peg$c273(s1);
	        }
	        s0 = s1;
	        return s0;
	    }
	    function peg$parseopaque() {
	        var s0, s1, s2, s3;
	        s0 = peg$currPos;
	        if (input.substr(peg$currPos, 6).toLowerCase() === peg$c274) {
	            s1 = input.substr(peg$currPos, 6);
	            peg$currPos += 6;
	        }
	        else {
	            s1 = peg$FAILED;
	            {
	                peg$fail(peg$c275);
	            }
	        }
	        if (s1 !== peg$FAILED) {
	            s2 = peg$parseEQUAL();
	            if (s2 !== peg$FAILED) {
	                s3 = peg$parsequoted_string_clean();
	                if (s3 !== peg$FAILED) {
	                    peg$savedPos = s0;
	                    s1 = peg$c276(s3);
	                    s0 = s1;
	                }
	                else {
	                    peg$currPos = s0;
	                    s0 = peg$FAILED;
	                }
	            }
	            else {
	                peg$currPos = s0;
	                s0 = peg$FAILED;
	            }
	        }
	        else {
	            peg$currPos = s0;
	            s0 = peg$FAILED;
	        }
	        return s0;
	    }
	    function peg$parsestale() {
	        var s0, s1, s2, s3, s4;
	        s0 = peg$currPos;
	        if (input.substr(peg$currPos, 5).toLowerCase() === peg$c277) {
	            s1 = input.substr(peg$currPos, 5);
	            peg$currPos += 5;
	        }
	        else {
	            s1 = peg$FAILED;
	            {
	                peg$fail(peg$c278);
	            }
	        }
	        if (s1 !== peg$FAILED) {
	            s2 = peg$parseEQUAL();
	            if (s2 !== peg$FAILED) {
	                s3 = peg$currPos;
	                if (input.substr(peg$currPos, 4).toLowerCase() === peg$c279) {
	                    s4 = input.substr(peg$currPos, 4);
	                    peg$currPos += 4;
	                }
	                else {
	                    s4 = peg$FAILED;
	                    {
	                        peg$fail(peg$c280);
	                    }
	                }
	                if (s4 !== peg$FAILED) {
	                    peg$savedPos = s3;
	                    s4 = peg$c281();
	                }
	                s3 = s4;
	                if (s3 === peg$FAILED) {
	                    s3 = peg$currPos;
	                    if (input.substr(peg$currPos, 5).toLowerCase() === peg$c282) {
	                        s4 = input.substr(peg$currPos, 5);
	                        peg$currPos += 5;
	                    }
	                    else {
	                        s4 = peg$FAILED;
	                        {
	                            peg$fail(peg$c283);
	                        }
	                    }
	                    if (s4 !== peg$FAILED) {
	                        peg$savedPos = s3;
	                        s4 = peg$c284();
	                    }
	                    s3 = s4;
	                }
	                if (s3 !== peg$FAILED) {
	                    s1 = [s1, s2, s3];
	                    s0 = s1;
	                }
	                else {
	                    peg$currPos = s0;
	                    s0 = peg$FAILED;
	                }
	            }
	            else {
	                peg$currPos = s0;
	                s0 = peg$FAILED;
	            }
	        }
	        else {
	            peg$currPos = s0;
	            s0 = peg$FAILED;
	        }
	        return s0;
	    }
	    function peg$parsealgorithm() {
	        var s0, s1, s2, s3;
	        s0 = peg$currPos;
	        if (input.substr(peg$currPos, 9).toLowerCase() === peg$c285) {
	            s1 = input.substr(peg$currPos, 9);
	            peg$currPos += 9;
	        }
	        else {
	            s1 = peg$FAILED;
	            {
	                peg$fail(peg$c286);
	            }
	        }
	        if (s1 !== peg$FAILED) {
	            s2 = peg$parseEQUAL();
	            if (s2 !== peg$FAILED) {
	                if (input.substr(peg$currPos, 3).toLowerCase() === peg$c287) {
	                    s3 = input.substr(peg$currPos, 3);
	                    peg$currPos += 3;
	                }
	                else {
	                    s3 = peg$FAILED;
	                    {
	                        peg$fail(peg$c288);
	                    }
	                }
	                if (s3 === peg$FAILED) {
	                    if (input.substr(peg$currPos, 8).toLowerCase() === peg$c289) {
	                        s3 = input.substr(peg$currPos, 8);
	                        peg$currPos += 8;
	                    }
	                    else {
	                        s3 = peg$FAILED;
	                        {
	                            peg$fail(peg$c290);
	                        }
	                    }
	                    if (s3 === peg$FAILED) {
	                        s3 = peg$parsetoken();
	                    }
	                }
	                if (s3 !== peg$FAILED) {
	                    peg$savedPos = s0;
	                    s1 = peg$c291(s3);
	                    s0 = s1;
	                }
	                else {
	                    peg$currPos = s0;
	                    s0 = peg$FAILED;
	                }
	            }
	            else {
	                peg$currPos = s0;
	                s0 = peg$FAILED;
	            }
	        }
	        else {
	            peg$currPos = s0;
	            s0 = peg$FAILED;
	        }
	        return s0;
	    }
	    function peg$parseqop_options() {
	        var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9;
	        s0 = peg$currPos;
	        if (input.substr(peg$currPos, 3).toLowerCase() === peg$c292) {
	            s1 = input.substr(peg$currPos, 3);
	            peg$currPos += 3;
	        }
	        else {
	            s1 = peg$FAILED;
	            {
	                peg$fail(peg$c293);
	            }
	        }
	        if (s1 !== peg$FAILED) {
	            s2 = peg$parseEQUAL();
	            if (s2 !== peg$FAILED) {
	                s3 = peg$parseLDQUOT();
	                if (s3 !== peg$FAILED) {
	                    s4 = peg$currPos;
	                    s5 = peg$parseqop_value();
	                    if (s5 !== peg$FAILED) {
	                        s6 = [];
	                        s7 = peg$currPos;
	                        if (input.charCodeAt(peg$currPos) === 44) {
	                            s8 = peg$c36;
	                            peg$currPos++;
	                        }
	                        else {
	                            s8 = peg$FAILED;
	                            {
	                                peg$fail(peg$c37);
	                            }
	                        }
	                        if (s8 !== peg$FAILED) {
	                            s9 = peg$parseqop_value();
	                            if (s9 !== peg$FAILED) {
	                                s8 = [s8, s9];
	                                s7 = s8;
	                            }
	                            else {
	                                peg$currPos = s7;
	                                s7 = peg$FAILED;
	                            }
	                        }
	                        else {
	                            peg$currPos = s7;
	                            s7 = peg$FAILED;
	                        }
	                        while (s7 !== peg$FAILED) {
	                            s6.push(s7);
	                            s7 = peg$currPos;
	                            if (input.charCodeAt(peg$currPos) === 44) {
	                                s8 = peg$c36;
	                                peg$currPos++;
	                            }
	                            else {
	                                s8 = peg$FAILED;
	                                {
	                                    peg$fail(peg$c37);
	                                }
	                            }
	                            if (s8 !== peg$FAILED) {
	                                s9 = peg$parseqop_value();
	                                if (s9 !== peg$FAILED) {
	                                    s8 = [s8, s9];
	                                    s7 = s8;
	                                }
	                                else {
	                                    peg$currPos = s7;
	                                    s7 = peg$FAILED;
	                                }
	                            }
	                            else {
	                                peg$currPos = s7;
	                                s7 = peg$FAILED;
	                            }
	                        }
	                        if (s6 !== peg$FAILED) {
	                            s5 = [s5, s6];
	                            s4 = s5;
	                        }
	                        else {
	                            peg$currPos = s4;
	                            s4 = peg$FAILED;
	                        }
	                    }
	                    else {
	                        peg$currPos = s4;
	                        s4 = peg$FAILED;
	                    }
	                    if (s4 !== peg$FAILED) {
	                        s5 = peg$parseRDQUOT();
	                        if (s5 !== peg$FAILED) {
	                            s1 = [s1, s2, s3, s4, s5];
	                            s0 = s1;
	                        }
	                        else {
	                            peg$currPos = s0;
	                            s0 = peg$FAILED;
	                        }
	                    }
	                    else {
	                        peg$currPos = s0;
	                        s0 = peg$FAILED;
	                    }
	                }
	                else {
	                    peg$currPos = s0;
	                    s0 = peg$FAILED;
	                }
	            }
	            else {
	                peg$currPos = s0;
	                s0 = peg$FAILED;
	            }
	        }
	        else {
	            peg$currPos = s0;
	            s0 = peg$FAILED;
	        }
	        return s0;
	    }
	    function peg$parseqop_value() {
	        var s0, s1;
	        s0 = peg$currPos;
	        if (input.substr(peg$currPos, 8).toLowerCase() === peg$c294) {
	            s1 = input.substr(peg$currPos, 8);
	            peg$currPos += 8;
	        }
	        else {
	            s1 = peg$FAILED;
	            {
	                peg$fail(peg$c295);
	            }
	        }
	        if (s1 === peg$FAILED) {
	            if (input.substr(peg$currPos, 4).toLowerCase() === peg$c296) {
	                s1 = input.substr(peg$currPos, 4);
	                peg$currPos += 4;
	            }
	            else {
	                s1 = peg$FAILED;
	                {
	                    peg$fail(peg$c297);
	                }
	            }
	            if (s1 === peg$FAILED) {
	                s1 = peg$parsetoken();
	            }
	        }
	        if (s1 !== peg$FAILED) {
	            peg$savedPos = s0;
	            s1 = peg$c298(s1);
	        }
	        s0 = s1;
	        return s0;
	    }
	    function peg$parseRecord_Route() {
	        var s0, s1, s2, s3, s4, s5;
	        s0 = peg$currPos;
	        s1 = peg$parserec_route();
	        if (s1 !== peg$FAILED) {
	            s2 = [];
	            s3 = peg$currPos;
	            s4 = peg$parseCOMMA();
	            if (s4 !== peg$FAILED) {
	                s5 = peg$parserec_route();
	                if (s5 !== peg$FAILED) {
	                    s4 = [s4, s5];
	                    s3 = s4;
	                }
	                else {
	                    peg$currPos = s3;
	                    s3 = peg$FAILED;
	                }
	            }
	            else {
	                peg$currPos = s3;
	                s3 = peg$FAILED;
	            }
	            while (s3 !== peg$FAILED) {
	                s2.push(s3);
	                s3 = peg$currPos;
	                s4 = peg$parseCOMMA();
	                if (s4 !== peg$FAILED) {
	                    s5 = peg$parserec_route();
	                    if (s5 !== peg$FAILED) {
	                        s4 = [s4, s5];
	                        s3 = s4;
	                    }
	                    else {
	                        peg$currPos = s3;
	                        s3 = peg$FAILED;
	                    }
	                }
	                else {
	                    peg$currPos = s3;
	                    s3 = peg$FAILED;
	                }
	            }
	            if (s2 !== peg$FAILED) {
	                peg$savedPos = s0;
	                s1 = peg$c300();
	                s0 = s1;
	            }
	            else {
	                peg$currPos = s0;
	                s0 = peg$FAILED;
	            }
	        }
	        else {
	            peg$currPos = s0;
	            s0 = peg$FAILED;
	        }
	        return s0;
	    }
	    function peg$parserec_route() {
	        var s0, s1, s2, s3, s4, s5;
	        s0 = peg$currPos;
	        s1 = peg$parsename_addr();
	        if (s1 !== peg$FAILED) {
	            s2 = [];
	            s3 = peg$currPos;
	            s4 = peg$parseSEMI();
	            if (s4 !== peg$FAILED) {
	                s5 = peg$parsegeneric_param();
	                if (s5 !== peg$FAILED) {
	                    s4 = [s4, s5];
	                    s3 = s4;
	                }
	                else {
	                    peg$currPos = s3;
	                    s3 = peg$FAILED;
	                }
	            }
	            else {
	                peg$currPos = s3;
	                s3 = peg$FAILED;
	            }
	            while (s3 !== peg$FAILED) {
	                s2.push(s3);
	                s3 = peg$currPos;
	                s4 = peg$parseSEMI();
	                if (s4 !== peg$FAILED) {
	                    s5 = peg$parsegeneric_param();
	                    if (s5 !== peg$FAILED) {
	                        s4 = [s4, s5];
	                        s3 = s4;
	                    }
	                    else {
	                        peg$currPos = s3;
	                        s3 = peg$FAILED;
	                    }
	                }
	                else {
	                    peg$currPos = s3;
	                    s3 = peg$FAILED;
	                }
	            }
	            if (s2 !== peg$FAILED) {
	                peg$savedPos = s0;
	                s1 = peg$c301();
	                s0 = s1;
	            }
	            else {
	                peg$currPos = s0;
	                s0 = peg$FAILED;
	            }
	        }
	        else {
	            peg$currPos = s0;
	            s0 = peg$FAILED;
	        }
	        return s0;
	    }
	    function peg$parseRefer_To() {
	        var s0, s1, s2, s3, s4, s5;
	        s0 = peg$currPos;
	        s1 = peg$parseSIP_URI_noparams();
	        if (s1 === peg$FAILED) {
	            s1 = peg$parsename_addr();
	            if (s1 === peg$FAILED) {
	                s1 = peg$currPos;
	                s2 = peg$parseLAQUOT();
	                if (s2 === peg$FAILED) {
	                    s2 = null;
	                }
	                if (s2 !== peg$FAILED) {
	                    s3 = peg$parseabsoluteURI();
	                    if (s3 !== peg$FAILED) {
	                        s4 = peg$parseRAQUOT();
	                        if (s4 === peg$FAILED) {
	                            s4 = null;
	                        }
	                        if (s4 !== peg$FAILED) {
	                            s2 = [s2, s3, s4];
	                            s1 = s2;
	                        }
	                        else {
	                            peg$currPos = s1;
	                            s1 = peg$FAILED;
	                        }
	                    }
	                    else {
	                        peg$currPos = s1;
	                        s1 = peg$FAILED;
	                    }
	                }
	                else {
	                    peg$currPos = s1;
	                    s1 = peg$FAILED;
	                }
	            }
	        }
	        if (s1 !== peg$FAILED) {
	            s2 = [];
	            s3 = peg$currPos;
	            s4 = peg$parseSEMI();
	            if (s4 !== peg$FAILED) {
	                s5 = peg$parsegeneric_param();
	                if (s5 !== peg$FAILED) {
	                    s4 = [s4, s5];
	                    s3 = s4;
	                }
	                else {
	                    peg$currPos = s3;
	                    s3 = peg$FAILED;
	                }
	            }
	            else {
	                peg$currPos = s3;
	                s3 = peg$FAILED;
	            }
	            while (s3 !== peg$FAILED) {
	                s2.push(s3);
	                s3 = peg$currPos;
	                s4 = peg$parseSEMI();
	                if (s4 !== peg$FAILED) {
	                    s5 = peg$parsegeneric_param();
	                    if (s5 !== peg$FAILED) {
	                        s4 = [s4, s5];
	                        s3 = s4;
	                    }
	                    else {
	                        peg$currPos = s3;
	                        s3 = peg$FAILED;
	                    }
	                }
	                else {
	                    peg$currPos = s3;
	                    s3 = peg$FAILED;
	                }
	            }
	            if (s2 !== peg$FAILED) {
	                peg$savedPos = s0;
	                s1 = peg$c302();
	                s0 = s1;
	            }
	            else {
	                peg$currPos = s0;
	                s0 = peg$FAILED;
	            }
	        }
	        else {
	            peg$currPos = s0;
	            s0 = peg$FAILED;
	        }
	        return s0;
	    }
	    function peg$parseReplaces() {
	        var s0, s1, s2, s3, s4, s5;
	        s0 = peg$currPos;
	        s1 = peg$parsereplaces_call_id();
	        if (s1 !== peg$FAILED) {
	            s2 = [];
	            s3 = peg$currPos;
	            s4 = peg$parseSEMI();
	            if (s4 !== peg$FAILED) {
	                s5 = peg$parsereplaces_params();
	                if (s5 !== peg$FAILED) {
	                    s4 = [s4, s5];
	                    s3 = s4;
	                }
	                else {
	                    peg$currPos = s3;
	                    s3 = peg$FAILED;
	                }
	            }
	            else {
	                peg$currPos = s3;
	                s3 = peg$FAILED;
	            }
	            while (s3 !== peg$FAILED) {
	                s2.push(s3);
	                s3 = peg$currPos;
	                s4 = peg$parseSEMI();
	                if (s4 !== peg$FAILED) {
	                    s5 = peg$parsereplaces_params();
	                    if (s5 !== peg$FAILED) {
	                        s4 = [s4, s5];
	                        s3 = s4;
	                    }
	                    else {
	                        peg$currPos = s3;
	                        s3 = peg$FAILED;
	                    }
	                }
	                else {
	                    peg$currPos = s3;
	                    s3 = peg$FAILED;
	                }
	            }
	            if (s2 !== peg$FAILED) {
	                peg$savedPos = s0;
	                s1 = peg$c303();
	                s0 = s1;
	            }
	            else {
	                peg$currPos = s0;
	                s0 = peg$FAILED;
	            }
	        }
	        else {
	            peg$currPos = s0;
	            s0 = peg$FAILED;
	        }
	        return s0;
	    }
	    function peg$parsereplaces_call_id() {
	        var s0, s1;
	        s0 = peg$currPos;
	        s1 = peg$parseCall_ID();
	        if (s1 !== peg$FAILED) {
	            peg$savedPos = s0;
	            s1 = peg$c304();
	        }
	        s0 = s1;
	        return s0;
	    }
	    function peg$parsereplaces_params() {
	        var s0, s1, s2, s3;
	        s0 = peg$currPos;
	        if (input.substr(peg$currPos, 8).toLowerCase() === peg$c305) {
	            s1 = input.substr(peg$currPos, 8);
	            peg$currPos += 8;
	        }
	        else {
	            s1 = peg$FAILED;
	            {
	                peg$fail(peg$c306);
	            }
	        }
	        if (s1 !== peg$FAILED) {
	            s2 = peg$parseEQUAL();
	            if (s2 !== peg$FAILED) {
	                s3 = peg$parsetoken();
	                if (s3 !== peg$FAILED) {
	                    peg$savedPos = s0;
	                    s1 = peg$c307(s3);
	                    s0 = s1;
	                }
	                else {
	                    peg$currPos = s0;
	                    s0 = peg$FAILED;
	                }
	            }
	            else {
	                peg$currPos = s0;
	                s0 = peg$FAILED;
	            }
	        }
	        else {
	            peg$currPos = s0;
	            s0 = peg$FAILED;
	        }
	        if (s0 === peg$FAILED) {
	            s0 = peg$currPos;
	            if (input.substr(peg$currPos, 6).toLowerCase() === peg$c308) {
	                s1 = input.substr(peg$currPos, 6);
	                peg$currPos += 6;
	            }
	            else {
	                s1 = peg$FAILED;
	                {
	                    peg$fail(peg$c309);
	                }
	            }
	            if (s1 !== peg$FAILED) {
	                s2 = peg$parseEQUAL();
	                if (s2 !== peg$FAILED) {
	                    s3 = peg$parsetoken();
	                    if (s3 !== peg$FAILED) {
	                        peg$savedPos = s0;
	                        s1 = peg$c310(s3);
	                        s0 = s1;
	                    }
	                    else {
	                        peg$currPos = s0;
	                        s0 = peg$FAILED;
	                    }
	                }
	                else {
	                    peg$currPos = s0;
	                    s0 = peg$FAILED;
	                }
	            }
	            else {
	                peg$currPos = s0;
	                s0 = peg$FAILED;
	            }
	            if (s0 === peg$FAILED) {
	                s0 = peg$currPos;
	                if (input.substr(peg$currPos, 10).toLowerCase() === peg$c311) {
	                    s1 = input.substr(peg$currPos, 10);
	                    peg$currPos += 10;
	                }
	                else {
	                    s1 = peg$FAILED;
	                    {
	                        peg$fail(peg$c312);
	                    }
	                }
	                if (s1 !== peg$FAILED) {
	                    peg$savedPos = s0;
	                    s1 = peg$c313();
	                }
	                s0 = s1;
	                if (s0 === peg$FAILED) {
	                    s0 = peg$parsegeneric_param();
	                }
	            }
	        }
	        return s0;
	    }
	    function peg$parseRequire() {
	        var s0, s1, s2, s3, s4, s5, s6;
	        s0 = peg$currPos;
	        s1 = peg$currPos;
	        s2 = peg$parsetoken();
	        if (s2 !== peg$FAILED) {
	            s3 = [];
	            s4 = peg$currPos;
	            s5 = peg$parseCOMMA();
	            if (s5 !== peg$FAILED) {
	                s6 = peg$parsetoken();
	                if (s6 !== peg$FAILED) {
	                    peg$savedPos = s4;
	                    s5 = peg$c314(s2, s6);
	                    s4 = s5;
	                }
	                else {
	                    peg$currPos = s4;
	                    s4 = peg$FAILED;
	                }
	            }
	            else {
	                peg$currPos = s4;
	                s4 = peg$FAILED;
	            }
	            while (s4 !== peg$FAILED) {
	                s3.push(s4);
	                s4 = peg$currPos;
	                s5 = peg$parseCOMMA();
	                if (s5 !== peg$FAILED) {
	                    s6 = peg$parsetoken();
	                    if (s6 !== peg$FAILED) {
	                        peg$savedPos = s4;
	                        s5 = peg$c314(s2, s6);
	                        s4 = s5;
	                    }
	                    else {
	                        peg$currPos = s4;
	                        s4 = peg$FAILED;
	                    }
	                }
	                else {
	                    peg$currPos = s4;
	                    s4 = peg$FAILED;
	                }
	            }
	            if (s3 !== peg$FAILED) {
	                peg$savedPos = s1;
	                s2 = peg$c315(s2, s3);
	                s1 = s2;
	            }
	            else {
	                peg$currPos = s1;
	                s1 = peg$FAILED;
	            }
	        }
	        else {
	            peg$currPos = s1;
	            s1 = peg$FAILED;
	        }
	        if (s1 === peg$FAILED) {
	            s1 = null;
	        }
	        if (s1 !== peg$FAILED) {
	            peg$savedPos = s0;
	            s1 = peg$c316(s1);
	        }
	        s0 = s1;
	        return s0;
	    }
	    function peg$parseSubscription_State() {
	        var s0, s1, s2, s3, s4, s5;
	        s0 = peg$currPos;
	        s1 = peg$parsesubstate_value();
	        if (s1 !== peg$FAILED) {
	            s2 = [];
	            s3 = peg$currPos;
	            s4 = peg$parseSEMI();
	            if (s4 !== peg$FAILED) {
	                s5 = peg$parsesubexp_params();
	                if (s5 !== peg$FAILED) {
	                    s4 = [s4, s5];
	                    s3 = s4;
	                }
	                else {
	                    peg$currPos = s3;
	                    s3 = peg$FAILED;
	                }
	            }
	            else {
	                peg$currPos = s3;
	                s3 = peg$FAILED;
	            }
	            while (s3 !== peg$FAILED) {
	                s2.push(s3);
	                s3 = peg$currPos;
	                s4 = peg$parseSEMI();
	                if (s4 !== peg$FAILED) {
	                    s5 = peg$parsesubexp_params();
	                    if (s5 !== peg$FAILED) {
	                        s4 = [s4, s5];
	                        s3 = s4;
	                    }
	                    else {
	                        peg$currPos = s3;
	                        s3 = peg$FAILED;
	                    }
	                }
	                else {
	                    peg$currPos = s3;
	                    s3 = peg$FAILED;
	                }
	            }
	            if (s2 !== peg$FAILED) {
	                s1 = [s1, s2];
	                s0 = s1;
	            }
	            else {
	                peg$currPos = s0;
	                s0 = peg$FAILED;
	            }
	        }
	        else {
	            peg$currPos = s0;
	            s0 = peg$FAILED;
	        }
	        return s0;
	    }
	    function peg$parsesubstate_value() {
	        var s0, s1;
	        s0 = peg$currPos;
	        if (input.substr(peg$currPos, 6).toLowerCase() === peg$c318) {
	            s1 = input.substr(peg$currPos, 6);
	            peg$currPos += 6;
	        }
	        else {
	            s1 = peg$FAILED;
	            {
	                peg$fail(peg$c319);
	            }
	        }
	        if (s1 === peg$FAILED) {
	            if (input.substr(peg$currPos, 7).toLowerCase() === peg$c320) {
	                s1 = input.substr(peg$currPos, 7);
	                peg$currPos += 7;
	            }
	            else {
	                s1 = peg$FAILED;
	                {
	                    peg$fail(peg$c321);
	                }
	            }
	            if (s1 === peg$FAILED) {
	                if (input.substr(peg$currPos, 10).toLowerCase() === peg$c322) {
	                    s1 = input.substr(peg$currPos, 10);
	                    peg$currPos += 10;
	                }
	                else {
	                    s1 = peg$FAILED;
	                    {
	                        peg$fail(peg$c323);
	                    }
	                }
	                if (s1 === peg$FAILED) {
	                    s1 = peg$parsetoken();
	                }
	            }
	        }
	        if (s1 !== peg$FAILED) {
	            peg$savedPos = s0;
	            s1 = peg$c324();
	        }
	        s0 = s1;
	        return s0;
	    }
	    function peg$parsesubexp_params() {
	        var s0, s1, s2, s3;
	        s0 = peg$currPos;
	        if (input.substr(peg$currPos, 6).toLowerCase() === peg$c325) {
	            s1 = input.substr(peg$currPos, 6);
	            peg$currPos += 6;
	        }
	        else {
	            s1 = peg$FAILED;
	            {
	                peg$fail(peg$c326);
	            }
	        }
	        if (s1 !== peg$FAILED) {
	            s2 = peg$parseEQUAL();
	            if (s2 !== peg$FAILED) {
	                s3 = peg$parseevent_reason_value();
	                if (s3 !== peg$FAILED) {
	                    peg$savedPos = s0;
	                    s1 = peg$c327(s3);
	                    s0 = s1;
	                }
	                else {
	                    peg$currPos = s0;
	                    s0 = peg$FAILED;
	                }
	            }
	            else {
	                peg$currPos = s0;
	                s0 = peg$FAILED;
	            }
	        }
	        else {
	            peg$currPos = s0;
	            s0 = peg$FAILED;
	        }
	        if (s0 === peg$FAILED) {
	            s0 = peg$currPos;
	            if (input.substr(peg$currPos, 7).toLowerCase() === peg$c213) {
	                s1 = input.substr(peg$currPos, 7);
	                peg$currPos += 7;
	            }
	            else {
	                s1 = peg$FAILED;
	                {
	                    peg$fail(peg$c214);
	                }
	            }
	            if (s1 !== peg$FAILED) {
	                s2 = peg$parseEQUAL();
	                if (s2 !== peg$FAILED) {
	                    s3 = peg$parsedelta_seconds();
	                    if (s3 !== peg$FAILED) {
	                        peg$savedPos = s0;
	                        s1 = peg$c328(s3);
	                        s0 = s1;
	                    }
	                    else {
	                        peg$currPos = s0;
	                        s0 = peg$FAILED;
	                    }
	                }
	                else {
	                    peg$currPos = s0;
	                    s0 = peg$FAILED;
	                }
	            }
	            else {
	                peg$currPos = s0;
	                s0 = peg$FAILED;
	            }
	            if (s0 === peg$FAILED) {
	                s0 = peg$currPos;
	                if (input.substr(peg$currPos, 11).toLowerCase() === peg$c329) {
	                    s1 = input.substr(peg$currPos, 11);
	                    peg$currPos += 11;
	                }
	                else {
	                    s1 = peg$FAILED;
	                    {
	                        peg$fail(peg$c330);
	                    }
	                }
	                if (s1 !== peg$FAILED) {
	                    s2 = peg$parseEQUAL();
	                    if (s2 !== peg$FAILED) {
	                        s3 = peg$parsedelta_seconds();
	                        if (s3 !== peg$FAILED) {
	                            peg$savedPos = s0;
	                            s1 = peg$c331(s3);
	                            s0 = s1;
	                        }
	                        else {
	                            peg$currPos = s0;
	                            s0 = peg$FAILED;
	                        }
	                    }
	                    else {
	                        peg$currPos = s0;
	                        s0 = peg$FAILED;
	                    }
	                }
	                else {
	                    peg$currPos = s0;
	                    s0 = peg$FAILED;
	                }
	                if (s0 === peg$FAILED) {
	                    s0 = peg$parsegeneric_param();
	                }
	            }
	        }
	        return s0;
	    }
	    function peg$parseevent_reason_value() {
	        var s0;
	        if (input.substr(peg$currPos, 11).toLowerCase() === peg$c332) {
	            s0 = input.substr(peg$currPos, 11);
	            peg$currPos += 11;
	        }
	        else {
	            s0 = peg$FAILED;
	            {
	                peg$fail(peg$c333);
	            }
	        }
	        if (s0 === peg$FAILED) {
	            if (input.substr(peg$currPos, 9).toLowerCase() === peg$c334) {
	                s0 = input.substr(peg$currPos, 9);
	                peg$currPos += 9;
	            }
	            else {
	                s0 = peg$FAILED;
	                {
	                    peg$fail(peg$c335);
	                }
	            }
	            if (s0 === peg$FAILED) {
	                if (input.substr(peg$currPos, 8).toLowerCase() === peg$c336) {
	                    s0 = input.substr(peg$currPos, 8);
	                    peg$currPos += 8;
	                }
	                else {
	                    s0 = peg$FAILED;
	                    {
	                        peg$fail(peg$c337);
	                    }
	                }
	                if (s0 === peg$FAILED) {
	                    if (input.substr(peg$currPos, 7).toLowerCase() === peg$c338) {
	                        s0 = input.substr(peg$currPos, 7);
	                        peg$currPos += 7;
	                    }
	                    else {
	                        s0 = peg$FAILED;
	                        {
	                            peg$fail(peg$c339);
	                        }
	                    }
	                    if (s0 === peg$FAILED) {
	                        if (input.substr(peg$currPos, 6).toLowerCase() === peg$c340) {
	                            s0 = input.substr(peg$currPos, 6);
	                            peg$currPos += 6;
	                        }
	                        else {
	                            s0 = peg$FAILED;
	                            {
	                                peg$fail(peg$c341);
	                            }
	                        }
	                        if (s0 === peg$FAILED) {
	                            if (input.substr(peg$currPos, 10).toLowerCase() === peg$c342) {
	                                s0 = input.substr(peg$currPos, 10);
	                                peg$currPos += 10;
	                            }
	                            else {
	                                s0 = peg$FAILED;
	                                {
	                                    peg$fail(peg$c343);
	                                }
	                            }
	                            if (s0 === peg$FAILED) {
	                                if (input.substr(peg$currPos, 9).toLowerCase() === peg$c344) {
	                                    s0 = input.substr(peg$currPos, 9);
	                                    peg$currPos += 9;
	                                }
	                                else {
	                                    s0 = peg$FAILED;
	                                    {
	                                        peg$fail(peg$c345);
	                                    }
	                                }
	                                if (s0 === peg$FAILED) {
	                                    s0 = peg$parsetoken();
	                                }
	                            }
	                        }
	                    }
	                }
	            }
	        }
	        return s0;
	    }
	    function peg$parseSupported() {
	        var s0, s1, s2, s3, s4, s5, s6;
	        s0 = peg$currPos;
	        s1 = peg$currPos;
	        s2 = peg$parsetoken();
	        if (s2 !== peg$FAILED) {
	            s3 = [];
	            s4 = peg$currPos;
	            s5 = peg$parseCOMMA();
	            if (s5 !== peg$FAILED) {
	                s6 = peg$parsetoken();
	                if (s6 !== peg$FAILED) {
	                    peg$savedPos = s4;
	                    s5 = peg$c314(s2, s6);
	                    s4 = s5;
	                }
	                else {
	                    peg$currPos = s4;
	                    s4 = peg$FAILED;
	                }
	            }
	            else {
	                peg$currPos = s4;
	                s4 = peg$FAILED;
	            }
	            while (s4 !== peg$FAILED) {
	                s3.push(s4);
	                s4 = peg$currPos;
	                s5 = peg$parseCOMMA();
	                if (s5 !== peg$FAILED) {
	                    s6 = peg$parsetoken();
	                    if (s6 !== peg$FAILED) {
	                        peg$savedPos = s4;
	                        s5 = peg$c314(s2, s6);
	                        s4 = s5;
	                    }
	                    else {
	                        peg$currPos = s4;
	                        s4 = peg$FAILED;
	                    }
	                }
	                else {
	                    peg$currPos = s4;
	                    s4 = peg$FAILED;
	                }
	            }
	            if (s3 !== peg$FAILED) {
	                peg$savedPos = s1;
	                s2 = peg$c315(s2, s3);
	                s1 = s2;
	            }
	            else {
	                peg$currPos = s1;
	                s1 = peg$FAILED;
	            }
	        }
	        else {
	            peg$currPos = s1;
	            s1 = peg$FAILED;
	        }
	        if (s1 === peg$FAILED) {
	            s1 = null;
	        }
	        if (s1 !== peg$FAILED) {
	            peg$savedPos = s0;
	            s1 = peg$c346(s1);
	        }
	        s0 = s1;
	        return s0;
	    }
	    function peg$parseTo() {
	        var s0, s1, s2, s3, s4, s5;
	        s0 = peg$currPos;
	        s1 = peg$parseSIP_URI_noparams();
	        if (s1 === peg$FAILED) {
	            s1 = peg$parsename_addr();
	        }
	        if (s1 !== peg$FAILED) {
	            s2 = [];
	            s3 = peg$currPos;
	            s4 = peg$parseSEMI();
	            if (s4 !== peg$FAILED) {
	                s5 = peg$parseto_param();
	                if (s5 !== peg$FAILED) {
	                    s4 = [s4, s5];
	                    s3 = s4;
	                }
	                else {
	                    peg$currPos = s3;
	                    s3 = peg$FAILED;
	                }
	            }
	            else {
	                peg$currPos = s3;
	                s3 = peg$FAILED;
	            }
	            while (s3 !== peg$FAILED) {
	                s2.push(s3);
	                s3 = peg$currPos;
	                s4 = peg$parseSEMI();
	                if (s4 !== peg$FAILED) {
	                    s5 = peg$parseto_param();
	                    if (s5 !== peg$FAILED) {
	                        s4 = [s4, s5];
	                        s3 = s4;
	                    }
	                    else {
	                        peg$currPos = s3;
	                        s3 = peg$FAILED;
	                    }
	                }
	                else {
	                    peg$currPos = s3;
	                    s3 = peg$FAILED;
	                }
	            }
	            if (s2 !== peg$FAILED) {
	                peg$savedPos = s0;
	                s1 = peg$c347();
	                s0 = s1;
	            }
	            else {
	                peg$currPos = s0;
	                s0 = peg$FAILED;
	            }
	        }
	        else {
	            peg$currPos = s0;
	            s0 = peg$FAILED;
	        }
	        return s0;
	    }
	    function peg$parseto_param() {
	        var s0;
	        s0 = peg$parsetag_param();
	        if (s0 === peg$FAILED) {
	            s0 = peg$parsegeneric_param();
	        }
	        return s0;
	    }
	    function peg$parseVia() {
	        var s0, s1, s2, s3, s4, s5;
	        s0 = peg$currPos;
	        s1 = peg$parsevia_parm();
	        if (s1 !== peg$FAILED) {
	            s2 = [];
	            s3 = peg$currPos;
	            s4 = peg$parseCOMMA();
	            if (s4 !== peg$FAILED) {
	                s5 = peg$parsevia_parm();
	                if (s5 !== peg$FAILED) {
	                    s4 = [s4, s5];
	                    s3 = s4;
	                }
	                else {
	                    peg$currPos = s3;
	                    s3 = peg$FAILED;
	                }
	            }
	            else {
	                peg$currPos = s3;
	                s3 = peg$FAILED;
	            }
	            while (s3 !== peg$FAILED) {
	                s2.push(s3);
	                s3 = peg$currPos;
	                s4 = peg$parseCOMMA();
	                if (s4 !== peg$FAILED) {
	                    s5 = peg$parsevia_parm();
	                    if (s5 !== peg$FAILED) {
	                        s4 = [s4, s5];
	                        s3 = s4;
	                    }
	                    else {
	                        peg$currPos = s3;
	                        s3 = peg$FAILED;
	                    }
	                }
	                else {
	                    peg$currPos = s3;
	                    s3 = peg$FAILED;
	                }
	            }
	            if (s2 !== peg$FAILED) {
	                s1 = [s1, s2];
	                s0 = s1;
	            }
	            else {
	                peg$currPos = s0;
	                s0 = peg$FAILED;
	            }
	        }
	        else {
	            peg$currPos = s0;
	            s0 = peg$FAILED;
	        }
	        return s0;
	    }
	    function peg$parsevia_parm() {
	        var s0, s1, s2, s3, s4, s5, s6, s7;
	        s0 = peg$currPos;
	        s1 = peg$parsesent_protocol();
	        if (s1 !== peg$FAILED) {
	            s2 = peg$parseLWS();
	            if (s2 !== peg$FAILED) {
	                s3 = peg$parsesent_by();
	                if (s3 !== peg$FAILED) {
	                    s4 = [];
	                    s5 = peg$currPos;
	                    s6 = peg$parseSEMI();
	                    if (s6 !== peg$FAILED) {
	                        s7 = peg$parsevia_params();
	                        if (s7 !== peg$FAILED) {
	                            s6 = [s6, s7];
	                            s5 = s6;
	                        }
	                        else {
	                            peg$currPos = s5;
	                            s5 = peg$FAILED;
	                        }
	                    }
	                    else {
	                        peg$currPos = s5;
	                        s5 = peg$FAILED;
	                    }
	                    while (s5 !== peg$FAILED) {
	                        s4.push(s5);
	                        s5 = peg$currPos;
	                        s6 = peg$parseSEMI();
	                        if (s6 !== peg$FAILED) {
	                            s7 = peg$parsevia_params();
	                            if (s7 !== peg$FAILED) {
	                                s6 = [s6, s7];
	                                s5 = s6;
	                            }
	                            else {
	                                peg$currPos = s5;
	                                s5 = peg$FAILED;
	                            }
	                        }
	                        else {
	                            peg$currPos = s5;
	                            s5 = peg$FAILED;
	                        }
	                    }
	                    if (s4 !== peg$FAILED) {
	                        s1 = [s1, s2, s3, s4];
	                        s0 = s1;
	                    }
	                    else {
	                        peg$currPos = s0;
	                        s0 = peg$FAILED;
	                    }
	                }
	                else {
	                    peg$currPos = s0;
	                    s0 = peg$FAILED;
	                }
	            }
	            else {
	                peg$currPos = s0;
	                s0 = peg$FAILED;
	            }
	        }
	        else {
	            peg$currPos = s0;
	            s0 = peg$FAILED;
	        }
	        return s0;
	    }
	    function peg$parsevia_params() {
	        var s0;
	        s0 = peg$parsevia_ttl();
	        if (s0 === peg$FAILED) {
	            s0 = peg$parsevia_maddr();
	            if (s0 === peg$FAILED) {
	                s0 = peg$parsevia_received();
	                if (s0 === peg$FAILED) {
	                    s0 = peg$parsevia_branch();
	                    if (s0 === peg$FAILED) {
	                        s0 = peg$parseresponse_port();
	                        if (s0 === peg$FAILED) {
	                            s0 = peg$parsegeneric_param();
	                        }
	                    }
	                }
	            }
	        }
	        return s0;
	    }
	    function peg$parsevia_ttl() {
	        var s0, s1, s2, s3;
	        s0 = peg$currPos;
	        if (input.substr(peg$currPos, 3).toLowerCase() === peg$c348) {
	            s1 = input.substr(peg$currPos, 3);
	            peg$currPos += 3;
	        }
	        else {
	            s1 = peg$FAILED;
	            {
	                peg$fail(peg$c349);
	            }
	        }
	        if (s1 !== peg$FAILED) {
	            s2 = peg$parseEQUAL();
	            if (s2 !== peg$FAILED) {
	                s3 = peg$parsettl();
	                if (s3 !== peg$FAILED) {
	                    peg$savedPos = s0;
	                    s1 = peg$c350(s3);
	                    s0 = s1;
	                }
	                else {
	                    peg$currPos = s0;
	                    s0 = peg$FAILED;
	                }
	            }
	            else {
	                peg$currPos = s0;
	                s0 = peg$FAILED;
	            }
	        }
	        else {
	            peg$currPos = s0;
	            s0 = peg$FAILED;
	        }
	        return s0;
	    }
	    function peg$parsevia_maddr() {
	        var s0, s1, s2, s3;
	        s0 = peg$currPos;
	        if (input.substr(peg$currPos, 5).toLowerCase() === peg$c351) {
	            s1 = input.substr(peg$currPos, 5);
	            peg$currPos += 5;
	        }
	        else {
	            s1 = peg$FAILED;
	            {
	                peg$fail(peg$c352);
	            }
	        }
	        if (s1 !== peg$FAILED) {
	            s2 = peg$parseEQUAL();
	            if (s2 !== peg$FAILED) {
	                s3 = peg$parsehost();
	                if (s3 !== peg$FAILED) {
	                    peg$savedPos = s0;
	                    s1 = peg$c353(s3);
	                    s0 = s1;
	                }
	                else {
	                    peg$currPos = s0;
	                    s0 = peg$FAILED;
	                }
	            }
	            else {
	                peg$currPos = s0;
	                s0 = peg$FAILED;
	            }
	        }
	        else {
	            peg$currPos = s0;
	            s0 = peg$FAILED;
	        }
	        return s0;
	    }
	    function peg$parsevia_received() {
	        var s0, s1, s2, s3;
	        s0 = peg$currPos;
	        if (input.substr(peg$currPos, 8).toLowerCase() === peg$c354) {
	            s1 = input.substr(peg$currPos, 8);
	            peg$currPos += 8;
	        }
	        else {
	            s1 = peg$FAILED;
	            {
	                peg$fail(peg$c355);
	            }
	        }
	        if (s1 !== peg$FAILED) {
	            s2 = peg$parseEQUAL();
	            if (s2 !== peg$FAILED) {
	                s3 = peg$parseIPv4address();
	                if (s3 === peg$FAILED) {
	                    s3 = peg$parseIPv6address();
	                    if (s3 === peg$FAILED) {
	                        s3 = peg$parseIPv6reference();
	                    }
	                }
	                if (s3 !== peg$FAILED) {
	                    peg$savedPos = s0;
	                    s1 = peg$c356(s3);
	                    s0 = s1;
	                }
	                else {
	                    peg$currPos = s0;
	                    s0 = peg$FAILED;
	                }
	            }
	            else {
	                peg$currPos = s0;
	                s0 = peg$FAILED;
	            }
	        }
	        else {
	            peg$currPos = s0;
	            s0 = peg$FAILED;
	        }
	        return s0;
	    }
	    function peg$parsevia_branch() {
	        var s0, s1, s2, s3;
	        s0 = peg$currPos;
	        if (input.substr(peg$currPos, 6).toLowerCase() === peg$c357) {
	            s1 = input.substr(peg$currPos, 6);
	            peg$currPos += 6;
	        }
	        else {
	            s1 = peg$FAILED;
	            {
	                peg$fail(peg$c358);
	            }
	        }
	        if (s1 !== peg$FAILED) {
	            s2 = peg$parseEQUAL();
	            if (s2 !== peg$FAILED) {
	                s3 = peg$parsetoken();
	                if (s3 !== peg$FAILED) {
	                    peg$savedPos = s0;
	                    s1 = peg$c359(s3);
	                    s0 = s1;
	                }
	                else {
	                    peg$currPos = s0;
	                    s0 = peg$FAILED;
	                }
	            }
	            else {
	                peg$currPos = s0;
	                s0 = peg$FAILED;
	            }
	        }
	        else {
	            peg$currPos = s0;
	            s0 = peg$FAILED;
	        }
	        return s0;
	    }
	    function peg$parseresponse_port() {
	        var s0, s1, s2, s3, s4;
	        s0 = peg$currPos;
	        if (input.substr(peg$currPos, 5).toLowerCase() === peg$c360) {
	            s1 = input.substr(peg$currPos, 5);
	            peg$currPos += 5;
	        }
	        else {
	            s1 = peg$FAILED;
	            {
	                peg$fail(peg$c361);
	            }
	        }
	        if (s1 !== peg$FAILED) {
	            s2 = peg$parseEQUAL();
	            if (s2 !== peg$FAILED) {
	                s3 = [];
	                s4 = peg$parseDIGIT();
	                while (s4 !== peg$FAILED) {
	                    s3.push(s4);
	                    s4 = peg$parseDIGIT();
	                }
	                if (s3 !== peg$FAILED) {
	                    peg$savedPos = s0;
	                    s1 = peg$c362(s3);
	                    s0 = s1;
	                }
	                else {
	                    peg$currPos = s0;
	                    s0 = peg$FAILED;
	                }
	            }
	            else {
	                peg$currPos = s0;
	                s0 = peg$FAILED;
	            }
	        }
	        else {
	            peg$currPos = s0;
	            s0 = peg$FAILED;
	        }
	        return s0;
	    }
	    function peg$parsesent_protocol() {
	        var s0, s1, s2, s3, s4, s5;
	        s0 = peg$currPos;
	        s1 = peg$parseprotocol_name();
	        if (s1 !== peg$FAILED) {
	            s2 = peg$parseSLASH();
	            if (s2 !== peg$FAILED) {
	                s3 = peg$parsetoken();
	                if (s3 !== peg$FAILED) {
	                    s4 = peg$parseSLASH();
	                    if (s4 !== peg$FAILED) {
	                        s5 = peg$parsetransport();
	                        if (s5 !== peg$FAILED) {
	                            s1 = [s1, s2, s3, s4, s5];
	                            s0 = s1;
	                        }
	                        else {
	                            peg$currPos = s0;
	                            s0 = peg$FAILED;
	                        }
	                    }
	                    else {
	                        peg$currPos = s0;
	                        s0 = peg$FAILED;
	                    }
	                }
	                else {
	                    peg$currPos = s0;
	                    s0 = peg$FAILED;
	                }
	            }
	            else {
	                peg$currPos = s0;
	                s0 = peg$FAILED;
	            }
	        }
	        else {
	            peg$currPos = s0;
	            s0 = peg$FAILED;
	        }
	        return s0;
	    }
	    function peg$parseprotocol_name() {
	        var s0, s1;
	        s0 = peg$currPos;
	        if (input.substr(peg$currPos, 3).toLowerCase() === peg$c114) {
	            s1 = input.substr(peg$currPos, 3);
	            peg$currPos += 3;
	        }
	        else {
	            s1 = peg$FAILED;
	            {
	                peg$fail(peg$c179);
	            }
	        }
	        if (s1 === peg$FAILED) {
	            s1 = peg$parsetoken();
	        }
	        if (s1 !== peg$FAILED) {
	            peg$savedPos = s0;
	            s1 = peg$c363(s1);
	        }
	        s0 = s1;
	        return s0;
	    }
	    function peg$parsetransport() {
	        var s0, s1;
	        s0 = peg$currPos;
	        if (input.substr(peg$currPos, 3).toLowerCase() === peg$c145) {
	            s1 = input.substr(peg$currPos, 3);
	            peg$currPos += 3;
	        }
	        else {
	            s1 = peg$FAILED;
	            {
	                peg$fail(peg$c364);
	            }
	        }
	        if (s1 === peg$FAILED) {
	            if (input.substr(peg$currPos, 3).toLowerCase() === peg$c147) {
	                s1 = input.substr(peg$currPos, 3);
	                peg$currPos += 3;
	            }
	            else {
	                s1 = peg$FAILED;
	                {
	                    peg$fail(peg$c365);
	                }
	            }
	            if (s1 === peg$FAILED) {
	                if (input.substr(peg$currPos, 3).toLowerCase() === peg$c151) {
	                    s1 = input.substr(peg$currPos, 3);
	                    peg$currPos += 3;
	                }
	                else {
	                    s1 = peg$FAILED;
	                    {
	                        peg$fail(peg$c366);
	                    }
	                }
	                if (s1 === peg$FAILED) {
	                    if (input.substr(peg$currPos, 4).toLowerCase() === peg$c149) {
	                        s1 = input.substr(peg$currPos, 4);
	                        peg$currPos += 4;
	                    }
	                    else {
	                        s1 = peg$FAILED;
	                        {
	                            peg$fail(peg$c367);
	                        }
	                    }
	                    if (s1 === peg$FAILED) {
	                        s1 = peg$parsetoken();
	                    }
	                }
	            }
	        }
	        if (s1 !== peg$FAILED) {
	            peg$savedPos = s0;
	            s1 = peg$c368(s1);
	        }
	        s0 = s1;
	        return s0;
	    }
	    function peg$parsesent_by() {
	        var s0, s1, s2, s3, s4;
	        s0 = peg$currPos;
	        s1 = peg$parseviaHost();
	        if (s1 !== peg$FAILED) {
	            s2 = peg$currPos;
	            s3 = peg$parseCOLON();
	            if (s3 !== peg$FAILED) {
	                s4 = peg$parsevia_port();
	                if (s4 !== peg$FAILED) {
	                    s3 = [s3, s4];
	                    s2 = s3;
	                }
	                else {
	                    peg$currPos = s2;
	                    s2 = peg$FAILED;
	                }
	            }
	            else {
	                peg$currPos = s2;
	                s2 = peg$FAILED;
	            }
	            if (s2 === peg$FAILED) {
	                s2 = null;
	            }
	            if (s2 !== peg$FAILED) {
	                s1 = [s1, s2];
	                s0 = s1;
	            }
	            else {
	                peg$currPos = s0;
	                s0 = peg$FAILED;
	            }
	        }
	        else {
	            peg$currPos = s0;
	            s0 = peg$FAILED;
	        }
	        return s0;
	    }
	    function peg$parseviaHost() {
	        var s0, s1;
	        s0 = peg$currPos;
	        s1 = peg$parsehostname();
	        if (s1 === peg$FAILED) {
	            s1 = peg$parseIPv4address();
	            if (s1 === peg$FAILED) {
	                s1 = peg$parseIPv6reference();
	            }
	        }
	        if (s1 !== peg$FAILED) {
	            peg$savedPos = s0;
	            s1 = peg$c369();
	        }
	        s0 = s1;
	        return s0;
	    }
	    function peg$parsevia_port() {
	        var s0, s1, s2, s3, s4, s5, s6;
	        s0 = peg$currPos;
	        s1 = peg$currPos;
	        s2 = peg$parseDIGIT();
	        if (s2 === peg$FAILED) {
	            s2 = null;
	        }
	        if (s2 !== peg$FAILED) {
	            s3 = peg$parseDIGIT();
	            if (s3 === peg$FAILED) {
	                s3 = null;
	            }
	            if (s3 !== peg$FAILED) {
	                s4 = peg$parseDIGIT();
	                if (s4 === peg$FAILED) {
	                    s4 = null;
	                }
	                if (s4 !== peg$FAILED) {
	                    s5 = peg$parseDIGIT();
	                    if (s5 === peg$FAILED) {
	                        s5 = null;
	                    }
	                    if (s5 !== peg$FAILED) {
	                        s6 = peg$parseDIGIT();
	                        if (s6 === peg$FAILED) {
	                            s6 = null;
	                        }
	                        if (s6 !== peg$FAILED) {
	                            s2 = [s2, s3, s4, s5, s6];
	                            s1 = s2;
	                        }
	                        else {
	                            peg$currPos = s1;
	                            s1 = peg$FAILED;
	                        }
	                    }
	                    else {
	                        peg$currPos = s1;
	                        s1 = peg$FAILED;
	                    }
	                }
	                else {
	                    peg$currPos = s1;
	                    s1 = peg$FAILED;
	                }
	            }
	            else {
	                peg$currPos = s1;
	                s1 = peg$FAILED;
	            }
	        }
	        else {
	            peg$currPos = s1;
	            s1 = peg$FAILED;
	        }
	        if (s1 !== peg$FAILED) {
	            peg$savedPos = s0;
	            s1 = peg$c370(s1);
	        }
	        s0 = s1;
	        return s0;
	    }
	    function peg$parsettl() {
	        var s0, s1, s2, s3, s4;
	        s0 = peg$currPos;
	        s1 = peg$currPos;
	        s2 = peg$parseDIGIT();
	        if (s2 !== peg$FAILED) {
	            s3 = peg$parseDIGIT();
	            if (s3 === peg$FAILED) {
	                s3 = null;
	            }
	            if (s3 !== peg$FAILED) {
	                s4 = peg$parseDIGIT();
	                if (s4 === peg$FAILED) {
	                    s4 = null;
	                }
	                if (s4 !== peg$FAILED) {
	                    s2 = [s2, s3, s4];
	                    s1 = s2;
	                }
	                else {
	                    peg$currPos = s1;
	                    s1 = peg$FAILED;
	                }
	            }
	            else {
	                peg$currPos = s1;
	                s1 = peg$FAILED;
	            }
	        }
	        else {
	            peg$currPos = s1;
	            s1 = peg$FAILED;
	        }
	        if (s1 !== peg$FAILED) {
	            peg$savedPos = s0;
	            s1 = peg$c371(s1);
	        }
	        s0 = s1;
	        return s0;
	    }
	    function peg$parseWWW_Authenticate() {
	        var s0;
	        s0 = peg$parsechallenge();
	        return s0;
	    }
	    function peg$parseSession_Expires() {
	        var s0, s1, s2, s3, s4, s5;
	        s0 = peg$currPos;
	        s1 = peg$parsedelta_seconds();
	        if (s1 !== peg$FAILED) {
	            s2 = [];
	            s3 = peg$currPos;
	            s4 = peg$parseSEMI();
	            if (s4 !== peg$FAILED) {
	                s5 = peg$parsese_params();
	                if (s5 !== peg$FAILED) {
	                    s4 = [s4, s5];
	                    s3 = s4;
	                }
	                else {
	                    peg$currPos = s3;
	                    s3 = peg$FAILED;
	                }
	            }
	            else {
	                peg$currPos = s3;
	                s3 = peg$FAILED;
	            }
	            while (s3 !== peg$FAILED) {
	                s2.push(s3);
	                s3 = peg$currPos;
	                s4 = peg$parseSEMI();
	                if (s4 !== peg$FAILED) {
	                    s5 = peg$parsese_params();
	                    if (s5 !== peg$FAILED) {
	                        s4 = [s4, s5];
	                        s3 = s4;
	                    }
	                    else {
	                        peg$currPos = s3;
	                        s3 = peg$FAILED;
	                    }
	                }
	                else {
	                    peg$currPos = s3;
	                    s3 = peg$FAILED;
	                }
	            }
	            if (s2 !== peg$FAILED) {
	                peg$savedPos = s0;
	                s1 = peg$c372(s1);
	                s0 = s1;
	            }
	            else {
	                peg$currPos = s0;
	                s0 = peg$FAILED;
	            }
	        }
	        else {
	            peg$currPos = s0;
	            s0 = peg$FAILED;
	        }
	        return s0;
	    }
	    function peg$parsese_params() {
	        var s0;
	        s0 = peg$parserefresher_param();
	        if (s0 === peg$FAILED) {
	            s0 = peg$parsegeneric_param();
	        }
	        return s0;
	    }
	    function peg$parserefresher_param() {
	        var s0, s1, s2, s3;
	        s0 = peg$currPos;
	        if (input.substr(peg$currPos, 9) === peg$c373) {
	            s1 = peg$c373;
	            peg$currPos += 9;
	        }
	        else {
	            s1 = peg$FAILED;
	            {
	                peg$fail(peg$c374);
	            }
	        }
	        if (s1 !== peg$FAILED) {
	            s2 = peg$parseEQUAL();
	            if (s2 !== peg$FAILED) {
	                if (input.substr(peg$currPos, 3) === peg$c375) {
	                    s3 = peg$c375;
	                    peg$currPos += 3;
	                }
	                else {
	                    s3 = peg$FAILED;
	                    {
	                        peg$fail(peg$c376);
	                    }
	                }
	                if (s3 === peg$FAILED) {
	                    if (input.substr(peg$currPos, 3) === peg$c377) {
	                        s3 = peg$c377;
	                        peg$currPos += 3;
	                    }
	                    else {
	                        s3 = peg$FAILED;
	                        {
	                            peg$fail(peg$c378);
	                        }
	                    }
	                }
	                if (s3 !== peg$FAILED) {
	                    peg$savedPos = s0;
	                    s1 = peg$c379(s3);
	                    s0 = s1;
	                }
	                else {
	                    peg$currPos = s0;
	                    s0 = peg$FAILED;
	                }
	            }
	            else {
	                peg$currPos = s0;
	                s0 = peg$FAILED;
	            }
	        }
	        else {
	            peg$currPos = s0;
	            s0 = peg$FAILED;
	        }
	        return s0;
	    }
	    function peg$parseMin_SE() {
	        var s0, s1, s2, s3, s4, s5;
	        s0 = peg$currPos;
	        s1 = peg$parsedelta_seconds();
	        if (s1 !== peg$FAILED) {
	            s2 = [];
	            s3 = peg$currPos;
	            s4 = peg$parseSEMI();
	            if (s4 !== peg$FAILED) {
	                s5 = peg$parsegeneric_param();
	                if (s5 !== peg$FAILED) {
	                    s4 = [s4, s5];
	                    s3 = s4;
	                }
	                else {
	                    peg$currPos = s3;
	                    s3 = peg$FAILED;
	                }
	            }
	            else {
	                peg$currPos = s3;
	                s3 = peg$FAILED;
	            }
	            while (s3 !== peg$FAILED) {
	                s2.push(s3);
	                s3 = peg$currPos;
	                s4 = peg$parseSEMI();
	                if (s4 !== peg$FAILED) {
	                    s5 = peg$parsegeneric_param();
	                    if (s5 !== peg$FAILED) {
	                        s4 = [s4, s5];
	                        s3 = s4;
	                    }
	                    else {
	                        peg$currPos = s3;
	                        s3 = peg$FAILED;
	                    }
	                }
	                else {
	                    peg$currPos = s3;
	                    s3 = peg$FAILED;
	                }
	            }
	            if (s2 !== peg$FAILED) {
	                peg$savedPos = s0;
	                s1 = peg$c380(s1);
	                s0 = s1;
	            }
	            else {
	                peg$currPos = s0;
	                s0 = peg$FAILED;
	            }
	        }
	        else {
	            peg$currPos = s0;
	            s0 = peg$FAILED;
	        }
	        return s0;
	    }
	    function peg$parsemessage_body() {
	        var s0, s1;
	        s0 = [];
	        s1 = peg$parseOCTET();
	        while (s1 !== peg$FAILED) {
	            s0.push(s1);
	            s1 = peg$parseOCTET();
	        }
	        return s0;
	    }
	    function peg$parsestun_URI() {
	        var s0, s1, s2, s3;
	        s0 = peg$currPos;
	        s1 = peg$parsestun_scheme();
	        if (s1 !== peg$FAILED) {
	            if (input.charCodeAt(peg$currPos) === 58) {
	                s2 = peg$c24;
	                peg$currPos++;
	            }
	            else {
	                s2 = peg$FAILED;
	                {
	                    peg$fail(peg$c25);
	                }
	            }
	            if (s2 !== peg$FAILED) {
	                s3 = peg$parsestun_host_port();
	                if (s3 !== peg$FAILED) {
	                    s1 = [s1, s2, s3];
	                    s0 = s1;
	                }
	                else {
	                    peg$currPos = s0;
	                    s0 = peg$FAILED;
	                }
	            }
	            else {
	                peg$currPos = s0;
	                s0 = peg$FAILED;
	            }
	        }
	        else {
	            peg$currPos = s0;
	            s0 = peg$FAILED;
	        }
	        return s0;
	    }
	    function peg$parsestun_scheme() {
	        var s0, s1;
	        s0 = peg$currPos;
	        if (input.substr(peg$currPos, 5).toLowerCase() === peg$c381) {
	            s1 = input.substr(peg$currPos, 5);
	            peg$currPos += 5;
	        }
	        else {
	            s1 = peg$FAILED;
	            {
	                peg$fail(peg$c382);
	            }
	        }
	        if (s1 === peg$FAILED) {
	            if (input.substr(peg$currPos, 4).toLowerCase() === peg$c383) {
	                s1 = input.substr(peg$currPos, 4);
	                peg$currPos += 4;
	            }
	            else {
	                s1 = peg$FAILED;
	                {
	                    peg$fail(peg$c384);
	                }
	            }
	        }
	        if (s1 !== peg$FAILED) {
	            peg$savedPos = s0;
	            s1 = peg$c385(s1);
	        }
	        s0 = s1;
	        return s0;
	    }
	    function peg$parsestun_host_port() {
	        var s0, s1, s2, s3, s4;
	        s0 = peg$currPos;
	        s1 = peg$parsestun_host();
	        if (s1 !== peg$FAILED) {
	            s2 = peg$currPos;
	            if (input.charCodeAt(peg$currPos) === 58) {
	                s3 = peg$c24;
	                peg$currPos++;
	            }
	            else {
	                s3 = peg$FAILED;
	                {
	                    peg$fail(peg$c25);
	                }
	            }
	            if (s3 !== peg$FAILED) {
	                s4 = peg$parseport();
	                if (s4 !== peg$FAILED) {
	                    s3 = [s3, s4];
	                    s2 = s3;
	                }
	                else {
	                    peg$currPos = s2;
	                    s2 = peg$FAILED;
	                }
	            }
	            else {
	                peg$currPos = s2;
	                s2 = peg$FAILED;
	            }
	            if (s2 === peg$FAILED) {
	                s2 = null;
	            }
	            if (s2 !== peg$FAILED) {
	                s1 = [s1, s2];
	                s0 = s1;
	            }
	            else {
	                peg$currPos = s0;
	                s0 = peg$FAILED;
	            }
	        }
	        else {
	            peg$currPos = s0;
	            s0 = peg$FAILED;
	        }
	        return s0;
	    }
	    function peg$parsestun_host() {
	        var s0, s1;
	        s0 = peg$currPos;
	        s1 = peg$parseIPv4address();
	        if (s1 === peg$FAILED) {
	            s1 = peg$parseIPv6reference();
	            if (s1 === peg$FAILED) {
	                s1 = peg$parsereg_name();
	            }
	        }
	        if (s1 !== peg$FAILED) {
	            peg$savedPos = s0;
	            s1 = peg$c386(s1);
	        }
	        s0 = s1;
	        return s0;
	    }
	    function peg$parseturn_URI() {
	        var s0, s1, s2, s3, s4, s5, s6;
	        s0 = peg$currPos;
	        s1 = peg$parseturn_scheme();
	        if (s1 !== peg$FAILED) {
	            if (input.charCodeAt(peg$currPos) === 58) {
	                s2 = peg$c24;
	                peg$currPos++;
	            }
	            else {
	                s2 = peg$FAILED;
	                {
	                    peg$fail(peg$c25);
	                }
	            }
	            if (s2 !== peg$FAILED) {
	                s3 = peg$parsestun_host_port();
	                if (s3 !== peg$FAILED) {
	                    s4 = peg$currPos;
	                    if (input.substr(peg$currPos, 11) === peg$c387) {
	                        s5 = peg$c387;
	                        peg$currPos += 11;
	                    }
	                    else {
	                        s5 = peg$FAILED;
	                        {
	                            peg$fail(peg$c388);
	                        }
	                    }
	                    if (s5 !== peg$FAILED) {
	                        s6 = peg$parsetransport();
	                        if (s6 !== peg$FAILED) {
	                            s5 = [s5, s6];
	                            s4 = s5;
	                        }
	                        else {
	                            peg$currPos = s4;
	                            s4 = peg$FAILED;
	                        }
	                    }
	                    else {
	                        peg$currPos = s4;
	                        s4 = peg$FAILED;
	                    }
	                    if (s4 === peg$FAILED) {
	                        s4 = null;
	                    }
	                    if (s4 !== peg$FAILED) {
	                        s1 = [s1, s2, s3, s4];
	                        s0 = s1;
	                    }
	                    else {
	                        peg$currPos = s0;
	                        s0 = peg$FAILED;
	                    }
	                }
	                else {
	                    peg$currPos = s0;
	                    s0 = peg$FAILED;
	                }
	            }
	            else {
	                peg$currPos = s0;
	                s0 = peg$FAILED;
	            }
	        }
	        else {
	            peg$currPos = s0;
	            s0 = peg$FAILED;
	        }
	        return s0;
	    }
	    function peg$parseturn_scheme() {
	        var s0, s1;
	        s0 = peg$currPos;
	        if (input.substr(peg$currPos, 5).toLowerCase() === peg$c389) {
	            s1 = input.substr(peg$currPos, 5);
	            peg$currPos += 5;
	        }
	        else {
	            s1 = peg$FAILED;
	            {
	                peg$fail(peg$c390);
	            }
	        }
	        if (s1 === peg$FAILED) {
	            if (input.substr(peg$currPos, 4).toLowerCase() === peg$c391) {
	                s1 = input.substr(peg$currPos, 4);
	                peg$currPos += 4;
	            }
	            else {
	                s1 = peg$FAILED;
	                {
	                    peg$fail(peg$c392);
	                }
	            }
	        }
	        if (s1 !== peg$FAILED) {
	            peg$savedPos = s0;
	            s1 = peg$c385(s1);
	        }
	        s0 = s1;
	        return s0;
	    }
	    function peg$parseuuid() {
	        var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9;
	        s0 = peg$currPos;
	        s1 = peg$parsehex8();
	        if (s1 !== peg$FAILED) {
	            if (input.charCodeAt(peg$currPos) === 45) {
	                s2 = peg$c38;
	                peg$currPos++;
	            }
	            else {
	                s2 = peg$FAILED;
	                {
	                    peg$fail(peg$c39);
	                }
	            }
	            if (s2 !== peg$FAILED) {
	                s3 = peg$parsehex4();
	                if (s3 !== peg$FAILED) {
	                    if (input.charCodeAt(peg$currPos) === 45) {
	                        s4 = peg$c38;
	                        peg$currPos++;
	                    }
	                    else {
	                        s4 = peg$FAILED;
	                        {
	                            peg$fail(peg$c39);
	                        }
	                    }
	                    if (s4 !== peg$FAILED) {
	                        s5 = peg$parsehex4();
	                        if (s5 !== peg$FAILED) {
	                            if (input.charCodeAt(peg$currPos) === 45) {
	                                s6 = peg$c38;
	                                peg$currPos++;
	                            }
	                            else {
	                                s6 = peg$FAILED;
	                                {
	                                    peg$fail(peg$c39);
	                                }
	                            }
	                            if (s6 !== peg$FAILED) {
	                                s7 = peg$parsehex4();
	                                if (s7 !== peg$FAILED) {
	                                    if (input.charCodeAt(peg$currPos) === 45) {
	                                        s8 = peg$c38;
	                                        peg$currPos++;
	                                    }
	                                    else {
	                                        s8 = peg$FAILED;
	                                        {
	                                            peg$fail(peg$c39);
	                                        }
	                                    }
	                                    if (s8 !== peg$FAILED) {
	                                        s9 = peg$parsehex12();
	                                        if (s9 !== peg$FAILED) {
	                                            peg$savedPos = s0;
	                                            s1 = peg$c394();
	                                            s0 = s1;
	                                        }
	                                        else {
	                                            peg$currPos = s0;
	                                            s0 = peg$FAILED;
	                                        }
	                                    }
	                                    else {
	                                        peg$currPos = s0;
	                                        s0 = peg$FAILED;
	                                    }
	                                }
	                                else {
	                                    peg$currPos = s0;
	                                    s0 = peg$FAILED;
	                                }
	                            }
	                            else {
	                                peg$currPos = s0;
	                                s0 = peg$FAILED;
	                            }
	                        }
	                        else {
	                            peg$currPos = s0;
	                            s0 = peg$FAILED;
	                        }
	                    }
	                    else {
	                        peg$currPos = s0;
	                        s0 = peg$FAILED;
	                    }
	                }
	                else {
	                    peg$currPos = s0;
	                    s0 = peg$FAILED;
	                }
	            }
	            else {
	                peg$currPos = s0;
	                s0 = peg$FAILED;
	            }
	        }
	        else {
	            peg$currPos = s0;
	            s0 = peg$FAILED;
	        }
	        return s0;
	    }
	    function peg$parsehex4() {
	        var s0, s1, s2, s3, s4;
	        s0 = peg$currPos;
	        s1 = peg$parseHEXDIG();
	        if (s1 !== peg$FAILED) {
	            s2 = peg$parseHEXDIG();
	            if (s2 !== peg$FAILED) {
	                s3 = peg$parseHEXDIG();
	                if (s3 !== peg$FAILED) {
	                    s4 = peg$parseHEXDIG();
	                    if (s4 !== peg$FAILED) {
	                        s1 = [s1, s2, s3, s4];
	                        s0 = s1;
	                    }
	                    else {
	                        peg$currPos = s0;
	                        s0 = peg$FAILED;
	                    }
	                }
	                else {
	                    peg$currPos = s0;
	                    s0 = peg$FAILED;
	                }
	            }
	            else {
	                peg$currPos = s0;
	                s0 = peg$FAILED;
	            }
	        }
	        else {
	            peg$currPos = s0;
	            s0 = peg$FAILED;
	        }
	        return s0;
	    }
	    function peg$parsehex8() {
	        var s0, s1, s2;
	        s0 = peg$currPos;
	        s1 = peg$parsehex4();
	        if (s1 !== peg$FAILED) {
	            s2 = peg$parsehex4();
	            if (s2 !== peg$FAILED) {
	                s1 = [s1, s2];
	                s0 = s1;
	            }
	            else {
	                peg$currPos = s0;
	                s0 = peg$FAILED;
	            }
	        }
	        else {
	            peg$currPos = s0;
	            s0 = peg$FAILED;
	        }
	        return s0;
	    }
	    function peg$parsehex12() {
	        var s0, s1, s2, s3;
	        s0 = peg$currPos;
	        s1 = peg$parsehex4();
	        if (s1 !== peg$FAILED) {
	            s2 = peg$parsehex4();
	            if (s2 !== peg$FAILED) {
	                s3 = peg$parsehex4();
	                if (s3 !== peg$FAILED) {
	                    s1 = [s1, s2, s3];
	                    s0 = s1;
	                }
	                else {
	                    peg$currPos = s0;
	                    s0 = peg$FAILED;
	                }
	            }
	            else {
	                peg$currPos = s0;
	                s0 = peg$FAILED;
	            }
	        }
	        else {
	            peg$currPos = s0;
	            s0 = peg$FAILED;
	        }
	        return s0;
	    }
	    function peg$parsesipfrag() {
	        var s0, s1, s2, s3, s4, s5;
	        s0 = peg$currPos;
	        s1 = peg$parseRequest_Response();
	        if (s1 !== peg$FAILED) {
	            s2 = [];
	            s3 = peg$parseheader();
	            while (s3 !== peg$FAILED) {
	                s2.push(s3);
	                s3 = peg$parseheader();
	            }
	            if (s2 !== peg$FAILED) {
	                s3 = peg$currPos;
	                s4 = peg$parseCRLF();
	                if (s4 !== peg$FAILED) {
	                    s5 = peg$parsemessage_body();
	                    if (s5 !== peg$FAILED) {
	                        s4 = [s4, s5];
	                        s3 = s4;
	                    }
	                    else {
	                        peg$currPos = s3;
	                        s3 = peg$FAILED;
	                    }
	                }
	                else {
	                    peg$currPos = s3;
	                    s3 = peg$FAILED;
	                }
	                if (s3 === peg$FAILED) {
	                    s3 = null;
	                }
	                if (s3 !== peg$FAILED) {
	                    s1 = [s1, s2, s3];
	                    s0 = s1;
	                }
	                else {
	                    peg$currPos = s0;
	                    s0 = peg$FAILED;
	                }
	            }
	            else {
	                peg$currPos = s0;
	                s0 = peg$FAILED;
	            }
	        }
	        else {
	            peg$currPos = s0;
	            s0 = peg$FAILED;
	        }
	        return s0;
	    }
	    function peg$parseReferred_By() {
	        var s0, s1, s2, s3, s4, s5, s6, s7;
	        s0 = peg$currPos;
	        if (input.substr(peg$currPos, 11) === peg$c395) {
	            s1 = peg$c395;
	            peg$currPos += 11;
	        }
	        else {
	            s1 = peg$FAILED;
	            {
	                peg$fail(peg$c396);
	            }
	        }
	        if (s1 === peg$FAILED) {
	            if (input.charCodeAt(peg$currPos) === 98) {
	                s1 = peg$c397;
	                peg$currPos++;
	            }
	            else {
	                s1 = peg$FAILED;
	                {
	                    peg$fail(peg$c398);
	                }
	            }
	        }
	        if (s1 !== peg$FAILED) {
	            s2 = peg$parseHCOLON();
	            if (s2 !== peg$FAILED) {
	                s3 = peg$parsereferrer_uri();
	                if (s3 !== peg$FAILED) {
	                    s4 = [];
	                    s5 = peg$currPos;
	                    s6 = peg$parseSEMI();
	                    if (s6 !== peg$FAILED) {
	                        s7 = peg$parsereferredby_id_param();
	                        if (s7 === peg$FAILED) {
	                            s7 = peg$parsegeneric_param();
	                        }
	                        if (s7 !== peg$FAILED) {
	                            s6 = [s6, s7];
	                            s5 = s6;
	                        }
	                        else {
	                            peg$currPos = s5;
	                            s5 = peg$FAILED;
	                        }
	                    }
	                    else {
	                        peg$currPos = s5;
	                        s5 = peg$FAILED;
	                    }
	                    while (s5 !== peg$FAILED) {
	                        s4.push(s5);
	                        s5 = peg$currPos;
	                        s6 = peg$parseSEMI();
	                        if (s6 !== peg$FAILED) {
	                            s7 = peg$parsereferredby_id_param();
	                            if (s7 === peg$FAILED) {
	                                s7 = peg$parsegeneric_param();
	                            }
	                            if (s7 !== peg$FAILED) {
	                                s6 = [s6, s7];
	                                s5 = s6;
	                            }
	                            else {
	                                peg$currPos = s5;
	                                s5 = peg$FAILED;
	                            }
	                        }
	                        else {
	                            peg$currPos = s5;
	                            s5 = peg$FAILED;
	                        }
	                    }
	                    if (s4 !== peg$FAILED) {
	                        s1 = [s1, s2, s3, s4];
	                        s0 = s1;
	                    }
	                    else {
	                        peg$currPos = s0;
	                        s0 = peg$FAILED;
	                    }
	                }
	                else {
	                    peg$currPos = s0;
	                    s0 = peg$FAILED;
	                }
	            }
	            else {
	                peg$currPos = s0;
	                s0 = peg$FAILED;
	            }
	        }
	        else {
	            peg$currPos = s0;
	            s0 = peg$FAILED;
	        }
	        return s0;
	    }
	    function peg$parsereferrer_uri() {
	        var s0;
	        s0 = peg$parsename_addr();
	        if (s0 === peg$FAILED) {
	            s0 = peg$parseSIP_URI_noparams();
	        }
	        return s0;
	    }
	    function peg$parsereferredby_id_param() {
	        var s0, s1, s2, s3;
	        s0 = peg$currPos;
	        if (input.substr(peg$currPos, 3) === peg$c399) {
	            s1 = peg$c399;
	            peg$currPos += 3;
	        }
	        else {
	            s1 = peg$FAILED;
	            {
	                peg$fail(peg$c400);
	            }
	        }
	        if (s1 !== peg$FAILED) {
	            s2 = peg$parseEQUAL();
	            if (s2 !== peg$FAILED) {
	                s3 = peg$parsesip_clean_msg_id();
	                if (s3 !== peg$FAILED) {
	                    s1 = [s1, s2, s3];
	                    s0 = s1;
	                }
	                else {
	                    peg$currPos = s0;
	                    s0 = peg$FAILED;
	                }
	            }
	            else {
	                peg$currPos = s0;
	                s0 = peg$FAILED;
	            }
	        }
	        else {
	            peg$currPos = s0;
	            s0 = peg$FAILED;
	        }
	        return s0;
	    }
	    function peg$parsesip_clean_msg_id() {
	        var s0, s1, s2, s3, s4, s5;
	        s0 = peg$currPos;
	        s1 = peg$parseLDQUOT();
	        if (s1 !== peg$FAILED) {
	            s2 = peg$parsemark();
	            if (s2 !== peg$FAILED) {
	                if (input.charCodeAt(peg$currPos) === 64) {
	                    s3 = peg$c26;
	                    peg$currPos++;
	                }
	                else {
	                    s3 = peg$FAILED;
	                    {
	                        peg$fail(peg$c27);
	                    }
	                }
	                if (s3 !== peg$FAILED) {
	                    s4 = peg$parsemark();
	                    if (s4 === peg$FAILED) {
	                        s4 = peg$parsehost();
	                    }
	                    if (s4 !== peg$FAILED) {
	                        s5 = peg$parseRDQUOT();
	                        if (s5 !== peg$FAILED) {
	                            s1 = [s1, s2, s3, s4, s5];
	                            s0 = s1;
	                        }
	                        else {
	                            peg$currPos = s0;
	                            s0 = peg$FAILED;
	                        }
	                    }
	                    else {
	                        peg$currPos = s0;
	                        s0 = peg$FAILED;
	                    }
	                }
	                else {
	                    peg$currPos = s0;
	                    s0 = peg$FAILED;
	                }
	            }
	            else {
	                peg$currPos = s0;
	                s0 = peg$FAILED;
	            }
	        }
	        else {
	            peg$currPos = s0;
	            s0 = peg$FAILED;
	        }
	        return s0;
	    }
	    options.data = {}; // Object to which header attributes will be assigned during parsing
	    function list(head, tail) {
	        return [head].concat(tail);
	    }
	    peg$result = peg$startRuleFunction();
	    if (peg$result !== peg$FAILED && peg$currPos === input.length) {
	        return peg$result;
	    }
	    else {
	        if (peg$result !== peg$FAILED && peg$currPos < input.length) {
	            peg$fail(peg$endExpectation());
	        }
	        throw peg$buildStructuredError(peg$maxFailExpected, peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null, peg$maxFailPos < input.length
	            ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1)
	            : peg$computeLocation(peg$maxFailPos, peg$maxFailPos));
	    }
	}
	exports.parse = peg$parse;
	});

	unwrapExports(Grammar);
	var Grammar_1 = Grammar.SyntaxError;
	var Grammar_2 = Grammar.parse;

	var Grammar_1$1 = createCommonjsModule(function (module, exports) {
	Object.defineProperty(exports, "__esModule", { value: true });

	var Grammar$1;
	(function (Grammar$1) {
	    function parse(input, startRule) {
	        var options = { startRule: startRule };
	        try {
	            Grammar.parse(input, options);
	        }
	        catch (e) {
	            options.data = -1;
	        }
	        return options.data;
	    }
	    Grammar$1.parse = parse;
	    /**
	     * Parse the given string and returns a SIP.NameAddrHeader instance or undefined if
	     * it is an invalid NameAddrHeader.
	     * @public
	     * @param {String} name_addr_header
	     */
	    function nameAddrHeaderParse(nameAddrHeader) {
	        var parsedNameAddrHeader = Grammar$1.parse(nameAddrHeader, "Name_Addr_Header");
	        return parsedNameAddrHeader !== -1 ? parsedNameAddrHeader : undefined;
	    }
	    Grammar$1.nameAddrHeaderParse = nameAddrHeaderParse;
	    /**
	     * Parse the given string and returns a SIP.URI instance or undefined if
	     * it is an invalid URI.
	     * @public
	     * @param {String} uri
	     */
	    function URIParse(uri) {
	        var parsedUri = Grammar$1.parse(uri, "SIP_URI");
	        return parsedUri !== -1 ? parsedUri : undefined;
	    }
	    Grammar$1.URIParse = URIParse;
	})(Grammar$1 = exports.Grammar || (exports.Grammar = {}));
	});

	unwrapExports(Grammar_1$1);
	var Grammar_2$1 = Grammar_1$1.Grammar;

	var Utils_1 = createCommonjsModule(function (module, exports) {
	Object.defineProperty(exports, "__esModule", { value: true });



	var Utils;
	(function (Utils) {
	    function defer() {
	        var deferred = {};
	        deferred.promise = new Promise(function (resolve, reject) {
	            deferred.resolve = resolve;
	            deferred.reject = reject;
	        });
	        return deferred;
	    }
	    Utils.defer = defer;
	    function reducePromises(arr, val) {
	        return arr.reduce(function (acc, fn) {
	            acc = acc.then(fn);
	            return acc;
	        }, Promise.resolve(val));
	    }
	    Utils.reducePromises = reducePromises;
	    function str_utf8_length(str) {
	        return encodeURIComponent(str).replace(/%[A-F\d]{2}/g, "U").length;
	    }
	    Utils.str_utf8_length = str_utf8_length;
	    function generateFakeSDP(body) {
	        if (!body) {
	            return;
	        }
	        var start = body.indexOf("o=");
	        var end = body.indexOf("\r\n", start);
	        return "v=0\r\n" + body.slice(start, end) + "\r\ns=-\r\nt=0 0\r\nc=IN IP4 0.0.0.0";
	    }
	    Utils.generateFakeSDP = generateFakeSDP;
	    function isDecimal(num) {
	        var numAsNum = parseInt(num, 10);
	        return !isNaN(numAsNum) && (parseFloat(num) === numAsNum);
	    }
	    Utils.isDecimal = isDecimal;
	    function createRandomToken(size, base) {
	        if (base === void 0) { base = 32; }
	        var token = "";
	        for (var i = 0; i < size; i++) {
	            var r = Math.floor(Math.random() * base);
	            token += r.toString(base);
	        }
	        return token;
	    }
	    Utils.createRandomToken = createRandomToken;
	    function newTag() {
	        // used to use the constant in UA
	        return Utils.createRandomToken(10);
	    }
	    Utils.newTag = newTag;
	    // http://stackoverflow.com/users/109538/broofa
	    function newUUID() {
	        var UUID = "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function (c) {
	            var r = Math.floor(Math.random() * 16);
	            var v = c === "x" ? r : (r % 4 + 8);
	            return v.toString(16);
	        });
	        return UUID;
	    }
	    Utils.newUUID = newUUID;
	    /*
	     * Normalize SIP URI.
	     * NOTE: It does not allow a SIP URI without username.
	     * Accepts 'sip', 'sips' and 'tel' URIs and convert them into 'sip'.
	     * Detects the domain part (if given) and properly hex-escapes the user portion.
	     * If the user portion has only 'tel' number symbols the user portion is clean of 'tel' visual separators.
	     * @private
	     * @param {String} target
	     * @param {String} [domain]
	     */
	    function normalizeTarget(target, domain) {
	        // If no target is given then raise an error.
	        if (!target) {
	            return;
	            // If a SIP.URI instance is given then return it.
	        }
	        else if (target.type === Enums.TypeStrings.URI) {
	            return target;
	            // If a string is given split it by '@':
	            // - Last fragment is the desired domain.
	            // - Otherwise append the given domain argument.
	        }
	        else if (typeof target === "string") {
	            var targetArray = target.split("@");
	            var targetUser = void 0;
	            var targetDomain = void 0;
	            switch (targetArray.length) {
	                case 1:
	                    if (!domain) {
	                        return;
	                    }
	                    targetUser = target;
	                    targetDomain = domain;
	                    break;
	                case 2:
	                    targetUser = targetArray[0];
	                    targetDomain = targetArray[1];
	                    break;
	                default:
	                    targetUser = targetArray.slice(0, targetArray.length - 1).join("@");
	                    targetDomain = targetArray[targetArray.length - 1];
	            }
	            // Remove the URI scheme (if present).
	            targetUser = targetUser.replace(/^(sips?|tel):/i, "");
	            // Remove 'tel' visual separators if the user portion just contains 'tel' number symbols.
	            if (/^[\-\.\(\)]*\+?[0-9\-\.\(\)]+$/.test(targetUser)) {
	                targetUser = targetUser.replace(/[\-\.\(\)]/g, "");
	            }
	            // Build the complete SIP URI.
	            target = Constants.C.SIP + ":" + Utils.escapeUser(targetUser) + "@" + targetDomain;
	            // Finally parse the resulting URI.
	            return Grammar_1$1.Grammar.URIParse(target);
	        }
	        else {
	            return;
	        }
	    }
	    Utils.normalizeTarget = normalizeTarget;
	    /*
	     * Hex-escape a SIP URI user.
	     * @private
	     * @param {String} user
	     */
	    function escapeUser(user) {
	        // Don't hex-escape ':' (%3A), '+' (%2B), '?' (%3F"), '/' (%2F).
	        return encodeURIComponent(decodeURIComponent(user))
	            .replace(/%3A/ig, ":")
	            .replace(/%2B/ig, "+")
	            .replace(/%3F/ig, "?")
	            .replace(/%2F/ig, "/");
	    }
	    Utils.escapeUser = escapeUser;
	    function headerize(str) {
	        var exceptions = {
	            "Call-Id": "Call-ID",
	            "Cseq": "CSeq",
	            "Min-Se": "Min-SE",
	            "Rack": "RAck",
	            "Rseq": "RSeq",
	            "Www-Authenticate": "WWW-Authenticate",
	        };
	        var name = str.toLowerCase().replace(/_/g, "-").split("-");
	        var parts = name.length;
	        var hname = "";
	        for (var part = 0; part < parts; part++) {
	            if (part !== 0) {
	                hname += "-";
	            }
	            hname += name[part].charAt(0).toUpperCase() + name[part].substring(1);
	        }
	        if (exceptions[hname]) {
	            hname = exceptions[hname];
	        }
	        return hname;
	    }
	    Utils.headerize = headerize;
	    function sipErrorCause(statusCode) {
	        for (var cause in Constants.C.SIP_ERROR_CAUSES) {
	            if (Constants.C.SIP_ERROR_CAUSES[cause].indexOf(statusCode) !== -1) {
	                return Constants.C.causes[cause];
	            }
	        }
	        return Constants.C.causes.SIP_FAILURE_CODE;
	    }
	    Utils.sipErrorCause = sipErrorCause;
	    function getReasonPhrase(code, specific) {
	        return specific || Constants.C.REASON_PHRASE[code] || "";
	    }
	    Utils.getReasonPhrase = getReasonPhrase;
	    function getReasonHeaderValue(code, reason) {
	        reason = Utils.getReasonPhrase(code, reason);
	        return "SIP;cause=" + code + ';text="' + reason + '"';
	    }
	    Utils.getReasonHeaderValue = getReasonHeaderValue;
	    function getCancelReason(code, reason) {
	        if (code && code < 200 || code > 699) {
	            throw new TypeError("Invalid statusCode: " + code);
	        }
	        else if (code) {
	            return Utils.getReasonHeaderValue(code, reason);
	        }
	    }
	    Utils.getCancelReason = getCancelReason;
	    function buildStatusLine(code, reason) {
	        // Validate code and reason values
	        if (!code || (code < 100 || code > 699)) {
	            throw new TypeError("Invalid statusCode: " + code);
	        }
	        else if (reason && typeof reason !== "string" && !(reason instanceof String)) {
	            throw new TypeError("Invalid reason: " + reason);
	        }
	        reason = Utils.getReasonPhrase(code, reason);
	        return "SIP/2.0 " + code + " " + reason + "\r\n";
	    }
	    Utils.buildStatusLine = buildStatusLine;
	})(Utils = exports.Utils || (exports.Utils = {}));
	});

	unwrapExports(Utils_1);
	var Utils_2 = Utils_1.Utils;

	var SIPMessage = createCommonjsModule(function (module, exports) {
	var __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	Object.defineProperty(exports, "__esModule", { value: true });





	exports.getSupportedHeader = function (request) {
	    var optionTags = [];
	    if (request.method === Constants.C.REGISTER) {
	        optionTags.push("path", "gruu");
	    }
	    else if (request.method === Constants.C.INVITE &&
	        (request.ua.contact.pubGruu || request.ua.contact.tempGruu)) {
	        optionTags.push("gruu");
	    }
	    if (request.ua.configuration.rel100 === Constants.C.supported.SUPPORTED) {
	        optionTags.push("100rel");
	    }
	    if (request.ua.configuration.replaces === Constants.C.supported.SUPPORTED) {
	        optionTags.push("replaces");
	    }
	    optionTags.push("outbound");
	    optionTags = optionTags.concat(request.ua.configuration.extraSupported || []);
	    var allowUnregistered = request.ua.configuration.hackAllowUnregisteredOptionTags || false;
	    var optionTagSet = {};
	    optionTags = optionTags.filter(function (optionTag) {
	        var registered = Constants.C.OPTION_TAGS[optionTag];
	        var unique = !optionTagSet[optionTag];
	        optionTagSet[optionTag] = true;
	        return (registered || allowUnregistered) && unique;
	    });
	    return "Supported: " + optionTags.join(", ") + "\r\n";
	};
	/**
	 * @class Class for outgoing SIP request.
	 * @param {String} method request method
	 * @param {String} ruri request uri
	 * @param {SIP.UA} ua
	 * @param {Object} params parameters that will have priority over ua.configuration parameters:
	 * <br>
	 *  - cseq, callId, fromTag, fromUri, fromDisplayName, toUri, toTag, routeSet
	 * @param {Object} [headers] extra headers
	 * @param {String} [body]
	 */
	var OutgoingRequest = /** @class */ (function () {
	    function OutgoingRequest(method, ruri, ua, params, extraHeaders, body) {
	        if (params === void 0) { params = {}; }
	        this.type = Enums.TypeStrings.OutgoingRequest;
	        this.logger = ua.getLogger("sip.sipmessage");
	        this.ua = ua;
	        this.headers = {};
	        this.method = method;
	        this.ruri = ruri;
	        this.body = body;
	        this.extraHeaders = (extraHeaders || []).slice();
	        // FIXME: Why are response properties on a Request class?
	        this.statusCode = params.statusCode;
	        this.reasonPhrase = params.reasonPhrase;
	        // Fill the Common SIP Request Headers
	        // Route
	        if (params.routeSet) {
	            this.setHeader("route", params.routeSet);
	        }
	        else if (ua.configuration.usePreloadedRoute && ua.transport) {
	            this.setHeader("route", ua.transport.server.sipUri);
	        }
	        // Via
	        // Empty Via header. Will be filled by the client transaction.
	        this.setHeader("via", "");
	        // Max-Forwards
	        // is a constant on ua.c, removed for circular dependency
	        this.setHeader("max-forwards", "70");
	        // To
	        var toUri = params.toUri || ruri;
	        this.toTag = params.toTag;
	        var to = (params.toDisplayName || params.toDisplayName === 0) ? '"' + params.toDisplayName + '" ' : "";
	        to += "<" + (toUri.type === Enums.TypeStrings.URI ? toUri.toRaw() : toUri) + ">";
	        to += this.toTag ? ";tag=" + this.toTag : "";
	        this.to = Grammar_1$1.Grammar.nameAddrHeaderParse(to);
	        this.setHeader("to", to);
	        // From
	        var fromUri = params.fromUri || ua.configuration.uri || "";
	        this.fromTag = params.fromTag || Utils_1.Utils.newTag();
	        var from;
	        if (params.fromDisplayName || params.fromDisplayName === 0) {
	            from = '"' + params.fromDisplayName + '" ';
	        }
	        else if (ua.configuration.displayName) {
	            from = '"' + ua.configuration.displayName + '" ';
	        }
	        else {
	            from = "";
	        }
	        from += "<" + (fromUri.type === Enums.TypeStrings.URI ? fromUri.toRaw() : fromUri) + ">;tag=";
	        from += this.fromTag;
	        this.from = Grammar_1$1.Grammar.nameAddrHeaderParse(from);
	        this.setHeader("from", from);
	        // Call-ID
	        this.callId = params.callId || (ua.configuration.sipjsId + Utils_1.Utils.createRandomToken(15));
	        this.setHeader("call-id", this.callId);
	        // CSeq
	        // Why not make this a "1" if not provided? See: https://tools.ietf.org/html/rfc3261#section-8.1.1.5
	        this.cseq = params.cseq || Math.floor(Math.random() * 10000);
	        this.setHeader("cseq", this.cseq + " " + method);
	    }
	    /**
	     * Get the value of the given header name at the given position.
	     * @param {String} name header name
	     * @returns {String|undefined} Returns the specified header, undefined if header doesn't exist.
	     */
	    OutgoingRequest.prototype.getHeader = function (name) {
	        var header = this.headers[Utils_1.Utils.headerize(name)];
	        if (header) {
	            if (header[0]) {
	                return header[0];
	            }
	        }
	        else {
	            var regexp = new RegExp("^\\s*" + name + "\\s*:", "i");
	            for (var _i = 0, _a = this.extraHeaders; _i < _a.length; _i++) {
	                var exHeader = _a[_i];
	                if (regexp.test(exHeader)) {
	                    return exHeader.substring(exHeader.indexOf(":") + 1).trim();
	                }
	            }
	        }
	        return;
	    };
	    /**
	     * Get the header/s of the given name.
	     * @param {String} name header name
	     * @returns {Array} Array with all the headers of the specified name.
	     */
	    OutgoingRequest.prototype.getHeaders = function (name) {
	        var result = [];
	        var headerArray = this.headers[Utils_1.Utils.headerize(name)];
	        if (headerArray) {
	            for (var _i = 0, headerArray_1 = headerArray; _i < headerArray_1.length; _i++) {
	                var headerPart = headerArray_1[_i];
	                result.push(headerPart);
	            }
	        }
	        else {
	            var regexp = new RegExp("^\\s*" + name + "\\s*:", "i");
	            for (var _a = 0, _b = this.extraHeaders; _a < _b.length; _a++) {
	                var exHeader = _b[_a];
	                if (regexp.test(exHeader)) {
	                    result.push(exHeader.substring(exHeader.indexOf(":") + 1).trim());
	                }
	            }
	        }
	        return result;
	    };
	    /**
	     * Verify the existence of the given header.
	     * @param {String} name header name
	     * @returns {boolean} true if header with given name exists, false otherwise
	     */
	    OutgoingRequest.prototype.hasHeader = function (name) {
	        if (this.headers[Utils_1.Utils.headerize(name)]) {
	            return true;
	        }
	        else {
	            var regexp = new RegExp("^\\s*" + name + "\\s*:", "i");
	            for (var _i = 0, _a = this.extraHeaders; _i < _a.length; _i++) {
	                var extraHeader = _a[_i];
	                if (regexp.test(extraHeader)) {
	                    return true;
	                }
	            }
	        }
	        return false;
	    };
	    /**
	     * Replace the the given header by the given value.
	     * @param {String} name header name
	     * @param {String | Array} value header value
	     */
	    OutgoingRequest.prototype.setHeader = function (name, value) {
	        this.headers[Utils_1.Utils.headerize(name)] = (value instanceof Array) ? value : [value];
	    };
	    /**
	     * The Via header field indicates the transport used for the transaction
	     * and identifies the location where the response is to be sent.  A Via
	     * header field value is added only after the transport that will be
	     * used to reach the next hop has been selected (which may involve the
	     * usage of the procedures in [4]).
	     *
	     * When the UAC creates a request, it MUST insert a Via into that
	     * request.  The protocol name and protocol version in the header field
	     * MUST be SIP and 2.0, respectively.  The Via header field value MUST
	     * contain a branch parameter.  This parameter is used to identify the
	     * transaction created by that request.  This parameter is used by both
	     * the client and the server.
	     * https://tools.ietf.org/html/rfc3261#section-8.1.1.7
	     * @param branchParameter The branch parameter.
	     * @param transport The transport.
	     */
	    OutgoingRequest.prototype.setViaHeader = function (branch, transport) {
	        // FIXME: Default scheme to "WSS"
	        // This should go away once transport is typed and we can be sure
	        // we are getting the something valid from there transport.
	        var scheme = "WSS";
	        // FIXME: Transport's server property is not typed (as of writing this).
	        if (transport.server && transport.server.scheme) {
	            scheme = transport.server.scheme;
	        }
	        // FIXME: Hack
	        if (this.ua.configuration.hackViaTcp) {
	            scheme = "TCP";
	        }
	        var via = "SIP/2.0/" + scheme;
	        via += " " + this.ua.configuration.viaHost + ";branch=" + branch;
	        if (this.ua.configuration.forceRport) {
	            via += ";rport";
	        }
	        this.setHeader("via", via);
	        this.branch = branch;
	    };
	    /**
	     * Cancel this request.
	     * If this is not an INVITE request, a no-op.
	     * @param reason Reason phrase.
	     * @param extraHeaders Extra headers.
	     */
	    OutgoingRequest.prototype.cancel = function (reason, extraHeaders) {
	        var _this = this;
	        if (!this.transaction) {
	            throw new Error("Transaction undefined.");
	        }
	        var sendCancel = function () {
	            if (!_this.transaction) {
	                throw new Error("Transaction undefined.");
	            }
	            if (!_this.to) {
	                throw new Error("To undefined.");
	            }
	            if (!_this.from) {
	                throw new Error("From undefined.");
	            }
	            // The following procedures are used to construct a CANCEL request.  The
	            // Request-URI, Call-ID, To, the numeric part of CSeq, and From header
	            // fields in the CANCEL request MUST be identical to those in the
	            // request being cancelled, including tags.  A CANCEL constructed by a
	            // client MUST have only a single Via header field value matching the
	            // top Via value in the request being cancelled.  Using the same values
	            // for these header fields allows the CANCEL to be matched with the
	            // request it cancels (Section 9.2 indicates how such matching occurs).
	            // However, the method part of the CSeq header field MUST have a value
	            // of CANCEL.  This allows it to be identified and processed as a
	            // transaction in its own right (See Section 17).
	            // https://tools.ietf.org/html/rfc3261#section-9.1
	            var cancel = new OutgoingRequest(Constants.C.CANCEL, _this.ruri, _this.ua, {
	                toUri: _this.to.uri,
	                toTag: _this.toTag,
	                fromUri: _this.from.uri,
	                fromTag: _this.fromTag,
	                callId: _this.callId,
	                cseq: _this.cseq
	            }, extraHeaders);
	            // TODO: Revisit this.
	            // The CANCEL needs to use the same branch parameter so that
	            // it matches the INVITE transaction, but this is a hacky way to do this.
	            // Or at the very least not well documented. If the the branch parameter
	            // is set on the outgoing request, the transaction will use it. Otherwise
	            // the transaction will make a new one.
	            cancel.branch = _this.branch;
	            // If the request being cancelled contains a Route header field, the
	            // CANCEL request MUST include that Route header field's values.
	            // https://tools.ietf.org/html/rfc3261#section-9.1
	            if (_this.headers.Route) {
	                cancel.headers.Route = _this.headers.Route;
	            }
	            if (reason) {
	                cancel.setHeader("Reason", reason);
	            }
	            var transport = _this.transaction.transport;
	            var user = {
	                loggerFactory: _this.ua.getLoggerFactory(),
	                onStateChange: function (newState) {
	                    if (newState === Transactions.TransactionState.Terminated) {
	                        _this.ua.destroyTransaction(clientTransaction);
	                    }
	                },
	                receiveResponse: function (response) { return; }
	            };
	            var clientTransaction = new Transactions.NonInviteClientTransaction(cancel, transport, user);
	            _this.ua.newTransaction(clientTransaction);
	        };
	        // A CANCEL request SHOULD NOT be sent to cancel a request other than INVITE.
	        // Since requests other than INVITE are responded to immediately, sending a
	        // CANCEL for a non-INVITE request would always create a race condition.
	        // https://tools.ietf.org/html/rfc3261#section-9.1
	        if (!(this.transaction instanceof Transactions.InviteClientTransaction)) {
	            return;
	        }
	        // If no provisional response has been received, the CANCEL request MUST
	        // NOT be sent; rather, the client MUST wait for the arrival of a
	        // provisional response before sending the request. If the original
	        // request has generated a final response, the CANCEL SHOULD NOT be
	        // sent, as it is an effective no-op, since CANCEL has no effect on
	        // requests that have already generated a final response.
	        // https://tools.ietf.org/html/rfc3261#section-9.1
	        if (this.transaction.state === Transactions.TransactionState.Proceeding) {
	            sendCancel();
	        }
	        else {
	            this.transaction.once("stateChanged", function () {
	                if (_this.transaction && _this.transaction.state === Transactions.TransactionState.Proceeding) {
	                    sendCancel();
	                }
	            });
	        }
	    };
	    OutgoingRequest.prototype.toString = function () {
	        var msg = "";
	        msg += this.method + " " + (this.ruri.type === Enums.TypeStrings.URI ?
	            this.ruri.toRaw() : this.ruri) + " SIP/2.0\r\n";
	        for (var header in this.headers) {
	            if (this.headers[header]) {
	                for (var _i = 0, _a = this.headers[header]; _i < _a.length; _i++) {
	                    var headerPart = _a[_i];
	                    msg += header + ": " + headerPart + "\r\n";
	                }
	            }
	        }
	        for (var _b = 0, _c = this.extraHeaders; _b < _c.length; _b++) {
	            var header = _c[_b];
	            msg += header.trim() + "\r\n";
	        }
	        msg += exports.getSupportedHeader(this);
	        msg += "User-Agent: " + this.ua.configuration.userAgentString + "\r\n";
	        if (this.body) {
	            if (typeof this.body === "string") {
	                msg += "Content-Length: " + Utils_1.Utils.str_utf8_length(this.body) + "\r\n\r\n";
	                msg += this.body;
	            }
	            else {
	                if (this.body.body && this.body.contentType) {
	                    msg += "Content-Type: " + this.body.contentType + "\r\n";
	                    msg += "Content-Length: " + Utils_1.Utils.str_utf8_length(this.body.body) + "\r\n\r\n";
	                    msg += this.body.body;
	                }
	                else {
	                    msg += "Content-Length: " + 0 + "\r\n\r\n";
	                }
	            }
	        }
	        else {
	            msg += "Content-Length: " + 0 + "\r\n\r\n";
	        }
	        return msg;
	    };
	    return OutgoingRequest;
	}());
	exports.OutgoingRequest = OutgoingRequest;
	/**
	 * @class Class for incoming SIP message.
	 */
	// tslint:disable-next-line:max-classes-per-file
	var IncomingMessage = /** @class */ (function () {
	    function IncomingMessage() {
	        this.type = Enums.TypeStrings.IncomingMessage;
	        this.headers = {};
	    }
	    /**
	     * Insert a header of the given name and value into the last position of the
	     * header array.
	     * @param {String} name header name
	     * @param {String} value header value
	     */
	    IncomingMessage.prototype.addHeader = function (name, value) {
	        var header = { raw: value };
	        name = Utils_1.Utils.headerize(name);
	        if (this.headers[name]) {
	            this.headers[name].push(header);
	        }
	        else {
	            this.headers[name] = [header];
	        }
	    };
	    /**
	     * Get the value of the given header name at the given position.
	     * @param {String} name header name
	     * @returns {String|undefined} Returns the specified header, undefined if header doesn't exist.
	     */
	    IncomingMessage.prototype.getHeader = function (name) {
	        var header = this.headers[Utils_1.Utils.headerize(name)];
	        if (header) {
	            if (header[0]) {
	                return header[0].raw;
	            }
	        }
	        else {
	            return;
	        }
	    };
	    /**
	     * Get the header/s of the given name.
	     * @param {String} name header name
	     * @returns {Array} Array with all the headers of the specified name.
	     */
	    IncomingMessage.prototype.getHeaders = function (name) {
	        var header = this.headers[Utils_1.Utils.headerize(name)];
	        var result = [];
	        if (!header) {
	            return [];
	        }
	        for (var _i = 0, header_1 = header; _i < header_1.length; _i++) {
	            var headerPart = header_1[_i];
	            result.push(headerPart.raw);
	        }
	        return result;
	    };
	    /**
	     * Verify the existence of the given header.
	     * @param {String} name header name
	     * @returns {boolean} true if header with given name exists, false otherwise
	     */
	    IncomingMessage.prototype.hasHeader = function (name) {
	        return !!this.headers[Utils_1.Utils.headerize(name)];
	    };
	    /**
	     * Parse the given header on the given index.
	     * @param {String} name header name
	     * @param {Number} [idx=0] header index
	     * @returns {Object|undefined} Parsed header object, undefined if the
	     *   header is not present or in case of a parsing error.
	     */
	    IncomingMessage.prototype.parseHeader = function (name, idx) {
	        if (idx === void 0) { idx = 0; }
	        name = Utils_1.Utils.headerize(name);
	        if (!this.headers[name]) {
	            // this.logger.log("header '" + name + "' not present");
	            return;
	        }
	        else if (idx >= this.headers[name].length) {
	            // this.logger.log("not so many '" + name + "' headers present");
	            return;
	        }
	        var header = this.headers[name][idx];
	        var value = header.raw;
	        if (header.parsed) {
	            return header.parsed;
	        }
	        // substitute '-' by '_' for grammar rule matching.
	        var parsed = Grammar_1$1.Grammar.parse(value, name.replace(/-/g, "_"));
	        if (parsed === -1) {
	            this.headers[name].splice(idx, 1); // delete from headers
	            // this.logger.warn('error parsing "' + name + '" header field with value "' + value + '"');
	            return;
	        }
	        else {
	            header.parsed = parsed;
	            return parsed;
	        }
	    };
	    /**
	     * Message Header attribute selector. Alias of parseHeader.
	     * @param {String} name header name
	     * @param {Number} [idx=0] header index
	     * @returns {Object|undefined} Parsed header object, undefined if the
	     *   header is not present or in case of a parsing error.
	     *
	     * @example
	     * message.s('via',3).port
	     */
	    IncomingMessage.prototype.s = function (name, idx) {
	        if (idx === void 0) { idx = 0; }
	        return this.parseHeader(name, idx);
	    };
	    /**
	     * Replace the value of the given header by the value.
	     * @param {String} name header name
	     * @param {String} value header value
	     */
	    IncomingMessage.prototype.setHeader = function (name, value) {
	        this.headers[Utils_1.Utils.headerize(name)] = [{ raw: value }];
	    };
	    IncomingMessage.prototype.toString = function () {
	        return this.data;
	    };
	    return IncomingMessage;
	}());
	exports.IncomingMessage = IncomingMessage;
	/**
	 * @class Class for incoming SIP request.
	 */
	// tslint:disable-next-line:max-classes-per-file
	var IncomingRequest = /** @class */ (function (_super) {
	    __extends(IncomingRequest, _super);
	    function IncomingRequest(ua) {
	        var _this = _super.call(this) || this;
	        _this.ua = ua;
	        _this.type = Enums.TypeStrings.IncomingRequest;
	        _this.logger = ua.getLogger("sip.sipmessage");
	        return _this;
	    }
	    /**
	     * Stateful reply.
	     * @param {Number} code status code
	     * @param {String} reason reason phrase
	     * @param {Object} headers extra headers
	     * @param {String} body body
	     */
	    IncomingRequest.prototype.reply = function (code, reason, extraHeaders, body) {
	        if (!this.transaction) {
	            throw new Error("Transaction undefined.");
	        }
	        var response = Utils_1.Utils.buildStatusLine(code, reason);
	        extraHeaders = (extraHeaders || []).slice();
	        if (this.method === Constants.C.INVITE && code > 100 && code <= 200) {
	            for (var _i = 0, _a = this.getHeaders("record-route"); _i < _a.length; _i++) {
	                var route = _a[_i];
	                response += "Record-Route: " + route + "\r\n";
	            }
	        }
	        for (var _b = 0, _c = this.getHeaders("via"); _b < _c.length; _b++) {
	            var via = _c[_b];
	            response += "Via: " + via + "\r\n";
	        }
	        var to = this.getHeader("to") || "";
	        if (!this.toTag && code > 100) {
	            to += ";tag=" + Utils_1.Utils.newTag();
	        }
	        else if (this.toTag && !this.s("to").hasParam("tag")) {
	            to += ";tag=" + this.toTag;
	        }
	        response += "To: " + to + "\r\n";
	        response += "From: " + this.getHeader("From") + "\r\n";
	        response += "Call-ID: " + this.callId + "\r\n";
	        response += "CSeq: " + this.cseq + " " + this.method + "\r\n";
	        for (var _d = 0, extraHeaders_1 = extraHeaders; _d < extraHeaders_1.length; _d++) {
	            var extraHeader = extraHeaders_1[_d];
	            response += extraHeader.trim() + "\r\n";
	        }
	        response += exports.getSupportedHeader(this);
	        response += "User-Agent: " + this.ua.configuration.userAgentString + "\r\n";
	        if (body) {
	            if (typeof body === "string") {
	                response += "Content-Type: application/sdp\r\n";
	                response += "Content-Length: " + Utils_1.Utils.str_utf8_length(body) + "\r\n\r\n";
	                response += body;
	            }
	            else {
	                if (body.body && body.contentType) {
	                    response += "Content-Type: " + body.contentType + "\r\n";
	                    response += "Content-Length: " + Utils_1.Utils.str_utf8_length(body.body) + "\r\n\r\n";
	                    response += body.body;
	                }
	                else {
	                    response += "Content-Length: " + 0 + "\r\n\r\n";
	                }
	            }
	        }
	        else {
	            response += "Content-Length: " + 0 + "\r\n\r\n";
	        }
	        this.transaction.receiveResponse(code, response);
	        return response;
	    };
	    /**
	     * Stateless reply.
	     * @param {Number} code status code
	     * @param {String} reason reason phrase
	     */
	    IncomingRequest.prototype.reply_sl = function (code, reason) {
	        if (!this.transport) {
	            throw new Error("Transport undefined.");
	        }
	        var response = Utils_1.Utils.buildStatusLine(code, reason);
	        for (var _i = 0, _a = this.getHeaders("via"); _i < _a.length; _i++) {
	            var via = _a[_i];
	            response += "Via: " + via + "\r\n";
	        }
	        var to = this.getHeader("To") || "";
	        if (!this.toTag && code > 100) {
	            // FIXME: This is a MUST, but we are generating a random tag each response
	            // o  To header tags MUST be generated for responses in a stateless
	            // manner - in a manner that will generate the same tag for the
	            // same request consistently.  For information on tag construction
	            // see Section 19.3.
	            // https://tools.ietf.org/html/rfc3261#section-8.2.7
	            to += ";tag=" + Utils_1.Utils.newTag();
	        }
	        else if (this.toTag && !this.s("to").hasParam("tag")) {
	            to += ";tag=" + this.toTag;
	        }
	        response += "To: " + to + "\r\n";
	        response += "From: " + this.getHeader("From") + "\r\n";
	        response += "Call-ID: " + this.callId + "\r\n";
	        response += "CSeq: " + this.cseq + " " + this.method + "\r\n";
	        response += "User-Agent: " + this.ua.configuration.userAgentString + "\r\n";
	        response += "Content-Length: " + 0 + "\r\n\r\n";
	        this.transport.send(response);
	        return response;
	    };
	    return IncomingRequest;
	}(IncomingMessage));
	exports.IncomingRequest = IncomingRequest;
	/**
	 * @class Class for incoming SIP response.
	 */
	// tslint:disable-next-line:max-classes-per-file
	var IncomingResponse = /** @class */ (function (_super) {
	    __extends(IncomingResponse, _super);
	    function IncomingResponse(ua) {
	        var _this = _super.call(this) || this;
	        _this.ua = ua;
	        _this.type = Enums.TypeStrings.IncomingResponse;
	        _this.logger = ua.getLogger("sip.sipmessage");
	        _this.headers = {};
	        return _this;
	    }
	    /**
	     * Constructs and sends ACK to 2xx final response. Returns the sent ACK.
	     * @param response The 2xx final repsonse the ACK is acknowledging.
	     * @param options ACK options; extra headers, body.
	     */
	    IncomingResponse.prototype.ack = function (options) {
	        if (!this.statusCode || this.statusCode < 200 || this.statusCode > 299) {
	            throw new Error("Response status code must be 2xx to ACK.");
	        }
	        if (this.method !== Constants.C.INVITE) {
	            throw new Error("Response must to be for an INVITE to ACK.");
	        }
	        if (!this.transaction) {
	            throw new Error("Transaction undefined.");
	        }
	        if (!(this.transaction instanceof Transactions.InviteClientTransaction)) {
	            throw new Error("Transaction not instance of InviteServerTrasaction.");
	        }
	        // FIXME: This should all be done by the dialog. The current dialog code
	        // structure is not currently setup to deal with ACKs to re-INVITEs, so
	        // what follows is duplicate code for specifially handling the ACK case.
	        // Dialog must exist after receipt of a 2xx response to an INVITE.
	        var dialog = this.ua.dialogs[this.callId + this.fromTag + this.toTag];
	        if (!dialog) {
	            throw new Error("Dialog undefined.");
	        }
	        // The UAC core MUST generate an ACK request for each 2xx received from
	        // the transaction layer.  The header fields of the ACK are constructed
	        // in the same way as for any request sent within a dialog (see Section
	        // 12) with the exception of the CSeq and the header fields related to
	        // authentication.  The sequence number of the CSeq header field MUST be
	        // the same as the INVITE being acknowledged, but the CSeq method MUST
	        // be ACK.  The ACK MUST contain the same credentials as the INVITE.  If
	        // the 2xx contains an offer (based on the rules above), the ACK MUST
	        // carry an answer in its body.  If the offer in the 2xx response is not
	        // acceptable, the UAC core MUST generate a valid answer in the ACK and
	        // then send a BYE immediately.
	        // https://tools.ietf.org/html/rfc3261#section-13.2.2.4
	        // The URI in the To field of the request MUST be set to the remote URI
	        // from the dialog state.  The tag in the To header field of the request
	        // MUST be set to the remote tag of the dialog ID.  The From URI of the
	        // request MUST be set to the local URI from the dialog state.  The tag
	        // in the From header field of the request MUST be set to the local tag
	        // of the dialog ID.  If the value of the remote or local tags is null,
	        // the tag parameter MUST be omitted from the To or From header fields,
	        // respectively.
	        //
	        // The Call-ID of the request MUST be set to the Call-ID of the dialog.
	        // Requests within a dialog MUST contain strictly monotonically
	        // increasing and contiguous CSeq sequence numbers (increasing-by-one)
	        // in each direction (excepting ACK and CANCEL of course, whose numbers
	        // equal the requests being acknowledged or cancelled).
	        // https://tools.ietf.org/html/rfc3261#section-12.2.1.1
	        var callId = this.callId;
	        var cseq = this.cseq;
	        var fromUri = dialog.localUri;
	        var fromTag = this.fromTag;
	        var toUri = dialog.remoteUri;
	        var toTag = this.toTag;
	        // The UAC uses the remote target and route set to build the Request-URI
	        // and Route header field of the request.
	        //
	        // If the route set is empty, the UAC MUST place the remote target URI
	        // into the Request-URI.  The UAC MUST NOT add a Route header field to
	        // the request.
	        //
	        // If the route set is not empty, and the first URI in the route set
	        // contains the lr parameter (see Section 19.1.1), the UAC MUST place
	        // the remote target URI into the Request-URI and MUST include a Route
	        // header field containing the route set values in order, including all
	        // parameters.
	        //
	        // If the route set is not empty, and its first URI does not contain the
	        // lr parameter, the UAC MUST place the first URI from the route set
	        // into the Request-URI, stripping any parameters that are not allowed
	        // in a Request-URI.  The UAC MUST add a Route header field containing
	        // the remainder of the route set values in order, including all
	        // parameters.  The UAC MUST then place the remote target URI into the
	        // Route header field as the last value.
	        // https://tools.ietf.org/html/rfc3261#section-12.2.1.1
	        // The lr parameter, when present, indicates that the element
	        // responsible for this resource implements the routing mechanisms
	        // specified in this document.  This parameter will be used in the
	        // URIs proxies place into Record-Route header field values, and
	        // may appear in the URIs in a pre-existing route set.
	        //
	        // This parameter is used to achieve backwards compatibility with
	        // systems implementing the strict-routing mechanisms of RFC 2543
	        // and the rfc2543bis drafts up to bis-05.  An element preparing
	        // to send a request based on a URI not containing this parameter
	        // can assume the receiving element implements strict-routing and
	        // reformat the message to preserve the information in the
	        // Request-URI.
	        // https://tools.ietf.org/html/rfc3261#section-19.1.1
	        // NOTE: Not backwards compatibile with RFC 2543 (no support for strict-routing).
	        var ruri = dialog.remoteTarget;
	        var routeSet = dialog.routeSet;
	        var request = new OutgoingRequest(Constants.C.ACK, ruri, this.ua, {
	            callId: callId,
	            cseq: cseq,
	            fromUri: fromUri,
	            fromTag: fromTag,
	            toUri: toUri,
	            toTag: toTag,
	            routeSet: routeSet
	        }, options ? options.extraHeaders : undefined, options ? options.body : undefined);
	        this.transaction.ackResponse(request);
	        return request;
	    };
	    return IncomingResponse;
	}(IncomingMessage));
	exports.IncomingResponse = IncomingResponse;
	});

	unwrapExports(SIPMessage);
	var SIPMessage_1 = SIPMessage.getSupportedHeader;
	var SIPMessage_2 = SIPMessage.OutgoingRequest;
	var SIPMessage_3 = SIPMessage.IncomingMessage;
	var SIPMessage_4 = SIPMessage.IncomingRequest;
	var SIPMessage_5 = SIPMessage.IncomingResponse;

	var ClientContext_1 = createCommonjsModule(function (module, exports) {
	var __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	Object.defineProperty(exports, "__esModule", { value: true });






	var ClientContext = /** @class */ (function (_super) {
	    __extends(ClientContext, _super);
	    function ClientContext(ua, method, target, options) {
	        var _this = _super.call(this) || this;
	        _this.data = {};
	        ClientContext.initializer(_this, ua, method, target, options);
	        return _this;
	    }
	    ClientContext.initializer = function (objToConstruct, ua, method, originalTarget, options) {
	        objToConstruct.type = Enums.TypeStrings.ClientContext;
	        // Validate arguments
	        if (originalTarget === undefined) {
	            throw new TypeError("Not enough arguments");
	        }
	        objToConstruct.ua = ua;
	        objToConstruct.logger = ua.getLogger("sip.clientcontext");
	        objToConstruct.method = method;
	        var target = ua.normalizeTarget(originalTarget);
	        if (!target) {
	            throw new TypeError("Invalid target: " + originalTarget);
	        }
	        /* Options
	        * - extraHeaders
	        * - params
	        * - contentType
	        * - body
	        */
	        options = Object.create(options || Object.prototype);
	        options.extraHeaders = (options.extraHeaders || []).slice();
	        // Build the request
	        objToConstruct.request = new SIPMessage.OutgoingRequest(objToConstruct.method, target, objToConstruct.ua, options.params, options.extraHeaders);
	        if (options.body) {
	            objToConstruct.body = {};
	            objToConstruct.body.body = options.body;
	            if (options.contentType) {
	                objToConstruct.body.contentType = options.contentType;
	            }
	            objToConstruct.request.body = objToConstruct.body;
	        }
	        /* Set other properties from the request */
	        if (objToConstruct.request.from) {
	            objToConstruct.localIdentity = objToConstruct.request.from;
	        }
	        if (objToConstruct.request.to) {
	            objToConstruct.remoteIdentity = objToConstruct.request.to;
	        }
	    };
	    ClientContext.prototype.send = function () {
	        var sender = new RequestSender_1.RequestSender(this, this.ua);
	        sender.send();
	        return this;
	    };
	    ClientContext.prototype.receiveResponse = function (response) {
	        var statusCode = response.statusCode || 0;
	        var cause = Utils_1.Utils.getReasonPhrase(statusCode);
	        switch (true) {
	            case /^1[0-9]{2}$/.test(statusCode.toString()):
	                this.emit("progress", response, cause);
	                break;
	            case /^2[0-9]{2}$/.test(statusCode.toString()):
	                if (this.ua.applicants[this.toString()]) {
	                    delete this.ua.applicants[this.toString()];
	                }
	                this.emit("accepted", response, cause);
	                break;
	            default:
	                if (this.ua.applicants[this.toString()]) {
	                    delete this.ua.applicants[this.toString()];
	                }
	                this.emit("rejected", response, cause);
	                this.emit("failed", response, cause);
	                break;
	        }
	    };
	    ClientContext.prototype.onRequestTimeout = function () {
	        this.emit("failed", undefined, Constants.C.causes.REQUEST_TIMEOUT);
	    };
	    ClientContext.prototype.onTransportError = function () {
	        this.emit("failed", undefined, Constants.C.causes.CONNECTION_ERROR);
	    };
	    return ClientContext;
	}(events.EventEmitter));
	exports.ClientContext = ClientContext;
	});

	unwrapExports(ClientContext_1);
	var ClientContext_2 = ClientContext_1.ClientContext;

	var core = createCommonjsModule(function (module, exports) {
	(function (root, factory) {
		{
			// CommonJS
			module.exports = exports = factory();
		}
	}(commonjsGlobal, function () {

		/**
		 * CryptoJS core components.
		 */
		var CryptoJS = CryptoJS || (function (Math, undefined$1) {
		    /*
		     * Local polyfil of Object.create
		     */
		    var create = Object.create || (function () {
		        function F() {}
		        return function (obj) {
		            var subtype;

		            F.prototype = obj;

		            subtype = new F();

		            F.prototype = null;

		            return subtype;
		        };
		    }());

		    /**
		     * CryptoJS namespace.
		     */
		    var C = {};

		    /**
		     * Library namespace.
		     */
		    var C_lib = C.lib = {};

		    /**
		     * Base object for prototypal inheritance.
		     */
		    var Base = C_lib.Base = (function () {


		        return {
		            /**
		             * Creates a new object that inherits from this object.
		             *
		             * @param {Object} overrides Properties to copy into the new object.
		             *
		             * @return {Object} The new object.
		             *
		             * @static
		             *
		             * @example
		             *
		             *     var MyType = CryptoJS.lib.Base.extend({
		             *         field: 'value',
		             *
		             *         method: function () {
		             *         }
		             *     });
		             */
		            extend: function (overrides) {
		                // Spawn
		                var subtype = create(this);

		                // Augment
		                if (overrides) {
		                    subtype.mixIn(overrides);
		                }

		                // Create default initializer
		                if (!subtype.hasOwnProperty('init') || this.init === subtype.init) {
		                    subtype.init = function () {
		                        subtype.$super.init.apply(this, arguments);
		                    };
		                }

		                // Initializer's prototype is the subtype object
		                subtype.init.prototype = subtype;

		                // Reference supertype
		                subtype.$super = this;

		                return subtype;
		            },

		            /**
		             * Extends this object and runs the init method.
		             * Arguments to create() will be passed to init().
		             *
		             * @return {Object} The new object.
		             *
		             * @static
		             *
		             * @example
		             *
		             *     var instance = MyType.create();
		             */
		            create: function () {
		                var instance = this.extend();
		                instance.init.apply(instance, arguments);

		                return instance;
		            },

		            /**
		             * Initializes a newly created object.
		             * Override this method to add some logic when your objects are created.
		             *
		             * @example
		             *
		             *     var MyType = CryptoJS.lib.Base.extend({
		             *         init: function () {
		             *             // ...
		             *         }
		             *     });
		             */
		            init: function () {
		            },

		            /**
		             * Copies properties into this object.
		             *
		             * @param {Object} properties The properties to mix in.
		             *
		             * @example
		             *
		             *     MyType.mixIn({
		             *         field: 'value'
		             *     });
		             */
		            mixIn: function (properties) {
		                for (var propertyName in properties) {
		                    if (properties.hasOwnProperty(propertyName)) {
		                        this[propertyName] = properties[propertyName];
		                    }
		                }

		                // IE won't copy toString using the loop above
		                if (properties.hasOwnProperty('toString')) {
		                    this.toString = properties.toString;
		                }
		            },

		            /**
		             * Creates a copy of this object.
		             *
		             * @return {Object} The clone.
		             *
		             * @example
		             *
		             *     var clone = instance.clone();
		             */
		            clone: function () {
		                return this.init.prototype.extend(this);
		            }
		        };
		    }());

		    /**
		     * An array of 32-bit words.
		     *
		     * @property {Array} words The array of 32-bit words.
		     * @property {number} sigBytes The number of significant bytes in this word array.
		     */
		    var WordArray = C_lib.WordArray = Base.extend({
		        /**
		         * Initializes a newly created word array.
		         *
		         * @param {Array} words (Optional) An array of 32-bit words.
		         * @param {number} sigBytes (Optional) The number of significant bytes in the words.
		         *
		         * @example
		         *
		         *     var wordArray = CryptoJS.lib.WordArray.create();
		         *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607]);
		         *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607], 6);
		         */
		        init: function (words, sigBytes) {
		            words = this.words = words || [];

		            if (sigBytes != undefined$1) {
		                this.sigBytes = sigBytes;
		            } else {
		                this.sigBytes = words.length * 4;
		            }
		        },

		        /**
		         * Converts this word array to a string.
		         *
		         * @param {Encoder} encoder (Optional) The encoding strategy to use. Default: CryptoJS.enc.Hex
		         *
		         * @return {string} The stringified word array.
		         *
		         * @example
		         *
		         *     var string = wordArray + '';
		         *     var string = wordArray.toString();
		         *     var string = wordArray.toString(CryptoJS.enc.Utf8);
		         */
		        toString: function (encoder) {
		            return (encoder || Hex).stringify(this);
		        },

		        /**
		         * Concatenates a word array to this word array.
		         *
		         * @param {WordArray} wordArray The word array to append.
		         *
		         * @return {WordArray} This word array.
		         *
		         * @example
		         *
		         *     wordArray1.concat(wordArray2);
		         */
		        concat: function (wordArray) {
		            // Shortcuts
		            var thisWords = this.words;
		            var thatWords = wordArray.words;
		            var thisSigBytes = this.sigBytes;
		            var thatSigBytes = wordArray.sigBytes;

		            // Clamp excess bits
		            this.clamp();

		            // Concat
		            if (thisSigBytes % 4) {
		                // Copy one byte at a time
		                for (var i = 0; i < thatSigBytes; i++) {
		                    var thatByte = (thatWords[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
		                    thisWords[(thisSigBytes + i) >>> 2] |= thatByte << (24 - ((thisSigBytes + i) % 4) * 8);
		                }
		            } else {
		                // Copy one word at a time
		                for (var i = 0; i < thatSigBytes; i += 4) {
		                    thisWords[(thisSigBytes + i) >>> 2] = thatWords[i >>> 2];
		                }
		            }
		            this.sigBytes += thatSigBytes;

		            // Chainable
		            return this;
		        },

		        /**
		         * Removes insignificant bits.
		         *
		         * @example
		         *
		         *     wordArray.clamp();
		         */
		        clamp: function () {
		            // Shortcuts
		            var words = this.words;
		            var sigBytes = this.sigBytes;

		            // Clamp
		            words[sigBytes >>> 2] &= 0xffffffff << (32 - (sigBytes % 4) * 8);
		            words.length = Math.ceil(sigBytes / 4);
		        },

		        /**
		         * Creates a copy of this word array.
		         *
		         * @return {WordArray} The clone.
		         *
		         * @example
		         *
		         *     var clone = wordArray.clone();
		         */
		        clone: function () {
		            var clone = Base.clone.call(this);
		            clone.words = this.words.slice(0);

		            return clone;
		        },

		        /**
		         * Creates a word array filled with random bytes.
		         *
		         * @param {number} nBytes The number of random bytes to generate.
		         *
		         * @return {WordArray} The random word array.
		         *
		         * @static
		         *
		         * @example
		         *
		         *     var wordArray = CryptoJS.lib.WordArray.random(16);
		         */
		        random: function (nBytes) {
		            var words = [];

		            var r = (function (m_w) {
		                var m_w = m_w;
		                var m_z = 0x3ade68b1;
		                var mask = 0xffffffff;

		                return function () {
		                    m_z = (0x9069 * (m_z & 0xFFFF) + (m_z >> 0x10)) & mask;
		                    m_w = (0x4650 * (m_w & 0xFFFF) + (m_w >> 0x10)) & mask;
		                    var result = ((m_z << 0x10) + m_w) & mask;
		                    result /= 0x100000000;
		                    result += 0.5;
		                    return result * (Math.random() > .5 ? 1 : -1);
		                }
		            });

		            for (var i = 0, rcache; i < nBytes; i += 4) {
		                var _r = r((rcache || Math.random()) * 0x100000000);

		                rcache = _r() * 0x3ade67b7;
		                words.push((_r() * 0x100000000) | 0);
		            }

		            return new WordArray.init(words, nBytes);
		        }
		    });

		    /**
		     * Encoder namespace.
		     */
		    var C_enc = C.enc = {};

		    /**
		     * Hex encoding strategy.
		     */
		    var Hex = C_enc.Hex = {
		        /**
		         * Converts a word array to a hex string.
		         *
		         * @param {WordArray} wordArray The word array.
		         *
		         * @return {string} The hex string.
		         *
		         * @static
		         *
		         * @example
		         *
		         *     var hexString = CryptoJS.enc.Hex.stringify(wordArray);
		         */
		        stringify: function (wordArray) {
		            // Shortcuts
		            var words = wordArray.words;
		            var sigBytes = wordArray.sigBytes;

		            // Convert
		            var hexChars = [];
		            for (var i = 0; i < sigBytes; i++) {
		                var bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
		                hexChars.push((bite >>> 4).toString(16));
		                hexChars.push((bite & 0x0f).toString(16));
		            }

		            return hexChars.join('');
		        },

		        /**
		         * Converts a hex string to a word array.
		         *
		         * @param {string} hexStr The hex string.
		         *
		         * @return {WordArray} The word array.
		         *
		         * @static
		         *
		         * @example
		         *
		         *     var wordArray = CryptoJS.enc.Hex.parse(hexString);
		         */
		        parse: function (hexStr) {
		            // Shortcut
		            var hexStrLength = hexStr.length;

		            // Convert
		            var words = [];
		            for (var i = 0; i < hexStrLength; i += 2) {
		                words[i >>> 3] |= parseInt(hexStr.substr(i, 2), 16) << (24 - (i % 8) * 4);
		            }

		            return new WordArray.init(words, hexStrLength / 2);
		        }
		    };

		    /**
		     * Latin1 encoding strategy.
		     */
		    var Latin1 = C_enc.Latin1 = {
		        /**
		         * Converts a word array to a Latin1 string.
		         *
		         * @param {WordArray} wordArray The word array.
		         *
		         * @return {string} The Latin1 string.
		         *
		         * @static
		         *
		         * @example
		         *
		         *     var latin1String = CryptoJS.enc.Latin1.stringify(wordArray);
		         */
		        stringify: function (wordArray) {
		            // Shortcuts
		            var words = wordArray.words;
		            var sigBytes = wordArray.sigBytes;

		            // Convert
		            var latin1Chars = [];
		            for (var i = 0; i < sigBytes; i++) {
		                var bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
		                latin1Chars.push(String.fromCharCode(bite));
		            }

		            return latin1Chars.join('');
		        },

		        /**
		         * Converts a Latin1 string to a word array.
		         *
		         * @param {string} latin1Str The Latin1 string.
		         *
		         * @return {WordArray} The word array.
		         *
		         * @static
		         *
		         * @example
		         *
		         *     var wordArray = CryptoJS.enc.Latin1.parse(latin1String);
		         */
		        parse: function (latin1Str) {
		            // Shortcut
		            var latin1StrLength = latin1Str.length;

		            // Convert
		            var words = [];
		            for (var i = 0; i < latin1StrLength; i++) {
		                words[i >>> 2] |= (latin1Str.charCodeAt(i) & 0xff) << (24 - (i % 4) * 8);
		            }

		            return new WordArray.init(words, latin1StrLength);
		        }
		    };

		    /**
		     * UTF-8 encoding strategy.
		     */
		    var Utf8 = C_enc.Utf8 = {
		        /**
		         * Converts a word array to a UTF-8 string.
		         *
		         * @param {WordArray} wordArray The word array.
		         *
		         * @return {string} The UTF-8 string.
		         *
		         * @static
		         *
		         * @example
		         *
		         *     var utf8String = CryptoJS.enc.Utf8.stringify(wordArray);
		         */
		        stringify: function (wordArray) {
		            try {
		                return decodeURIComponent(escape(Latin1.stringify(wordArray)));
		            } catch (e) {
		                throw new Error('Malformed UTF-8 data');
		            }
		        },

		        /**
		         * Converts a UTF-8 string to a word array.
		         *
		         * @param {string} utf8Str The UTF-8 string.
		         *
		         * @return {WordArray} The word array.
		         *
		         * @static
		         *
		         * @example
		         *
		         *     var wordArray = CryptoJS.enc.Utf8.parse(utf8String);
		         */
		        parse: function (utf8Str) {
		            return Latin1.parse(unescape(encodeURIComponent(utf8Str)));
		        }
		    };

		    /**
		     * Abstract buffered block algorithm template.
		     *
		     * The property blockSize must be implemented in a concrete subtype.
		     *
		     * @property {number} _minBufferSize The number of blocks that should be kept unprocessed in the buffer. Default: 0
		     */
		    var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm = Base.extend({
		        /**
		         * Resets this block algorithm's data buffer to its initial state.
		         *
		         * @example
		         *
		         *     bufferedBlockAlgorithm.reset();
		         */
		        reset: function () {
		            // Initial values
		            this._data = new WordArray.init();
		            this._nDataBytes = 0;
		        },

		        /**
		         * Adds new data to this block algorithm's buffer.
		         *
		         * @param {WordArray|string} data The data to append. Strings are converted to a WordArray using UTF-8.
		         *
		         * @example
		         *
		         *     bufferedBlockAlgorithm._append('data');
		         *     bufferedBlockAlgorithm._append(wordArray);
		         */
		        _append: function (data) {
		            // Convert string to WordArray, else assume WordArray already
		            if (typeof data == 'string') {
		                data = Utf8.parse(data);
		            }

		            // Append
		            this._data.concat(data);
		            this._nDataBytes += data.sigBytes;
		        },

		        /**
		         * Processes available data blocks.
		         *
		         * This method invokes _doProcessBlock(offset), which must be implemented by a concrete subtype.
		         *
		         * @param {boolean} doFlush Whether all blocks and partial blocks should be processed.
		         *
		         * @return {WordArray} The processed data.
		         *
		         * @example
		         *
		         *     var processedData = bufferedBlockAlgorithm._process();
		         *     var processedData = bufferedBlockAlgorithm._process(!!'flush');
		         */
		        _process: function (doFlush) {
		            // Shortcuts
		            var data = this._data;
		            var dataWords = data.words;
		            var dataSigBytes = data.sigBytes;
		            var blockSize = this.blockSize;
		            var blockSizeBytes = blockSize * 4;

		            // Count blocks ready
		            var nBlocksReady = dataSigBytes / blockSizeBytes;
		            if (doFlush) {
		                // Round up to include partial blocks
		                nBlocksReady = Math.ceil(nBlocksReady);
		            } else {
		                // Round down to include only full blocks,
		                // less the number of blocks that must remain in the buffer
		                nBlocksReady = Math.max((nBlocksReady | 0) - this._minBufferSize, 0);
		            }

		            // Count words ready
		            var nWordsReady = nBlocksReady * blockSize;

		            // Count bytes ready
		            var nBytesReady = Math.min(nWordsReady * 4, dataSigBytes);

		            // Process blocks
		            if (nWordsReady) {
		                for (var offset = 0; offset < nWordsReady; offset += blockSize) {
		                    // Perform concrete-algorithm logic
		                    this._doProcessBlock(dataWords, offset);
		                }

		                // Remove processed words
		                var processedWords = dataWords.splice(0, nWordsReady);
		                data.sigBytes -= nBytesReady;
		            }

		            // Return processed words
		            return new WordArray.init(processedWords, nBytesReady);
		        },

		        /**
		         * Creates a copy of this object.
		         *
		         * @return {Object} The clone.
		         *
		         * @example
		         *
		         *     var clone = bufferedBlockAlgorithm.clone();
		         */
		        clone: function () {
		            var clone = Base.clone.call(this);
		            clone._data = this._data.clone();

		            return clone;
		        },

		        _minBufferSize: 0
		    });

		    /**
		     * Abstract hasher template.
		     *
		     * @property {number} blockSize The number of 32-bit words this hasher operates on. Default: 16 (512 bits)
		     */
		    var Hasher = C_lib.Hasher = BufferedBlockAlgorithm.extend({
		        /**
		         * Configuration options.
		         */
		        cfg: Base.extend(),

		        /**
		         * Initializes a newly created hasher.
		         *
		         * @param {Object} cfg (Optional) The configuration options to use for this hash computation.
		         *
		         * @example
		         *
		         *     var hasher = CryptoJS.algo.SHA256.create();
		         */
		        init: function (cfg) {
		            // Apply config defaults
		            this.cfg = this.cfg.extend(cfg);

		            // Set initial values
		            this.reset();
		        },

		        /**
		         * Resets this hasher to its initial state.
		         *
		         * @example
		         *
		         *     hasher.reset();
		         */
		        reset: function () {
		            // Reset data buffer
		            BufferedBlockAlgorithm.reset.call(this);

		            // Perform concrete-hasher logic
		            this._doReset();
		        },

		        /**
		         * Updates this hasher with a message.
		         *
		         * @param {WordArray|string} messageUpdate The message to append.
		         *
		         * @return {Hasher} This hasher.
		         *
		         * @example
		         *
		         *     hasher.update('message');
		         *     hasher.update(wordArray);
		         */
		        update: function (messageUpdate) {
		            // Append
		            this._append(messageUpdate);

		            // Update the hash
		            this._process();

		            // Chainable
		            return this;
		        },

		        /**
		         * Finalizes the hash computation.
		         * Note that the finalize operation is effectively a destructive, read-once operation.
		         *
		         * @param {WordArray|string} messageUpdate (Optional) A final message update.
		         *
		         * @return {WordArray} The hash.
		         *
		         * @example
		         *
		         *     var hash = hasher.finalize();
		         *     var hash = hasher.finalize('message');
		         *     var hash = hasher.finalize(wordArray);
		         */
		        finalize: function (messageUpdate) {
		            // Final message update
		            if (messageUpdate) {
		                this._append(messageUpdate);
		            }

		            // Perform concrete-hasher logic
		            var hash = this._doFinalize();

		            return hash;
		        },

		        blockSize: 512/32,

		        /**
		         * Creates a shortcut function to a hasher's object interface.
		         *
		         * @param {Hasher} hasher The hasher to create a helper for.
		         *
		         * @return {Function} The shortcut function.
		         *
		         * @static
		         *
		         * @example
		         *
		         *     var SHA256 = CryptoJS.lib.Hasher._createHelper(CryptoJS.algo.SHA256);
		         */
		        _createHelper: function (hasher) {
		            return function (message, cfg) {
		                return new hasher.init(cfg).finalize(message);
		            };
		        },

		        /**
		         * Creates a shortcut function to the HMAC's object interface.
		         *
		         * @param {Hasher} hasher The hasher to use in this HMAC helper.
		         *
		         * @return {Function} The shortcut function.
		         *
		         * @static
		         *
		         * @example
		         *
		         *     var HmacSHA256 = CryptoJS.lib.Hasher._createHmacHelper(CryptoJS.algo.SHA256);
		         */
		        _createHmacHelper: function (hasher) {
		            return function (message, key) {
		                return new C_algo.HMAC.init(hasher, key).finalize(message);
		            };
		        }
		    });

		    /**
		     * Algorithm namespace.
		     */
		    var C_algo = C.algo = {};

		    return C;
		}(Math));


		return CryptoJS;

	}));
	});

	var md5 = createCommonjsModule(function (module, exports) {
	(function (root, factory) {
		{
			// CommonJS
			module.exports = exports = factory(core);
		}
	}(commonjsGlobal, function (CryptoJS) {

		(function (Math) {
		    // Shortcuts
		    var C = CryptoJS;
		    var C_lib = C.lib;
		    var WordArray = C_lib.WordArray;
		    var Hasher = C_lib.Hasher;
		    var C_algo = C.algo;

		    // Constants table
		    var T = [];

		    // Compute constants
		    (function () {
		        for (var i = 0; i < 64; i++) {
		            T[i] = (Math.abs(Math.sin(i + 1)) * 0x100000000) | 0;
		        }
		    }());

		    /**
		     * MD5 hash algorithm.
		     */
		    var MD5 = C_algo.MD5 = Hasher.extend({
		        _doReset: function () {
		            this._hash = new WordArray.init([
		                0x67452301, 0xefcdab89,
		                0x98badcfe, 0x10325476
		            ]);
		        },

		        _doProcessBlock: function (M, offset) {
		            // Swap endian
		            for (var i = 0; i < 16; i++) {
		                // Shortcuts
		                var offset_i = offset + i;
		                var M_offset_i = M[offset_i];

		                M[offset_i] = (
		                    (((M_offset_i << 8)  | (M_offset_i >>> 24)) & 0x00ff00ff) |
		                    (((M_offset_i << 24) | (M_offset_i >>> 8))  & 0xff00ff00)
		                );
		            }

		            // Shortcuts
		            var H = this._hash.words;

		            var M_offset_0  = M[offset + 0];
		            var M_offset_1  = M[offset + 1];
		            var M_offset_2  = M[offset + 2];
		            var M_offset_3  = M[offset + 3];
		            var M_offset_4  = M[offset + 4];
		            var M_offset_5  = M[offset + 5];
		            var M_offset_6  = M[offset + 6];
		            var M_offset_7  = M[offset + 7];
		            var M_offset_8  = M[offset + 8];
		            var M_offset_9  = M[offset + 9];
		            var M_offset_10 = M[offset + 10];
		            var M_offset_11 = M[offset + 11];
		            var M_offset_12 = M[offset + 12];
		            var M_offset_13 = M[offset + 13];
		            var M_offset_14 = M[offset + 14];
		            var M_offset_15 = M[offset + 15];

		            // Working varialbes
		            var a = H[0];
		            var b = H[1];
		            var c = H[2];
		            var d = H[3];

		            // Computation
		            a = FF(a, b, c, d, M_offset_0,  7,  T[0]);
		            d = FF(d, a, b, c, M_offset_1,  12, T[1]);
		            c = FF(c, d, a, b, M_offset_2,  17, T[2]);
		            b = FF(b, c, d, a, M_offset_3,  22, T[3]);
		            a = FF(a, b, c, d, M_offset_4,  7,  T[4]);
		            d = FF(d, a, b, c, M_offset_5,  12, T[5]);
		            c = FF(c, d, a, b, M_offset_6,  17, T[6]);
		            b = FF(b, c, d, a, M_offset_7,  22, T[7]);
		            a = FF(a, b, c, d, M_offset_8,  7,  T[8]);
		            d = FF(d, a, b, c, M_offset_9,  12, T[9]);
		            c = FF(c, d, a, b, M_offset_10, 17, T[10]);
		            b = FF(b, c, d, a, M_offset_11, 22, T[11]);
		            a = FF(a, b, c, d, M_offset_12, 7,  T[12]);
		            d = FF(d, a, b, c, M_offset_13, 12, T[13]);
		            c = FF(c, d, a, b, M_offset_14, 17, T[14]);
		            b = FF(b, c, d, a, M_offset_15, 22, T[15]);

		            a = GG(a, b, c, d, M_offset_1,  5,  T[16]);
		            d = GG(d, a, b, c, M_offset_6,  9,  T[17]);
		            c = GG(c, d, a, b, M_offset_11, 14, T[18]);
		            b = GG(b, c, d, a, M_offset_0,  20, T[19]);
		            a = GG(a, b, c, d, M_offset_5,  5,  T[20]);
		            d = GG(d, a, b, c, M_offset_10, 9,  T[21]);
		            c = GG(c, d, a, b, M_offset_15, 14, T[22]);
		            b = GG(b, c, d, a, M_offset_4,  20, T[23]);
		            a = GG(a, b, c, d, M_offset_9,  5,  T[24]);
		            d = GG(d, a, b, c, M_offset_14, 9,  T[25]);
		            c = GG(c, d, a, b, M_offset_3,  14, T[26]);
		            b = GG(b, c, d, a, M_offset_8,  20, T[27]);
		            a = GG(a, b, c, d, M_offset_13, 5,  T[28]);
		            d = GG(d, a, b, c, M_offset_2,  9,  T[29]);
		            c = GG(c, d, a, b, M_offset_7,  14, T[30]);
		            b = GG(b, c, d, a, M_offset_12, 20, T[31]);

		            a = HH(a, b, c, d, M_offset_5,  4,  T[32]);
		            d = HH(d, a, b, c, M_offset_8,  11, T[33]);
		            c = HH(c, d, a, b, M_offset_11, 16, T[34]);
		            b = HH(b, c, d, a, M_offset_14, 23, T[35]);
		            a = HH(a, b, c, d, M_offset_1,  4,  T[36]);
		            d = HH(d, a, b, c, M_offset_4,  11, T[37]);
		            c = HH(c, d, a, b, M_offset_7,  16, T[38]);
		            b = HH(b, c, d, a, M_offset_10, 23, T[39]);
		            a = HH(a, b, c, d, M_offset_13, 4,  T[40]);
		            d = HH(d, a, b, c, M_offset_0,  11, T[41]);
		            c = HH(c, d, a, b, M_offset_3,  16, T[42]);
		            b = HH(b, c, d, a, M_offset_6,  23, T[43]);
		            a = HH(a, b, c, d, M_offset_9,  4,  T[44]);
		            d = HH(d, a, b, c, M_offset_12, 11, T[45]);
		            c = HH(c, d, a, b, M_offset_15, 16, T[46]);
		            b = HH(b, c, d, a, M_offset_2,  23, T[47]);

		            a = II(a, b, c, d, M_offset_0,  6,  T[48]);
		            d = II(d, a, b, c, M_offset_7,  10, T[49]);
		            c = II(c, d, a, b, M_offset_14, 15, T[50]);
		            b = II(b, c, d, a, M_offset_5,  21, T[51]);
		            a = II(a, b, c, d, M_offset_12, 6,  T[52]);
		            d = II(d, a, b, c, M_offset_3,  10, T[53]);
		            c = II(c, d, a, b, M_offset_10, 15, T[54]);
		            b = II(b, c, d, a, M_offset_1,  21, T[55]);
		            a = II(a, b, c, d, M_offset_8,  6,  T[56]);
		            d = II(d, a, b, c, M_offset_15, 10, T[57]);
		            c = II(c, d, a, b, M_offset_6,  15, T[58]);
		            b = II(b, c, d, a, M_offset_13, 21, T[59]);
		            a = II(a, b, c, d, M_offset_4,  6,  T[60]);
		            d = II(d, a, b, c, M_offset_11, 10, T[61]);
		            c = II(c, d, a, b, M_offset_2,  15, T[62]);
		            b = II(b, c, d, a, M_offset_9,  21, T[63]);

		            // Intermediate hash value
		            H[0] = (H[0] + a) | 0;
		            H[1] = (H[1] + b) | 0;
		            H[2] = (H[2] + c) | 0;
		            H[3] = (H[3] + d) | 0;
		        },

		        _doFinalize: function () {
		            // Shortcuts
		            var data = this._data;
		            var dataWords = data.words;

		            var nBitsTotal = this._nDataBytes * 8;
		            var nBitsLeft = data.sigBytes * 8;

		            // Add padding
		            dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);

		            var nBitsTotalH = Math.floor(nBitsTotal / 0x100000000);
		            var nBitsTotalL = nBitsTotal;
		            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 15] = (
		                (((nBitsTotalH << 8)  | (nBitsTotalH >>> 24)) & 0x00ff00ff) |
		                (((nBitsTotalH << 24) | (nBitsTotalH >>> 8))  & 0xff00ff00)
		            );
		            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = (
		                (((nBitsTotalL << 8)  | (nBitsTotalL >>> 24)) & 0x00ff00ff) |
		                (((nBitsTotalL << 24) | (nBitsTotalL >>> 8))  & 0xff00ff00)
		            );

		            data.sigBytes = (dataWords.length + 1) * 4;

		            // Hash final blocks
		            this._process();

		            // Shortcuts
		            var hash = this._hash;
		            var H = hash.words;

		            // Swap endian
		            for (var i = 0; i < 4; i++) {
		                // Shortcut
		                var H_i = H[i];

		                H[i] = (((H_i << 8)  | (H_i >>> 24)) & 0x00ff00ff) |
		                       (((H_i << 24) | (H_i >>> 8))  & 0xff00ff00);
		            }

		            // Return final computed hash
		            return hash;
		        },

		        clone: function () {
		            var clone = Hasher.clone.call(this);
		            clone._hash = this._hash.clone();

		            return clone;
		        }
		    });

		    function FF(a, b, c, d, x, s, t) {
		        var n = a + ((b & c) | (~b & d)) + x + t;
		        return ((n << s) | (n >>> (32 - s))) + b;
		    }

		    function GG(a, b, c, d, x, s, t) {
		        var n = a + ((b & d) | (c & ~d)) + x + t;
		        return ((n << s) | (n >>> (32 - s))) + b;
		    }

		    function HH(a, b, c, d, x, s, t) {
		        var n = a + (b ^ c ^ d) + x + t;
		        return ((n << s) | (n >>> (32 - s))) + b;
		    }

		    function II(a, b, c, d, x, s, t) {
		        var n = a + (c ^ (b | ~d)) + x + t;
		        return ((n << s) | (n >>> (32 - s))) + b;
		    }

		    /**
		     * Shortcut function to the hasher's object interface.
		     *
		     * @param {WordArray|string} message The message to hash.
		     *
		     * @return {WordArray} The hash.
		     *
		     * @static
		     *
		     * @example
		     *
		     *     var hash = CryptoJS.MD5('message');
		     *     var hash = CryptoJS.MD5(wordArray);
		     */
		    C.MD5 = Hasher._createHelper(MD5);

		    /**
		     * Shortcut function to the HMAC's object interface.
		     *
		     * @param {WordArray|string} message The message to hash.
		     * @param {WordArray|string} key The secret key.
		     *
		     * @return {WordArray} The HMAC.
		     *
		     * @static
		     *
		     * @example
		     *
		     *     var hmac = CryptoJS.HmacMD5(message, key);
		     */
		    C.HmacMD5 = Hasher._createHmacHelper(MD5);
		}(Math));


		return CryptoJS.MD5;

	}));
	});

	var DigestAuthentication_1 = createCommonjsModule(function (module, exports) {
	Object.defineProperty(exports, "__esModule", { value: true });



	/**
	 * SIP Digest Authentication.
	 * @function Digest Authentication
	 * @param {SIP.UA} ua
	 */
	var DigestAuthentication = /** @class */ (function () {
	    function DigestAuthentication(ua) {
	        this.type = Enums.TypeStrings.DigestAuthentication;
	        this.logger = ua.getLogger("sipjs.digestauthentication");
	        this.username = ua.configuration.authorizationUser;
	        this.password = ua.configuration.password;
	        this.nc = 0;
	        this.ncHex = "00000000";
	    }
	    /**
	     * Performs Digest authentication given a SIP request and the challenge
	     * received in a response to that request.
	     * Returns true if credentials were successfully generated, false otherwise.
	     *
	     * @param {SIP.OutgoingRequest} request
	     * @param {Object} challenge
	     */
	    DigestAuthentication.prototype.authenticate = function (request, challenge, body) {
	        // Inspect and validate the challenge.
	        this.algorithm = challenge.algorithm;
	        this.realm = challenge.realm;
	        this.nonce = challenge.nonce;
	        this.opaque = challenge.opaque;
	        this.stale = challenge.stale;
	        if (this.algorithm) {
	            if (this.algorithm !== "MD5") {
	                this.logger.warn("challenge with Digest algorithm different than 'MD5', authentication aborted");
	                return false;
	            }
	        }
	        else {
	            this.algorithm = "MD5";
	        }
	        if (!this.realm) {
	            this.logger.warn("challenge without Digest realm, authentication aborted");
	            return false;
	        }
	        if (!this.nonce) {
	            this.logger.warn("challenge without Digest nonce, authentication aborted");
	            return false;
	        }
	        // 'qop' can contain a list of values (Array). Let's choose just one.
	        if (challenge.qop) {
	            if (challenge.qop.indexOf("auth") > -1) {
	                this.qop = "auth";
	            }
	            else if (challenge.qop.indexOf("auth-int") > -1) {
	                this.qop = "auth-int";
	            }
	            else {
	                // Otherwise 'qop' is present but does not contain 'auth' or 'auth-int', so abort here.
	                this.logger.warn("challenge without Digest qop different than 'auth' or 'auth-int', authentication aborted");
	                return false;
	            }
	        }
	        else {
	            this.qop = undefined;
	        }
	        // Fill other attributes.
	        this.method = request.method;
	        this.uri = request.ruri;
	        this.cnonce = Utils_1.Utils.createRandomToken(12);
	        this.nc += 1;
	        this.updateNcHex();
	        // nc-value = 8LHEX. Max value = 'FFFFFFFF'.
	        if (this.nc === 4294967296) {
	            this.nc = 1;
	            this.ncHex = "00000001";
	        }
	        // Calculate the Digest "response" value.
	        this.calculateResponse(body);
	        return true;
	    };
	    /**
	     * Return the Proxy-Authorization or WWW-Authorization header value.
	     */
	    DigestAuthentication.prototype.toString = function () {
	        var authParams = [];
	        if (!this.response) {
	            throw new Error("response field does not exist, cannot generate Authorization header");
	        }
	        authParams.push("algorithm=" + this.algorithm);
	        authParams.push('username="' + this.username + '"');
	        authParams.push('realm="' + this.realm + '"');
	        authParams.push('nonce="' + this.nonce + '"');
	        authParams.push('uri="' + this.uri + '"');
	        authParams.push('response="' + this.response + '"');
	        if (this.opaque) {
	            authParams.push('opaque="' + this.opaque + '"');
	        }
	        if (this.qop) {
	            authParams.push("qop=" + this.qop);
	            authParams.push('cnonce="' + this.cnonce + '"');
	            authParams.push("nc=" + this.ncHex);
	        }
	        return "Digest " + authParams.join(", ");
	    };
	    /**
	     * Generate the 'nc' value as required by Digest in this.ncHex by reading this.nc.
	     * @private
	     */
	    DigestAuthentication.prototype.updateNcHex = function () {
	        var hex = Number(this.nc).toString(16);
	        this.ncHex = "00000000".substr(0, 8 - hex.length) + hex;
	    };
	    /**
	     * Generate Digest 'response' value.
	     * @private
	     */
	    DigestAuthentication.prototype.calculateResponse = function (body) {
	        var ha2;
	        // HA1 = MD5(A1) = MD5(username:realm:password)
	        var ha1 = md5(this.username + ":" + this.realm + ":" + this.password);
	        if (this.qop === "auth") {
	            // HA2 = MD5(A2) = MD5(method:digestURI)
	            ha2 = md5(this.method + ":" + this.uri);
	            // response = MD5(HA1:nonce:nonceCount:credentialsNonce:qop:HA2)
	            this.response = md5(ha1 + ":" + this.nonce + ":" + this.ncHex + ":" + this.cnonce + ":auth:" + ha2);
	        }
	        else if (this.qop === "auth-int") {
	            // HA2 = MD5(A2) = MD5(method:digestURI:MD5(entityBody))
	            ha2 = md5(this.method + ":" + this.uri + ":" + md5(body ? body : ""));
	            // response = MD5(HA1:nonce:nonceCount:credentialsNonce:qop:HA2)
	            this.response = md5(ha1 + ":" + this.nonce + ":" + this.ncHex + ":" + this.cnonce + ":auth-int:" + ha2);
	        }
	        else if (this.qop === undefined) {
	            // HA2 = MD5(A2) = MD5(method:digestURI)
	            ha2 = md5(this.method + ":" + this.uri);
	            // response = MD5(HA1:nonce:HA2)
	            this.response = md5(ha1 + ":" + this.nonce + ":" + ha2);
	        }
	    };
	    return DigestAuthentication;
	}());
	exports.DigestAuthentication = DigestAuthentication;
	});

	unwrapExports(DigestAuthentication_1);
	var DigestAuthentication_2 = DigestAuthentication_1.DigestAuthentication;

	var LoggerFactory_1 = createCommonjsModule(function (module, exports) {
	Object.defineProperty(exports, "__esModule", { value: true });

	var Levels;
	(function (Levels) {
	    Levels[Levels["error"] = 0] = "error";
	    Levels[Levels["warn"] = 1] = "warn";
	    Levels[Levels["log"] = 2] = "log";
	    Levels[Levels["debug"] = 3] = "debug";
	})(Levels = exports.Levels || (exports.Levels = {}));
	var LoggerFactory = /** @class */ (function () {
	    function LoggerFactory() {
	        this.builtinEnabled = true;
	        // tslint:disable-next-line:variable-name
	        this._level = Levels.log;
	        this.loggers = {};
	        this.type = Enums.TypeStrings.LoggerFactory;
	        this.logger = this.getLogger("sip:loggerfactory");
	    }
	    Object.defineProperty(LoggerFactory.prototype, "level", {
	        get: function () { return this._level; },
	        set: function (newLevel) {
	            if (newLevel >= 0 && newLevel <= 3) {
	                this._level = newLevel;
	            }
	            else if (newLevel > 3) {
	                this._level = 3;
	            }
	            else if (Levels.hasOwnProperty(newLevel)) {
	                this._level = newLevel;
	            }
	            else {
	                this.logger.error("invalid 'level' parameter value: " + JSON.stringify(newLevel));
	            }
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(LoggerFactory.prototype, "connector", {
	        get: function () {
	            return this._connector;
	        },
	        set: function (value) {
	            if (!value) {
	                this._connector = undefined;
	            }
	            else if (typeof value === "function") {
	                this._connector = value;
	            }
	            else {
	                this.logger.error("invalid 'connector' parameter value: " + JSON.stringify(value));
	            }
	        },
	        enumerable: true,
	        configurable: true
	    });
	    LoggerFactory.prototype.getLogger = function (category, label) {
	        if (label && this.level === 3) {
	            return new Logger(this, category, label);
	        }
	        else if (this.loggers[category]) {
	            return this.loggers[category];
	        }
	        else {
	            var logger = new Logger(this, category);
	            this.loggers[category] = logger;
	            return logger;
	        }
	    };
	    LoggerFactory.prototype.genericLog = function (levelToLog, category, label, content) {
	        if (this.level >= levelToLog) {
	            if (this.builtinEnabled) {
	                this.print(console[Levels[levelToLog]], category, label, content);
	            }
	        }
	        if (this.connector) {
	            this.connector(Levels[levelToLog], category, label, content);
	        }
	    };
	    LoggerFactory.prototype.print = function (target, category, label, content) {
	        if (typeof content === "string") {
	            var prefix = [new Date(), category];
	            if (label) {
	                prefix.push(label);
	            }
	            content = prefix.concat(content).join(" | ");
	        }
	        target.call(console, content);
	    };
	    return LoggerFactory;
	}());
	exports.LoggerFactory = LoggerFactory;
	// tslint:disable-next-line:max-classes-per-file
	var Logger = /** @class */ (function () {
	    function Logger(logger, category, label) {
	        this.type = Enums.TypeStrings.Logger;
	        this.logger = logger;
	        this.category = category;
	        this.label = label;
	    }
	    Logger.prototype.error = function (content) { this.genericLog(Levels.error, content); };
	    Logger.prototype.warn = function (content) { this.genericLog(Levels.warn, content); };
	    Logger.prototype.log = function (content) { this.genericLog(Levels.log, content); };
	    Logger.prototype.debug = function (content) { this.genericLog(Levels.debug, content); };
	    Logger.prototype.genericLog = function (level, content) {
	        this.logger.genericLog(level, this.category, this.label, content);
	    };
	    return Logger;
	}());
	exports.Logger = Logger;
	});

	unwrapExports(LoggerFactory_1);
	var LoggerFactory_2 = LoggerFactory_1.Levels;
	var LoggerFactory_3 = LoggerFactory_1.LoggerFactory;
	var LoggerFactory_4 = LoggerFactory_1.Logger;

	var Parser_1 = createCommonjsModule(function (module, exports) {
	Object.defineProperty(exports, "__esModule", { value: true });



	// SIP.Parser = Parser;
	/**
	 * Extract and parse every header of a SIP message.
	 * @namespace
	 */
	var Parser;
	(function (Parser) {
	    function getHeader(data, headerStart) {
	        // 'start' position of the header.
	        var start = headerStart;
	        // 'end' position of the header.
	        var end = 0;
	        // 'partial end' position of the header.
	        var partialEnd = 0;
	        // End of message.
	        if (data.substring(start, start + 2).match(/(^\r\n)/)) {
	            return -2;
	        }
	        while (end === 0) {
	            // Partial End of Header.
	            partialEnd = data.indexOf("\r\n", start);
	            // 'indexOf' returns -1 if the value to be found never occurs.
	            if (partialEnd === -1) {
	                return partialEnd;
	            }
	            if (!data.substring(partialEnd + 2, partialEnd + 4).match(/(^\r\n)/) &&
	                data.charAt(partialEnd + 2).match(/(^\s+)/)) {
	                // Not the end of the message. Continue from the next position.
	                start = partialEnd + 2;
	            }
	            else {
	                end = partialEnd;
	            }
	        }
	        return end;
	    }
	    Parser.getHeader = getHeader;
	    function parseHeader(message, data, headerStart, headerEnd) {
	        var hcolonIndex = data.indexOf(":", headerStart);
	        var headerName = data.substring(headerStart, hcolonIndex).trim();
	        var headerValue = data.substring(hcolonIndex + 1, headerEnd).trim();
	        var parsed;
	        // If header-field is well-known, parse it.
	        switch (headerName.toLowerCase()) {
	            case "via":
	            case "v":
	                message.addHeader("via", headerValue);
	                if (message.getHeaders("via").length === 1) {
	                    parsed = message.parseHeader("Via");
	                    if (parsed) {
	                        message.via = parsed;
	                        message.viaBranch = parsed.branch;
	                    }
	                }
	                else {
	                    parsed = 0;
	                }
	                break;
	            case "from":
	            case "f":
	                message.setHeader("from", headerValue);
	                parsed = message.parseHeader("from");
	                if (parsed) {
	                    message.from = parsed;
	                    message.fromTag = parsed.getParam("tag");
	                }
	                break;
	            case "to":
	            case "t":
	                message.setHeader("to", headerValue);
	                parsed = message.parseHeader("to");
	                if (parsed) {
	                    message.to = parsed;
	                    message.toTag = parsed.getParam("tag");
	                }
	                break;
	            case "record-route":
	                parsed = Grammar_1$1.Grammar.parse(headerValue, "Record_Route");
	                if (parsed === -1) {
	                    parsed = undefined;
	                    break;
	                }
	                for (var header in parsed) {
	                    if (parsed[header]) {
	                        message.addHeader("record-route", headerValue.substring(parsed[header].position, parsed[header].offset));
	                        message.headers["Record-Route"][message.getHeaders("record-route").length - 1].parsed =
	                            parsed[header].parsed;
	                    }
	                }
	                break;
	            case "call-id":
	            case "i":
	                message.setHeader("call-id", headerValue);
	                parsed = message.parseHeader("call-id");
	                if (parsed) {
	                    message.callId = headerValue;
	                }
	                break;
	            case "contact":
	            case "m":
	                parsed = Grammar_1$1.Grammar.parse(headerValue, "Contact");
	                if (parsed === -1) {
	                    parsed = undefined;
	                    break;
	                }
	                if (!(parsed instanceof Array)) {
	                    parsed = undefined;
	                    break;
	                }
	                parsed.forEach(function (header) {
	                    message.addHeader("contact", headerValue.substring(header.position, header.offset));
	                    message.headers.Contact[message.getHeaders("contact").length - 1].parsed = header.parsed;
	                });
	                break;
	            case "content-length":
	            case "l":
	                message.setHeader("content-length", headerValue);
	                parsed = message.parseHeader("content-length");
	                break;
	            case "content-type":
	            case "c":
	                message.setHeader("content-type", headerValue);
	                parsed = message.parseHeader("content-type");
	                break;
	            case "cseq":
	                message.setHeader("cseq", headerValue);
	                parsed = message.parseHeader("cseq");
	                if (parsed) {
	                    message.cseq = parsed.value;
	                }
	                if (message.type === Enums.TypeStrings.IncomingResponse) {
	                    message.method = parsed.method;
	                }
	                break;
	            case "max-forwards":
	                message.setHeader("max-forwards", headerValue);
	                parsed = message.parseHeader("max-forwards");
	                break;
	            case "www-authenticate":
	                message.setHeader("www-authenticate", headerValue);
	                parsed = message.parseHeader("www-authenticate");
	                break;
	            case "proxy-authenticate":
	                message.setHeader("proxy-authenticate", headerValue);
	                parsed = message.parseHeader("proxy-authenticate");
	                break;
	            case "refer-to":
	            case "r":
	                message.setHeader("refer-to", headerValue);
	                parsed = message.parseHeader("refer-to");
	                if (parsed) {
	                    message.referTo = parsed;
	                }
	                break;
	            default:
	                // Do not parse this header.
	                message.setHeader(headerName, headerValue);
	                parsed = 0;
	        }
	        if (parsed === undefined) {
	            return {
	                error: "error parsing header '" + headerName + "'"
	            };
	        }
	        else {
	            return true;
	        }
	    }
	    Parser.parseHeader = parseHeader;
	    /** Parse SIP Message
	     * @function
	     * @param {String} message SIP message.
	     * @param {Object} logger object.
	     * @returns {SIP.IncomingRequest|SIP.IncomingResponse|undefined}
	     */
	    function parseMessage(data, ua) {
	        var headerStart = 0;
	        var headerEnd = data.indexOf("\r\n");
	        var logger = ua.getLogger("sip.parser");
	        if (headerEnd === -1) {
	            logger.warn("no CRLF found, not a SIP message, discarded");
	            return;
	        }
	        // Parse first line. Check if it is a Request or a Reply.
	        var firstLine = data.substring(0, headerEnd);
	        var parsed = Grammar_1$1.Grammar.parse(firstLine, "Request_Response");
	        var message;
	        if (parsed === -1) {
	            logger.warn('error parsing first line of SIP message: "' + firstLine + '"');
	            return;
	        }
	        else if (!parsed.status_code) {
	            message = new SIPMessage.IncomingRequest(ua);
	            message.method = parsed.method;
	            message.ruri = parsed.uri;
	        }
	        else {
	            message = new SIPMessage.IncomingResponse(ua);
	            message.statusCode = parsed.status_code;
	            message.reasonPhrase = parsed.reason_phrase;
	        }
	        message.data = data;
	        headerStart = headerEnd + 2;
	        /* Loop over every line in data. Detect the end of each header and parse
	        * it or simply add to the headers collection.
	        */
	        var bodyStart;
	        while (true) {
	            headerEnd = getHeader(data, headerStart);
	            // The SIP message has normally finished.
	            if (headerEnd === -2) {
	                bodyStart = headerStart + 2;
	                break;
	            }
	            else if (headerEnd === -1) {
	                // data.indexOf returned -1 due to a malformed message.
	                logger.error("malformed message");
	                return;
	            }
	            var parsedHeader = parseHeader(message, data, headerStart, headerEnd);
	            if (parsedHeader !== true) {
	                logger.error(parsed.error);
	                return;
	            }
	            headerStart = headerEnd + 2;
	        }
	        /* RFC3261 18.3.
	        * If there are additional bytes in the transport packet
	        * beyond the end of the body, they MUST be discarded.
	        */
	        if (message.hasHeader("content-length")) {
	            message.body = data.substr(bodyStart, Number(message.getHeader("content-length")));
	        }
	        else {
	            message.body = data.substring(bodyStart);
	        }
	        return message;
	    }
	    Parser.parseMessage = parseMessage;
	})(Parser = exports.Parser || (exports.Parser = {}));
	});

	unwrapExports(Parser_1);
	var Parser_2 = Parser_1.Parser;

	var PublishContext_1 = createCommonjsModule(function (module, exports) {
	var __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	Object.defineProperty(exports, "__esModule", { value: true });






	/**
	 * SIP Publish (SIP Extension for Event State Publication RFC3903)
	 * @class Class creating a SIP PublishContext.
	 */
	var PublishContext = /** @class */ (function (_super) {
	    __extends(PublishContext, _super);
	    function PublishContext(ua, target, event, options) {
	        if (options === void 0) { options = {}; }
	        var _this = this;
	        options.extraHeaders = (options.extraHeaders || []).slice();
	        options.contentType = (options.contentType || "text/plain");
	        if (typeof options.expires !== "number" || (options.expires % 1) !== 0) {
	            options.expires = 3600;
	        }
	        else {
	            options.expires = Number(options.expires);
	        }
	        if (typeof (options.unpublishOnClose) !== "boolean") {
	            options.unpublishOnClose = true;
	        }
	        if (target === undefined || target === null || target === "") {
	            throw new Exceptions_1.Exceptions.MethodParameterError("Publish", "Target", target);
	        }
	        else {
	            target = ua.normalizeTarget(target);
	            if (target === undefined) {
	                throw new Exceptions_1.Exceptions.MethodParameterError("Publish", "Target", target);
	            }
	        }
	        _this = _super.call(this, ua, Constants.C.PUBLISH, target, options) || this;
	        _this.type = Enums.TypeStrings.PublishContext;
	        _this.options = options;
	        _this.target = target;
	        if (event === undefined || event === null || event === "") {
	            throw new Exceptions_1.Exceptions.MethodParameterError("Publish", "Event", event);
	        }
	        else {
	            _this.event = event;
	        }
	        _this.logger = ua.getLogger("sip.publish");
	        _this.pubRequestExpires = _this.options.expires;
	        ua.on("transportCreated", function (transport) {
	            transport.on("transportError", function () { return _this.onTransportError(); });
	        });
	        return _this;
	    }
	    /**
	     * Publish
	     * @param {string} Event body to publish, optional
	     */
	    PublishContext.prototype.publish = function (body) {
	        // Clean up before the run
	        if (this.publishRefreshTimer) {
	            clearTimeout(this.publishRefreshTimer);
	            this.publishRefreshTimer = undefined;
	        }
	        // is Inital or Modify request
	        this.options.body = body;
	        this.pubRequestBody = this.options.body;
	        if (this.pubRequestExpires === 0) {
	            // This is Initial request after unpublish
	            this.pubRequestExpires = this.options.expires;
	            this.pubRequestEtag = undefined;
	        }
	        if (!(this.ua.publishers[this.target.toString() + ":" + this.event])) {
	            this.ua.publishers[this.target.toString() + ":" + this.event] = this;
	        }
	        this.sendPublishRequest();
	    };
	    /**
	     * Unpublish
	     */
	    PublishContext.prototype.unpublish = function () {
	        // Clean up before the run
	        if (this.publishRefreshTimer) {
	            clearTimeout(this.publishRefreshTimer);
	            this.publishRefreshTimer = undefined;
	        }
	        this.pubRequestBody = undefined;
	        this.pubRequestExpires = 0;
	        if (this.pubRequestEtag !== undefined) {
	            this.sendPublishRequest();
	        }
	    };
	    /**
	     * Close
	     */
	    PublishContext.prototype.close = function () {
	        // Send unpublish, if requested
	        if (this.options.unpublishOnClose) {
	            this.unpublish();
	        }
	        else {
	            if (this.publishRefreshTimer) {
	                clearTimeout(this.publishRefreshTimer);
	                this.publishRefreshTimer = undefined;
	            }
	            this.pubRequestBody = undefined;
	            this.pubRequestExpires = 0;
	            this.pubRequestEtag = undefined;
	        }
	        if (this.ua.publishers[this.target.toString() + ":" + this.event]) {
	            delete this.ua.publishers[this.target.toString() + ":" + this.event];
	        }
	    };
	    PublishContext.prototype.onRequestTimeout = function () {
	        _super.prototype.onRequestTimeout.call(this);
	        this.emit("unpublished", undefined, Constants.C.causes.REQUEST_TIMEOUT);
	    };
	    PublishContext.prototype.onTransportError = function () {
	        _super.prototype.onTransportError.call(this);
	        this.emit("unpublished", undefined, Constants.C.causes.CONNECTION_ERROR);
	    };
	    PublishContext.prototype.receiveResponse = function (response) {
	        var _this = this;
	        var statusCode = response.statusCode || 0;
	        var cause = Utils_1.Utils.getReasonPhrase(statusCode);
	        switch (true) {
	            case /^1[0-9]{2}$/.test(statusCode.toString()):
	                this.emit("progress", response, cause);
	                break;
	            case /^2[0-9]{2}$/.test(statusCode.toString()):
	                // Set SIP-Etag
	                if (response.hasHeader("SIP-ETag")) {
	                    this.pubRequestEtag = response.getHeader("SIP-ETag");
	                }
	                else {
	                    this.logger.warn("SIP-ETag header missing in a 200-class response to PUBLISH");
	                }
	                // Update Expire
	                if (response.hasHeader("Expires")) {
	                    var expires = Number(response.getHeader("Expires"));
	                    if (typeof expires === "number" && expires >= 0 && expires <= this.pubRequestExpires) {
	                        this.pubRequestExpires = expires;
	                    }
	                    else {
	                        this.logger.warn("Bad Expires header in a 200-class response to PUBLISH");
	                    }
	                }
	                else {
	                    this.logger.warn("Expires header missing in a 200-class response to PUBLISH");
	                }
	                if (this.pubRequestExpires !== 0) {
	                    // Schedule refresh
	                    this.publishRefreshTimer = setTimeout(function () { return _this.refreshRequest(); }, this.pubRequestExpires * 900);
	                    this.emit("published", response, cause);
	                }
	                else {
	                    this.emit("unpublished", response, cause);
	                }
	                break;
	            case /^412$/.test(statusCode.toString()):
	                // 412 code means no matching ETag - possibly the PUBLISH expired
	                // Resubmit as new request, if the current request is not a "remove"
	                if (this.pubRequestEtag !== undefined && this.pubRequestExpires !== 0) {
	                    this.logger.warn("412 response to PUBLISH, recovering");
	                    this.pubRequestEtag = undefined;
	                    this.emit("progress", response, cause);
	                    this.publish(this.options.body);
	                }
	                else {
	                    this.logger.warn("412 response to PUBLISH, recovery failed");
	                    this.pubRequestExpires = 0;
	                    this.emit("failed", response, cause);
	                    this.emit("unpublished", response, cause);
	                }
	                break;
	            case /^423$/.test(statusCode.toString()):
	                // 423 code means we need to adjust the Expires interval up
	                if (this.pubRequestExpires !== 0 && response.hasHeader("Min-Expires")) {
	                    var minExpires = Number(response.getHeader("Min-Expires"));
	                    if (typeof minExpires === "number" || minExpires > this.pubRequestExpires) {
	                        this.logger.warn("423 code in response to PUBLISH, adjusting the Expires value and trying to recover");
	                        this.pubRequestExpires = minExpires;
	                        this.emit("progress", response, cause);
	                        this.publish(this.options.body);
	                    }
	                    else {
	                        this.logger.warn("Bad 423 response Min-Expires header received for PUBLISH");
	                        this.pubRequestExpires = 0;
	                        this.emit("failed", response, cause);
	                        this.emit("unpublished", response, cause);
	                    }
	                }
	                else {
	                    this.logger.warn("423 response to PUBLISH, recovery failed");
	                    this.pubRequestExpires = 0;
	                    this.emit("failed", response, cause);
	                    this.emit("unpublished", response, cause);
	                }
	                break;
	            default:
	                this.pubRequestExpires = 0;
	                this.emit("failed", response, cause);
	                this.emit("unpublished", response, cause);
	                break;
	        }
	        // Do the cleanup
	        if (this.pubRequestExpires === 0) {
	            if (this.publishRefreshTimer) {
	                clearTimeout(this.publishRefreshTimer);
	                this.publishRefreshTimer = undefined;
	            }
	            this.pubRequestBody = undefined;
	            this.pubRequestEtag = undefined;
	        }
	    };
	    PublishContext.prototype.refreshRequest = function () {
	        // Clean up before the run
	        if (this.publishRefreshTimer) {
	            clearTimeout(this.publishRefreshTimer);
	            this.publishRefreshTimer = undefined;
	        }
	        // This is Refresh request
	        this.pubRequestBody = undefined;
	        if (this.pubRequestEtag === undefined) {
	            // Request not valid
	            throw new Exceptions_1.Exceptions.MethodParameterError("Publish", "Body", undefined);
	        }
	        if (this.pubRequestExpires === 0) {
	            // Request not valid
	            throw new Exceptions_1.Exceptions.MethodParameterError("Publish", "Expire", this.pubRequestExpires);
	        }
	        this.sendPublishRequest();
	    };
	    PublishContext.prototype.sendPublishRequest = function () {
	        var reqOptions = Object.create(this.options || Object.prototype);
	        reqOptions.extraHeaders = (this.options.extraHeaders || []).slice();
	        reqOptions.extraHeaders.push("Event: " + this.event);
	        reqOptions.extraHeaders.push("Expires: " + this.pubRequestExpires);
	        if (this.pubRequestEtag !== undefined) {
	            reqOptions.extraHeaders.push("SIP-If-Match: " + this.pubRequestEtag);
	        }
	        this.request = new SIPMessage.OutgoingRequest(Constants.C.PUBLISH, this.target, this.ua, this.options.params, reqOptions.extraHeaders);
	        if (this.pubRequestBody !== undefined) {
	            this.request.body = {
	                body: this.pubRequestBody,
	                contentType: this.options.contentType
	            };
	        }
	        this.send();
	    };
	    return PublishContext;
	}(ClientContext_1.ClientContext));
	exports.PublishContext = PublishContext;
	});

	unwrapExports(PublishContext_1);
	var PublishContext_2 = PublishContext_1.PublishContext;

	var RegisterContext_1 = createCommonjsModule(function (module, exports) {
	var __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	var __assign = (commonjsGlobal && commonjsGlobal.__assign) || function () {
	    __assign = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign.apply(this, arguments);
	};
	Object.defineProperty(exports, "__esModule", { value: true });






	/**
	 * Configuration load.
	 * @private
	 * returns {any}
	 */
	function loadConfig(configuration) {
	    var settings = {
	        expires: 600,
	        extraContactHeaderParams: [],
	        instanceId: undefined,
	        params: {},
	        regId: undefined,
	        registrar: undefined,
	    };
	    var configCheck = getConfigurationCheck();
	    // Check Mandatory parameters
	    for (var parameter in configCheck.mandatory) {
	        if (!configuration.hasOwnProperty(parameter)) {
	            throw new Exceptions_1.Exceptions.ConfigurationError(parameter);
	        }
	        else {
	            var value = configuration[parameter];
	            var checkedValue = configCheck.mandatory[parameter](value);
	            if (checkedValue !== undefined) {
	                settings[parameter] = checkedValue;
	            }
	            else {
	                throw new Exceptions_1.Exceptions.ConfigurationError(parameter, value);
	            }
	        }
	    }
	    // Check Optional parameters
	    for (var parameter in configCheck.optional) {
	        if (configuration.hasOwnProperty(parameter)) {
	            var value = configuration[parameter];
	            // If the parameter value is an empty array, but shouldn't be, apply its default value.
	            if (value instanceof Array && value.length === 0) {
	                continue;
	            }
	            // If the parameter value is null, empty string, or undefined then apply its default value.
	            // If it's a number with NaN value then also apply its default value.
	            // NOTE: JS does not allow "value === NaN", the following does the work:
	            if (value === null || value === "" || value === undefined ||
	                (typeof (value) === "number" && isNaN(value))) {
	                continue;
	            }
	            var checkedValue = configCheck.optional[parameter](value);
	            if (checkedValue !== undefined) {
	                settings[parameter] = checkedValue;
	            }
	            else {
	                throw new Exceptions_1.Exceptions.ConfigurationError(parameter, value);
	            }
	        }
	    }
	    return settings;
	}
	function getConfigurationCheck() {
	    return {
	        mandatory: {},
	        optional: {
	            expires: function (expires) {
	                if (Utils_1.Utils.isDecimal(expires)) {
	                    var value = Number(expires);
	                    if (value >= 0) {
	                        return value;
	                    }
	                }
	            },
	            extraContactHeaderParams: function (extraContactHeaderParams) {
	                if (extraContactHeaderParams instanceof Array) {
	                    return extraContactHeaderParams.filter(function (contactHeaderParam) { return (typeof contactHeaderParam === "string"); });
	                }
	            },
	            instanceId: function (instanceId) {
	                if (typeof instanceId !== "string") {
	                    return;
	                }
	                if ((/^uuid:/i.test(instanceId))) {
	                    instanceId = instanceId.substr(5);
	                }
	                if (Grammar_1$1.Grammar.parse(instanceId, "uuid") === -1) {
	                    return;
	                }
	                else {
	                    return instanceId;
	                }
	            },
	            params: function (params) {
	                if (typeof params === "object") {
	                    return params;
	                }
	            },
	            regId: function (regId) {
	                if (Utils_1.Utils.isDecimal(regId)) {
	                    var value = Number(regId);
	                    if (value >= 0) {
	                        return value;
	                    }
	                }
	            },
	            registrar: function (registrar) {
	                if (typeof registrar !== "string") {
	                    return;
	                }
	                if (!/^sip:/i.test(registrar)) {
	                    registrar = Constants.C.SIP + ":" + registrar;
	                }
	                var parsed = Grammar_1$1.Grammar.URIParse(registrar);
	                if (!parsed) {
	                    return;
	                }
	                else if (parsed.user) {
	                    return;
	                }
	                else {
	                    return parsed;
	                }
	            }
	        }
	    };
	}
	var RegisterContext = /** @class */ (function (_super) {
	    __extends(RegisterContext, _super);
	    function RegisterContext(ua, options) {
	        if (options === void 0) { options = {}; }
	        var _this = this;
	        var settings = loadConfig(options);
	        if (settings.regId && !settings.instanceId) {
	            settings.instanceId = Utils_1.Utils.newUUID();
	        }
	        else if (!settings.regId && settings.instanceId) {
	            settings.regId = 1;
	        }
	        settings.params.toUri = settings.params.toUri || ua.configuration.uri;
	        settings.params.toDisplayName = settings.params.toDisplayName || ua.configuration.displayName;
	        settings.params.callId = settings.params.callId || Utils_1.Utils.createRandomToken(22);
	        settings.params.cseq = settings.params.cseq || Math.floor(Math.random() * 10000);
	        /* If no 'registrarServer' is set use the 'uri' value without user portion. */
	        if (!settings.registrar) {
	            var registrarServer = {};
	            if (typeof ua.configuration.uri === "object") {
	                registrarServer = ua.configuration.uri.clone();
	                registrarServer.user = undefined;
	            }
	            else {
	                registrarServer = ua.configuration.uri;
	            }
	            settings.registrar = registrarServer;
	        }
	        _this = _super.call(this, ua, Constants.C.REGISTER, settings.registrar, settings) || this;
	        _this.type = Enums.TypeStrings.RegisterContext;
	        _this.options = settings;
	        _this.logger = ua.getLogger("sip.registercontext");
	        _this.logger.log("configuration parameters for RegisterContext after validation:");
	        for (var parameter in settings) {
	            if (settings.hasOwnProperty(parameter)) {
	                _this.logger.log("· " + parameter + ": " + JSON.stringify(settings[parameter]));
	            }
	        }
	        // Registration expires
	        _this.expires = settings.expires;
	        // Cseq
	        _this.cseq = settings.params.cseq;
	        // Contact header
	        _this.contact = ua.contact.toString();
	        // Set status
	        _this.registered = false;
	        ua.on("transportCreated", function (transport) {
	            transport.on("disconnected", function () { return _this.onTransportDisconnected(); });
	        });
	        return _this;
	    }
	    RegisterContext.prototype.register = function (options) {
	        var _this = this;
	        if (options === void 0) { options = {}; }
	        // Handle Options
	        this.options = __assign({}, this.options, options);
	        var extraHeaders = (this.options.extraHeaders || []).slice();
	        extraHeaders.push("Contact: " + this.generateContactHeader(this.expires));
	        // this is UA.C.ALLOWED_METHODS, removed to get around circular dependency
	        extraHeaders.push("Allow: " + [
	            "ACK",
	            "CANCEL",
	            "INVITE",
	            "MESSAGE",
	            "BYE",
	            "OPTIONS",
	            "INFO",
	            "NOTIFY",
	            "REFER"
	        ].toString());
	        // Save original extraHeaders to be used in .close
	        this.closeHeaders = this.options.closeWithHeaders ?
	            (this.options.extraHeaders || []).slice() : [];
	        this.receiveResponse = function (response) {
	            // Discard responses to older REGISTER/un-REGISTER requests.
	            if (response.cseq !== _this.cseq) {
	                return;
	            }
	            // Clear registration timer
	            if (_this.registrationTimer !== undefined) {
	                clearTimeout(_this.registrationTimer);
	                _this.registrationTimer = undefined;
	            }
	            var statusCode = (response.statusCode || 0).toString();
	            switch (true) {
	                case /^1[0-9]{2}$/.test(statusCode):
	                    _this.emit("progress", response);
	                    break;
	                case /^2[0-9]{2}$/.test(statusCode):
	                    _this.emit("accepted", response);
	                    var expires = void 0;
	                    if (response.hasHeader("expires")) {
	                        expires = Number(response.getHeader("expires"));
	                    }
	                    if (_this.registrationExpiredTimer !== undefined) {
	                        clearTimeout(_this.registrationExpiredTimer);
	                        _this.registrationExpiredTimer = undefined;
	                    }
	                    // Search the Contact pointing to us and update the expires value accordingly.
	                    var contacts = response.getHeaders("contact").length;
	                    if (!contacts) {
	                        _this.logger.warn("no Contact header in response to REGISTER, response ignored");
	                        break;
	                    }
	                    var contact = void 0;
	                    while (contacts--) {
	                        contact = response.parseHeader("contact", contacts);
	                        if (contact.uri.user === _this.ua.contact.uri.user) {
	                            expires = contact.getParam("expires");
	                            break;
	                        }
	                        else {
	                            contact = undefined;
	                        }
	                    }
	                    if (!contact) {
	                        _this.logger.warn("no Contact header pointing to us, response ignored");
	                        break;
	                    }
	                    if (expires === undefined) {
	                        expires = _this.expires;
	                    }
	                    // Re-Register before the expiration interval has elapsed.
	                    // For that, decrease the expires value. ie: 3 seconds
	                    _this.registrationTimer = setTimeout(function () {
	                        _this.registrationTimer = undefined;
	                        _this.register(_this.options);
	                    }, (expires * 1000) - 3000);
	                    _this.registrationExpiredTimer = setTimeout(function () {
	                        _this.logger.warn("registration expired");
	                        if (_this.registered) {
	                            _this.unregistered(undefined, Constants.C.causes.EXPIRES);
	                        }
	                    }, expires * 1000);
	                    // Save gruu values
	                    if (contact.hasParam("temp-gruu")) {
	                        _this.ua.contact.tempGruu = Grammar_1$1.Grammar.URIParse(contact.getParam("temp-gruu").replace(/"/g, ""));
	                    }
	                    if (contact.hasParam("pub-gruu")) {
	                        _this.ua.contact.pubGruu = Grammar_1$1.Grammar.URIParse(contact.getParam("pub-gruu").replace(/"/g, ""));
	                    }
	                    _this.registered = true;
	                    _this.emit("registered", response || undefined);
	                    break;
	                // Interval too brief RFC3261 10.2.8
	                case /^423$/.test(statusCode):
	                    if (response.hasHeader("min-expires")) {
	                        // Increase our registration interval to the suggested minimum
	                        _this.expires = Number(response.getHeader("min-expires"));
	                        // Attempt the registration again immediately
	                        _this.register(_this.options);
	                    }
	                    else { // This response MUST contain a Min-Expires header field
	                        _this.logger.warn("423 response received for REGISTER without Min-Expires");
	                        _this.registrationFailure(response, Constants.C.causes.SIP_FAILURE_CODE);
	                    }
	                    break;
	                default:
	                    _this.registrationFailure(response, Utils_1.Utils.sipErrorCause(response.statusCode || 0));
	            }
	        };
	        this.onRequestTimeout = function () {
	            _this.registrationFailure(undefined, Constants.C.causes.REQUEST_TIMEOUT);
	        };
	        this.onTransportError = function () {
	            _this.registrationFailure(undefined, Constants.C.causes.CONNECTION_ERROR);
	        };
	        this.cseq++;
	        if (this.request) {
	            this.request.cseq = this.cseq;
	            this.request.setHeader("cseq", this.cseq + " REGISTER");
	            this.request.extraHeaders = extraHeaders;
	        }
	        this.send();
	    };
	    RegisterContext.prototype.close = function () {
	        var options = {
	            all: false,
	            extraHeaders: this.closeHeaders
	        };
	        this.registeredBefore = this.registered;
	        if (this.registered) {
	            this.unregister(options);
	        }
	    };
	    RegisterContext.prototype.unregister = function (options) {
	        var _this = this;
	        if (options === void 0) { options = {}; }
	        if (!this.registered && !options.all) {
	            this.logger.warn("Already unregistered, but sending an unregister anyways.");
	        }
	        var extraHeaders = (options.extraHeaders || []).slice();
	        this.registered = false;
	        // Clear the registration timer.
	        if (this.registrationTimer !== undefined) {
	            clearTimeout(this.registrationTimer);
	            this.registrationTimer = undefined;
	        }
	        if (options.all) {
	            extraHeaders.push("Contact: *");
	            extraHeaders.push("Expires: 0");
	        }
	        else {
	            extraHeaders.push("Contact: " + this.generateContactHeader(0));
	        }
	        this.receiveResponse = function (response) {
	            var statusCode = (response && response.statusCode) ? response.statusCode.toString() : "";
	            switch (true) {
	                case /^1[0-9]{2}$/.test(statusCode):
	                    _this.emit("progress", response);
	                    break;
	                case /^2[0-9]{2}$/.test(statusCode):
	                    _this.emit("accepted", response);
	                    if (_this.registrationExpiredTimer !== undefined) {
	                        clearTimeout(_this.registrationExpiredTimer);
	                        _this.registrationExpiredTimer = undefined;
	                    }
	                    _this.unregistered(response);
	                    break;
	                default:
	                    _this.unregistered(response, Utils_1.Utils.sipErrorCause(response.statusCode || 0));
	            }
	        };
	        this.onRequestTimeout = function () {
	            // Not actually unregistered...
	            // this.unregistered(undefined, SIP.C.causes.REQUEST_TIMEOUT);
	        };
	        this.cseq++;
	        if (this.request) {
	            this.request.cseq = this.cseq;
	            this.request.setHeader("cseq", this.cseq + " REGISTER");
	            this.request.extraHeaders = extraHeaders;
	        }
	        this.send();
	    };
	    RegisterContext.prototype.unregistered = function (response, cause) {
	        this.registered = false;
	        this.emit("unregistered", response || undefined, cause || undefined);
	    };
	    RegisterContext.prototype.registrationFailure = function (response, cause) {
	        this.emit("failed", response || undefined, cause || undefined);
	    };
	    RegisterContext.prototype.onTransportDisconnected = function () {
	        this.registeredBefore = this.registered;
	        if (this.registrationTimer !== undefined) {
	            clearTimeout(this.registrationTimer);
	            this.registrationTimer = undefined;
	        }
	        if (this.registrationExpiredTimer !== undefined) {
	            clearTimeout(this.registrationExpiredTimer);
	            this.registrationExpiredTimer = undefined;
	        }
	        if (this.registered) {
	            this.unregistered(undefined, Constants.C.causes.CONNECTION_ERROR);
	        }
	    };
	    /**
	     * Helper Function to generate Contact Header
	     * @private
	     * returns {String}
	     */
	    RegisterContext.prototype.generateContactHeader = function (expires) {
	        if (expires === void 0) { expires = 0; }
	        var contact = this.contact;
	        if (this.options.regId && this.options.instanceId) {
	            contact += ";reg-id=" + this.options.regId;
	            contact += ';+sip.instance="<urn:uuid:' + this.options.instanceId + '>"';
	        }
	        if (this.options.extraContactHeaderParams) {
	            this.options.extraContactHeaderParams.forEach(function (header) {
	                contact += ";" + header;
	            });
	        }
	        contact += ";expires=" + expires;
	        return contact;
	    };
	    return RegisterContext;
	}(ClientContext_1.ClientContext));
	exports.RegisterContext = RegisterContext;
	});

	unwrapExports(RegisterContext_1);
	var RegisterContext_2 = RegisterContext_1.RegisterContext;

	var SanityCheck_1 = createCommonjsModule(function (module, exports) {
	Object.defineProperty(exports, "__esModule", { value: true });



	/**
	 * Incoming SIP message sanity check.
	 * @function
	 * @param {SIP.IncomingMessage} message
	 * @param {SIP.UA} ua
	 * @param {SIP.Transport} transport
	 * @returns {Boolean}
	 */
	var SanityCheck;
	(function (SanityCheck) {
	    // Reply
	    function reply(statusCode, message, transport) {
	        var response = Utils_1.Utils.buildStatusLine(statusCode);
	        var vias = message.getHeaders("via");
	        for (var _i = 0, vias_1 = vias; _i < vias_1.length; _i++) {
	            var via = vias_1[_i];
	            response += "Via: " + via + "\r\n";
	        }
	        var to = message.getHeader("To") || "";
	        if (!message.toTag) {
	            to += ";tag=" + Utils_1.Utils.newTag();
	        }
	        response += "To: " + to + "\r\n";
	        response += "From: " + message.getHeader("From") + "\r\n";
	        response += "Call-ID: " + message.callId + "\r\n";
	        response += "CSeq: " + message.cseq + " " + message.method + "\r\n";
	        response += "\r\n";
	        transport.send(response);
	    }
	    SanityCheck.reply = reply;
	    /*
	    * Sanity Check for incoming Messages
	    *
	    * Requests:
	    *  - _rfc3261_8_2_2_1_ Receive a Request with a non supported URI scheme
	    *  - _rfc3261_16_3_4_ Receive a Request already sent by us
	    *   Does not look at via sent-by but at sipjsId, which is inserted as
	    *   a prefix in all initial requests generated by the ua
	    *  - _rfc3261_18_3_request_ Body Content-Length
	    *  - _rfc3261_8_2_2_2_ Merged Requests
	    *
	    * Responses:
	    *  - _rfc3261_8_1_3_3_ Multiple Via headers
	    *  - _rfc3261_18_1_2_ sent-by mismatch
	    *  - _rfc3261_18_3_response_ Body Content-Length
	    *
	    * All:
	    *  - Minimum headers in a SIP message
	    */
	    // Sanity Check functions for requests
	    function rfc3261_8_2_2_1(message, ua, transport) {
	        if (!message.ruri || message.ruri.scheme !== "sip") {
	            reply(416, message, transport);
	            return false;
	        }
	        return true;
	    }
	    SanityCheck.rfc3261_8_2_2_1 = rfc3261_8_2_2_1;
	    function rfc3261_16_3_4(message, ua, transport) {
	        if (!message.toTag) {
	            if (message.callId.substr(0, 5) === ua.configuration.sipjsId) {
	                reply(482, message, transport);
	                return false;
	            }
	        }
	        return true;
	    }
	    SanityCheck.rfc3261_16_3_4 = rfc3261_16_3_4;
	    function rfc3261_18_3_request(message, ua, transport) {
	        var len = Utils_1.Utils.str_utf8_length(message.body);
	        var contentLength = message.getHeader("content-length");
	        if (contentLength && len < Number(contentLength)) {
	            reply(400, message, transport);
	            return false;
	        }
	        return true;
	    }
	    SanityCheck.rfc3261_18_3_request = rfc3261_18_3_request;
	    /**
	     * 8.2.2.2 Merged Requests
	     *
	     * If the request has no tag in the To header field, the UAS core MUST
	     * check the request against ongoing transactions.  If the From tag,
	     * Call-ID, and CSeq exactly match those associated with an ongoing
	     * transaction, but the request does not match that transaction (based
	     * on the matching rules in Section 17.2.3), the UAS core SHOULD
	     * generate a 482 (Loop Detected) response and pass it to the server
	     * transaction.
	     *
	     *    The same request has arrived at the UAS more than once, following
	     *    different paths, most likely due to forking.  The UAS processes
	     *    the first such request received and responds with a 482 (Loop
	     *    Detected) to the rest of them.
	     *
	     * @param message Incoming request message.
	     * @param ua User agent.
	     * @param transport Transport.
	     */
	    function rfc3261_8_2_2_2(message, ua, transport) {
	        var fromTag = message.fromTag;
	        var callId = message.callId;
	        var cseq = message.cseq;
	        if (!message.toTag) {
	            if (message.method === Constants.C.INVITE) {
	                if (ua.transactions.ist[message.viaBranch]) {
	                    return true;
	                }
	                else {
	                    for (var idx in ua.transactions.ist) {
	                        if (ua.transactions.ist.hasOwnProperty(idx)) {
	                            var tr = ua.transactions.ist[idx];
	                            if (tr && tr.request.fromTag === fromTag && tr.request.callId === callId && tr.request.cseq === cseq) {
	                                reply(482, message, transport);
	                                return false;
	                            }
	                        }
	                    }
	                }
	            }
	            else {
	                if (ua.transactions.nist[message.viaBranch]) {
	                    return true;
	                }
	                else {
	                    for (var idx in ua.transactions.nist) {
	                        if (ua.transactions.nist.hasOwnProperty(idx)) {
	                            var tr = ua.transactions.nist[idx];
	                            if (tr && tr.request.fromTag === fromTag && tr.request.callId === callId && tr.request.cseq === cseq) {
	                                reply(482, message, transport);
	                                return false;
	                            }
	                        }
	                    }
	                }
	            }
	        }
	        return true;
	    }
	    SanityCheck.rfc3261_8_2_2_2 = rfc3261_8_2_2_2;
	    // Sanity Check functions for responses
	    function rfc3261_8_1_3_3(message, ua) {
	        if (message.getHeaders("via").length > 1) {
	            ua.getLogger("sip.sanitycheck").warn("More than one Via header field present in the response." +
	                " Dropping the response");
	            return false;
	        }
	        return true;
	    }
	    SanityCheck.rfc3261_8_1_3_3 = rfc3261_8_1_3_3;
	    function rfc3261_18_1_2(message, ua) {
	        if (message.via.host !== ua.configuration.viaHost || message.via.port !== undefined) {
	            ua.getLogger("sip.sanitycheck").warn("Via sent-by in the response does not match UA Via host value." +
	                " Dropping the response");
	            return false;
	        }
	        return true;
	    }
	    SanityCheck.rfc3261_18_1_2 = rfc3261_18_1_2;
	    function rfc3261_18_3_response(message, ua) {
	        var len = Utils_1.Utils.str_utf8_length(message.body);
	        var contentLength = message.getHeader("content-length");
	        if (contentLength && len < Number(contentLength)) {
	            ua.getLogger("sip.sanitycheck").warn("Message body length is lower than the value in" +
	                " Content-Length header field. Dropping the response");
	            return false;
	        }
	        return true;
	    }
	    SanityCheck.rfc3261_18_3_response = rfc3261_18_3_response;
	    // Sanity Check functions for requests and responses
	    function minimumHeaders(message, ua) {
	        var mandatoryHeaders = ["from", "to", "call_id", "cseq", "via"];
	        for (var _i = 0, mandatoryHeaders_1 = mandatoryHeaders; _i < mandatoryHeaders_1.length; _i++) {
	            var header = mandatoryHeaders_1[_i];
	            if (!message.hasHeader(header)) {
	                ua.getLogger("sip.sanitycheck").warn("Missing mandatory header field : " +
	                    header + ". Dropping the response");
	                return false;
	            }
	        }
	        return true;
	    }
	    SanityCheck.minimumHeaders = minimumHeaders;
	    function sanityCheck(message, ua, transport) {
	        var requests = [
	            rfc3261_8_2_2_1,
	            rfc3261_16_3_4,
	            rfc3261_18_3_request,
	            rfc3261_8_2_2_2
	        ];
	        var responses = [
	            rfc3261_8_1_3_3,
	            rfc3261_18_1_2,
	            rfc3261_18_3_response
	        ];
	        var all = [
	            minimumHeaders
	        ];
	        for (var _i = 0, all_1 = all; _i < all_1.length; _i++) {
	            var checkFunction = all_1[_i];
	            if (!checkFunction(message, ua, transport)) {
	                return false;
	            }
	        }
	        if (message.type === Enums.TypeStrings.IncomingRequest) {
	            for (var _a = 0, requests_1 = requests; _a < requests_1.length; _a++) {
	                var checkFunction = requests_1[_a];
	                if (!checkFunction(message, ua, transport)) {
	                    return false;
	                }
	            }
	        }
	        else if (message.type === Enums.TypeStrings.IncomingResponse) {
	            for (var _b = 0, responses_1 = responses; _b < responses_1.length; _b++) {
	                var checkFunction = responses_1[_b];
	                if (!checkFunction(message, ua, transport)) {
	                    return false;
	                }
	            }
	        }
	        // Everything is OK
	        return true;
	    }
	    SanityCheck.sanityCheck = sanityCheck;
	})(SanityCheck = exports.SanityCheck || (exports.SanityCheck = {}));
	});

	unwrapExports(SanityCheck_1);
	var SanityCheck_2 = SanityCheck_1.SanityCheck;

	var ServerContext_1 = createCommonjsModule(function (module, exports) {
	var __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	Object.defineProperty(exports, "__esModule", { value: true });






	var ServerContext = /** @class */ (function (_super) {
	    __extends(ServerContext, _super);
	    function ServerContext(ua, request) {
	        var _this = _super.call(this) || this;
	        _this.data = {};
	        ServerContext.initializer(_this, ua, request);
	        return _this;
	    }
	    // hack to get around our multiple inheritance issues
	    ServerContext.initializer = function (objectToConstruct, ua, request) {
	        objectToConstruct.type = Enums.TypeStrings.ServerContext;
	        objectToConstruct.ua = ua;
	        objectToConstruct.logger = ua.getLogger("sip.servercontext");
	        objectToConstruct.request = request;
	        var transport = ua.transport;
	        if (!transport) {
	            throw new Error("Transport undefined.");
	        }
	        var user = {
	            loggerFactory: ua.getLoggerFactory(),
	            onStateChange: function (newState) {
	                if (newState === Transactions.TransactionState.Terminated) {
	                    ua.destroyTransaction(objectToConstruct.transaction);
	                }
	            },
	            onTransportError: function (error) {
	                objectToConstruct.logger.error(error.message);
	                objectToConstruct.onTransportError();
	            }
	        };
	        if (request.method === Constants.C.INVITE) {
	            objectToConstruct.transaction = new Transactions.InviteServerTransaction(request, transport, user);
	        }
	        else {
	            objectToConstruct.transaction = new Transactions.NonInviteServerTransaction(request, transport, user);
	        }
	        ua.newTransaction(objectToConstruct.transaction);
	        if (request.body) {
	            objectToConstruct.body = request.body;
	        }
	        if (request.hasHeader("Content-Type")) {
	            objectToConstruct.contentType = request.getHeader("Content-Type");
	        }
	        objectToConstruct.method = request.method;
	        objectToConstruct.localIdentity = request.to;
	        objectToConstruct.remoteIdentity = request.from;
	        var hasAssertedIdentity = request.hasHeader("P-Asserted-Identity");
	        if (hasAssertedIdentity) {
	            var assertedIdentity = request.getHeader("P-Asserted-Identity");
	            if (assertedIdentity) {
	                objectToConstruct.assertedIdentity = Grammar_1$1.Grammar.nameAddrHeaderParse(assertedIdentity);
	            }
	        }
	    };
	    ServerContext.prototype.progress = function (options) {
	        if (options === void 0) { options = {}; }
	        options.statusCode = options.statusCode || 180;
	        options.minCode = 100;
	        options.maxCode = 199;
	        options.events = ["progress"];
	        return this.reply(options);
	    };
	    ServerContext.prototype.accept = function (options) {
	        if (options === void 0) { options = {}; }
	        options.statusCode = options.statusCode || 200;
	        options.minCode = 200;
	        options.maxCode = 299;
	        options.events = ["accepted"];
	        return this.reply(options);
	    };
	    ServerContext.prototype.reject = function (options) {
	        if (options === void 0) { options = {}; }
	        options.statusCode = options.statusCode || 480;
	        options.minCode = 300;
	        options.maxCode = 699;
	        options.events = ["rejected", "failed"];
	        return this.reply(options);
	    };
	    ServerContext.prototype.reply = function (options) {
	        var _this = this;
	        if (options === void 0) { options = {}; }
	        var statusCode = options.statusCode || 100;
	        var minCode = options.minCode || 100;
	        var maxCode = options.maxCode || 699;
	        var reasonPhrase = Utils_1.Utils.getReasonPhrase(statusCode, options.reasonPhrase);
	        var extraHeaders = options.extraHeaders || [];
	        var body = options.body;
	        var events = options.events || [];
	        if (statusCode < minCode || statusCode > maxCode) {
	            throw new TypeError("Invalid statusCode: " + statusCode);
	        }
	        var response = this.request.reply(statusCode, reasonPhrase, extraHeaders, body);
	        events.forEach(function (event) {
	            _this.emit(event, response, reasonPhrase);
	        });
	        return this;
	    };
	    ServerContext.prototype.onRequestTimeout = function () {
	        this.emit("failed", undefined, Constants.C.causes.REQUEST_TIMEOUT);
	    };
	    ServerContext.prototype.onTransportError = function () {
	        this.emit("failed", undefined, Constants.C.causes.CONNECTION_ERROR);
	    };
	    return ServerContext;
	}(events.EventEmitter));
	exports.ServerContext = ServerContext;
	});

	unwrapExports(ServerContext_1);
	var ServerContext_2 = ServerContext_1.ServerContext;

	var Dialogs = createCommonjsModule(function (module, exports) {
	Object.defineProperty(exports, "__esModule", { value: true });





	/*
	 * @augments SIP
	 * @class Class creating a SIP dialog. RFC 3261 12.1
	 * @param {SIP.RTCSession} owner
	 * @param {SIP.IncomingRequest|SIP.IncomingResponse} message
	 * @param {Enum} type UAC / UAS
	 * @param {Enum} state SIP.Dialog.C.STATUS_EARLY / SIP.Dialog.C.STATUS_CONFIRMED
	 */
	var Dialog = /** @class */ (function () {
	    function Dialog(owner, message, type, state) {
	        this.pracked = [];
	        this.uacPendingReply = false;
	        this.uasPendingReply = false;
	        this.type = Enums.TypeStrings.Dialog;
	        if (!message.hasHeader("contact")) {
	            throw new Error("unable to create a Dialog without Contact header field");
	        }
	        if (message.type === Enums.TypeStrings.IncomingResponse) {
	            var statusCode = message.statusCode;
	            state = (statusCode && statusCode < 200) ?
	                Enums.DialogStatus.STATUS_EARLY : Enums.DialogStatus.STATUS_CONFIRMED;
	        }
	        else {
	            // Create confirmed dialog if state is not defined
	            state = state || Enums.DialogStatus.STATUS_CONFIRMED;
	        }
	        var contact = message.parseHeader("contact");
	        // RFC 3261 12.1.1
	        if (type === "UAS" && message.type === Enums.TypeStrings.IncomingRequest) {
	            this.id = {
	                callId: message.callId,
	                localTag: message.toTag,
	                remoteTag: message.fromTag,
	                toString: function () {
	                    return message.callId + message.toTag + message.fromTag;
	                }
	            };
	            this.state = state;
	            this.remoteSeqnum = message.cseq;
	            this.localUri = (message.parseHeader("to") || {}).uri;
	            this.remoteUri = (message.parseHeader("from") || {}).uri;
	            this.remoteTarget = contact.uri;
	            this.routeSet = message.getHeaders("record-route");
	            this.inviteSeqnum = message.cseq;
	            this.localSeqnum = message.cseq;
	        }
	        else { // type is UAC, RFC 3261 12.1.2
	            this.id = {
	                callId: message.callId,
	                localTag: message.fromTag,
	                remoteTag: message.toTag,
	                toString: function () {
	                    return message.callId + message.fromTag + message.toTag;
	                }
	            };
	            this.state = state;
	            this.inviteSeqnum = message.cseq;
	            this.localSeqnum = message.cseq;
	            this.localUri = message.parseHeader("from").uri;
	            this.pracked = [];
	            this.remoteUri = message.parseHeader("to").uri;
	            this.remoteTarget = contact.uri;
	            this.routeSet = message.getHeaders("record-route").reverse();
	        }
	        this.logger = owner.ua.getLogger("sip.dialog", this.id.toString());
	        this.owner = owner;
	        owner.ua.dialogs[this.id.toString()] = this;
	        this.logger.log("new " + type + " dialog created with status " +
	            (this.state === Enums.DialogStatus.STATUS_EARLY ? "EARLY" : "CONFIRMED"));
	        owner.emit("dialog", this);
	    }
	    /**
	     * @param {SIP.IncomingMessage} message
	     * @param {Enum} UAC/UAS
	     */
	    Dialog.prototype.update = function (message, type) {
	        this.state = Enums.DialogStatus.STATUS_CONFIRMED;
	        this.logger.log("dialog " + this.id.toString() + "  changed to CONFIRMED state");
	        if (type === "UAC") {
	            // RFC 3261 13.2.2.4
	            this.routeSet = message.getHeaders("record-route").reverse();
	        }
	    };
	    Dialog.prototype.terminate = function () {
	        this.logger.log("dialog " + this.id.toString() + " deleted");
	        if (this.sessionDescriptionHandler && this.state !== Enums.DialogStatus.STATUS_CONFIRMED) {
	            // TODO: This should call .close() on the handler when implemented
	            this.sessionDescriptionHandler.close();
	        }
	        delete this.owner.ua.dialogs[this.id.toString()];
	    };
	    /**
	     * @param {String} method request method
	     * @param {Object} extraHeaders extra headers
	     * @returns {SIP.OutgoingRequest}
	     */
	    // RFC 3261 12.2.1.1
	    Dialog.prototype.createRequest = function (method, extraHeaders, body) {
	        if (extraHeaders === void 0) { extraHeaders = []; }
	        extraHeaders = extraHeaders.slice();
	        if (!this.localSeqnum) {
	            this.localSeqnum = Math.floor(Math.random() * 10000);
	        }
	        var cseq = (method === Constants.C.CANCEL || method === Constants.C.ACK) ? this.inviteSeqnum : this.localSeqnum += 1;
	        var request = new SIPMessage.OutgoingRequest(method, this.remoteTarget, this.owner.ua, {
	            cseq: cseq,
	            callId: this.id.callId,
	            fromUri: this.localUri,
	            fromTag: this.id.localTag,
	            toIri: this.remoteUri,
	            toTag: this.id.remoteTag,
	            routeSet: this.routeSet
	        }, extraHeaders, body);
	        request.dialog = this;
	        return request;
	    };
	    /**
	     * @param {SIP.IncomingRequest} request
	     * @returns {Boolean}
	     */
	    // RFC 3261 12.2.2
	    Dialog.prototype.checkInDialogRequest = function (request) {
	        var _this = this;
	        if (!this.remoteSeqnum) {
	            this.remoteSeqnum = request.cseq;
	        }
	        else if (request.cseq < this.remoteSeqnum) {
	            // Do not try to reply to an ACK request.
	            if (request.method !== Constants.C.ACK) {
	                request.reply(500);
	            }
	            return request.cseq === this.inviteSeqnum;
	        }
	        switch (request.method) {
	            // RFC3261 14.2 Modifying an Existing Session -UAS BEHAVIOR-
	            case Constants.C.INVITE:
	                if (this.uacPendingReply === true) {
	                    request.reply(491);
	                }
	                else if (this.uasPendingReply === true && request.cseq > this.remoteSeqnum) {
	                    var retryAfter = Math.floor((Math.random() * 10)) + 1;
	                    request.reply(500, undefined, ["Retry-After:" + retryAfter]);
	                    this.remoteSeqnum = request.cseq;
	                    return false;
	                }
	                else {
	                    this.uasPendingReply = true;
	                    var stateChanged_1 = function () {
	                        if (request.transaction &&
	                            (request.transaction.state === Transactions.TransactionState.Accepted ||
	                                request.transaction.state === Transactions.TransactionState.Completed ||
	                                request.transaction.state === Transactions.TransactionState.Terminated)) {
	                            request.transaction.removeListener("stateChanged", stateChanged_1);
	                            _this.uasPendingReply = false;
	                        }
	                    };
	                    if (request.transaction) {
	                        request.transaction.on("stateChanged", stateChanged_1);
	                    }
	                }
	                // RFC3261 12.2.2 Replace the dialog`s remote target URI if the request is accepted
	                if (request.hasHeader("contact") && request.transaction) {
	                    request.transaction.on("stateChanged", function () {
	                        if (request.transaction && request.transaction.state === Transactions.TransactionState.Accepted) {
	                            _this.remoteTarget = request.parseHeader("contact").uri;
	                        }
	                    });
	                }
	                break;
	            case Constants.C.NOTIFY:
	                // RFC6665 3.2 Replace the dialog`s remote target URI if the request is accepted
	                if (request.hasHeader("contact") && request.transaction) {
	                    request.transaction.on("stateChanged", function () {
	                        if (request.transaction && request.transaction.state === Transactions.TransactionState.Completed) {
	                            _this.remoteTarget = request.parseHeader("contact").uri;
	                        }
	                    });
	                }
	                break;
	        }
	        if (request.cseq > this.remoteSeqnum) {
	            this.remoteSeqnum = request.cseq;
	        }
	        return true;
	    };
	    Dialog.prototype.sendRequest = function (applicant, method, options) {
	        var _this = this;
	        if (options === void 0) { options = {}; }
	        var extraHeaders = (options.extraHeaders || []).slice();
	        var body;
	        if (options.body) {
	            if (options.body.body) {
	                body = options.body;
	            }
	            else {
	                body = {};
	                body.body = options.body;
	                if (options.contentType) {
	                    body.contentType = options.contentType;
	                }
	            }
	        }
	        var request = this.createRequest(method, extraHeaders, body);
	        var dialogSend = function (reattempt) {
	            var requestSender = new RequestSender_1.RequestSender({
	                request: request,
	                onRequestTimeout: applicant.onRequestTimeout.bind(applicant),
	                onTransportError: applicant.onTransportError.bind(applicant),
	                receiveResponse: function (response) {
	                    // RFC3261 12.2.1.2 408 or 481 is received for a request within a dialog.
	                    if (response.statusCode === 408 || response.statusCode === 481) {
	                        applicant.onDialogError(response);
	                    }
	                    else if (response.method === Constants.C.INVITE && response.statusCode === 491) {
	                        if (reattempt) {
	                            applicant.receiveResponse(response);
	                        }
	                        else {
	                            request.cseq = _this.localSeqnum += 1;
	                            setTimeout(function () {
	                                // first check is to determine !Subscription (remove circular dependency)
	                                if (_this.owner.status !== undefined &&
	                                    _this.owner.status
	                                        !== Enums.SessionStatus.STATUS_TERMINATED) {
	                                    // RFC3261 14.1 Modifying an Existing Session. UAC Behavior.
	                                    dialogSend(true);
	                                }
	                            }, 1000);
	                        }
	                    }
	                    else {
	                        applicant.receiveResponse(response);
	                    }
	                }
	            }, _this.owner.ua);
	            requestSender.send();
	            // RFC3261 14.2 Modifying an Existing Session -UAC BEHAVIOR-
	            if (!requestSender.clientTransaction) {
	                return;
	            }
	            else if (request.method === Constants.C.INVITE &&
	                requestSender.clientTransaction &&
	                requestSender.clientTransaction.state
	                    !== Transactions.TransactionState.Terminated) {
	                _this.uacPendingReply = true;
	                var stateChanged_2 = function () {
	                    var state = requestSender.clientTransaction.state;
	                    if (!requestSender.clientTransaction) {
	                        return;
	                    }
	                    else if (requestSender.clientTransaction &&
	                        (state === Transactions.TransactionState.Accepted ||
	                            state === Transactions.TransactionState.Completed ||
	                            state === Transactions.TransactionState.Terminated)) {
	                        requestSender.clientTransaction.removeListener("stateChanged", stateChanged_2);
	                        _this.uacPendingReply = false;
	                    }
	                };
	                requestSender.clientTransaction.on("stateChanged", stateChanged_2);
	            }
	        };
	        dialogSend(false);
	        return request;
	    };
	    /**
	     * @param {SIP.IncomingRequest} request
	     */
	    Dialog.prototype.receiveRequest = function (request) {
	        // Check in-dialog request
	        if (!this.checkInDialogRequest(request)) {
	            return;
	        }
	        this.owner.receiveRequest(request);
	    };
	    Dialog.C = Enums.DialogStatus;
	    return Dialog;
	}());
	exports.Dialog = Dialog;
	});

	unwrapExports(Dialogs);
	var Dialogs_1 = Dialogs.Dialog;

	var DTMF_1 = createCommonjsModule(function (module, exports) {
	var __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	Object.defineProperty(exports, "__esModule", { value: true });





	/**
	 * @class DTMF
	 * @param {SIP.Session} session
	 */
	var DTMF = /** @class */ (function (_super) {
	    __extends(DTMF, _super);
	    function DTMF(session, tone, options) {
	        if (options === void 0) { options = {}; }
	        var _this = _super.call(this) || this;
	        _this.C = {
	            MIN_DURATION: 70,
	            MAX_DURATION: 6000,
	            DEFAULT_DURATION: 100,
	            MIN_INTER_TONE_GAP: 50,
	            DEFAULT_INTER_TONE_GAP: 500
	        };
	        _this.type = Enums.TypeStrings.DTMF;
	        if (tone === undefined) {
	            throw new TypeError("Not enough arguments");
	        }
	        _this.logger = session.ua.getLogger("sip.invitecontext.dtmf", session.id);
	        _this.owner = session;
	        // Check tone type
	        if (typeof tone === "string") {
	            tone = tone.toUpperCase();
	        }
	        else if (typeof tone === "number") {
	            tone = tone.toString();
	        }
	        else {
	            throw new TypeError("Invalid tone: " + tone);
	        }
	        // Check tone value
	        if (!tone.match(/^[0-9A-D#*]$/)) {
	            throw new TypeError("Invalid tone: " + tone);
	        }
	        else {
	            _this.tone = tone;
	        }
	        var duration = options.duration;
	        var interToneGap = options.interToneGap;
	        // Check duration
	        if (duration && !Utils_1.Utils.isDecimal(duration)) {
	            throw new TypeError("Invalid tone duration: " + duration);
	        }
	        else if (!duration) {
	            duration = _this.C.DEFAULT_DURATION;
	        }
	        else if (duration < _this.C.MIN_DURATION) {
	            _this.logger.warn("'duration' value is lower than the minimum allowed, setting it to " +
	                _this.C.MIN_DURATION + " milliseconds");
	            duration = _this.C.MIN_DURATION;
	        }
	        else if (duration > _this.C.MAX_DURATION) {
	            _this.logger.warn("'duration' value is greater than the maximum allowed, setting it to " +
	                _this.C.MAX_DURATION + " milliseconds");
	            duration = _this.C.MAX_DURATION;
	        }
	        else {
	            duration = Math.abs(duration);
	        }
	        _this.duration = duration;
	        // Check interToneGap
	        if (interToneGap && !Utils_1.Utils.isDecimal(interToneGap)) {
	            throw new TypeError("Invalid interToneGap: " + interToneGap);
	        }
	        else if (!interToneGap) {
	            interToneGap = _this.C.DEFAULT_INTER_TONE_GAP;
	        }
	        else if (interToneGap < _this.C.MIN_INTER_TONE_GAP) {
	            _this.logger.warn("'interToneGap' value is lower than the minimum allowed, setting it to " +
	                _this.C.MIN_INTER_TONE_GAP + " milliseconds");
	            interToneGap = _this.C.MIN_INTER_TONE_GAP;
	        }
	        else {
	            interToneGap = Math.abs(interToneGap);
	        }
	        _this.interToneGap = interToneGap;
	        return _this;
	    }
	    DTMF.prototype.send = function (options) {
	        if (options === void 0) { options = {}; }
	        // Check RTCSession Status
	        if (this.owner.status !== Enums.SessionStatus.STATUS_CONFIRMED &&
	            this.owner.status !== Enums.SessionStatus.STATUS_WAITING_FOR_ACK) {
	            throw new Exceptions_1.Exceptions.InvalidStateError(this.owner.status);
	        }
	        // Get DTMF options
	        var extraHeaders = options.extraHeaders ? options.extraHeaders.slice() : [];
	        var body = {
	            contentType: "application/dtmf-relay",
	            body: "Signal= " + this.tone + "\r\nDuration= " + this.duration
	        };
	        if (this.owner.dialog) {
	            var request = this.owner.dialog.sendRequest(this, Constants.C.INFO, {
	                extraHeaders: extraHeaders,
	                body: body
	            });
	            this.owner.emit("dtmf", request, this);
	        }
	    };
	    DTMF.prototype.init_incoming = function (request) {
	        request.reply(200);
	        if (!this.tone || !this.duration) {
	            this.logger.warn("invalid INFO DTMF received, discarded");
	        }
	        else {
	            this.owner.emit("dtmf", request, this);
	        }
	    };
	    DTMF.prototype.receiveResponse = function (response) {
	        var statusCode = response && response.statusCode ? response.statusCode : 0;
	        switch (true) {
	            case /^1[0-9]{2}$/.test(statusCode.toString()):
	                // Ignore provisional responses.
	                break;
	            case /^2[0-9]{2}$/.test(statusCode.toString()):
	                this.emit("succeeded", {
	                    originator: "remote",
	                    response: response
	                });
	                break;
	            default:
	                var cause = Utils_1.Utils.sipErrorCause(statusCode);
	                this.emit("failed", response, cause);
	                break;
	        }
	    };
	    DTMF.prototype.onRequestTimeout = function () {
	        this.emit("failed", undefined, Constants.C.causes.REQUEST_TIMEOUT);
	        this.owner.onRequestTimeout();
	    };
	    DTMF.prototype.onTransportError = function () {
	        this.emit("failed", undefined, Constants.C.causes.CONNECTION_ERROR);
	        this.owner.onTransportError();
	    };
	    DTMF.prototype.onDialogError = function (response) {
	        this.emit("failed", response, Constants.C.causes.DIALOG_ERROR);
	        this.owner.onDialogError(response);
	    };
	    return DTMF;
	}(events.EventEmitter));
	exports.DTMF = DTMF;
	});

	unwrapExports(DTMF_1);
	var DTMF_2 = DTMF_1.DTMF;

	var Session_1 = createCommonjsModule(function (module, exports) {
	var __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	Object.defineProperty(exports, "__esModule", { value: true });














	/*
	 * @param {function returning SIP.sessionDescriptionHandler} [sessionDescriptionHandlerFactory]
	 *        (See the documentation for the sessionDescriptionHandlerFactory argument of the UA constructor.)
	 */
	var Session = /** @class */ (function (_super) {
	    __extends(Session, _super);
	    function Session(sessionDescriptionHandlerFactory) {
	        var _this = _super.call(this) || this;
	        _this.data = {};
	        _this.type = Enums.TypeStrings.Session;
	        if (!sessionDescriptionHandlerFactory) {
	            throw new Exceptions_1.Exceptions.SessionDescriptionHandlerError("A session description handler is required for the session to function");
	        }
	        _this.status = Session.C.STATUS_NULL;
	        _this.dialog = undefined;
	        _this.pendingReinvite = false;
	        _this.earlyDialogs = {};
	        _this.sessionDescriptionHandlerFactory = sessionDescriptionHandlerFactory;
	        _this.hasOffer = false;
	        _this.hasAnswer = false;
	        // Session Timers
	        _this.timers = {
	            ackTimer: undefined,
	            expiresTimer: undefined,
	            invite2xxTimer: undefined,
	            userNoAnswerTimer: undefined,
	            rel1xxTimer: undefined,
	            prackTimer: undefined
	        };
	        // Session info
	        _this.startTime = undefined;
	        _this.endTime = undefined;
	        _this.tones = undefined;
	        // Hold state
	        _this.localHold = false;
	        _this.earlySdp = undefined;
	        _this.rel100 = Constants.C.supported.UNSUPPORTED;
	        _this.originalReceiveRequest = _this.receiveRequest;
	        return _this;
	    }
	    Session.prototype.dtmf = function (tones, options) {
	        var _this = this;
	        if (options === void 0) { options = {}; }
	        // Check Session Status
	        if (this.status !== Enums.SessionStatus.STATUS_CONFIRMED && this.status !== Enums.SessionStatus.STATUS_WAITING_FOR_ACK) {
	            throw new Exceptions_1.Exceptions.InvalidStateError(this.status);
	        }
	        // Check tones
	        if (!tones || !tones.toString().match(/^[0-9A-D#*,]+$/i)) {
	            throw new TypeError("Invalid tones: " + tones);
	        }
	        var sendDTMF = function () {
	            if (_this.status === Enums.SessionStatus.STATUS_TERMINATED || !_this.tones || _this.tones.length === 0) {
	                // Stop sending DTMF
	                _this.tones = undefined;
	                return;
	            }
	            var dtmf = _this.tones.shift();
	            var timeout;
	            if (dtmf.tone === ",") {
	                timeout = 2000;
	            }
	            else {
	                dtmf.on("failed", function () { _this.tones = undefined; });
	                dtmf.send(options);
	                timeout = dtmf.duration + dtmf.interToneGap;
	            }
	            // Set timeout for the next tone
	            setTimeout(sendDTMF, timeout);
	        };
	        tones = tones.toString();
	        var dtmfType = this.ua.configuration.dtmfType;
	        if (this.sessionDescriptionHandler && dtmfType === Constants.C.dtmfType.RTP) {
	            var sent = this.sessionDescriptionHandler.sendDtmf(tones, options);
	            if (!sent) {
	                this.logger.warn("Attempt to use dtmfType 'RTP' has failed, falling back to INFO packet method");
	                dtmfType = Constants.C.dtmfType.INFO;
	            }
	        }
	        if (dtmfType === Constants.C.dtmfType.INFO) {
	            var dtmfs = [];
	            var tonesArray = tones.split("");
	            while (tonesArray.length > 0) {
	                dtmfs.push(new DTMF_1.DTMF(this, tonesArray.shift(), options));
	            }
	            if (this.tones) {
	                // Tones are already queued, just add to the queue
	                this.tones = this.tones.concat(dtmfs);
	                return this;
	            }
	            this.tones = dtmfs;
	            sendDTMF();
	        }
	        return this;
	    };
	    Session.prototype.bye = function (options) {
	        if (options === void 0) { options = {}; }
	        // Check Session Status
	        if (this.status === Enums.SessionStatus.STATUS_TERMINATED) {
	            this.logger.error("Error: Attempted to send BYE in a terminated session.");
	            return this;
	        }
	        this.logger.log("terminating Session");
	        var statusCode = options.statusCode;
	        if (statusCode && (statusCode < 200 || statusCode >= 700)) {
	            throw new TypeError("Invalid statusCode: " + statusCode);
	        }
	        options.receiveResponse = function () { };
	        return this.sendRequest(Constants.C.BYE, options).terminated();
	    };
	    Session.prototype.refer = function (target, options) {
	        if (options === void 0) { options = {}; }
	        // Check Session Status
	        if (this.status !== Enums.SessionStatus.STATUS_CONFIRMED) {
	            throw new Exceptions_1.Exceptions.InvalidStateError(this.status);
	        }
	        this.referContext = new ReferClientContext(this.ua, this, target, options);
	        this.emit("referRequested", this.referContext);
	        this.referContext.refer(options);
	        return this.referContext;
	    };
	    Session.prototype.sendRequest = function (method, options) {
	        var _this = this;
	        if (options === void 0) { options = {}; }
	        options = options || {};
	        if (!this.dialog) {
	            throw new Error("sending request without a dialog");
	        }
	        var request = new SIPMessage.OutgoingRequest(method, this.dialog.remoteTarget, this.ua, {
	            cseq: options.cseq || (this.dialog.localSeqnum += 1),
	            callId: this.dialog.id.callId,
	            fromUri: this.dialog.localUri,
	            fromTag: this.dialog.id.localTag,
	            ToUri: this.dialog.remoteUri,
	            toTag: this.dialog.id.remoteTag,
	            routeSet: this.dialog.routeSet,
	            statusCode: options.statusCode,
	            reasonPhrase: options.reasonPhrase
	        }, options.extraHeaders || [], options.body);
	        new RequestSender_1.RequestSender({
	            request: request,
	            onRequestTimeout: function () { return _this.onRequestTimeout(); },
	            onTransportError: function () { return _this.onTransportError(); },
	            receiveResponse: function (response) {
	                return (options.receiveResponse || _this.receiveNonInviteResponse.bind(_this))(response);
	            }
	        }, this.ua).send();
	        // Emit the request event
	        this.emit(method.toLowerCase(), request);
	        return this;
	    };
	    Session.prototype.close = function () {
	        if (this.status === Enums.SessionStatus.STATUS_TERMINATED) {
	            return this;
	        }
	        this.logger.log("closing INVITE session " + this.id);
	        // 1st Step. Terminate media.
	        if (this.sessionDescriptionHandler) {
	            this.sessionDescriptionHandler.close();
	        }
	        // 2nd Step. Terminate signaling.
	        // Clear session timers
	        for (var timer in this.timers) {
	            if (this.timers[timer]) {
	                clearTimeout(this.timers[timer]);
	            }
	        }
	        // Terminate dialogs
	        // Terminate confirmed dialog
	        if (this.dialog) {
	            this.dialog.terminate();
	            delete this.dialog;
	        }
	        // Terminate early dialogs
	        for (var idx in this.earlyDialogs) {
	            if (this.earlyDialogs.hasOwnProperty(idx)) {
	                this.earlyDialogs[idx].terminate();
	                delete this.earlyDialogs[idx];
	            }
	        }
	        this.status = Enums.SessionStatus.STATUS_TERMINATED;
	        if (this.ua.transport) {
	            this.ua.transport.removeListener("transportError", this.errorListener);
	        }
	        delete this.ua.sessions[this.id];
	        return this;
	    };
	    Session.prototype.createDialog = function (message, type, early) {
	        if (early === void 0) { early = false; }
	        var localTag = message[(type === "UAS") ? "toTag" : "fromTag"];
	        var remoteTag = message[(type === "UAS") ? "fromTag" : "toTag"];
	        var id = message.callId + localTag + remoteTag;
	        if (early) { // Early Dialog
	            if (this.earlyDialogs[id]) {
	                return true;
	            }
	            else {
	                var earlyDialog = new Dialogs.Dialog(this, message, type, Dialogs.Dialog.C.STATUS_EARLY);
	                // Dialog has been successfully created.
	                if (earlyDialog.error) {
	                    this.logger.error(earlyDialog.error);
	                    this.failed(message, Constants.C.causes.INTERNAL_ERROR);
	                    return false;
	                }
	                else {
	                    this.earlyDialogs[id] = earlyDialog;
	                    return true;
	                }
	            }
	        }
	        else { // Confirmed Dialog
	            // In case the dialog is in _early_ state, update it
	            var earlyDialog = this.earlyDialogs[id];
	            if (earlyDialog) {
	                earlyDialog.update(message, type);
	                this.dialog = earlyDialog;
	                delete this.earlyDialogs[id];
	                for (var idx in this.earlyDialogs) {
	                    if (this.earlyDialogs.hasOwnProperty(idx)) {
	                        this.earlyDialogs[idx].terminate();
	                        delete this.earlyDialogs[idx];
	                    }
	                }
	                return true;
	            }
	            // Otherwise, create a _confirmed_ dialog
	            var dialog = new Dialogs.Dialog(this, message, type);
	            if (dialog.error) {
	                this.logger.error(dialog.error);
	                this.failed(message, Constants.C.causes.INTERNAL_ERROR);
	                return false;
	            }
	            else {
	                this.toTag = message.toTag;
	                this.dialog = dialog;
	                return true;
	            }
	        }
	    };
	    Session.prototype.hold = function (options, modifiers) {
	        if (options === void 0) { options = {}; }
	        if (modifiers === void 0) { modifiers = []; }
	        if (this.status !== Enums.SessionStatus.STATUS_WAITING_FOR_ACK && this.status !== Enums.SessionStatus.STATUS_CONFIRMED) {
	            throw new Exceptions_1.Exceptions.InvalidStateError(this.status);
	        }
	        if (this.localHold) {
	            this.logger.log("Session is already on hold, cannot put it on hold again");
	            return;
	        }
	        options.modifiers = modifiers;
	        if (this.sessionDescriptionHandler) {
	            options.modifiers.push(this.sessionDescriptionHandler.holdModifier);
	        }
	        this.localHold = true;
	        this.sendReinvite(options);
	    };
	    Session.prototype.unhold = function (options, modifiers) {
	        if (options === void 0) { options = {}; }
	        if (modifiers === void 0) { modifiers = []; }
	        if (this.status !== Enums.SessionStatus.STATUS_WAITING_FOR_ACK && this.status !== Enums.SessionStatus.STATUS_CONFIRMED) {
	            throw new Exceptions_1.Exceptions.InvalidStateError(this.status);
	        }
	        if (!this.localHold) {
	            this.logger.log("Session is not on hold, cannot unhold it");
	            return;
	        }
	        options.modifiers = modifiers;
	        this.localHold = false;
	        this.sendReinvite(options);
	    };
	    Session.prototype.reinvite = function (options, modifiers) {
	        if (options === void 0) { options = {}; }
	        if (modifiers === void 0) { modifiers = []; }
	        options.modifiers = modifiers;
	        return this.sendReinvite(options);
	    };
	    Session.prototype.receiveRequest = function (request) {
	        switch (request.method) { // TODO: This needs a default case
	            case Constants.C.BYE:
	                request.reply(200);
	                if (this.status === Enums.SessionStatus.STATUS_CONFIRMED) {
	                    this.emit("bye", request);
	                    this.terminated(request, Constants.C.BYE);
	                }
	                break;
	            case Constants.C.INVITE:
	                if (this.status === Enums.SessionStatus.STATUS_CONFIRMED) {
	                    this.logger.log("re-INVITE received");
	                    this.receiveReinvite(request);
	                }
	                break;
	            case Constants.C.INFO:
	                if (this.status === Enums.SessionStatus.STATUS_CONFIRMED || this.status === Enums.SessionStatus.STATUS_WAITING_FOR_ACK) {
	                    if (this.onInfo) {
	                        return this.onInfo(request);
	                    }
	                    var contentType = request.getHeader("content-type");
	                    if (contentType) {
	                        if (contentType.match(/^application\/dtmf-relay/i)) {
	                            if (request.body) {
	                                var body = request.body.split("\r\n", 2);
	                                if (body.length === 2) {
	                                    var tone = void 0;
	                                    var duration = void 0;
	                                    var regTone = /^(Signal\s*?=\s*?)([0-9A-D#*]{1})(\s)?.*/;
	                                    if (regTone.test(body[0])) {
	                                        tone = body[0].replace(regTone, "$2");
	                                    }
	                                    var regDuration = /^(Duration\s?=\s?)([0-9]{1,4})(\s)?.*/;
	                                    if (regDuration.test(body[1])) {
	                                        duration = parseInt(body[1].replace(regDuration, "$2"), 10);
	                                    }
	                                    if (tone && duration) {
	                                        new DTMF_1.DTMF(this, tone, { duration: duration }).init_incoming(request);
	                                    }
	                                }
	                            }
	                        }
	                        else {
	                            request.reply(415, undefined, ["Accept: application/dtmf-relay"]);
	                        }
	                    }
	                }
	                break;
	            case Constants.C.REFER:
	                if (this.status === Enums.SessionStatus.STATUS_CONFIRMED) {
	                    this.logger.log("REFER received");
	                    this.referContext = new ReferServerContext(this.ua, request);
	                    if (this.listeners("referRequested").length) {
	                        this.emit("referRequested", this.referContext);
	                    }
	                    else {
	                        this.logger.log("No referRequested listeners, automatically accepting and following the refer");
	                        var options = { followRefer: true };
	                        if (this.passedOptions) {
	                            options.inviteOptions = this.passedOptions;
	                        }
	                        this.referContext.accept(options, this.modifiers);
	                    }
	                }
	                break;
	            case Constants.C.NOTIFY:
	                if ((this.referContext && this.referContext.type === Enums.TypeStrings.ReferClientContext) &&
	                    request.hasHeader("event") && /^refer(;.*)?$/.test(request.getHeader("event"))) {
	                    this.referContext.receiveNotify(request);
	                    return;
	                }
	                request.reply(200, "OK");
	                this.emit("notify", request);
	                break;
	        }
	    };
	    Session.prototype.terminate = function (options) {
	        // here for types and to be overridden
	        return this;
	    };
	    Session.prototype.onTransportError = function () {
	        if (this.status !== Enums.SessionStatus.STATUS_CONFIRMED && this.status !== Enums.SessionStatus.STATUS_TERMINATED) {
	            this.failed(undefined, Constants.C.causes.CONNECTION_ERROR);
	        }
	    };
	    Session.prototype.onRequestTimeout = function () {
	        if (this.status === Enums.SessionStatus.STATUS_CONFIRMED) {
	            this.terminated(undefined, Constants.C.causes.REQUEST_TIMEOUT);
	        }
	        else if (this.status !== Enums.SessionStatus.STATUS_TERMINATED) {
	            this.failed(undefined, Constants.C.causes.REQUEST_TIMEOUT);
	            this.terminated(undefined, Constants.C.causes.REQUEST_TIMEOUT);
	        }
	    };
	    Session.prototype.onDialogError = function (response) {
	        if (this.status === Enums.SessionStatus.STATUS_CONFIRMED) {
	            this.terminated(response, Constants.C.causes.DIALOG_ERROR);
	        }
	        else if (this.status !== Enums.SessionStatus.STATUS_TERMINATED) {
	            this.failed(response, Constants.C.causes.DIALOG_ERROR);
	            this.terminated(response, Constants.C.causes.DIALOG_ERROR);
	        }
	    };
	    Session.prototype.on = function (name, callback) {
	        return _super.prototype.on.call(this, name, callback);
	    };
	    // In dialog INVITE Reception
	    Session.prototype.receiveReinvite = function (request) {
	        // TODO: Should probably check state of the session
	        var _this = this;
	        this.emit("reinvite", this, request);
	        if (request.hasHeader("P-Asserted-Identity")) {
	            this.assertedIdentity = Grammar_1$1.Grammar.nameAddrHeaderParse(request.getHeader("P-Asserted-Identity"));
	        }
	        var promise;
	        if (!this.sessionDescriptionHandler) {
	            this.logger.warn("No SessionDescriptionHandler to reinvite");
	            return;
	        }
	        if (request.getHeader("Content-Length") === "0" && !request.getHeader("Content-Type")) { // Invite w/o SDP
	            promise = this.sessionDescriptionHandler.getDescription(this.sessionDescriptionHandlerOptions, this.modifiers);
	        }
	        else if (this.sessionDescriptionHandler.hasDescription(request.getHeader("Content-Type") || "")) {
	            // Invite w/ SDP
	            promise = this.sessionDescriptionHandler.setDescription(request.body, this.sessionDescriptionHandlerOptions, this.modifiers).then(this.sessionDescriptionHandler.getDescription.bind(this.sessionDescriptionHandler, this.sessionDescriptionHandlerOptions, this.modifiers));
	        }
	        else { // Bad Packet (should never get hit)
	            request.reply(415);
	            this.emit("reinviteFailed", this);
	            return;
	        }
	        this.receiveRequest = function (incRequest) {
	            if (incRequest.method === Constants.C.ACK && _this.status === Enums.SessionStatus.STATUS_WAITING_FOR_ACK) {
	                if (_this.sessionDescriptionHandler &&
	                    _this.sessionDescriptionHandler.hasDescription(incRequest.getHeader("Content-Type") || "")) {
	                    _this.hasAnswer = true;
	                    _this.sessionDescriptionHandler.setDescription(incRequest.body, _this.sessionDescriptionHandlerOptions, _this.modifiers).then(function () {
	                        clearTimeout(_this.timers.ackTimer);
	                        clearTimeout(_this.timers.invite2xxTimer);
	                        _this.status = Enums.SessionStatus.STATUS_CONFIRMED;
	                        _this.emit("confirmed", incRequest);
	                    });
	                }
	                else {
	                    clearTimeout(_this.timers.ackTimer);
	                    clearTimeout(_this.timers.invite2xxTimer);
	                    _this.status = Enums.SessionStatus.STATUS_CONFIRMED;
	                    _this.emit("confirmed", incRequest);
	                }
	            }
	            else {
	                _this.originalReceiveRequest(incRequest);
	            }
	        };
	        promise.catch(function (e) {
	            var statusCode;
	            if (e.type === Enums.TypeStrings.SessionDescriptionHandlerError) {
	                statusCode = 500;
	            }
	            else if (e.type === Enums.TypeStrings.RenegotiationError) {
	                _this.emit("renegotiationError", e);
	                _this.logger.warn(e.toString());
	                statusCode = 488;
	            }
	            else {
	                _this.logger.error(e);
	                statusCode = 488;
	            }
	            request.reply(statusCode);
	            _this.emit("reinviteFailed", _this);
	            // TODO: This could be better
	            throw e;
	        }).then(function (description) {
	            var extraHeaders = ["Contact: " + _this.contact];
	            request.reply(200, undefined, extraHeaders, description);
	            _this.status = Enums.SessionStatus.STATUS_WAITING_FOR_ACK;
	            _this.setACKTimer();
	            _this.emit("reinviteAccepted", _this);
	        });
	    };
	    Session.prototype.sendReinvite = function (options) {
	        var _this = this;
	        if (options === void 0) { options = {}; }
	        if (this.pendingReinvite) {
	            this.logger.warn("Reinvite in progress. Please wait until complete, then try again.");
	            return;
	        }
	        if (!this.sessionDescriptionHandler) {
	            this.logger.warn("No SessionDescriptionHandler, can't reinvite..");
	            return;
	        }
	        this.pendingReinvite = true;
	        options.modifiers = options.modifiers || [];
	        var extraHeaders = (options.extraHeaders || []).slice();
	        extraHeaders.push("Contact: " + this.contact);
	        // this is UA.C.ALLOWED_METHODS, removed to get around circular dependency
	        extraHeaders.push("Allow: " + [
	            "ACK",
	            "CANCEL",
	            "INVITE",
	            "MESSAGE",
	            "BYE",
	            "OPTIONS",
	            "INFO",
	            "NOTIFY",
	            "REFER"
	        ].toString());
	        this.sessionDescriptionHandler.getDescription(options.sessionDescriptionHandlerOptions, options.modifiers)
	            .then(function (description) {
	            _this.sendRequest(Constants.C.INVITE, {
	                extraHeaders: extraHeaders,
	                body: description,
	                receiveResponse: function (response) { return _this.receiveReinviteResponse(response); }
	            });
	        }).catch(function (e) {
	            if (e.type === Enums.TypeStrings.RenegotiationError) {
	                _this.pendingReinvite = false;
	                _this.emit("renegotiationError", e);
	                _this.logger.warn("Renegotiation Error");
	                _this.logger.warn(e.toString());
	                throw e;
	            }
	            _this.logger.error("sessionDescriptionHandler error");
	            _this.logger.error(e);
	            throw e;
	        });
	    };
	    // Reception of Response for in-dialog INVITE
	    Session.prototype.receiveReinviteResponse = function (response) {
	        var _this = this;
	        if (this.status === Enums.SessionStatus.STATUS_TERMINATED) {
	            this.logger.error("Received reinvite response, but in STATUS_TERMINATED");
	            // TODO: Do we need to send a SIP response?
	            return;
	        }
	        if (!this.pendingReinvite) {
	            this.logger.error("Received reinvite response, but have no pending reinvite");
	            // TODO: Do we need to send a SIP response?
	            return;
	        }
	        var statusCode = response && response.statusCode ? response.statusCode.toString() : "";
	        switch (true) {
	            case /^1[0-9]{2}$/.test(statusCode):
	                break;
	            case /^2[0-9]{2}$/.test(statusCode):
	                this.status = Enums.SessionStatus.STATUS_CONFIRMED;
	                // 17.1.1.1 - For each final response that is received at the client transaction,
	                // the client transaction sends an ACK,
	                this.emit("ack", response.ack());
	                this.pendingReinvite = false;
	                // TODO: All of these timers should move into the Transaction layer
	                clearTimeout(this.timers.invite2xxTimer);
	                if (!this.sessionDescriptionHandler ||
	                    !this.sessionDescriptionHandler.hasDescription(response.getHeader("Content-Type") || "")) {
	                    this.logger.error("2XX response received to re-invite but did not have a description");
	                    this.emit("reinviteFailed", this);
	                    this.emit("renegotiationError", new Exceptions_1.Exceptions.RenegotiationError("2XX response received to re-invite but did not have a description"));
	                    break;
	                }
	                this.sessionDescriptionHandler
	                    .setDescription(response.body, this.sessionDescriptionHandlerOptions, this.modifiers)
	                    .catch(function (e) {
	                    _this.logger.error("Could not set the description in 2XX response");
	                    _this.logger.error(e);
	                    _this.emit("reinviteFailed", _this);
	                    _this.emit("renegotiationError", e);
	                    _this.sendRequest(Constants.C.BYE, {
	                        extraHeaders: ["Reason: " + Utils_1.Utils.getReasonHeaderValue(488, "Not Acceptable Here")]
	                    });
	                    _this.terminated(undefined, Constants.C.causes.INCOMPATIBLE_SDP);
	                    throw e;
	                })
	                    .then(function () {
	                    _this.emit("reinviteAccepted", _this);
	                });
	                break;
	            default:
	                this.pendingReinvite = false;
	                this.logger.log("Received a non 1XX or 2XX response to a re-invite");
	                this.emit("reinviteFailed", this);
	                this.emit("renegotiationError", new Exceptions_1.Exceptions.RenegotiationError("Invalid response to a re-invite"));
	        }
	    };
	    Session.prototype.acceptAndTerminate = function (response, statusCode, reasonPhrase) {
	        var extraHeaders = [];
	        if (statusCode) {
	            extraHeaders.push("Reason: " + Utils_1.Utils.getReasonHeaderValue(statusCode, reasonPhrase));
	        }
	        // An error on dialog creation will fire 'failed' event
	        if (this.dialog || this.createDialog(response, "UAC")) {
	            this.emit("ack", response.ack());
	            this.sendRequest(Constants.C.BYE, { extraHeaders: extraHeaders });
	        }
	        return this;
	    };
	    /**
	     * RFC3261 13.3.1.4
	     * Response retransmissions cannot be accomplished by transaction layer
	     *  since it is destroyed when receiving the first 2xx answer
	     */
	    Session.prototype.setInvite2xxTimer = function (request, description) {
	        var _this = this;
	        var timeout = Timers.Timers.T1;
	        var invite2xxRetransmission = function () {
	            if (_this.status !== Enums.SessionStatus.STATUS_WAITING_FOR_ACK) {
	                return;
	            }
	            _this.logger.log("no ACK received, attempting to retransmit OK");
	            var extraHeaders = ["Contact: " + _this.contact];
	            request.reply(200, undefined, extraHeaders, description);
	            timeout = Math.min(timeout * 2, Timers.Timers.T2);
	            _this.timers.invite2xxTimer = setTimeout(invite2xxRetransmission, timeout);
	        };
	        this.timers.invite2xxTimer = setTimeout(invite2xxRetransmission, timeout);
	    };
	    /**
	     * RFC3261 14.2
	     * If a UAS generates a 2xx response and never receives an ACK,
	     * it SHOULD generate a BYE to terminate the dialog.
	     */
	    Session.prototype.setACKTimer = function () {
	        var _this = this;
	        this.timers.ackTimer = setTimeout(function () {
	            if (_this.status === Enums.SessionStatus.STATUS_WAITING_FOR_ACK) {
	                _this.logger.log("no ACK received for an extended period of time, terminating the call");
	                clearTimeout(_this.timers.invite2xxTimer);
	                _this.sendRequest(Constants.C.BYE);
	                _this.terminated(undefined, Constants.C.causes.NO_ACK);
	            }
	        }, Timers.Timers.TIMER_H);
	    };
	    Session.prototype.failed = function (response, cause) {
	        if (this.status === Enums.SessionStatus.STATUS_TERMINATED) {
	            return this;
	        }
	        this.emit("failed", response, cause);
	        return this;
	    };
	    Session.prototype.rejected = function (response, cause) {
	        this.emit("rejected", response, cause);
	        return this;
	    };
	    Session.prototype.canceled = function () {
	        if (this.sessionDescriptionHandler) {
	            this.sessionDescriptionHandler.close();
	        }
	        this.emit("cancel");
	        return this;
	    };
	    Session.prototype.accepted = function (response, cause) {
	        if (!(response instanceof String)) {
	            cause = Utils_1.Utils.getReasonPhrase((response && response.statusCode) || 0, cause);
	        }
	        this.startTime = new Date();
	        if (this.replacee) {
	            this.replacee.emit("replaced", this);
	            this.replacee.terminate();
	        }
	        this.emit("accepted", response, cause);
	        return this;
	    };
	    Session.prototype.terminated = function (message, cause) {
	        if (this.status === Enums.SessionStatus.STATUS_TERMINATED) {
	            return this;
	        }
	        this.endTime = new Date();
	        this.close();
	        this.emit("terminated", message, cause);
	        return this;
	    };
	    Session.prototype.connecting = function (request) {
	        this.emit("connecting", { request: request });
	        return this;
	    };
	    Session.prototype.receiveNonInviteResponse = function (response) {
	        // blank, to be overridden
	    };
	    Session.C = Enums.SessionStatus;
	    return Session;
	}(events.EventEmitter));
	exports.Session = Session;
	// tslint:disable-next-line:max-classes-per-file
	var InviteServerContext = /** @class */ (function (_super) {
	    __extends(InviteServerContext, _super);
	    function InviteServerContext(ua, request) {
	        var _this = this;
	        if (!ua.configuration.sessionDescriptionHandlerFactory) {
	            ua.logger.warn("Can't build ISC without SDH Factory");
	            throw new Error("ISC Constructor Failed");
	        }
	        _this = _super.call(this, ua.configuration.sessionDescriptionHandlerFactory) || this;
	        ServerContext_1.ServerContext.initializer(_this, ua, request);
	        _this.type = Enums.TypeStrings.InviteServerContext;
	        var contentDisp = request.parseHeader("Content-Disposition");
	        if (contentDisp && contentDisp.type === "render") {
	            _this.renderbody = request.body;
	            _this.rendertype = request.getHeader("Content-Type");
	        }
	        _this.status = Enums.SessionStatus.STATUS_INVITE_RECEIVED;
	        _this.fromTag = request.fromTag;
	        _this.id = request.callId + _this.fromTag;
	        _this.request = request;
	        _this.contact = _this.ua.contact.toString();
	        _this.receiveNonInviteResponse = function () { };
	        _this.logger = ua.getLogger("sip.inviteservercontext", _this.id);
	        // Save the session into the ua sessions collection.
	        _this.ua.sessions[_this.id] = _this;
	        // Set 100rel if necessary
	        var set100rel = function (header, relSetting) {
	            if (request.hasHeader(header) && request.getHeader(header).toLowerCase().indexOf("100rel") >= 0) {
	                _this.rel100 = relSetting;
	            }
	        };
	        set100rel("require", Constants.C.supported.REQUIRED);
	        set100rel("supported", Constants.C.supported.SUPPORTED);
	        /* Set the toTag before
	        * replying a response code that will create a dialog.
	        */
	        request.toTag = Utils_1.Utils.newTag();
	        // An error on dialog creation will fire 'failed' event
	        if (!_this.createDialog(request, "UAS", true)) {
	            request.reply(500, "Missing Contact header field");
	            return;
	        }
	        var options = { extraHeaders: ["Contact: " + _this.contact] };
	        if (_this.rel100 !== Constants.C.supported.REQUIRED) {
	            _this.progress(options);
	        }
	        _this.status = Enums.SessionStatus.STATUS_WAITING_FOR_ANSWER;
	        // Set userNoAnswerTimer
	        _this.timers.userNoAnswerTimer = setTimeout(function () {
	            request.reply(408);
	            _this.failed(request, Constants.C.causes.NO_ANSWER);
	            _this.terminated(request, Constants.C.causes.NO_ANSWER);
	        }, _this.ua.configuration.noAnswerTimeout || 60);
	        /* Set expiresTimer
	        * RFC3261 13.3.1
	        */
	        // Get the Expires header value if exists
	        if (request.hasHeader("expires")) {
	            var expires = Number(request.getHeader("expires") || 0) * 1000;
	            _this.timers.expiresTimer = setTimeout(function () {
	                if (_this.status === Enums.SessionStatus.STATUS_WAITING_FOR_ANSWER) {
	                    request.reply(487);
	                    _this.failed(request, Constants.C.causes.EXPIRES);
	                    _this.terminated(request, Constants.C.causes.EXPIRES);
	                }
	            }, expires);
	        }
	        _this.errorListener = _this.onTransportError.bind(_this);
	        if (ua.transport) {
	            ua.transport.on("transportError", _this.errorListener);
	        }
	        return _this;
	    }
	    // typing note: this was the only function using its super in ServerContext
	    // so the bottom half of this function is copied and paired down from that
	    InviteServerContext.prototype.reject = function (options) {
	        var _this = this;
	        if (options === void 0) { options = {}; }
	        // Check Session Status
	        if (this.status === Enums.SessionStatus.STATUS_TERMINATED) {
	            throw new Exceptions_1.Exceptions.InvalidStateError(this.status);
	        }
	        this.logger.log("rejecting RTCSession");
	        var statusCode = options.statusCode || 480;
	        var reasonPhrase = Utils_1.Utils.getReasonPhrase(statusCode, options.reasonPhrase);
	        var extraHeaders = options.extraHeaders || [];
	        if (statusCode < 300 || statusCode > 699) {
	            throw new TypeError("Invalid statusCode: " + statusCode);
	        }
	        var response = this.request.reply(statusCode, reasonPhrase, extraHeaders, options.body);
	        (["rejected", "failed"]).forEach(function (event) {
	            _this.emit(event, response, reasonPhrase);
	        });
	        return this.terminated();
	    };
	    // type hack for servercontext interface
	    InviteServerContext.prototype.reply = function (options) {
	        return this;
	    };
	    InviteServerContext.prototype.terminate = function (options) {
	        var _this = this;
	        if (options === void 0) { options = {}; }
	        var extraHeaders = (options.extraHeaders || []).slice();
	        if (this.status === Enums.SessionStatus.STATUS_WAITING_FOR_ACK &&
	            this.request.transaction &&
	            this.request.transaction.state !== Transactions.TransactionState.Terminated) {
	            var dialog = this.dialog;
	            this.receiveRequest = function (request) {
	                if (request.method === Constants.C.ACK) {
	                    _this.sendRequest(Constants.C.BYE, { extraHeaders: extraHeaders });
	                    if (_this.dialog) {
	                        _this.dialog.terminate();
	                    }
	                }
	            };
	            this.request.transaction.on("stateChanged", function () {
	                if (_this.request.transaction &&
	                    _this.request.transaction.state === Transactions.TransactionState.Terminated &&
	                    _this.dialog) {
	                    _this.bye();
	                    _this.dialog.terminate();
	                }
	            });
	            this.emit("bye", this.request);
	            this.terminated();
	            // Restore the dialog into 'ua' so the ACK can reach 'this' session
	            this.dialog = dialog;
	            if (this.dialog) {
	                this.ua.dialogs[this.dialog.id.toString()] = this.dialog;
	            }
	        }
	        else if (this.status === Enums.SessionStatus.STATUS_CONFIRMED) {
	            this.bye(options);
	        }
	        else {
	            this.reject(options);
	        }
	        return this;
	    };
	    // @param {Object} [options.sessionDescriptionHandlerOptions]
	    // gets passed to SIP.SessionDescriptionHandler.getDescription as options
	    InviteServerContext.prototype.progress = function (options) {
	        var _this = this;
	        if (options === void 0) { options = {}; }
	        var statusCode = options.statusCode || 180;
	        var extraHeaders = (options.extraHeaders || []).slice();
	        if (statusCode < 100 || statusCode > 199) {
	            throw new TypeError("Invalid statusCode: " + statusCode);
	        }
	        if (this.status === Enums.SessionStatus.STATUS_TERMINATED) {
	            return this;
	        }
	        var do100rel = function () {
	            var relStatusCode = options.statusCode || 183;
	            // Set status and add extra headers
	            _this.status = Enums.SessionStatus.STATUS_WAITING_FOR_PRACK;
	            extraHeaders.push("Contact: " + _this.contact);
	            extraHeaders.push("Require: 100rel");
	            extraHeaders.push("RSeq: " + Math.floor(Math.random() * 10000));
	            if (!_this.sessionDescriptionHandler) {
	                _this.logger.warn("No SessionDescriptionHandler, can't do 100rel");
	                return;
	            }
	            // Get the session description to add to preaccept with
	            _this.sessionDescriptionHandler.getDescription(options.sessionDescriptionHandlerOptions, options.modifiers)
	                .then(function (description) {
	                if (_this.status === Enums.SessionStatus.STATUS_TERMINATED) {
	                    return;
	                }
	                _this.earlySdp = description.body;
	                _this[_this.hasOffer ? "hasAnswer" : "hasOffer"] = true;
	                // Retransmit until we get a response or we time out (see prackTimer below)
	                var timeout = Timers.Timers.T1;
	                var rel1xxRetransmission = function () {
	                    _this.request.reply(relStatusCode, undefined, extraHeaders, description);
	                    timeout *= 2;
	                    _this.timers.rel1xxTimer = setTimeout(rel1xxRetransmission, timeout);
	                };
	                _this.timers.rel1xxTimer = setTimeout(rel1xxRetransmission, timeout);
	                // Timeout and reject INVITE if no response
	                _this.timers.prackTimer = setTimeout(function () {
	                    if (_this.status !== Enums.SessionStatus.STATUS_WAITING_FOR_PRACK) {
	                        return;
	                    }
	                    _this.logger.log("no PRACK received, rejecting the call");
	                    clearTimeout(_this.timers.rel1xxTimer);
	                    _this.request.reply(504);
	                    _this.terminated(undefined, Constants.C.causes.NO_PRACK);
	                }, Timers.Timers.T1 * 64);
	                // Send the initial response
	                var response = _this.request.reply(relStatusCode, options.reasonPhrase, extraHeaders, description);
	                _this.emit("progress", response, options.reasonPhrase);
	            }, function () {
	                _this.request.reply(480);
	                _this.failed(undefined, Constants.C.causes.WEBRTC_ERROR);
	                _this.terminated(undefined, Constants.C.causes.WEBRTC_ERROR);
	            });
	        }; // end do100rel
	        var normalReply = function () {
	            var response = _this.request.reply(statusCode, options.reasonPhrase, extraHeaders, options.body);
	            _this.emit("progress", response, options.reasonPhrase);
	        };
	        if (options.statusCode !== 100 &&
	            (this.rel100 === Constants.C.supported.REQUIRED ||
	                (this.rel100 === Constants.C.supported.SUPPORTED && options.rel100) ||
	                (this.rel100 === Constants.C.supported.SUPPORTED && (this.ua.configuration.rel100 === Constants.C.supported.REQUIRED)))) {
	            this.sessionDescriptionHandler = this.setupSessionDescriptionHandler();
	            this.emit("SessionDescriptionHandler-created", this.sessionDescriptionHandler);
	            if (this.sessionDescriptionHandler.hasDescription(this.request.getHeader("Content-Type") || "")) {
	                this.hasOffer = true;
	                this.sessionDescriptionHandler.setDescription(this.request.body, options.sessionDescriptionHandlerOptions, options.modifiers).then(do100rel)
	                    .catch(function (e) {
	                    _this.logger.warn("invalid description");
	                    _this.logger.warn(e);
	                    _this.failed(undefined, Constants.C.causes.WEBRTC_ERROR);
	                    _this.terminated(undefined, Constants.C.causes.WEBRTC_ERROR);
	                    throw e;
	                });
	            }
	            else {
	                do100rel();
	            }
	        }
	        else {
	            normalReply();
	        }
	        return this;
	    };
	    // @param {Object} [options.sessionDescriptionHandlerOptions] gets passed
	    // to SIP.SessionDescriptionHandler.getDescription as options
	    InviteServerContext.prototype.accept = function (options) {
	        var _this = this;
	        if (options === void 0) { options = {}; }
	        this.onInfo = options.onInfo;
	        var extraHeaders = (options.extraHeaders || []).slice();
	        var descriptionCreationSucceeded = function (description) {
	            extraHeaders.push("Contact: " + _this.contact);
	            // this is UA.C.ALLOWED_METHODS, removed to get around circular dependency
	            extraHeaders.push("Allow: " + [
	                "ACK",
	                "CANCEL",
	                "INVITE",
	                "MESSAGE",
	                "BYE",
	                "OPTIONS",
	                "INFO",
	                "NOTIFY",
	                "REFER"
	            ].toString());
	            if (!_this.hasOffer) {
	                _this.hasOffer = true;
	            }
	            else {
	                _this.hasAnswer = true;
	            }
	            var response = _this.request.reply(200, undefined, extraHeaders, description);
	            _this.status = Enums.SessionStatus.STATUS_WAITING_FOR_ACK;
	            _this.setInvite2xxTimer(_this.request, description);
	            _this.setACKTimer();
	            _this.accepted(response, Utils_1.Utils.getReasonPhrase(200));
	        };
	        var descriptionCreationFailed = function (err) {
	            if (err.type === Enums.TypeStrings.SessionDescriptionHandlerError) {
	                _this.logger.log(err.message);
	                if (err.error) {
	                    _this.logger.log(err.error);
	                }
	            }
	            _this.request.reply(480);
	            _this.failed(undefined, Constants.C.causes.WEBRTC_ERROR);
	            _this.terminated(undefined, Constants.C.causes.WEBRTC_ERROR);
	            throw err;
	        };
	        // Check Session Status
	        if (this.status === Enums.SessionStatus.STATUS_WAITING_FOR_PRACK) {
	            this.status = Enums.SessionStatus.STATUS_ANSWERED_WAITING_FOR_PRACK;
	            return this;
	        }
	        else if (this.status === Enums.SessionStatus.STATUS_WAITING_FOR_ANSWER) {
	            this.status = Enums.SessionStatus.STATUS_ANSWERED;
	        }
	        else if (this.status !== Enums.SessionStatus.STATUS_EARLY_MEDIA) {
	            throw new Exceptions_1.Exceptions.InvalidStateError(this.status);
	        }
	        // An error on dialog creation will fire 'failed' event
	        if (!this.createDialog(this.request, "UAS")) {
	            this.request.reply(500, "Missing Contact header field");
	            return this;
	        }
	        clearTimeout(this.timers.userNoAnswerTimer);
	        if (this.status === Enums.SessionStatus.STATUS_EARLY_MEDIA) {
	            descriptionCreationSucceeded({});
	        }
	        else {
	            this.sessionDescriptionHandler = this.setupSessionDescriptionHandler();
	            this.emit("SessionDescriptionHandler-created", this.sessionDescriptionHandler);
	            if (this.request.getHeader("Content-Length") === "0" && !this.request.getHeader("Content-Type")) {
	                this.sessionDescriptionHandler.getDescription(options.sessionDescriptionHandlerOptions, options.modifiers)
	                    .catch(descriptionCreationFailed)
	                    .then(descriptionCreationSucceeded);
	            }
	            else if (this.sessionDescriptionHandler.hasDescription(this.request.getHeader("Content-Type") || "")) {
	                this.hasOffer = true;
	                this.sessionDescriptionHandler.setDescription(this.request.body, options.sessionDescriptionHandlerOptions, options.modifiers).then(function () {
	                    if (!_this.sessionDescriptionHandler) {
	                        throw new Error("No SDH");
	                    }
	                    return _this.sessionDescriptionHandler.getDescription(options.sessionDescriptionHandlerOptions, options.modifiers);
	                })
	                    .catch(descriptionCreationFailed)
	                    .then(descriptionCreationSucceeded);
	            }
	            else {
	                this.request.reply(415);
	                // TODO: Events
	                return this;
	            }
	        }
	        return this;
	    };
	    // ISC RECEIVE REQUEST
	    InviteServerContext.prototype.receiveRequest = function (request) {
	        var _this = this;
	        var confirmSession = function () {
	            clearTimeout(_this.timers.ackTimer);
	            clearTimeout(_this.timers.invite2xxTimer);
	            _this.status = Enums.SessionStatus.STATUS_CONFIRMED;
	            var contentDisp = request.getHeader("Content-Disposition");
	            if (contentDisp && contentDisp.type === "render") {
	                _this.renderbody = request.body;
	                _this.rendertype = request.getHeader("Content-Type");
	            }
	            _this.emit("confirmed", request);
	        };
	        switch (request.method) {
	            case Constants.C.CANCEL:
	                /* RFC3261 15 States that a UAS may have accepted an invitation while a CANCEL
	                * was in progress and that the UAC MAY continue with the session established by
	                * any 2xx response, or MAY terminate with BYE. SIP does continue with the
	                * established session. So the CANCEL is processed only if the session is not yet
	                * established.
	                */
	                /*
	                * Terminate the whole session in case the user didn't accept (or yet to send the answer) nor reject the
	                *request opening the session.
	                */
	                if (this.status === Enums.SessionStatus.STATUS_WAITING_FOR_ANSWER ||
	                    this.status === Enums.SessionStatus.STATUS_WAITING_FOR_PRACK ||
	                    this.status === Enums.SessionStatus.STATUS_ANSWERED_WAITING_FOR_PRACK ||
	                    this.status === Enums.SessionStatus.STATUS_EARLY_MEDIA ||
	                    this.status === Enums.SessionStatus.STATUS_ANSWERED) {
	                    this.status = Enums.SessionStatus.STATUS_CANCELED;
	                    this.request.reply(487);
	                    this.canceled();
	                    this.rejected(request, Constants.C.causes.CANCELED);
	                    this.failed(request, Constants.C.causes.CANCELED);
	                    this.terminated(request, Constants.C.causes.CANCELED);
	                }
	                break;
	            case Constants.C.ACK:
	                if (this.status === Enums.SessionStatus.STATUS_WAITING_FOR_ACK) {
	                    this.status = Enums.SessionStatus.STATUS_CONFIRMED;
	                    if (this.sessionDescriptionHandler &&
	                        this.sessionDescriptionHandler.hasDescription(request.getHeader("Content-Type") || "")) {
	                        // ACK contains answer to an INVITE w/o SDP negotiation
	                        this.hasAnswer = true;
	                        this.sessionDescriptionHandler.setDescription(request.body, this.sessionDescriptionHandlerOptions, this.modifiers).catch(function (e) {
	                            _this.logger.warn(e);
	                            _this.terminate({
	                                statusCode: "488",
	                                reasonPhrase: "Bad Media Description"
	                            });
	                            _this.failed(request, Constants.C.causes.BAD_MEDIA_DESCRIPTION);
	                            _this.terminated(request, Constants.C.causes.BAD_MEDIA_DESCRIPTION);
	                            throw e;
	                        }).then(function () { return confirmSession(); });
	                    }
	                    else {
	                        confirmSession();
	                    }
	                }
	                break;
	            case Constants.C.PRACK:
	                if (this.status === Enums.SessionStatus.STATUS_WAITING_FOR_PRACK ||
	                    this.status === Enums.SessionStatus.STATUS_ANSWERED_WAITING_FOR_PRACK) {
	                    if (!this.hasAnswer) {
	                        this.sessionDescriptionHandler = this.setupSessionDescriptionHandler();
	                        this.emit("SessionDescriptionHandler-created", this.sessionDescriptionHandler);
	                        if (this.sessionDescriptionHandler.hasDescription(request.getHeader("Content-Type") || "")) {
	                            this.hasAnswer = true;
	                            this.sessionDescriptionHandler.setDescription(request.body, this.sessionDescriptionHandlerOptions, this.modifiers).then(function () {
	                                clearTimeout(_this.timers.rel1xxTimer);
	                                clearTimeout(_this.timers.prackTimer);
	                                request.reply(200);
	                                if (_this.status === Enums.SessionStatus.STATUS_ANSWERED_WAITING_FOR_PRACK) {
	                                    _this.status = Enums.SessionStatus.STATUS_EARLY_MEDIA;
	                                    _this.accept();
	                                }
	                                _this.status = Enums.SessionStatus.STATUS_EARLY_MEDIA;
	                            }, function (e) {
	                                _this.logger.warn(e);
	                                _this.terminate({
	                                    statusCode: "488",
	                                    reasonPhrase: "Bad Media Description"
	                                });
	                                _this.failed(request, Constants.C.causes.BAD_MEDIA_DESCRIPTION);
	                                _this.terminated(request, Constants.C.causes.BAD_MEDIA_DESCRIPTION);
	                            });
	                        }
	                        else {
	                            this.terminate({
	                                statusCode: "488",
	                                reasonPhrase: "Bad Media Description"
	                            });
	                            this.failed(request, Constants.C.causes.BAD_MEDIA_DESCRIPTION);
	                            this.terminated(request, Constants.C.causes.BAD_MEDIA_DESCRIPTION);
	                        }
	                    }
	                    else {
	                        clearTimeout(this.timers.rel1xxTimer);
	                        clearTimeout(this.timers.prackTimer);
	                        request.reply(200);
	                        if (this.status === Enums.SessionStatus.STATUS_ANSWERED_WAITING_FOR_PRACK) {
	                            this.status = Enums.SessionStatus.STATUS_EARLY_MEDIA;
	                            this.accept();
	                        }
	                        this.status = Enums.SessionStatus.STATUS_EARLY_MEDIA;
	                    }
	                }
	                else if (this.status === Enums.SessionStatus.STATUS_EARLY_MEDIA) {
	                    request.reply(200);
	                }
	                break;
	            default:
	                Session.prototype.receiveRequest.apply(this, [request]);
	                break;
	        }
	    };
	    // Internal Function to setup the handler consistently
	    InviteServerContext.prototype.setupSessionDescriptionHandler = function () {
	        if (this.sessionDescriptionHandler) {
	            return this.sessionDescriptionHandler;
	        }
	        return this.sessionDescriptionHandlerFactory(this, this.ua.configuration.sessionDescriptionHandlerFactoryOptions);
	    };
	    return InviteServerContext;
	}(Session));
	exports.InviteServerContext = InviteServerContext;
	// tslint:disable-next-line:max-classes-per-file
	var InviteClientContext = /** @class */ (function (_super) {
	    __extends(InviteClientContext, _super);
	    function InviteClientContext(ua, target, options, modifiers) {
	        if (options === void 0) { options = {}; }
	        if (modifiers === void 0) { modifiers = []; }
	        var _this = this;
	        if (!ua.configuration.sessionDescriptionHandlerFactory) {
	            ua.logger.warn("Can't build ISC without SDH Factory");
	            throw new Error("ICC Constructor Failed");
	        }
	        options.params = options.params || {};
	        var anonymous = options.anonymous || false;
	        var fromTag = Utils_1.Utils.newTag();
	        options.params.fromTag = fromTag;
	        /* Do not add ;ob in initial forming dialog requests if the registration over
	        *  the current connection got a GRUU URI.
	        */
	        var contact = ua.contact.toString({
	            anonymous: anonymous,
	            outbound: anonymous ? !ua.contact.tempGruu : !ua.contact.pubGruu
	        });
	        var extraHeaders = (options.extraHeaders || []).slice();
	        if (anonymous && ua.configuration.uri) {
	            options.params.from_displayName = "Anonymous";
	            options.params.from_uri = "sip:anonymous@anonymous.invalid";
	            extraHeaders.push("P-Preferred-Identity: " + ua.configuration.uri.toString());
	            extraHeaders.push("Privacy: id");
	        }
	        extraHeaders.push("Contact: " + contact);
	        // this is UA.C.ALLOWED_METHODS, removed to get around circular dependency
	        extraHeaders.push("Allow: " + [
	            "ACK",
	            "CANCEL",
	            "INVITE",
	            "MESSAGE",
	            "BYE",
	            "OPTIONS",
	            "INFO",
	            "NOTIFY",
	            "REFER"
	        ].toString());
	        if (ua.configuration.rel100 === Constants.C.supported.REQUIRED) {
	            extraHeaders.push("Require: 100rel");
	        }
	        if (ua.configuration.replaces === Constants.C.supported.REQUIRED) {
	            extraHeaders.push("Require: replaces");
	        }
	        options.extraHeaders = extraHeaders;
	        _this = _super.call(this, ua.configuration.sessionDescriptionHandlerFactory) || this;
	        ClientContext_1.ClientContext.initializer(_this, ua, Constants.C.INVITE, target, options);
	        _this.type = Enums.TypeStrings.InviteClientContext;
	        _this.passedOptions = options; // Save for later to use with refer
	        _this.sessionDescriptionHandlerOptions = options.sessionDescriptionHandlerOptions || {};
	        _this.modifiers = modifiers;
	        _this.inviteWithoutSdp = options.inviteWithoutSdp || false;
	        // Set anonymous property
	        _this.anonymous = options.anonymous || false;
	        // Custom data to be sent either in INVITE or in ACK
	        _this.renderbody = options.renderbody || undefined;
	        _this.rendertype = options.rendertype || "text/plain";
	        // Session parameter initialization
	        _this.fromTag = fromTag;
	        _this.contact = contact;
	        // Check Session Status
	        if (_this.status !== Enums.SessionStatus.STATUS_NULL) {
	            throw new Exceptions_1.Exceptions.InvalidStateError(_this.status);
	        }
	        // OutgoingSession specific parameters
	        _this.isCanceled = false;
	        _this.received100 = false;
	        _this.method = Constants.C.INVITE;
	        _this.logger = ua.getLogger("sip.inviteclientcontext");
	        ua.applicants[_this.toString()] = _this;
	        _this.id = _this.request.callId + _this.fromTag;
	        _this.onInfo = options.onInfo;
	        _this.errorListener = _this.onTransportError.bind(_this);
	        if (ua.transport) {
	            ua.transport.on("transportError", _this.errorListener);
	        }
	        return _this;
	    }
	    InviteClientContext.prototype.receiveNonInviteResponse = function (response) {
	        this.receiveInviteResponse(response);
	    };
	    InviteClientContext.prototype.receiveResponse = function (response) {
	        this.receiveInviteResponse(response);
	    };
	    // hack for getting around ClientContext interface
	    InviteClientContext.prototype.send = function () {
	        var sender = new RequestSender_1.RequestSender(this, this.ua);
	        sender.send();
	        return this;
	    };
	    InviteClientContext.prototype.invite = function () {
	        var _this = this;
	        // Save the session into the ua sessions collection.
	        // Note: placing in constructor breaks call to request.cancel on close... User does not need this anyway
	        this.ua.sessions[this.id] = this;
	        // This should allow the function to return so that listeners can be set up for these events
	        Promise.resolve().then(function () {
	            if (_this.inviteWithoutSdp) {
	                // just send an invite with no sdp...
	                _this.request.body = _this.renderbody;
	                _this.status = Enums.SessionStatus.STATUS_INVITE_SENT;
	                _this.send();
	            }
	            else {
	                // Initialize Media Session
	                _this.sessionDescriptionHandler = _this.sessionDescriptionHandlerFactory(_this, _this.ua.configuration.sessionDescriptionHandlerFactoryOptions || {});
	                _this.emit("SessionDescriptionHandler-created", _this.sessionDescriptionHandler);
	                _this.sessionDescriptionHandler.getDescription(_this.sessionDescriptionHandlerOptions, _this.modifiers)
	                    .then(function (description) {
	                    if (_this.isCanceled || _this.status === Enums.SessionStatus.STATUS_TERMINATED) {
	                        return;
	                    }
	                    _this.hasOffer = true;
	                    _this.request.body = description;
	                    _this.status = Enums.SessionStatus.STATUS_INVITE_SENT;
	                    _this.send();
	                }, function (err) {
	                    if (err.type === Enums.TypeStrings.SessionDescriptionHandlerError) {
	                        _this.logger.log(err.message);
	                        if (err.error) {
	                            _this.logger.log(err.error);
	                        }
	                    }
	                    if (_this.status === Enums.SessionStatus.STATUS_TERMINATED) {
	                        return;
	                    }
	                    _this.failed(undefined, Constants.C.causes.WEBRTC_ERROR);
	                    _this.terminated(undefined, Constants.C.causes.WEBRTC_ERROR);
	                });
	            }
	        });
	        return this;
	    };
	    InviteClientContext.prototype.receiveInviteResponse = function (response) {
	        var _this = this;
	        if (this.status === Enums.SessionStatus.STATUS_TERMINATED || response.method !== Constants.C.INVITE) {
	            return;
	        }
	        var id = response.callId + response.fromTag + response.toTag;
	        var extraHeaders = [];
	        if (this.dialog && (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299)) {
	            if (id !== this.dialog.id.toString()) {
	                if (!this.createDialog(response, "UAC", true)) {
	                    return;
	                }
	                this.emit("ack", response.ack({ body: Utils_1.Utils.generateFakeSDP(response.body) }));
	                this.earlyDialogs[id].sendRequest(this, Constants.C.BYE);
	                /* NOTE: This fails because the forking proxy does not recognize that an unanswerable
	                 * leg (due to peerConnection limitations) has been answered first. If your forking
	                 * proxy does not hang up all unanswered branches on the first branch answered, remove this.
	                 */
	                if (this.status !== Enums.SessionStatus.STATUS_CONFIRMED) {
	                    this.failed(response, Constants.C.causes.WEBRTC_ERROR);
	                    this.terminated(response, Constants.C.causes.WEBRTC_ERROR);
	                }
	                return;
	            }
	            else if (this.status === Enums.SessionStatus.STATUS_CONFIRMED) {
	                this.emit("ack", response.ack(response));
	                return;
	            }
	            else if (!this.hasAnswer) {
	                // invite w/o sdp is waiting for callback
	                // an invite with sdp must go on, and hasAnswer is true
	                return;
	            }
	        }
	        var statusCode = response && response.statusCode;
	        if (this.dialog && statusCode && statusCode < 200) {
	            /*
	              Early media has been set up with at least one other different branch,
	              but a final 2xx response hasn't been received
	            */
	            var rseq = response.getHeader("rseq");
	            if (rseq && (this.dialog.pracked.indexOf(rseq) !== -1 ||
	                (Number(this.dialog.pracked[this.dialog.pracked.length - 1]) >= Number(rseq) &&
	                    this.dialog.pracked.length > 0))) {
	                return;
	            }
	            if (!this.earlyDialogs[id] && !this.createDialog(response, "UAC", true)) {
	                return;
	            }
	            if (this.earlyDialogs[id].pracked.indexOf(response.getHeader("rseq")) !== -1 ||
	                (this.earlyDialogs[id].pracked[this.earlyDialogs[id].pracked.length - 1] >= Number(rseq) &&
	                    this.earlyDialogs[id].pracked.length > 0)) {
	                return;
	            }
	            extraHeaders.push("RAck: " + response.getHeader("rseq") + " " + response.getHeader("cseq"));
	            this.earlyDialogs[id].pracked.push(response.getHeader("rseq"));
	            this.earlyDialogs[id].sendRequest(this, Constants.C.PRACK, {
	                extraHeaders: extraHeaders,
	                body: Utils_1.Utils.generateFakeSDP(response.body)
	            });
	            return;
	        }
	        // Proceed to cancellation if the user requested.
	        if (this.isCanceled) {
	            if (statusCode && statusCode >= 100 && statusCode < 200) {
	                this.request.cancel(this.cancelReason, extraHeaders);
	                this.canceled();
	            }
	            else if (statusCode && statusCode >= 200 && statusCode < 299) {
	                this.acceptAndTerminate(response);
	                this.emit("bye", this.request);
	            }
	            else if (statusCode && statusCode >= 300) {
	                var cause = Constants.C.REASON_PHRASE[response.statusCode || 0] || Constants.C.causes.CANCELED;
	                this.rejected(response, cause);
	                this.failed(response, cause);
	                this.terminated(response, cause);
	            }
	            return;
	        }
	        var codeString = statusCode ? statusCode.toString() : "";
	        switch (true) {
	            case /^100$/.test(codeString):
	                this.received100 = true;
	                this.emit("progress", response);
	                break;
	            case (/^1[0-9]{2}$/.test(codeString)):
	                // Do nothing with 1xx responses without To tag.
	                if (!response.toTag) {
	                    this.logger.warn("1xx response received without to tag");
	                    break;
	                }
	                // Create Early Dialog if 1XX comes with contact
	                if (response.hasHeader("contact")) {
	                    // An error on dialog creation will fire 'failed' event
	                    if (!this.createDialog(response, "UAC", true)) {
	                        break;
	                    }
	                }
	                this.status = Enums.SessionStatus.STATUS_1XX_RECEIVED;
	                if (response.hasHeader("P-Asserted-Identity")) {
	                    this.assertedIdentity = Grammar_1$1.Grammar.nameAddrHeaderParse(response.getHeader("P-Asserted-Identity"));
	                }
	                if (response.hasHeader("require") &&
	                    response.getHeader("require").indexOf("100rel") !== -1) {
	                    // Do nothing if this.dialog is already confirmed
	                    if (this.dialog || !this.earlyDialogs[id]) {
	                        break;
	                    }
	                    var rseq_1 = response.getHeader("rseq");
	                    if (this.earlyDialogs[id].pracked.indexOf(rseq_1) !== -1 ||
	                        (this.earlyDialogs[id].pracked[this.earlyDialogs[id].pracked.length - 1] >= Number(rseq_1) &&
	                            this.earlyDialogs[id].pracked.length > 0)) {
	                        return;
	                    }
	                    // TODO: This may be broken. It may have to be on the early dialog
	                    this.sessionDescriptionHandler = this.sessionDescriptionHandlerFactory(this, this.ua.configuration.sessionDescriptionHandlerFactoryOptions || {});
	                    this.emit("SessionDescriptionHandler-created", this.sessionDescriptionHandler);
	                    if (!this.sessionDescriptionHandler.hasDescription(response.getHeader("Content-Type") || "")) {
	                        extraHeaders.push("RAck: " + response.getHeader("rseq") + " " + response.getHeader("cseq"));
	                        this.earlyDialogs[id].pracked.push(response.getHeader("rseq"));
	                        this.earlyDialogs[id].sendRequest(this, Constants.C.PRACK, {
	                            extraHeaders: extraHeaders
	                        });
	                        this.emit("progress", response);
	                    }
	                    else if (this.hasOffer) {
	                        if (!this.createDialog(response, "UAC")) {
	                            break;
	                        }
	                        this.hasAnswer = true;
	                        if (this.dialog !== undefined && rseq_1) {
	                            this.dialog.pracked.push(rseq_1);
	                        }
	                        this.sessionDescriptionHandler.setDescription(response.body, this.sessionDescriptionHandlerOptions, this.modifiers).then(function () {
	                            extraHeaders.push("RAck: " + response.getHeader("rseq") + " " + response.getHeader("cseq"));
	                            _this.sendRequest(Constants.C.PRACK, {
	                                extraHeaders: extraHeaders,
	                                // tslint:disable-next-line:no-empty
	                                receiveResponse: function () { }
	                            });
	                            _this.status = Enums.SessionStatus.STATUS_EARLY_MEDIA;
	                            _this.emit("progress", response);
	                        }, function (e) {
	                            _this.logger.warn(e);
	                            _this.acceptAndTerminate(response, 488, "Not Acceptable Here");
	                            _this.failed(response, Constants.C.causes.BAD_MEDIA_DESCRIPTION);
	                        });
	                    }
	                    else {
	                        var earlyDialog_1 = this.earlyDialogs[id];
	                        earlyDialog_1.sessionDescriptionHandler = this.sessionDescriptionHandlerFactory(this, this.ua.configuration.sessionDescriptionHandlerFactoryOptions || {});
	                        this.emit("SessionDescriptionHandler-created", earlyDialog_1.sessionDescriptionHandler);
	                        if (rseq_1) {
	                            earlyDialog_1.pracked.push(rseq_1);
	                        }
	                        if (earlyDialog_1.sessionDescriptionHandler) {
	                            earlyDialog_1.sessionDescriptionHandler.setDescription(response.body, this.sessionDescriptionHandlerOptions, this.modifiers).then(function () { return earlyDialog_1.sessionDescriptionHandler.getDescription(_this.sessionDescriptionHandlerOptions, _this.modifiers); }).then(function (description) {
	                                extraHeaders.push("RAck: " + rseq_1 + " " + response.getHeader("cseq"));
	                                earlyDialog_1.sendRequest(_this, Constants.C.PRACK, {
	                                    extraHeaders: extraHeaders,
	                                    body: description
	                                });
	                                _this.status = Enums.SessionStatus.STATUS_EARLY_MEDIA;
	                                _this.emit("progress", response);
	                            }).catch(function (e) {
	                                // TODO: This is a bit wonky
	                                if (rseq_1 && e.type === Enums.TypeStrings.SessionDescriptionHandlerError) {
	                                    earlyDialog_1.pracked.push(rseq_1);
	                                    if (_this.status === Enums.SessionStatus.STATUS_TERMINATED) {
	                                        return;
	                                    }
	                                    _this.failed(undefined, Constants.C.causes.WEBRTC_ERROR);
	                                    _this.terminated(undefined, Constants.C.causes.WEBRTC_ERROR);
	                                }
	                                else {
	                                    if (rseq_1) {
	                                        earlyDialog_1.pracked.splice(earlyDialog_1.pracked.indexOf(rseq_1), 1);
	                                    }
	                                    // Could not set remote description
	                                    _this.logger.warn("invalid description");
	                                    _this.logger.warn(e);
	                                }
	                                // FIXME: DON'T EAT UNHANDLED ERRORS!
	                            });
	                        }
	                    }
	                }
	                else {
	                    this.emit("progress", response);
	                }
	                break;
	            case /^2[0-9]{2}$/.test(codeString):
	                var cseq = this.request.cseq + " " + this.request.method;
	                if (cseq !== response.getHeader("cseq")) {
	                    break;
	                }
	                if (response.hasHeader("P-Asserted-Identity")) {
	                    this.assertedIdentity = Grammar_1$1.Grammar.nameAddrHeaderParse(response.getHeader("P-Asserted-Identity"));
	                }
	                if (this.status === Enums.SessionStatus.STATUS_EARLY_MEDIA && this.dialog) {
	                    this.status = Enums.SessionStatus.STATUS_CONFIRMED;
	                    var options = {};
	                    if (this.renderbody) {
	                        extraHeaders.push("Content-Type: " + this.rendertype);
	                        options.extraHeaders = extraHeaders;
	                        options.body = this.renderbody;
	                    }
	                    this.emit("ack", response.ack(options));
	                    this.accepted(response);
	                    break;
	                }
	                // Do nothing if this.dialog is already confirmed
	                if (this.dialog) {
	                    break;
	                }
	                // This is an invite without sdp
	                if (!this.hasOffer) {
	                    if (this.earlyDialogs[id] && this.earlyDialogs[id].sessionDescriptionHandler) {
	                        // REVISIT
	                        this.hasOffer = true;
	                        this.hasAnswer = true;
	                        this.sessionDescriptionHandler = this.earlyDialogs[id].sessionDescriptionHandler;
	                        if (!this.createDialog(response, "UAC")) {
	                            break;
	                        }
	                        this.status = Enums.SessionStatus.STATUS_CONFIRMED;
	                        this.emit("ack", response.ack());
	                        this.accepted(response);
	                    }
	                    else {
	                        this.sessionDescriptionHandler = this.sessionDescriptionHandlerFactory(this, this.ua.configuration.sessionDescriptionHandlerFactoryOptions || {});
	                        this.emit("SessionDescriptionHandler-created", this.sessionDescriptionHandler);
	                        if (!this.sessionDescriptionHandler.hasDescription(response.getHeader("Content-Type") || "")) {
	                            this.acceptAndTerminate(response, 400, "Missing session description");
	                            this.failed(response, Constants.C.causes.BAD_MEDIA_DESCRIPTION);
	                            break;
	                        }
	                        if (!this.createDialog(response, "UAC")) {
	                            break;
	                        }
	                        this.hasOffer = true;
	                        this.sessionDescriptionHandler.setDescription(response.body, this.sessionDescriptionHandlerOptions, this.modifiers).then(function () { return _this.sessionDescriptionHandler.getDescription(_this.sessionDescriptionHandlerOptions, _this.modifiers); }).then(function (description) {
	                            if (_this.isCanceled || _this.status === Enums.SessionStatus.STATUS_TERMINATED) {
	                                return;
	                            }
	                            _this.status = Enums.SessionStatus.STATUS_CONFIRMED;
	                            _this.hasAnswer = true;
	                            _this.emit("ack", response.ack({ body: description }));
	                            _this.accepted(response);
	                        }).catch(function (e) {
	                            if (e.type === Enums.TypeStrings.SessionDescriptionHandlerError) {
	                                _this.logger.warn("invalid description");
	                                _this.logger.warn(e.toString());
	                                // TODO: This message is inconsistent
	                                _this.acceptAndTerminate(response, 488, "Invalid session description");
	                                _this.failed(response, Constants.C.causes.BAD_MEDIA_DESCRIPTION);
	                            }
	                            else {
	                                throw e;
	                            }
	                        });
	                    }
	                }
	                else if (this.hasAnswer) {
	                    var options = {};
	                    if (this.renderbody) {
	                        extraHeaders.push("Content-Type: " + this.rendertype);
	                        options.extraHeaders = extraHeaders;
	                        options.body = this.renderbody;
	                    }
	                    this.emit("ack", response.ack(options));
	                }
	                else {
	                    if (!this.sessionDescriptionHandler ||
	                        !this.sessionDescriptionHandler.hasDescription(response.getHeader("Content-Type") || "")) {
	                        this.acceptAndTerminate(response, 400, "Missing session description");
	                        this.failed(response, Constants.C.causes.BAD_MEDIA_DESCRIPTION);
	                        break;
	                    }
	                    if (!this.createDialog(response, "UAC")) {
	                        break;
	                    }
	                    this.hasAnswer = true;
	                    this.sessionDescriptionHandler.setDescription(response.body, this.sessionDescriptionHandlerOptions, this.modifiers).then(function () {
	                        var options = {};
	                        _this.status = Enums.SessionStatus.STATUS_CONFIRMED;
	                        if (_this.renderbody) {
	                            extraHeaders.push("Content-Type: " + _this.rendertype);
	                            options.extraHeaders = extraHeaders;
	                            options.body = _this.renderbody;
	                        }
	                        _this.emit("ack", response.ack(options));
	                        _this.accepted(response);
	                    }, function (e) {
	                        _this.logger.warn(e);
	                        _this.acceptAndTerminate(response, 488, "Not Acceptable Here");
	                        _this.failed(response, Constants.C.causes.BAD_MEDIA_DESCRIPTION);
	                        // FIME: DON'T EAT UNHANDLED ERRORS!
	                    });
	                }
	                break;
	            default:
	                var cause = Utils_1.Utils.sipErrorCause(statusCode || 0);
	                this.rejected(response, cause);
	                this.failed(response, cause);
	                this.terminated(response, cause);
	        }
	    };
	    InviteClientContext.prototype.cancel = function (options) {
	        if (options === void 0) { options = {}; }
	        options.extraHeaders = (options.extraHeaders || []).slice();
	        if (this.isCanceled) {
	            throw new Exceptions_1.Exceptions.InvalidStateError(Enums.SessionStatus.STATUS_CANCELED);
	        }
	        // Check Session Status
	        if (this.status === Enums.SessionStatus.STATUS_TERMINATED || this.status === Enums.SessionStatus.STATUS_CONFIRMED) {
	            throw new Exceptions_1.Exceptions.InvalidStateError(this.status);
	        }
	        this.logger.log("canceling RTCSession");
	        this.isCanceled = true;
	        var cancelReason = Utils_1.Utils.getCancelReason(options.statusCode, options.reasonPhrase);
	        // Check Session Status
	        if (this.status === Enums.SessionStatus.STATUS_NULL ||
	            (this.status === Enums.SessionStatus.STATUS_INVITE_SENT && !this.received100)) {
	            this.cancelReason = cancelReason;
	        }
	        else if (this.status === Enums.SessionStatus.STATUS_INVITE_SENT ||
	            this.status === Enums.SessionStatus.STATUS_1XX_RECEIVED ||
	            this.status === Enums.SessionStatus.STATUS_EARLY_MEDIA) {
	            this.request.cancel(cancelReason, options.extraHeaders);
	        }
	        return this.canceled();
	    };
	    InviteClientContext.prototype.terminate = function (options) {
	        if (this.status === Enums.SessionStatus.STATUS_TERMINATED) {
	            return this;
	        }
	        if (this.status === Enums.SessionStatus.STATUS_WAITING_FOR_ACK || this.status === Enums.SessionStatus.STATUS_CONFIRMED) {
	            this.bye(options);
	        }
	        else {
	            this.cancel(options);
	        }
	        return this;
	    };
	    // ICC RECEIVE REQUEST
	    InviteClientContext.prototype.receiveRequest = function (request) {
	        // Reject CANCELs
	        if (request.method === Constants.C.CANCEL) ;
	        if (request.method === Constants.C.ACK && this.status === Enums.SessionStatus.STATUS_WAITING_FOR_ACK) {
	            clearTimeout(this.timers.ackTimer);
	            clearTimeout(this.timers.invite2xxTimer);
	            this.status = Enums.SessionStatus.STATUS_CONFIRMED;
	            this.accepted();
	        }
	        return _super.prototype.receiveRequest.call(this, request);
	    };
	    return InviteClientContext;
	}(Session));
	exports.InviteClientContext = InviteClientContext;
	// tslint:disable-next-line:max-classes-per-file
	var ReferClientContext = /** @class */ (function (_super) {
	    __extends(ReferClientContext, _super);
	    function ReferClientContext(ua, applicant, target, options) {
	        if (options === void 0) { options = {}; }
	        var _this = this;
	        if (ua === undefined || applicant === undefined || target === undefined) {
	            throw new TypeError("Not enough arguments");
	        }
	        _this = _super.call(this, ua, Constants.C.REFER, applicant.remoteIdentity.uri.toString(), options) || this;
	        _this.type = Enums.TypeStrings.ReferClientContext;
	        _this.options = options;
	        _this.extraHeaders = (_this.options.extraHeaders || []).slice();
	        _this.applicant = applicant;
	        if (!(typeof target === "string") &&
	            (target.type === Enums.TypeStrings.InviteServerContext || target.type === Enums.TypeStrings.InviteClientContext)) {
	            // Attended Transfer (with replaces)
	            // All of these fields should be defined based on the check above
	            var dialog = target.dialog;
	            if (dialog) {
	                _this.target = '"' + target.remoteIdentity.friendlyName + '" ' +
	                    "<" + dialog.remoteTarget.toString() +
	                    "?Replaces=" + encodeURIComponent(dialog.id.callId +
	                    ";to-tag=" + dialog.id.remoteTag +
	                    ";from-tag=" + dialog.id.localTag) + ">";
	            }
	            else {
	                throw new TypeError("Invalid target due to no dialog: " + target);
	            }
	        }
	        else {
	            // Blind Transfer
	            // Refer-To: <sip:bob@example.com>
	            var targetString = Grammar_1$1.Grammar.parse(target, "Refer_To");
	            _this.target = targetString && targetString.uri ? targetString.uri : target;
	            // Check target validity
	            var targetUri = _this.ua.normalizeTarget(_this.target);
	            if (!targetUri) {
	                throw new TypeError("Invalid target: " + target);
	            }
	            _this.target = targetUri;
	        }
	        if (_this.ua) {
	            _this.extraHeaders.push("Referred-By: <" + _this.ua.configuration.uri + ">");
	        }
	        // TODO: Check that this is correct isc/icc
	        _this.extraHeaders.push("Contact: " + applicant.contact);
	        // this is UA.C.ALLOWED_METHODS, removed to get around circular dependency
	        _this.extraHeaders.push("Allow: " + [
	            "ACK",
	            "CANCEL",
	            "INVITE",
	            "MESSAGE",
	            "BYE",
	            "OPTIONS",
	            "INFO",
	            "NOTIFY",
	            "REFER"
	        ].toString());
	        _this.extraHeaders.push("Refer-To: " + _this.target);
	        _this.errorListener = _this.onTransportError.bind(_this);
	        if (ua.transport) {
	            ua.transport.on("transportError", _this.errorListener);
	        }
	        return _this;
	    }
	    ReferClientContext.prototype.refer = function (options) {
	        var _this = this;
	        if (options === void 0) { options = {}; }
	        var extraHeaders = (this.extraHeaders || []).slice();
	        if (options.extraHeaders) {
	            extraHeaders.concat(options.extraHeaders);
	        }
	        this.applicant.sendRequest(Constants.C.REFER, {
	            extraHeaders: this.extraHeaders,
	            receiveResponse: function (response) {
	                var statusCode = response && response.statusCode ? response.statusCode.toString() : "";
	                if (/^1[0-9]{2}$/.test(statusCode)) {
	                    _this.emit("referRequestProgress", _this);
	                }
	                else if (/^2[0-9]{2}$/.test(statusCode)) {
	                    _this.emit("referRequestAccepted", _this);
	                }
	                else if (/^[4-6][0-9]{2}$/.test(statusCode)) {
	                    _this.emit("referRequestRejected", _this);
	                }
	                if (options.receiveResponse) {
	                    options.receiveResponse(response);
	                }
	            }
	        });
	        return this;
	    };
	    ReferClientContext.prototype.receiveNotify = function (request) {
	        // If we can correctly handle this, then we need to send a 200 OK!
	        var contentType = request.hasHeader("Content-Type") ?
	            request.getHeader("Content-Type") : undefined;
	        if (contentType && contentType.search(/^message\/sipfrag/) !== -1) {
	            var messageBody = Grammar_1$1.Grammar.parse(request.body, "sipfrag");
	            if (messageBody === -1) {
	                request.reply(489, "Bad Event");
	                return;
	            }
	            switch (true) {
	                case (/^1[0-9]{2}$/.test(messageBody.status_code)):
	                    this.emit("referProgress", this);
	                    break;
	                case (/^2[0-9]{2}$/.test(messageBody.status_code)):
	                    this.emit("referAccepted", this);
	                    if (!this.options.activeAfterTransfer && this.applicant.terminate) {
	                        this.applicant.terminate();
	                    }
	                    break;
	                default:
	                    this.emit("referRejected", this);
	                    break;
	            }
	            request.reply(200);
	            this.emit("notify", request);
	            return;
	        }
	        request.reply(489, "Bad Event");
	    };
	    return ReferClientContext;
	}(ClientContext_1.ClientContext));
	exports.ReferClientContext = ReferClientContext;
	// tslint:disable-next-line:max-classes-per-file
	var ReferServerContext = /** @class */ (function (_super) {
	    __extends(ReferServerContext, _super);
	    function ReferServerContext(ua, request) {
	        var _this = _super.call(this, ua, request) || this;
	        _this.type = Enums.TypeStrings.ReferServerContext;
	        _this.ua = ua;
	        _this.status = Enums.SessionStatus.STATUS_INVITE_RECEIVED;
	        _this.fromTag = request.fromTag;
	        _this.id = request.callId + _this.fromTag;
	        _this.request = request;
	        _this.contact = _this.ua.contact.toString();
	        _this.logger = ua.getLogger("sip.referservercontext", _this.id);
	        // Needed to send the NOTIFY's
	        _this.cseq = Math.floor(Math.random() * 10000);
	        _this.callId = _this.request.callId;
	        _this.fromUri = _this.request.to.uri;
	        _this.fromTag = _this.request.to.parameters.tag;
	        _this.remoteTarget = _this.request.headers.Contact[0].parsed.uri;
	        _this.toUri = _this.request.from.uri;
	        _this.toTag = _this.request.fromTag;
	        _this.routeSet = _this.request.getHeaders("record-route");
	        // RFC 3515 2.4.1
	        if (!_this.request.hasHeader("refer-to")) {
	            _this.logger.warn("Invalid REFER packet. A refer-to header is required. Rejecting refer.");
	            _this.reject();
	            return _this;
	        }
	        _this.referTo = _this.request.parseHeader("refer-to");
	        // TODO: Must set expiration timer and send 202 if there is no response by then
	        _this.referredSession = _this.ua.findSession(request);
	        if (_this.request.hasHeader("referred-by")) {
	            _this.referredBy = _this.request.getHeader("referred-by");
	        }
	        if (_this.referTo.uri.hasHeader("replaces")) {
	            _this.replaces = _this.referTo.uri.getHeader("replaces");
	        }
	        _this.errorListener = _this.onTransportError.bind(_this);
	        if (ua.transport) {
	            ua.transport.on("transportError", _this.errorListener);
	        }
	        _this.status = Enums.SessionStatus.STATUS_WAITING_FOR_ANSWER;
	        return _this;
	    }
	    ReferServerContext.prototype.receiveNonInviteResponse = function (response) { };
	    ReferServerContext.prototype.progress = function () {
	        if (this.status !== Enums.SessionStatus.STATUS_WAITING_FOR_ANSWER) {
	            throw new Exceptions_1.Exceptions.InvalidStateError(this.status);
	        }
	        this.request.reply(100);
	    };
	    ReferServerContext.prototype.reject = function (options) {
	        if (options === void 0) { options = {}; }
	        if (this.status === Enums.SessionStatus.STATUS_TERMINATED) {
	            throw new Exceptions_1.Exceptions.InvalidStateError(this.status);
	        }
	        this.logger.log("Rejecting refer");
	        this.status = Enums.SessionStatus.STATUS_TERMINATED;
	        _super.prototype.reject.call(this, options);
	        this.emit("referRequestRejected", this);
	    };
	    ReferServerContext.prototype.accept = function (options, modifiers) {
	        var _this = this;
	        if (options === void 0) { options = {}; }
	        if (this.status === Enums.SessionStatus.STATUS_WAITING_FOR_ANSWER) {
	            this.status = Enums.SessionStatus.STATUS_ANSWERED;
	        }
	        else {
	            throw new Exceptions_1.Exceptions.InvalidStateError(this.status);
	        }
	        this.request.reply(202, "Accepted");
	        this.emit("referRequestAccepted", this);
	        if (options.followRefer) {
	            this.logger.log("Accepted refer, attempting to automatically follow it");
	            var target = this.referTo.uri;
	            if (!target.scheme || !target.scheme.match("^sips?$")) {
	                this.logger.error("SIP.js can only automatically follow SIP refer target");
	                this.reject();
	                return;
	            }
	            var inviteOptions = options.inviteOptions || {};
	            var extraHeaders = (inviteOptions.extraHeaders || []).slice();
	            if (this.replaces) {
	                // decodeURIComponent is a holdover from 2c086eb4. Not sure that it is actually necessary
	                extraHeaders.push("Replaces: " + decodeURIComponent(this.replaces));
	            }
	            if (this.referredBy) {
	                extraHeaders.push("Referred-By: " + this.referredBy);
	            }
	            inviteOptions.extraHeaders = extraHeaders;
	            target.clearHeaders();
	            this.targetSession = this.ua.invite(target.toString(), inviteOptions, modifiers);
	            this.emit("referInviteSent", this);
	            if (this.targetSession) {
	                this.targetSession.once("progress", function (response) {
	                    var statusCode = response.statusCode || 100;
	                    var reasonPhrase = response.reasonPhrase;
	                    _this.sendNotify(("SIP/2.0 " + statusCode + " " + reasonPhrase).trim());
	                    _this.emit("referProgress", _this);
	                    if (_this.referredSession) {
	                        _this.referredSession.emit("referProgress", _this);
	                    }
	                });
	                this.targetSession.once("accepted", function () {
	                    _this.logger.log("Successfully followed the refer");
	                    _this.sendNotify("SIP/2.0 200 OK");
	                    _this.emit("referAccepted", _this);
	                    if (_this.referredSession) {
	                        _this.referredSession.emit("referAccepted", _this);
	                    }
	                });
	                var referFailed = function (response) {
	                    if (_this.status === Enums.SessionStatus.STATUS_TERMINATED) {
	                        return; // No throw here because it is possible this gets called multiple times
	                    }
	                    _this.logger.log("Refer was not successful. Resuming session");
	                    if (response && response.statusCode === 429) {
	                        _this.logger.log("Alerting referrer that identity is required.");
	                        _this.sendNotify("SIP/2.0 429 Provide Referrer Identity");
	                        return;
	                    }
	                    _this.sendNotify("SIP/2.0 603 Declined");
	                    // Must change the status after sending the final Notify or it will not send due to check
	                    _this.status = Enums.SessionStatus.STATUS_TERMINATED;
	                    _this.emit("referRejected", _this);
	                    if (_this.referredSession) {
	                        _this.referredSession.emit("referRejected");
	                    }
	                };
	                this.targetSession.once("rejected", referFailed);
	                this.targetSession.once("failed", referFailed);
	            }
	        }
	        else {
	            this.logger.log("Accepted refer, but did not automatically follow it");
	            this.sendNotify("SIP/2.0 200 OK");
	            this.emit("referAccepted", this);
	            if (this.referredSession) {
	                this.referredSession.emit("referAccepted", this);
	            }
	        }
	    };
	    ReferServerContext.prototype.sendNotify = function (body) {
	        if (this.status !== Enums.SessionStatus.STATUS_ANSWERED) {
	            throw new Exceptions_1.Exceptions.InvalidStateError(this.status);
	        }
	        if (Grammar_1$1.Grammar.parse(body, "sipfrag") === -1) {
	            throw new Error("sipfrag body is required to send notify for refer");
	        }
	        var request = new SIPMessage.OutgoingRequest(Constants.C.NOTIFY, this.remoteTarget, this.ua, {
	            cseq: this.cseq += 1,
	            callId: this.callId,
	            fromUri: this.fromUri,
	            fromTag: this.fromTag,
	            toUri: this.toUri,
	            toTag: this.toTag,
	            routeSet: this.routeSet
	        }, [
	            "Event: refer",
	            "Subscription-State: terminated",
	            "Content-Type: message/sipfrag"
	        ], body);
	        new RequestSender_1.RequestSender({
	            request: request,
	            onRequestTimeout: function () {
	                return;
	            },
	            onTransportError: function () {
	                return;
	            },
	            receiveResponse: function () {
	                return;
	            }
	        }, this.ua).send();
	    };
	    ReferServerContext.prototype.on = function (name, callback) { return _super.prototype.on.call(this, name, callback); };
	    return ReferServerContext;
	}(ServerContext_1.ServerContext));
	exports.ReferServerContext = ReferServerContext;
	});

	unwrapExports(Session_1);
	var Session_2 = Session_1.Session;
	var Session_3 = Session_1.InviteServerContext;
	var Session_4 = Session_1.InviteClientContext;
	var Session_5 = Session_1.ReferClientContext;
	var Session_6 = Session_1.ReferServerContext;

	var Subscription_1 = createCommonjsModule(function (module, exports) {
	var __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	Object.defineProperty(exports, "__esModule", { value: true });






	/**
	 * SIP Subscriber (SIP-Specific Event Notifications RFC6665)
	 * @class Class creating a SIP Subscription.
	 */
	var Subscription = /** @class */ (function (_super) {
	    __extends(Subscription, _super);
	    function Subscription(ua, target, event, options) {
	        if (options === void 0) { options = {}; }
	        var _this = this;
	        if (!event) {
	            throw new TypeError("Event necessary to create a subscription.");
	        }
	        options.extraHeaders = (options.extraHeaders || []).slice();
	        var expires;
	        if (typeof options.expires !== "number") {
	            ua.logger.warn("expires must be a number. Using default of 3600.");
	            expires = 3600;
	        }
	        else {
	            expires = options.expires;
	        }
	        options.extraHeaders.push("Event: " + event);
	        options.extraHeaders.push("Expires: " + expires);
	        options.extraHeaders.push("Contact: " + ua.contact.toString());
	        // was UA.C.ALLOWED_METHODS, removed due to circular dependency
	        options.extraHeaders.push("Allow: " + [
	            "ACK",
	            "CANCEL",
	            "INVITE",
	            "MESSAGE",
	            "BYE",
	            "OPTIONS",
	            "INFO",
	            "NOTIFY",
	            "REFER"
	        ].toString());
	        _this = _super.call(this, ua, Constants.C.SUBSCRIBE, target, options) || this;
	        _this.type = Enums.TypeStrings.Subscription;
	        // TODO: check for valid events here probably make a list in SIP.C; or leave it up to app to check?
	        // The check may need to/should probably occur on the other side,
	        _this.event = event;
	        _this.requestedExpires = expires;
	        _this.state = "init";
	        _this.contact = ua.contact.toString();
	        _this.extraHeaders = options.extraHeaders;
	        _this.logger = ua.getLogger("sip.subscription");
	        _this.expires = expires;
	        _this.timers = { N: undefined, subDuration: undefined };
	        _this.errorCodes = [404, 405, 410, 416, 480, 481, 482, 483, 484, 485, 489, 501, 604];
	        return _this;
	    }
	    Subscription.prototype.subscribe = function () {
	        var _this = this;
	        // these states point to an existing subscription, no subscribe is necessary
	        if (this.state === "active") {
	            this.refresh();
	            return this;
	        }
	        else if (this.state === "notify_wait") {
	            return this;
	        }
	        clearTimeout(this.timers.subDuration);
	        clearTimeout(this.timers.N);
	        this.timers.N = setTimeout(function () { return _this.timer_fire(); }, Timers.Timers.TIMER_N);
	        if (this.request && this.request.from) {
	            this.ua.earlySubscriptions[this.request.callId + this.request.from.parameters.tag + this.event] = this;
	        }
	        this.send();
	        this.state = "notify_wait";
	        return this;
	    };
	    Subscription.prototype.refresh = function () {
	        if (this.state === "terminated" || this.state === "pending" || this.state === "notify_wait" || !this.dialog) {
	            return;
	        }
	        this.dialog.sendRequest(this, Constants.C.SUBSCRIBE, {
	            extraHeaders: this.extraHeaders,
	            body: this.body
	        });
	    };
	    Subscription.prototype.receiveResponse = function (response) {
	        var _this = this;
	        var statusCode = response.statusCode ? response.statusCode : 0;
	        var cause = Utils_1.Utils.getReasonPhrase(statusCode);
	        if ((this.state === "notify_wait" && statusCode >= 300) ||
	            (this.state !== "notify_wait" && this.errorCodes.indexOf(statusCode) !== -1)) {
	            this.failed(response, undefined);
	        }
	        else if (/^2[0-9]{2}$/.test(statusCode.toString())) {
	            this.emit("accepted", response, cause);
	            // As we don't support RFC 5839 or other extensions where the NOTIFY is optional, timer N will not be cleared
	            // clearTimeout(this.timers.N);
	            var expires = response.getHeader("Expires");
	            if (expires && Number(expires) <= this.requestedExpires) {
	                // Preserve new expires value for subsequent requests
	                this.expires = Number(expires);
	                this.timers.subDuration = setTimeout(function () { return _this.refresh(); }, Number(expires) * 900);
	            }
	            else {
	                if (!expires) {
	                    this.logger.warn("Expires header missing in a 200-class response to SUBSCRIBE");
	                    this.failed(response, "Expires Header Missing");
	                }
	                else {
	                    this.logger.warn("Expires header in a 200-class response to" +
	                        " SUBSCRIBE with a higher value than the one in the request");
	                    this.failed(response, "Invalid Expires Header");
	                }
	            }
	        }
	        else if (statusCode > 300) {
	            this.emit("failed", response, cause);
	            this.emit("rejected", response, cause);
	        }
	    };
	    Subscription.prototype.unsubscribe = function () {
	        var _this = this;
	        var extraHeaders = [];
	        this.state = "terminated";
	        extraHeaders.push("Event: " + this.event);
	        extraHeaders.push("Expires: 0");
	        extraHeaders.push("Contact: " + this.contact);
	        // was UA.C.ALLOWED_METHODS, removed due to circular dependency
	        extraHeaders.push("Allow: " + [
	            "ACK",
	            "CANCEL",
	            "INVITE",
	            "MESSAGE",
	            "BYE",
	            "OPTIONS",
	            "INFO",
	            "NOTIFY",
	            "REFER"
	        ].toString());
	        // makes sure expires isn't set, and other typical resubscribe behavior
	        this.receiveResponse = function () { };
	        if (this.dialog) {
	            this.dialog.sendRequest(this, Constants.C.SUBSCRIBE, {
	                extraHeaders: extraHeaders,
	                body: this.body
	            });
	        }
	        clearTimeout(this.timers.subDuration);
	        clearTimeout(this.timers.N);
	        this.timers.N = setTimeout(function () { return _this.timer_fire(); }, Timers.Timers.TIMER_N);
	        this.emit("terminated");
	    };
	    Subscription.prototype.receiveRequest = function (request) {
	        var _this = this;
	        var subState;
	        var setExpiresTimeout = function () {
	            if (subState.expires) {
	                clearTimeout(_this.timers.subDuration);
	                subState.expires = Math.min(_this.expires, Math.max(subState.expires, 0));
	                _this.timers.subDuration = setTimeout(function () { return _this.refresh(); }, subState.expires * 900);
	            }
	        };
	        if (!this.matchEvent(request)) { // checks event and subscription_state headers
	            request.reply(489);
	            return;
	        }
	        if (!this.dialog) {
	            if (this.createConfirmedDialog(request, "UAS")) {
	                if (this.dialog) {
	                    this.id = this.dialog.id.toString();
	                    if (this.request && this.request.from) {
	                        delete this.ua.earlySubscriptions[this.request.callId + this.request.from.parameters.tag + this.event];
	                        this.ua.subscriptions[this.id || ""] = this;
	                        // UPDATE ROUTE SET TO BE BACKWARDS COMPATIBLE?
	                    }
	                }
	            }
	        }
	        subState = request.parseHeader("Subscription-State");
	        request.reply(200);
	        clearTimeout(this.timers.N);
	        this.emit("notify", { request: request });
	        // if we've set state to terminated, no further processing should take place
	        // and we are only interested in cleaning up after the appropriate NOTIFY
	        if (this.state === "terminated") {
	            if (subState.state === "terminated") {
	                this.terminateDialog();
	                clearTimeout(this.timers.N);
	                clearTimeout(this.timers.subDuration);
	                delete this.ua.subscriptions[this.id || ""];
	            }
	            return;
	        }
	        switch (subState.state) {
	            case "active":
	                this.state = "active";
	                setExpiresTimeout();
	                break;
	            case "pending":
	                if (this.state === "notify_wait") {
	                    setExpiresTimeout();
	                }
	                this.state = "pending";
	                break;
	            case "terminated":
	                clearTimeout(this.timers.subDuration);
	                if (subState.reason) {
	                    this.logger.log("terminating subscription with reason " + subState.reason);
	                    switch (subState.reason) {
	                        case "deactivated":
	                        case "timeout":
	                            this.subscribe();
	                            return;
	                        case "probation":
	                        case "giveup":
	                            if (subState.params && subState.params["retry-after"]) {
	                                this.timers.subDuration = setTimeout(function () { return _this.subscribe(); }, subState.params["retry-after"]);
	                            }
	                            else {
	                                this.subscribe();
	                            }
	                            return;
	                        case "rejected":
	                        case "noresource":
	                        case "invariant":
	                            break;
	                    }
	                }
	                this.close();
	                break;
	        }
	    };
	    Subscription.prototype.close = function () {
	        if (this.state === "notify_wait") {
	            this.state = "terminated";
	            clearTimeout(this.timers.N);
	            clearTimeout(this.timers.subDuration);
	            this.receiveResponse = function () { };
	            if (this.request && this.request.from) {
	                delete this.ua.earlySubscriptions[this.request.callId + this.request.from.parameters.tag + this.event];
	            }
	            this.emit("terminated");
	        }
	        else if (this.state !== "terminated") {
	            this.unsubscribe();
	        }
	    };
	    Subscription.prototype.onDialogError = function (response) {
	        this.failed(response, Constants.C.causes.DIALOG_ERROR);
	    };
	    Subscription.prototype.on = function (name, callback) { return _super.prototype.on.call(this, name, callback); };
	    Subscription.prototype.timer_fire = function () {
	        if (this.state === "terminated") {
	            this.terminateDialog();
	            clearTimeout(this.timers.N);
	            clearTimeout(this.timers.subDuration);
	            delete this.ua.subscriptions[this.id || ""];
	        }
	        else if (this.state === "notify_wait" || this.state === "pending") {
	            this.close();
	        }
	        else {
	            this.refresh();
	        }
	    };
	    Subscription.prototype.createConfirmedDialog = function (message, type) {
	        this.terminateDialog();
	        var dialog = new Dialogs.Dialog(this, message, type);
	        if (this.request) {
	            dialog.inviteSeqnum = this.request.cseq;
	            dialog.localSeqnum = this.request.cseq;
	        }
	        if (!dialog.error) {
	            this.dialog = dialog;
	            return true;
	        }
	        else {
	            // Dialog not created due to an errora
	            return false;
	        }
	    };
	    Subscription.prototype.terminateDialog = function () {
	        if (this.dialog) {
	            delete this.ua.subscriptions[this.id || ""];
	            this.dialog.terminate();
	            delete this.dialog;
	        }
	    };
	    Subscription.prototype.failed = function (response, cause) {
	        this.close();
	        this.emit("failed", response, cause);
	        this.emit("rejected", response, cause);
	        return this;
	    };
	    Subscription.prototype.matchEvent = function (request) {
	        // Check mandatory header Event
	        if (!request.hasHeader("Event")) {
	            this.logger.warn("missing Event header");
	            return false;
	        }
	        // Check mandatory header Subscription-State
	        if (!request.hasHeader("Subscription-State")) {
	            this.logger.warn("missing Subscription-State header");
	            return false;
	        }
	        // Check whether the event in NOTIFY matches the event in SUBSCRIBE
	        var event = request.parseHeader("event").event;
	        if (this.event !== event) {
	            this.logger.warn("event match failed");
	            request.reply(481, "Event Match Failed");
	            return false;
	        }
	        else {
	            return true;
	        }
	    };
	    return Subscription;
	}(ClientContext_1.ClientContext));
	exports.Subscription = Subscription;
	});

	unwrapExports(Subscription_1);
	var Subscription_2 = Subscription_1.Subscription;

	var Modifiers = createCommonjsModule(function (module, exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	var stripPayload = function (sdp, payload) {
	    var mediaDescs = [];
	    var lines = sdp.split(/\r\n/);
	    var currentMediaDesc;
	    for (var i = 0; i < lines.length;) {
	        var line = lines[i];
	        if (/^m=(?:audio|video)/.test(line)) {
	            currentMediaDesc = {
	                index: i,
	                stripped: []
	            };
	            mediaDescs.push(currentMediaDesc);
	        }
	        else if (currentMediaDesc) {
	            var rtpmap = /^a=rtpmap:(\d+) ([^/]+)\//.exec(line);
	            if (rtpmap && payload === rtpmap[2]) {
	                lines.splice(i, 1);
	                currentMediaDesc.stripped.push(rtpmap[1]);
	                continue; // Don't increment 'i'
	            }
	        }
	        i++;
	    }
	    for (var _i = 0, mediaDescs_1 = mediaDescs; _i < mediaDescs_1.length; _i++) {
	        var mediaDesc = mediaDescs_1[_i];
	        var mline = lines[mediaDesc.index].split(" ");
	        // Ignore the first 3 parameters of the mline. The codec information is after that
	        for (var j = 3; j < mline.length;) {
	            if (mediaDesc.stripped.indexOf(mline[j]) !== -1) {
	                mline.splice(j, 1);
	                continue;
	            }
	            j++;
	        }
	        lines[mediaDesc.index] = mline.join(" ");
	    }
	    return lines.join("\r\n");
	};
	var stripMediaDescription = function (sdp, description) {
	    var descriptionRegExp = new RegExp("m=" + description + ".*$", "gm");
	    var groupRegExp = new RegExp("^a=group:.*$", "gm");
	    if (descriptionRegExp.test(sdp)) {
	        var midLineToRemove_1;
	        sdp = sdp.split(/^m=/gm).filter(function (section) {
	            if (section.substr(0, description.length) === description) {
	                midLineToRemove_1 = section.match(/^a=mid:.*$/gm);
	                if (midLineToRemove_1) {
	                    var step = midLineToRemove_1[0].match(/:.+$/g);
	                    if (step) {
	                        midLineToRemove_1 = step[0].substr(1);
	                    }
	                }
	                return false;
	            }
	            return true;
	        }).join("m=");
	        var groupLine = sdp.match(groupRegExp);
	        if (groupLine && groupLine.length === 1) {
	            var groupLinePortion = groupLine[0];
	            var groupRegExpReplace = new RegExp("\ *" + midLineToRemove_1 + "[^\ ]*", "g");
	            groupLinePortion = groupLinePortion.replace(groupRegExpReplace, "");
	            sdp = sdp.split(groupRegExp).join(groupLinePortion);
	        }
	    }
	    return sdp;
	};
	function stripTcpCandidates(description) {
	    description.sdp = (description.sdp || "").replace(/^a=candidate:\d+ \d+ tcp .*?\r\n/img, "");
	    return Promise.resolve(description);
	}
	exports.stripTcpCandidates = stripTcpCandidates;
	function stripTelephoneEvent(description) {
	    description.sdp = stripPayload(description.sdp || "", "telephone-event");
	    return Promise.resolve(description);
	}
	exports.stripTelephoneEvent = stripTelephoneEvent;
	function cleanJitsiSdpImageattr(description) {
	    description.sdp = (description.sdp || "").replace(/^(a=imageattr:.*?)(x|y)=\[0-/gm, "$1$2=[1:");
	    return Promise.resolve(description);
	}
	exports.cleanJitsiSdpImageattr = cleanJitsiSdpImageattr;
	function stripG722(description) {
	    description.sdp = stripPayload(description.sdp || "", "G722");
	    return Promise.resolve(description);
	}
	exports.stripG722 = stripG722;
	function stripRtpPayload(payload) {
	    return function (description) {
	        description.sdp = stripPayload(description.sdp || "", payload);
	        return Promise.resolve(description);
	    };
	}
	exports.stripRtpPayload = stripRtpPayload;
	function stripVideo(description) {
	    description.sdp = stripMediaDescription(description.sdp || "", "video");
	    return Promise.resolve(description);
	}
	exports.stripVideo = stripVideo;
	function addMidLines(description) {
	    var sdp = description.sdp || "";
	    if (sdp.search(/^a=mid.*$/gm) === -1) {
	        var mlines_1 = sdp.match(/^m=.*$/gm);
	        var sdpArray_1 = sdp.split(/^m=.*$/gm);
	        if (mlines_1) {
	            mlines_1.forEach(function (elem, idx) {
	                mlines_1[idx] = elem + "\na=mid:" + idx;
	            });
	        }
	        sdpArray_1.forEach(function (elem, idx) {
	            if (mlines_1 && mlines_1[idx]) {
	                sdpArray_1[idx] = elem + mlines_1[idx];
	            }
	        });
	        sdp = sdpArray_1.join("");
	        description.sdp = sdp;
	    }
	    return Promise.resolve(description);
	}
	exports.addMidLines = addMidLines;
	});

	unwrapExports(Modifiers);
	var Modifiers_1 = Modifiers.stripTcpCandidates;
	var Modifiers_2 = Modifiers.stripTelephoneEvent;
	var Modifiers_3 = Modifiers.cleanJitsiSdpImageattr;
	var Modifiers_4 = Modifiers.stripG722;
	var Modifiers_5 = Modifiers.stripRtpPayload;
	var Modifiers_6 = Modifiers.stripVideo;
	var Modifiers_7 = Modifiers.addMidLines;

	var SessionDescriptionHandlerObserver_1 = createCommonjsModule(function (module, exports) {
	Object.defineProperty(exports, "__esModule", { value: true });

	/* SessionDescriptionHandlerObserver
	 * @class SessionDescriptionHandler Observer Class.
	 * @param {SIP.Session} session
	 * @param {Object} [options]
	 */
	var SessionDescriptionHandlerObserver = /** @class */ (function () {
	    function SessionDescriptionHandlerObserver(session, options) {
	        this.type = Enums.TypeStrings.SessionDescriptionHandlerObserver;
	        this.session = session;
	        this.options = options;
	    }
	    SessionDescriptionHandlerObserver.prototype.trackAdded = function () {
	        this.session.emit("trackAdded");
	    };
	    SessionDescriptionHandlerObserver.prototype.directionChanged = function () {
	        this.session.emit("directionChanged");
	    };
	    return SessionDescriptionHandlerObserver;
	}());
	exports.SessionDescriptionHandlerObserver = SessionDescriptionHandlerObserver;
	});

	unwrapExports(SessionDescriptionHandlerObserver_1);
	var SessionDescriptionHandlerObserver_2 = SessionDescriptionHandlerObserver_1.SessionDescriptionHandlerObserver;

	var SessionDescriptionHandler_1 = createCommonjsModule(function (module, exports) {
	var __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	Object.defineProperty(exports, "__esModule", { value: true });






	/* SessionDescriptionHandler
	 * @class PeerConnection helper Class.
	 * @param {SIP.Session} session
	 * @param {Object} [options]
	 */
	var SessionDescriptionHandler = /** @class */ (function (_super) {
	    __extends(SessionDescriptionHandler, _super);
	    function SessionDescriptionHandler(logger, observer, options) {
	        var _this = _super.call(this) || this;
	        _this.type = Enums.TypeStrings.SessionDescriptionHandler;
	        // TODO: Validate the options
	        _this.options = options || {};
	        _this.logger = logger;
	        _this.observer = observer;
	        _this.dtmfSender = undefined;
	        _this.shouldAcquireMedia = true;
	        _this.CONTENT_TYPE = "application/sdp";
	        _this.C = {
	            DIRECTION: {
	                NULL: null,
	                SENDRECV: "sendrecv",
	                SENDONLY: "sendonly",
	                RECVONLY: "recvonly",
	                INACTIVE: "inactive"
	            }
	        };
	        _this.logger.log("SessionDescriptionHandlerOptions: " + JSON.stringify(_this.options));
	        _this.direction = _this.C.DIRECTION.NULL;
	        _this.modifiers = _this.options.modifiers || [];
	        if (!Array.isArray(_this.modifiers)) {
	            _this.modifiers = [_this.modifiers];
	        }
	        var environment = commonjsGlobal.window || commonjsGlobal;
	        _this.WebRTC = {
	            MediaStream: environment.MediaStream,
	            getUserMedia: environment.navigator.mediaDevices.getUserMedia.bind(environment.navigator.mediaDevices),
	            RTCPeerConnection: environment.RTCPeerConnection
	        };
	        _this.iceGatheringTimeout = false;
	        _this.initPeerConnection(_this.options.peerConnectionOptions);
	        _this.constraints = _this.checkAndDefaultConstraints(_this.options.constraints);
	        return _this;
	    }
	    /**
	     * @param {SIP.Session} session
	     * @param {Object} [options]
	     */
	    SessionDescriptionHandler.defaultFactory = function (session, options) {
	        var logger = session.ua.getLogger("sip.invitecontext.sessionDescriptionHandler", session.id);
	        var observer = new SessionDescriptionHandlerObserver_1.SessionDescriptionHandlerObserver(session, options);
	        return new SessionDescriptionHandler(logger, observer, options);
	    };
	    // Functions the sesssion can use
	    /**
	     * Destructor
	     */
	    SessionDescriptionHandler.prototype.close = function () {
	        this.logger.log("closing PeerConnection");
	        // have to check signalingState since this.close() gets called multiple times
	        if (this.peerConnection && this.peerConnection.signalingState !== "closed") {
	            if (this.peerConnection.getSenders) {
	                this.peerConnection.getSenders().forEach(function (sender) {
	                    if (sender.track) {
	                        sender.track.stop();
	                    }
	                });
	            }
	            else {
	                this.logger.warn("Using getLocalStreams which is deprecated");
	                this.peerConnection.getLocalStreams().forEach(function (stream) {
	                    stream.getTracks().forEach(function (track) {
	                        track.stop();
	                    });
	                });
	            }
	            if (this.peerConnection.getReceivers) {
	                this.peerConnection.getReceivers().forEach(function (receiver) {
	                    if (receiver.track) {
	                        receiver.track.stop();
	                    }
	                });
	            }
	            else {
	                this.logger.warn("Using getRemoteStreams which is deprecated");
	                this.peerConnection.getRemoteStreams().forEach(function (stream) {
	                    stream.getTracks().forEach(function (track) {
	                        track.stop();
	                    });
	                });
	            }
	            this.resetIceGatheringComplete();
	            this.peerConnection.close();
	        }
	    };
	    /**
	     * Gets the local description from the underlying media implementation
	     * @param {Object} [options] Options object to be used by getDescription
	     * @param {MediaStreamConstraints} [options.constraints] MediaStreamConstraints
	     *   https://developer.mozilla.org/en-US/docs/Web/API/MediaStreamConstraints
	     * @param {Object} [options.peerConnectionOptions] If this is set it will recreate the peer
	     *   connection with the new options
	     * @param {Array} [modifiers] Array with one time use description modifiers
	     * @returns {Promise} Promise that resolves with the local description to be used for the session
	     */
	    SessionDescriptionHandler.prototype.getDescription = function (options, modifiers) {
	        var _this = this;
	        if (options === void 0) { options = {}; }
	        if (modifiers === void 0) { modifiers = []; }
	        if (options.peerConnectionOptions) {
	            this.initPeerConnection(options.peerConnectionOptions);
	        }
	        // Merge passed constraints with saved constraints and save
	        var newConstraints = Object.assign({}, this.constraints, options.constraints);
	        newConstraints = this.checkAndDefaultConstraints(newConstraints);
	        if (JSON.stringify(newConstraints) !== JSON.stringify(this.constraints)) {
	            this.constraints = newConstraints;
	            this.shouldAcquireMedia = true;
	        }
	        if (!Array.isArray(modifiers)) {
	            modifiers = [modifiers];
	        }
	        modifiers = modifiers.concat(this.modifiers);
	        return Promise.resolve().then(function () {
	            if (_this.shouldAcquireMedia) {
	                return _this.acquire(_this.constraints).then(function () {
	                    _this.shouldAcquireMedia = false;
	                });
	            }
	        }).then(function () { return _this.createOfferOrAnswer(options.RTCOfferOptions, modifiers); })
	            .then(function (description) {
	            if (description.sdp === undefined) {
	                throw new Exceptions_1.Exceptions.SessionDescriptionHandlerError("getDescription", undefined, "SDP undefined");
	            }
	            _this.emit("getDescription", description);
	            return {
	                body: description.sdp,
	                contentType: _this.CONTENT_TYPE
	            };
	        });
	    };
	    /**
	     * Check if the Session Description Handler can handle the Content-Type described by a SIP Message
	     * @param {String} contentType The content type that is in the SIP Message
	     * @returns {boolean}
	     */
	    SessionDescriptionHandler.prototype.hasDescription = function (contentType) {
	        return contentType === this.CONTENT_TYPE;
	    };
	    /**
	     * The modifier that should be used when the session would like to place the call on hold
	     * @param {String} [sdp] The description that will be modified
	     * @returns {Promise} Promise that resolves with modified SDP
	     */
	    SessionDescriptionHandler.prototype.holdModifier = function (description) {
	        if (!description.sdp) {
	            return Promise.resolve(description);
	        }
	        if (!(/a=(sendrecv|sendonly|recvonly|inactive)/).test(description.sdp)) {
	            description.sdp = description.sdp.replace(/(m=[^\r]*\r\n)/g, "$1a=sendonly\r\n");
	        }
	        else {
	            description.sdp = description.sdp.replace(/a=sendrecv\r\n/g, "a=sendonly\r\n");
	            description.sdp = description.sdp.replace(/a=recvonly\r\n/g, "a=inactive\r\n");
	        }
	        return Promise.resolve(description);
	    };
	    /**
	     * Set the remote description to the underlying media implementation
	     * @param {String} sessionDescription The description provided by a SIP message to be set on the media implementation
	     * @param {Object} [options] Options object to be used by getDescription
	     * @param {MediaStreamConstraints} [options.constraints] MediaStreamConstraints
	     *   https://developer.mozilla.org/en-US/docs/Web/API/MediaStreamConstraints
	     * @param {Object} [options.peerConnectionOptions] If this is set it will recreate the peer
	     *   connection with the new options
	     * @param {Array} [modifiers] Array with one time use description modifiers
	     * @returns {Promise} Promise that resolves once the description is set
	     */
	    SessionDescriptionHandler.prototype.setDescription = function (sessionDescription, options, modifiers) {
	        var _this = this;
	        if (options === void 0) { options = {}; }
	        if (modifiers === void 0) { modifiers = []; }
	        if (options.peerConnectionOptions) {
	            this.initPeerConnection(options.peerConnectionOptions);
	        }
	        if (!Array.isArray(modifiers)) {
	            modifiers = [modifiers];
	        }
	        modifiers = modifiers.concat(this.modifiers);
	        var description = {
	            type: this.hasOffer("local") ? "answer" : "offer",
	            sdp: sessionDescription
	        };
	        return Promise.resolve().then(function () {
	            // Media should be acquired in getDescription unless we need to do it sooner for some reason (FF61+)
	            if (_this.shouldAcquireMedia && _this.options.alwaysAcquireMediaFirst) {
	                return _this.acquire(_this.constraints).then(function () {
	                    _this.shouldAcquireMedia = false;
	                });
	            }
	        }).then(function () { return Utils_1.Utils.reducePromises(modifiers, description); })
	            .catch(function (e) {
	            if (e.type === Enums.TypeStrings.SessionDescriptionHandlerError) {
	                throw e;
	            }
	            var error = new Exceptions_1.Exceptions.SessionDescriptionHandlerError("setDescription", e, "The modifiers did not resolve successfully");
	            _this.logger.error(error.message);
	            _this.emit("peerConnection-setRemoteDescriptionFailed", error);
	            throw error;
	        }).then(function (modifiedDescription) {
	            _this.emit("setDescription", modifiedDescription);
	            return _this.peerConnection.setRemoteDescription(modifiedDescription);
	        }).catch(function (e) {
	            if (e.type === Enums.TypeStrings.SessionDescriptionHandlerError) {
	                throw e;
	            }
	            // Check the original SDP for video, and ensure that we have want to do audio fallback
	            if ((/^m=video.+$/gm).test(sessionDescription) && !options.disableAudioFallback) {
	                // Do not try to audio fallback again
	                options.disableAudioFallback = true;
	                // Remove video first, then do the other modifiers
	                return _this.setDescription(sessionDescription, options, [Modifiers.stripVideo].concat(modifiers));
	            }
	            var error = new Exceptions_1.Exceptions.SessionDescriptionHandlerError("setDescription", e);
	            if (error.error) {
	                _this.logger.error(error.error);
	            }
	            _this.emit("peerConnection-setRemoteDescriptionFailed", error);
	            throw error;
	        }).then(function () {
	            if (_this.peerConnection.getReceivers) {
	                _this.emit("setRemoteDescription", _this.peerConnection.getReceivers());
	            }
	            else {
	                _this.emit("setRemoteDescription", _this.peerConnection.getRemoteStreams());
	            }
	            _this.emit("confirmed", _this);
	        });
	    };
	    /**
	     * Send DTMF via RTP (RFC 4733)
	     * @param {String} tones A string containing DTMF digits
	     * @param {Object} [options] Options object to be used by sendDtmf
	     * @returns {boolean} true if DTMF send is successful, false otherwise
	     */
	    SessionDescriptionHandler.prototype.sendDtmf = function (tones, options) {
	        if (options === void 0) { options = {}; }
	        if (!this.dtmfSender && this.hasBrowserGetSenderSupport()) {
	            var senders = this.peerConnection.getSenders();
	            if (senders.length > 0) {
	                this.dtmfSender = senders[0].dtmf;
	            }
	        }
	        if (!this.dtmfSender && this.hasBrowserTrackSupport()) {
	            var streams = this.peerConnection.getLocalStreams();
	            if (streams.length > 0) {
	                var audioTracks = streams[0].getAudioTracks();
	                if (audioTracks.length > 0) {
	                    this.dtmfSender = this.peerConnection.createDTMFSender(audioTracks[0]);
	                }
	            }
	        }
	        if (!this.dtmfSender) {
	            return false;
	        }
	        try {
	            this.dtmfSender.insertDTMF(tones, options.duration, options.interToneGap);
	        }
	        catch (e) {
	            if (e.type === "InvalidStateError" || e.type === "InvalidCharacterError") {
	                this.logger.error(e);
	                return false;
	            }
	            else {
	                throw e;
	            }
	        }
	        this.logger.log("DTMF sent via RTP: " + tones.toString());
	        return true;
	    };
	    /**
	     * Get the direction of the session description
	     * @returns {String} direction of the description
	     */
	    SessionDescriptionHandler.prototype.getDirection = function () {
	        return this.direction;
	    };
	    SessionDescriptionHandler.prototype.on = function (name, callback) { return _super.prototype.on.call(this, name, callback); };
	    // Internal functions
	    SessionDescriptionHandler.prototype.createOfferOrAnswer = function (RTCOfferOptions, modifiers) {
	        var _this = this;
	        if (RTCOfferOptions === void 0) { RTCOfferOptions = {}; }
	        if (modifiers === void 0) { modifiers = []; }
	        var methodName = this.hasOffer("remote") ? "createAnswer" : "createOffer";
	        var pc = this.peerConnection;
	        this.logger.log(methodName);
	        return pc[methodName](RTCOfferOptions).catch(function (e) {
	            if (e.type === Enums.TypeStrings.SessionDescriptionHandlerError) {
	                throw e;
	            }
	            var error = new Exceptions_1.Exceptions.SessionDescriptionHandlerError("createOfferOrAnswer", e, "peerConnection-" + methodName + "Failed");
	            _this.emit("peerConnection-" + methodName + "Failed", error);
	            throw error;
	        }).then(function (sdp) {
	            return Utils_1.Utils.reducePromises(modifiers, _this.createRTCSessionDescriptionInit(sdp));
	        }).then(function (sdp) {
	            _this.resetIceGatheringComplete();
	            _this.logger.log("Setting local sdp.");
	            _this.logger.log("sdp is " + sdp.sdp || "undefined");
	            return pc.setLocalDescription(sdp);
	        }).catch(function (e) {
	            if (e.type === Enums.TypeStrings.SessionDescriptionHandlerError) {
	                throw e;
	            }
	            var error = new Exceptions_1.Exceptions.SessionDescriptionHandlerError("createOfferOrAnswer", e, "peerConnection-SetLocalDescriptionFailed");
	            _this.emit("peerConnection-SetLocalDescriptionFailed", error);
	            throw error;
	        }).then(function () { return _this.waitForIceGatheringComplete(); })
	            .then(function () {
	            var localDescription = _this.createRTCSessionDescriptionInit(_this.peerConnection.localDescription);
	            return Utils_1.Utils.reducePromises(modifiers, localDescription);
	        }).then(function (localDescription) {
	            _this.setDirection(localDescription.sdp || "");
	            return localDescription;
	        }).catch(function (e) {
	            if (e.type === Enums.TypeStrings.SessionDescriptionHandlerError) {
	                throw e;
	            }
	            var error = new Exceptions_1.Exceptions.SessionDescriptionHandlerError("createOfferOrAnswer", e);
	            _this.logger.error(error.toString());
	            throw error;
	        });
	    };
	    // Creates an RTCSessionDescriptionInit from an RTCSessionDescription
	    SessionDescriptionHandler.prototype.createRTCSessionDescriptionInit = function (RTCSessionDescription) {
	        return {
	            type: RTCSessionDescription.type,
	            sdp: RTCSessionDescription.sdp
	        };
	    };
	    SessionDescriptionHandler.prototype.addDefaultIceCheckingTimeout = function (peerConnectionOptions) {
	        if (peerConnectionOptions.iceCheckingTimeout === undefined) {
	            peerConnectionOptions.iceCheckingTimeout = 5000;
	        }
	        return peerConnectionOptions;
	    };
	    SessionDescriptionHandler.prototype.addDefaultIceServers = function (rtcConfiguration) {
	        if (!rtcConfiguration.iceServers) {
	            rtcConfiguration.iceServers = [{ urls: "stun:stun.l.google.com:19302" }];
	        }
	        return rtcConfiguration;
	    };
	    SessionDescriptionHandler.prototype.checkAndDefaultConstraints = function (constraints) {
	        var defaultConstraints = { audio: true, video: !this.options.alwaysAcquireMediaFirst };
	        constraints = constraints || defaultConstraints;
	        // Empty object check
	        if (Object.keys(constraints).length === 0 && constraints.constructor === Object) {
	            return defaultConstraints;
	        }
	        return constraints;
	    };
	    SessionDescriptionHandler.prototype.hasBrowserTrackSupport = function () {
	        return Boolean(this.peerConnection.addTrack);
	    };
	    SessionDescriptionHandler.prototype.hasBrowserGetSenderSupport = function () {
	        return Boolean(this.peerConnection.getSenders);
	    };
	    SessionDescriptionHandler.prototype.initPeerConnection = function (options) {
	        var _this = this;
	        if (options === void 0) { options = {}; }
	        options = this.addDefaultIceCheckingTimeout(options);
	        options.rtcConfiguration = options.rtcConfiguration || {};
	        options.rtcConfiguration = this.addDefaultIceServers(options.rtcConfiguration);
	        this.logger.log("initPeerConnection");
	        if (this.peerConnection) {
	            this.logger.log("Already have a peer connection for this session. Tearing down.");
	            this.resetIceGatheringComplete();
	            this.peerConnection.close();
	        }
	        this.peerConnection = new this.WebRTC.RTCPeerConnection(options.rtcConfiguration);
	        this.logger.log("New peer connection created");
	        if ("ontrack" in this.peerConnection) {
	            this.peerConnection.addEventListener("track", function (e) {
	                _this.logger.log("track added");
	                _this.observer.trackAdded();
	                _this.emit("addTrack", e);
	            });
	        }
	        else {
	            this.logger.warn("Using onaddstream which is deprecated");
	            this.peerConnection.onaddstream = function (e) {
	                _this.logger.log("stream added");
	                _this.emit("addStream", e);
	            };
	        }
	        this.peerConnection.onicecandidate = function (e) {
	            _this.emit("iceCandidate", e);
	            if (e.candidate) {
	                _this.logger.log("ICE candidate received: " +
	                    (e.candidate.candidate === null ? null : e.candidate.candidate.trim()));
	            }
	            else if (e.candidate === null) {
	                // indicates the end of candidate gathering
	                _this.logger.log("ICE candidate gathering complete");
	                _this.triggerIceGatheringComplete();
	            }
	        };
	        this.peerConnection.onicegatheringstatechange = function () {
	            _this.logger.log("RTCIceGatheringState changed: " + _this.peerConnection.iceGatheringState);
	            switch (_this.peerConnection.iceGatheringState) {
	                case "gathering":
	                    _this.emit("iceGathering", _this);
	                    if (!_this.iceGatheringTimer && options.iceCheckingTimeout) {
	                        _this.iceGatheringTimeout = false;
	                        _this.iceGatheringTimer = setTimeout(function () {
	                            _this.logger.log("RTCIceChecking Timeout Triggered after " + options.iceCheckingTimeout + " milliseconds");
	                            _this.iceGatheringTimeout = true;
	                            _this.triggerIceGatheringComplete();
	                        }, options.iceCheckingTimeout);
	                    }
	                    break;
	                case "complete":
	                    _this.triggerIceGatheringComplete();
	                    break;
	            }
	        };
	        this.peerConnection.oniceconnectionstatechange = function () {
	            var stateEvent;
	            switch (_this.peerConnection.iceConnectionState) {
	                case "new":
	                    stateEvent = "iceConnection";
	                    break;
	                case "checking":
	                    stateEvent = "iceConnectionChecking";
	                    break;
	                case "connected":
	                    stateEvent = "iceConnectionConnected";
	                    break;
	                case "completed":
	                    stateEvent = "iceConnectionCompleted";
	                    break;
	                case "failed":
	                    stateEvent = "iceConnectionFailed";
	                    break;
	                case "disconnected":
	                    stateEvent = "iceConnectionDisconnected";
	                    break;
	                case "closed":
	                    stateEvent = "iceConnectionClosed";
	                    break;
	                default:
	                    _this.logger.warn("Unknown iceConnection state: " + _this.peerConnection.iceConnectionState);
	                    return;
	            }
	            _this.logger.log("ICE Connection State changed to " + stateEvent);
	            _this.emit(stateEvent, _this);
	        };
	    };
	    SessionDescriptionHandler.prototype.acquire = function (constraints) {
	        var _this = this;
	        // Default audio & video to true
	        constraints = this.checkAndDefaultConstraints(constraints);
	        return new Promise(function (resolve, reject) {
	            /*
	             * Make the call asynchronous, so that ICCs have a chance
	             * to define callbacks to `userMediaRequest`
	             */
	            _this.logger.log("acquiring local media");
	            _this.emit("userMediaRequest", constraints);
	            if (constraints.audio || constraints.video) {
	                _this.WebRTC.getUserMedia(constraints).then(function (streams) {
	                    _this.observer.trackAdded();
	                    _this.emit("userMedia", streams);
	                    resolve(streams);
	                }).catch(function (e) {
	                    _this.emit("userMediaFailed", e);
	                    reject(e);
	                });
	            }
	            else {
	                // Local streams were explicitly excluded.
	                resolve([]);
	            }
	        }).catch(function (e) {
	            if (e.type === Enums.TypeStrings.SessionDescriptionHandlerError) {
	                throw e;
	            }
	            var error = new Exceptions_1.Exceptions.SessionDescriptionHandlerError("acquire", e, "unable to acquire streams");
	            _this.logger.error(error.message);
	            if (error.error) {
	                _this.logger.error(error.error);
	            }
	            throw error;
	        }).then(function (streams) {
	            _this.logger.log("acquired local media streams");
	            try {
	                // Remove old tracks
	                if (_this.peerConnection.removeTrack) {
	                    _this.peerConnection.getSenders().forEach(function (sender) {
	                        _this.peerConnection.removeTrack(sender);
	                    });
	                }
	                return streams;
	            }
	            catch (e) {
	                return Promise.reject(e);
	            }
	        }).catch(function (e) {
	            if (e.type === Enums.TypeStrings.SessionDescriptionHandlerError) {
	                throw e;
	            }
	            var error = new Exceptions_1.Exceptions.SessionDescriptionHandlerError("acquire", e, "error removing streams");
	            _this.logger.error(error.message);
	            if (error.error) {
	                _this.logger.error(error.error);
	            }
	            throw error;
	        }).then(function (streams) {
	            try {
	                streams = [].concat(streams);
	                streams.forEach(function (stream) {
	                    if (_this.peerConnection.addTrack) {
	                        stream.getTracks().forEach(function (track) {
	                            _this.peerConnection.addTrack(track, stream);
	                        });
	                    }
	                    else {
	                        // Chrome 59 does not support addTrack
	                        _this.peerConnection.addStream(stream);
	                    }
	                });
	            }
	            catch (e) {
	                return Promise.reject(e);
	            }
	            return Promise.resolve();
	        }).catch(function (e) {
	            if (e.type === Enums.TypeStrings.SessionDescriptionHandlerError) {
	                throw e;
	            }
	            var error = new Exceptions_1.Exceptions.SessionDescriptionHandlerError("acquire", e, "error adding stream");
	            _this.logger.error(error.message);
	            if (error.error) {
	                _this.logger.error(error.error);
	            }
	            throw error;
	        });
	    };
	    SessionDescriptionHandler.prototype.hasOffer = function (where) {
	        var offerState = "have-" + where + "-offer";
	        return this.peerConnection.signalingState === offerState;
	    };
	    // ICE gathering state handling
	    SessionDescriptionHandler.prototype.isIceGatheringComplete = function () {
	        return this.peerConnection.iceGatheringState === "complete" || this.iceGatheringTimeout;
	    };
	    SessionDescriptionHandler.prototype.resetIceGatheringComplete = function () {
	        this.iceGatheringTimeout = false;
	        this.logger.log("resetIceGatheringComplete");
	        if (this.iceGatheringTimer) {
	            clearTimeout(this.iceGatheringTimer);
	            this.iceGatheringTimer = undefined;
	        }
	        if (this.iceGatheringDeferred) {
	            this.iceGatheringDeferred.reject();
	            this.iceGatheringDeferred = undefined;
	        }
	    };
	    SessionDescriptionHandler.prototype.setDirection = function (sdp) {
	        var match = sdp.match(/a=(sendrecv|sendonly|recvonly|inactive)/);
	        if (match === null) {
	            this.direction = this.C.DIRECTION.NULL;
	            this.observer.directionChanged();
	            return;
	        }
	        var direction = match[1];
	        switch (direction) {
	            case this.C.DIRECTION.SENDRECV:
	            case this.C.DIRECTION.SENDONLY:
	            case this.C.DIRECTION.RECVONLY:
	            case this.C.DIRECTION.INACTIVE:
	                this.direction = direction;
	                break;
	            default:
	                this.direction = this.C.DIRECTION.NULL;
	                break;
	        }
	        this.observer.directionChanged();
	    };
	    SessionDescriptionHandler.prototype.triggerIceGatheringComplete = function () {
	        if (this.isIceGatheringComplete()) {
	            this.emit("iceGatheringComplete", this);
	            if (this.iceGatheringTimer) {
	                clearTimeout(this.iceGatheringTimer);
	                this.iceGatheringTimer = undefined;
	            }
	            if (this.iceGatheringDeferred) {
	                this.iceGatheringDeferred.resolve();
	                this.iceGatheringDeferred = undefined;
	            }
	        }
	    };
	    SessionDescriptionHandler.prototype.waitForIceGatheringComplete = function () {
	        this.logger.log("waitForIceGatheringComplete");
	        if (this.isIceGatheringComplete()) {
	            this.logger.log("ICE is already complete. Return resolved.");
	            return Promise.resolve();
	        }
	        else if (!this.iceGatheringDeferred) {
	            this.iceGatheringDeferred = Utils_1.Utils.defer();
	        }
	        this.logger.log("ICE is not complete. Returning promise");
	        return this.iceGatheringDeferred ? this.iceGatheringDeferred.promise : Promise.resolve();
	    };
	    return SessionDescriptionHandler;
	}(events.EventEmitter));
	exports.SessionDescriptionHandler = SessionDescriptionHandler;
	});

	unwrapExports(SessionDescriptionHandler_1);
	var SessionDescriptionHandler_2 = SessionDescriptionHandler_1.SessionDescriptionHandler;

	var Transport_1 = createCommonjsModule(function (module, exports) {
	var __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	Object.defineProperty(exports, "__esModule", { value: true });


	/* Transport
	 * @class Abstract transport layer parent class
	 * @param {Logger} logger
	 * @param {Object} [options]
	 */
	var Transport = /** @class */ (function (_super) {
	    __extends(Transport, _super);
	    function Transport(logger, options) {
	        var _this = _super.call(this) || this;
	        _this.type = Enums.TypeStrings.Transport;
	        _this.logger = logger;
	        return _this;
	    }
	    /**
	     * Returns the promise designated by the child layer then emits a connected event.
	     * Automatically emits an event upon resolution, unless overrideEvent is set. If you
	     * override the event in this fashion, you should emit it in your implementation of connectPromise
	     * @param {Object} [options]
	     * @returns {Promise}
	     */
	    Transport.prototype.connect = function (options) {
	        var _this = this;
	        if (options === void 0) { options = {}; }
	        return this.connectPromise(options).then(function (data) {
	            if (!data.overrideEvent) {
	                _this.emit("connected");
	            }
	        });
	    };
	    /**
	     * Sends a message then emits a 'messageSent' event. Automatically emits an
	     * event upon resolution, unless data.overrideEvent is set. If you override
	     * the event in this fashion, you should emit it in your implementation of sendPromise
	     * @param {String} msg
	     * @param {Object} options
	     * @returns {Promise}
	     */
	    Transport.prototype.send = function (msg, options) {
	        var _this = this;
	        return this.sendPromise(msg).then(function (data) {
	            if (!data.overrideEvent) {
	                _this.emit("messageSent", data.msg);
	            }
	        });
	    };
	    /**
	     * Returns the promise designated by the child layer then emits a
	     * disconnected event. Automatically emits an event upon resolution,
	     * unless overrideEvent is set. If you override the event in this fashion,
	     * you should emit it in your implementation of disconnectPromise
	     * @param {Object} [options]
	     * @returns {Promise}
	     */
	    Transport.prototype.disconnect = function (options) {
	        var _this = this;
	        if (options === void 0) { options = {}; }
	        return this.disconnectPromise(options).then(function (data) {
	            if (!data.overrideEvent) {
	                _this.emit("disconnected");
	            }
	        });
	    };
	    Transport.prototype.afterConnected = function (callback) {
	        if (this.isConnected()) {
	            callback();
	        }
	        else {
	            this.once("connected", callback);
	        }
	    };
	    /**
	     * Returns a promise which resolves once the UA is connected. DEPRECATION WARNING: just use afterConnected()
	     * @returns {Promise}
	     */
	    Transport.prototype.waitForConnected = function () {
	        var _this = this;
	        // tslint:disable-next-line:no-console
	        console.warn("DEPRECATION WARNING Transport.waitForConnected(): use afterConnected() instead");
	        return new Promise(function (resolve) {
	            _this.afterConnected(resolve);
	        });
	    };
	    return Transport;
	}(events.EventEmitter));
	exports.Transport = Transport;
	});

	unwrapExports(Transport_1);
	var Transport_2 = Transport_1.Transport;

	var Transport_2$1 = createCommonjsModule(function (module, exports) {
	var __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	Object.defineProperty(exports, "__esModule", { value: true });





	var TransportStatus;
	(function (TransportStatus) {
	    TransportStatus[TransportStatus["STATUS_CONNECTING"] = 0] = "STATUS_CONNECTING";
	    TransportStatus[TransportStatus["STATUS_OPEN"] = 1] = "STATUS_OPEN";
	    TransportStatus[TransportStatus["STATUS_CLOSING"] = 2] = "STATUS_CLOSING";
	    TransportStatus[TransportStatus["STATUS_CLOSED"] = 3] = "STATUS_CLOSED";
	})(TransportStatus = exports.TransportStatus || (exports.TransportStatus = {}));
	/**
	 * Compute an amount of time in seconds to wait before sending another
	 * keep-alive.
	 * @returns {Number}
	 */
	var computeKeepAliveTimeout = function (upperBound) {
	    var lowerBound = upperBound * 0.8;
	    return 1000 * (Math.random() * (upperBound - lowerBound) + lowerBound);
	};
	/**
	 * @class Transport
	 * @param {Object} options
	 */
	var Transport = /** @class */ (function (_super) {
	    __extends(Transport, _super);
	    function Transport(logger, options) {
	        if (options === void 0) { options = {}; }
	        var _this = _super.call(this, logger, options) || this;
	        _this.WebSocket = (commonjsGlobal.window || commonjsGlobal).WebSocket;
	        _this.type = Enums.TypeStrings.Transport;
	        _this.reconnectionAttempts = 0;
	        _this.status = TransportStatus.STATUS_CONNECTING;
	        _this.configuration = _this.loadConfig(options);
	        _this.server = _this.configuration.wsServers[0];
	        return _this;
	    }
	    /**
	     * @returns {Boolean}
	     */
	    Transport.prototype.isConnected = function () {
	        return this.status === TransportStatus.STATUS_OPEN;
	    };
	    /**
	     * Send a message.
	     * @param {SIP.OutgoingRequest|String} msg
	     * @param {Object} [options]
	     * @returns {Promise}
	     */
	    Transport.prototype.sendPromise = function (msg, options) {
	        if (options === void 0) { options = {}; }
	        if (!this.statusAssert(TransportStatus.STATUS_OPEN, options.force)) {
	            this.onError("unable to send message - WebSocket not open");
	            return Promise.reject();
	        }
	        var message = msg.toString();
	        if (this.ws) {
	            if (this.configuration.traceSip === true) {
	                this.logger.log("sending WebSocket message:\n\n" + message + "\n");
	            }
	            this.ws.send(message);
	            return Promise.resolve({ msg: message });
	        }
	        else {
	            this.onError("unable to send message - WebSocket does not exist");
	            return Promise.reject();
	        }
	    };
	    /**
	     * Disconnect socket.
	     */
	    Transport.prototype.disconnectPromise = function (options) {
	        var _this = this;
	        if (options === void 0) { options = {}; }
	        if (this.disconnectionPromise) { // Already disconnecting. Just return this.
	            return this.disconnectionPromise;
	        }
	        options.code = options.code || 1000;
	        if (!this.statusTransition(TransportStatus.STATUS_CLOSING, options.force)) {
	            if (this.status === TransportStatus.STATUS_CLOSED) { // Websocket is already closed
	                return Promise.resolve({ overrideEvent: true });
	            }
	            else if (this.connectionPromise) { // Websocket is connecting, cannot move to disconneting yet
	                return this.connectionPromise.then(function () { return Promise.reject("The websocket did not disconnect"); })
	                    .catch(function () { return Promise.resolve({ overrideEvent: true }); });
	            }
	            else {
	                // Cannot move to disconnecting, but not in connecting state.
	                return Promise.reject("The websocket did not disconnect");
	            }
	        }
	        this.emit("disconnecting");
	        this.disconnectionPromise = new Promise(function (resolve, reject) {
	            _this.disconnectDeferredResolve = resolve;
	            if (_this.reconnectTimer) {
	                clearTimeout(_this.reconnectTimer);
	                _this.reconnectTimer = undefined;
	            }
	            if (_this.ws) {
	                _this.stopSendingKeepAlives();
	                _this.logger.log("closing WebSocket " + _this.server.wsUri);
	                _this.ws.close(options.code, options.reason);
	            }
	            else {
	                reject("Attempted to disconnect but the websocket doesn't exist");
	            }
	        });
	        return this.disconnectionPromise;
	    };
	    /**
	     * Connect socket.
	     */
	    Transport.prototype.connectPromise = function (options) {
	        var _this = this;
	        if (options === void 0) { options = {}; }
	        if (this.status === TransportStatus.STATUS_CLOSING && !options.force) {
	            return Promise.reject("WebSocket " + this.server.wsUri + " is closing");
	        }
	        if (this.connectionPromise) {
	            return this.connectionPromise;
	        }
	        this.server = this.server || this.getNextWsServer(options.force);
	        this.connectionPromise = new Promise(function (resolve, reject) {
	            if ((_this.status === TransportStatus.STATUS_OPEN || _this.status === TransportStatus.STATUS_CLOSING)
	                && !options.force) {
	                _this.logger.warn("WebSocket " + _this.server.wsUri + " is already connected");
	                reject("Failed status check - attempted to open a connection but already open/closing");
	                return;
	            }
	            _this.connectDeferredResolve = resolve;
	            _this.status = TransportStatus.STATUS_CONNECTING;
	            _this.emit("connecting");
	            _this.logger.log("connecting to WebSocket " + _this.server.wsUri);
	            _this.disposeWs();
	            try {
	                _this.ws = new WebSocket(_this.server.wsUri, "sip");
	            }
	            catch (e) {
	                _this.ws = null;
	                _this.status = TransportStatus.STATUS_CLOSED; // force status to closed in error case
	                _this.onError("error connecting to WebSocket " + _this.server.wsUri + ":" + e);
	                reject("Failed to create a websocket");
	                return;
	            }
	            if (!_this.ws) {
	                reject("Unexpected instance websocket not set");
	                return;
	            }
	            _this.connectionTimeout = setTimeout(function () {
	                _this.statusTransition(TransportStatus.STATUS_CLOSED);
	                _this.logger.warn("took too long to connect - exceeded time set in configuration.connectionTimeout: " +
	                    _this.configuration.connectionTimeout + "s");
	                _this.emit("disconnected", { code: 1000 });
	                _this.connectionPromise = undefined;
	                reject("Connection timeout");
	            }, _this.configuration.connectionTimeout * 1000);
	            _this.boundOnOpen = _this.onOpen.bind(_this);
	            _this.boundOnMessage = _this.onMessage.bind(_this);
	            _this.boundOnClose = _this.onClose.bind(_this);
	            _this.boundOnError = _this.onWebsocketError.bind(_this);
	            _this.ws.addEventListener("open", _this.boundOnOpen);
	            _this.ws.addEventListener("message", _this.boundOnMessage);
	            _this.ws.addEventListener("close", _this.boundOnClose);
	            _this.ws.addEventListener("error", _this.boundOnError);
	        });
	        return this.connectionPromise;
	    };
	    /**
	     * @event
	     * @param {event} e
	     */
	    Transport.prototype.onMessage = function (e) {
	        var data = e.data;
	        var finishedData;
	        // CRLF Keep Alive response from server. Clear our keep alive timeout.
	        if (/^(\r\n)+$/.test(data)) {
	            this.clearKeepAliveTimeout();
	            if (this.configuration.traceSip === true) {
	                this.logger.log("received WebSocket message with CRLF Keep Alive response");
	            }
	            return;
	        }
	        else if (!data) {
	            this.logger.warn("received empty message, message discarded");
	            return;
	        }
	        else if (typeof data !== "string") { // WebSocket binary message.
	            try {
	                // the UInt8Data was here prior to types, and doesn't check
	                finishedData = String.fromCharCode.apply(null, new Uint8Array(data));
	            }
	            catch (err) {
	                this.logger.warn("received WebSocket binary message failed to be converted into string, message discarded");
	                return;
	            }
	            if (this.configuration.traceSip === true) {
	                this.logger.log("received WebSocket binary message:\n\n" + data + "\n");
	            }
	        }
	        else { // WebSocket text message.
	            if (this.configuration.traceSip === true) {
	                this.logger.log("received WebSocket text message:\n\n" + data + "\n");
	            }
	            finishedData = data;
	        }
	        this.emit("message", finishedData);
	    };
	    // Transport Event Handlers
	    /**
	     * @event
	     * @param {event} e
	     */
	    Transport.prototype.onOpen = function () {
	        if (this.status === TransportStatus.STATUS_CLOSED) { // Indicated that the transport thinks the ws is dead already
	            var ws = this.ws;
	            this.disposeWs();
	            ws.close(1000);
	            return;
	        }
	        this.status = TransportStatus.STATUS_OPEN; // quietly force status to open
	        this.emit("connected");
	        if (this.connectionTimeout) {
	            clearTimeout(this.connectionTimeout);
	            this.connectionTimeout = undefined;
	        }
	        this.logger.log("WebSocket " + this.server.wsUri + " connected");
	        // Clear reconnectTimer since we are not disconnected
	        if (this.reconnectTimer !== undefined) {
	            clearTimeout(this.reconnectTimer);
	            this.reconnectTimer = undefined;
	        }
	        // Reset reconnectionAttempts
	        this.reconnectionAttempts = 0;
	        // Reset disconnection promise so we can disconnect from a fresh state
	        this.disconnectionPromise = undefined;
	        this.disconnectDeferredResolve = undefined;
	        // Start sending keep-alives
	        this.startSendingKeepAlives();
	        if (this.connectDeferredResolve) {
	            this.connectDeferredResolve({ overrideEvent: true });
	        }
	        else {
	            this.logger.warn("Unexpected websocket.onOpen with no connectDeferredResolve");
	        }
	    };
	    /**
	     * @event
	     * @param {event} e
	     */
	    Transport.prototype.onClose = function (e) {
	        this.logger.log("WebSocket disconnected (code: " + e.code + (e.reason ? "| reason: " + e.reason : "") + ")");
	        if (this.status !== TransportStatus.STATUS_CLOSING) {
	            this.logger.warn("WebSocket closed without SIP.js requesting it");
	            this.emit("transportError");
	        }
	        this.stopSendingKeepAlives();
	        // Clean up connection variables so we can connect again from a fresh state
	        if (this.connectionTimeout) {
	            clearTimeout(this.connectionTimeout);
	        }
	        this.connectionTimeout = undefined;
	        this.connectionPromise = undefined;
	        this.connectDeferredResolve = undefined;
	        // Check whether the user requested to close.
	        if (this.disconnectDeferredResolve) {
	            this.disconnectDeferredResolve({ overrideEvent: true });
	            this.statusTransition(TransportStatus.STATUS_CLOSED);
	            this.disconnectDeferredResolve = undefined;
	            return;
	        }
	        this.status = TransportStatus.STATUS_CLOSED; // quietly force status to closed
	        this.emit("disconnected", { code: e.code, reason: e.reason });
	        this.reconnect();
	    };
	    /**
	     * Removes event listeners and clears the instance ws
	     */
	    Transport.prototype.disposeWs = function () {
	        if (this.ws) {
	            this.ws.removeEventListener("open", this.boundOnOpen);
	            this.ws.removeEventListener("message", this.boundOnMessage);
	            this.ws.removeEventListener("close", this.boundOnClose);
	            this.ws.removeEventListener("error", this.boundOnError);
	            this.ws = undefined;
	        }
	    };
	    /**
	     * @event
	     * @param {string} e
	     */
	    Transport.prototype.onError = function (e) {
	        this.logger.warn("Transport error: " + e);
	        this.emit("transportError");
	    };
	    /**
	     * @event
	     * @private
	     */
	    Transport.prototype.onWebsocketError = function () {
	        this.onError("The Websocket had an error");
	    };
	    /**
	     * Reconnection attempt logic.
	     */
	    Transport.prototype.reconnect = function () {
	        var _this = this;
	        if (this.reconnectionAttempts > 0) {
	            this.logger.log("Reconnection attempt " + this.reconnectionAttempts + " failed");
	        }
	        if (this.noAvailableServers()) {
	            this.logger.warn("attempted to get next ws server but there are no available ws servers left");
	            this.logger.warn("no available ws servers left - going to closed state");
	            this.status = TransportStatus.STATUS_CLOSED;
	            this.emit("closed");
	            this.resetServerErrorStatus();
	            return;
	        }
	        if (this.isConnected()) {
	            this.logger.warn("attempted to reconnect while connected - forcing disconnect");
	            this.disconnect({ force: true });
	        }
	        this.reconnectionAttempts += 1;
	        if (this.reconnectionAttempts > this.configuration.maxReconnectionAttempts) {
	            this.logger.warn("maximum reconnection attempts for WebSocket " + this.server.wsUri);
	            this.logger.log("transport " + this.server.wsUri + " failed | connection state set to 'error'");
	            this.server.isError = true;
	            this.emit("transportError");
	            if (!this.noAvailableServers()) {
	                this.server = this.getNextWsServer();
	            }
	            // When there are no available servers, the reconnect function ends on the next recursive call
	            // after checking for no available servers again.
	            this.reconnectionAttempts = 0;
	            this.reconnect();
	        }
	        else {
	            this.logger.log("trying to reconnect to WebSocket " +
	                this.server.wsUri + " (reconnection attempt " + this.reconnectionAttempts + ")");
	            this.reconnectTimer = setTimeout(function () {
	                _this.connect();
	                _this.reconnectTimer = undefined;
	            }, (this.reconnectionAttempts === 1) ? 0 : this.configuration.reconnectionTimeout * 1000);
	        }
	    };
	    /**
	     * Resets the error state of all servers in the configuration
	     */
	    Transport.prototype.resetServerErrorStatus = function () {
	        for (var _i = 0, _a = this.configuration.wsServers; _i < _a.length; _i++) {
	            var websocket = _a[_i];
	            websocket.isError = false;
	        }
	    };
	    /**
	     * Retrieve the next server to which connect.
	     * @param {Boolean} force allows bypass of server error status checking
	     * @returns {Object} WsServer
	     */
	    Transport.prototype.getNextWsServer = function (force) {
	        if (force === void 0) { force = false; }
	        if (this.noAvailableServers()) {
	            this.logger.warn("attempted to get next ws server but there are no available ws servers left");
	            throw new Error("Attempted to get next ws server, but there are no available ws servers left.");
	        }
	        // Order servers by weight
	        var candidates = [];
	        for (var _i = 0, _a = this.configuration.wsServers; _i < _a.length; _i++) {
	            var wsServer = _a[_i];
	            if (wsServer.isError && !force) {
	                continue;
	            }
	            else if (candidates.length === 0) {
	                candidates.push(wsServer);
	            }
	            else if (wsServer.weight > candidates[0].weight) {
	                candidates = [wsServer];
	            }
	            else if (wsServer.weight === candidates[0].weight) {
	                candidates.push(wsServer);
	            }
	        }
	        var idx = Math.floor(Math.random() * candidates.length);
	        return candidates[idx];
	    };
	    /**
	     * Checks all configuration servers, returns true if all of them have isError: true and false otherwise
	     * @returns {Boolean}
	     */
	    Transport.prototype.noAvailableServers = function () {
	        for (var _i = 0, _a = this.configuration.wsServers; _i < _a.length; _i++) {
	            var server = _a[_i];
	            if (!server.isError) {
	                return false;
	            }
	        }
	        return true;
	    };
	    // ==============================
	    // KeepAlive Stuff
	    // ==============================
	    /**
	     * Send a keep-alive (a double-CRLF sequence).
	     * @returns {Boolean}
	     */
	    Transport.prototype.sendKeepAlive = function () {
	        var _this = this;
	        if (this.keepAliveDebounceTimeout) {
	            // We already have an outstanding keep alive, do not send another.
	            return;
	        }
	        this.keepAliveDebounceTimeout = setTimeout(function () {
	            _this.emit("keepAliveDebounceTimeout");
	            _this.clearKeepAliveTimeout();
	        }, this.configuration.keepAliveDebounce * 1000);
	        return this.send("\r\n\r\n");
	    };
	    Transport.prototype.clearKeepAliveTimeout = function () {
	        if (this.keepAliveDebounceTimeout) {
	            clearTimeout(this.keepAliveDebounceTimeout);
	        }
	        this.keepAliveDebounceTimeout = undefined;
	    };
	    /**
	     * Start sending keep-alives.
	     */
	    Transport.prototype.startSendingKeepAlives = function () {
	        var _this = this;
	        if (this.configuration.keepAliveInterval && !this.keepAliveInterval) {
	            this.keepAliveInterval = setInterval(function () {
	                _this.sendKeepAlive();
	                _this.startSendingKeepAlives();
	            }, computeKeepAliveTimeout(this.configuration.keepAliveInterval));
	        }
	    };
	    /**
	     * Stop sending keep-alives.
	     */
	    Transport.prototype.stopSendingKeepAlives = function () {
	        if (this.keepAliveInterval) {
	            clearInterval(this.keepAliveInterval);
	        }
	        if (this.keepAliveDebounceTimeout) {
	            clearTimeout(this.keepAliveDebounceTimeout);
	        }
	        this.keepAliveInterval = undefined;
	        this.keepAliveDebounceTimeout = undefined;
	    };
	    // ==============================
	    // Status Stuff
	    // ==============================
	    /**
	     * Checks given status against instance current status. Returns true if they match
	     * @param {Number} status
	     * @param {Boolean} [force]
	     * @returns {Boolean}
	     */
	    Transport.prototype.statusAssert = function (status, force) {
	        if (status === this.status) {
	            return true;
	        }
	        else {
	            if (force) {
	                this.logger.warn("Attempted to assert " +
	                    Object.keys(TransportStatus)[this.status] + " as " +
	                    Object.keys(TransportStatus)[status] + "- continuing with option: 'force'");
	                return true;
	            }
	            else {
	                this.logger.warn("Tried to assert " +
	                    Object.keys(TransportStatus)[status] + " but is currently " +
	                    Object.keys(TransportStatus)[this.status]);
	                return false;
	            }
	        }
	    };
	    /**
	     * Transitions the status. Checks for legal transition via assertion beforehand
	     * @param {Number} status
	     * @param {Boolean} [force]
	     * @returns {Boolean}
	     */
	    Transport.prototype.statusTransition = function (status, force) {
	        if (force === void 0) { force = false; }
	        this.logger.log("Attempting to transition status from " +
	            Object.keys(TransportStatus)[this.status] + " to " +
	            Object.keys(TransportStatus)[status]);
	        if ((status === TransportStatus.STATUS_CONNECTING && this.statusAssert(TransportStatus.STATUS_CLOSED, force)) ||
	            (status === TransportStatus.STATUS_OPEN && this.statusAssert(TransportStatus.STATUS_CONNECTING, force)) ||
	            (status === TransportStatus.STATUS_CLOSING && this.statusAssert(TransportStatus.STATUS_OPEN, force)) ||
	            (status === TransportStatus.STATUS_CLOSED)) {
	            this.status = status;
	            return true;
	        }
	        else {
	            this.logger.warn("Status transition failed - result: no-op - reason:" +
	                " either gave an nonexistent status or attempted illegal transition");
	            return false;
	        }
	    };
	    // ==============================
	    // Configuration Handling
	    // ==============================
	    /**
	     * Configuration load.
	     * returns {Configuration}
	     */
	    Transport.prototype.loadConfig = function (configuration) {
	        var settings = {
	            wsServers: [{
	                    scheme: "WSS",
	                    sipUri: "<sip:edge.sip.onsip.com;transport=ws;lr>",
	                    weight: 0,
	                    wsUri: "wss://edge.sip.onsip.com",
	                    isError: false
	                }],
	            connectionTimeout: 5,
	            maxReconnectionAttempts: 3,
	            reconnectionTimeout: 4,
	            keepAliveInterval: 0,
	            keepAliveDebounce: 10,
	            // Logging
	            traceSip: false
	        };
	        var configCheck = this.getConfigurationCheck();
	        // Check Mandatory parameters
	        for (var parameter in configCheck.mandatory) {
	            if (!configuration.hasOwnProperty(parameter)) {
	                throw new Exceptions_1.Exceptions.ConfigurationError(parameter);
	            }
	            else {
	                var value = configuration[parameter];
	                var checkedValue = configCheck.mandatory[parameter](value);
	                if (checkedValue !== undefined) {
	                    settings[parameter] = checkedValue;
	                }
	                else {
	                    throw new Exceptions_1.Exceptions.ConfigurationError(parameter, value);
	                }
	            }
	        }
	        // Check Optional parameters
	        for (var parameter in configCheck.optional) {
	            if (configuration.hasOwnProperty(parameter)) {
	                var value = configuration[parameter];
	                // If the parameter value is an empty array, but shouldn't be, apply its default value.
	                // If the parameter value is null, empty string, or undefined then apply its default value.
	                // If it's a number with NaN value then also apply its default value.
	                // NOTE: JS does not allow "value === NaN", the following does the work:
	                if ((value instanceof Array && value.length === 0) ||
	                    (value === null || value === "" || value === undefined) ||
	                    (typeof (value) === "number" && isNaN(value))) {
	                    continue;
	                }
	                var checkedValue = configCheck.optional[parameter](value);
	                if (checkedValue !== undefined) {
	                    settings[parameter] = checkedValue;
	                }
	                else {
	                    throw new Exceptions_1.Exceptions.ConfigurationError(parameter, value);
	                }
	            }
	        }
	        var skeleton = {}; // Fill the value of the configuration_skeleton
	        for (var parameter in settings) {
	            if (settings.hasOwnProperty(parameter)) {
	                skeleton[parameter] = {
	                    value: settings[parameter],
	                };
	            }
	        }
	        var returnConfiguration = Object.defineProperties({}, skeleton);
	        this.logger.log("configuration parameters after validation:");
	        for (var parameter in settings) {
	            if (settings.hasOwnProperty(parameter)) {
	                this.logger.log("· " + parameter + ": " + JSON.stringify(settings[parameter]));
	            }
	        }
	        return returnConfiguration;
	    };
	    /**
	     * Configuration checker.
	     * @return {Boolean}
	     */
	    Transport.prototype.getConfigurationCheck = function () {
	        return {
	            mandatory: {},
	            optional: {
	                // Note: this function used to call 'this.logger.error' but calling 'this' with anything here is invalid
	                wsServers: function (wsServers) {
	                    /* Allow defining wsServers parameter as:
	                     *  String: "host"
	                     *  Array of Strings: ["host1", "host2"]
	                     *  Array of Objects: [{wsUri:"host1", weight:1}, {wsUri:"host2", weight:0}]
	                     *  Array of Objects and Strings: [{wsUri:"host1"}, "host2"]
	                     */
	                    if (typeof wsServers === "string") {
	                        wsServers = [{ wsUri: wsServers }];
	                    }
	                    else if (wsServers instanceof Array) {
	                        for (var idx = 0; idx < wsServers.length; idx++) {
	                            if (typeof wsServers[idx] === "string") {
	                                wsServers[idx] = { wsUri: wsServers[idx] };
	                            }
	                        }
	                    }
	                    else {
	                        return;
	                    }
	                    if (wsServers.length === 0) {
	                        return false;
	                    }
	                    for (var _i = 0, wsServers_1 = wsServers; _i < wsServers_1.length; _i++) {
	                        var wsServer = wsServers_1[_i];
	                        if (!wsServer.wsUri) {
	                            return;
	                        }
	                        if (wsServer.weight && !Number(wsServer.weight)) {
	                            return;
	                        }
	                        var url = Grammar_1$1.Grammar.parse(wsServer.wsUri, "absoluteURI");
	                        if (url === -1) {
	                            return;
	                        }
	                        else if (["wss", "ws", "udp"].indexOf(url.scheme) < 0) {
	                            return;
	                        }
	                        else {
	                            wsServer.sipUri = "<sip:" + url.host +
	                                (url.port ? ":" + url.port : "") + ";transport=" + url.scheme.replace(/^wss$/i, "ws") + ";lr>";
	                            if (!wsServer.weight) {
	                                wsServer.weight = 0;
	                            }
	                            wsServer.isError = false;
	                            wsServer.scheme = url.scheme.toUpperCase();
	                        }
	                    }
	                    return wsServers;
	                },
	                keepAliveInterval: function (keepAliveInterval) {
	                    if (Utils_1.Utils.isDecimal(keepAliveInterval)) {
	                        var value = Number(keepAliveInterval);
	                        if (value > 0) {
	                            return value;
	                        }
	                    }
	                },
	                keepAliveDebounce: function (keepAliveDebounce) {
	                    if (Utils_1.Utils.isDecimal(keepAliveDebounce)) {
	                        var value = Number(keepAliveDebounce);
	                        if (value > 0) {
	                            return value;
	                        }
	                    }
	                },
	                traceSip: function (traceSip) {
	                    if (typeof traceSip === "boolean") {
	                        return traceSip;
	                    }
	                },
	                connectionTimeout: function (connectionTimeout) {
	                    if (Utils_1.Utils.isDecimal(connectionTimeout)) {
	                        var value = Number(connectionTimeout);
	                        if (value > 0) {
	                            return value;
	                        }
	                    }
	                },
	                maxReconnectionAttempts: function (maxReconnectionAttempts) {
	                    if (Utils_1.Utils.isDecimal(maxReconnectionAttempts)) {
	                        var value = Number(maxReconnectionAttempts);
	                        if (value >= 0) {
	                            return value;
	                        }
	                    }
	                },
	                reconnectionTimeout: function (reconnectionTimeout) {
	                    if (Utils_1.Utils.isDecimal(reconnectionTimeout)) {
	                        var value = Number(reconnectionTimeout);
	                        if (value > 0) {
	                            return value;
	                        }
	                    }
	                }
	            }
	        };
	    };
	    Transport.C = TransportStatus;
	    return Transport;
	}(Transport_1.Transport));
	exports.Transport = Transport;
	});

	unwrapExports(Transport_2$1);
	var Transport_3 = Transport_2$1.TransportStatus;
	var Transport_4 = Transport_2$1.Transport;

	var UA_1 = createCommonjsModule(function (module, exports) {
	var __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	Object.defineProperty(exports, "__esModule", { value: true });





















	var environment = commonjsGlobal.window || commonjsGlobal;
	/**
	 * @class Class creating a SIP User Agent.
	 * @param {function returning SIP.sessionDescriptionHandler} [configuration.sessionDescriptionHandlerFactory]
	 *  A function will be invoked by each of the UA's Sessions to build the sessionDescriptionHandler for that Session.
	 *  If no (or a falsy) value is provided, each Session will use a default (WebRTC) sessionDescriptionHandler.
	 */
	var UA = /** @class */ (function (_super) {
	    __extends(UA, _super);
	    function UA(configuration) {
	        var _this = _super.call(this) || this;
	        _this.type = Enums.TypeStrings.UA;
	        _this.log = new LoggerFactory_1.LoggerFactory();
	        _this.logger = _this.getLogger("sip.ua");
	        _this.cache = {
	            credentials: {}
	        };
	        _this.configuration = {};
	        _this.dialogs = {};
	        // User actions outside any session/dialog (MESSAGE)
	        _this.applicants = {};
	        _this.data = {};
	        _this.sessions = {};
	        _this.subscriptions = {};
	        _this.earlySubscriptions = {};
	        _this.publishers = {};
	        _this.status = Enums.UAStatus.STATUS_INIT;
	        _this.transactions = {
	            nist: {},
	            nict: {},
	            ist: {},
	            ict: {}
	        };
	        /**
	         * Load configuration
	         *
	         * @throws {SIP.Exceptions.ConfigurationError}
	         * @throws {TypeError}
	         */
	        if (configuration === undefined) {
	            configuration = {};
	        }
	        else if (typeof configuration === "string" || configuration instanceof String) {
	            configuration = {
	                uri: configuration
	            };
	        }
	        // Apply log configuration if present
	        if (configuration.log) {
	            if (configuration.log.hasOwnProperty("builtinEnabled")) {
	                _this.log.builtinEnabled = configuration.log.builtinEnabled;
	            }
	            if (configuration.log.hasOwnProperty("connector")) {
	                _this.log.connector = configuration.log.connector;
	            }
	            if (configuration.log.hasOwnProperty("level")) {
	                var level = configuration.log.level;
	                var normalized = typeof level === "string" ? LoggerFactory_1.Levels[level] : level;
	                // avoid setting level when invalid, use default level instead
	                if (!normalized) {
	                    _this.logger.error("Invalid \"level\" parameter value: " + JSON.stringify(level));
	                }
	                else {
	                    _this.log.level = normalized;
	                }
	            }
	        }
	        try {
	            _this.loadConfig(configuration);
	        }
	        catch (e) {
	            _this.status = Enums.UAStatus.STATUS_NOT_READY;
	            _this.error = UA.C.CONFIGURATION_ERROR;
	            throw e;
	        }
	        // Initialize registerContext
	        _this.registerContext = new RegisterContext_1.RegisterContext(_this, configuration.registerOptions);
	        _this.registerContext.on("failed", _this.emit.bind(_this, "registrationFailed"));
	        _this.registerContext.on("registered", _this.emit.bind(_this, "registered"));
	        _this.registerContext.on("unregistered", _this.emit.bind(_this, "unregistered"));
	        if (_this.configuration.autostart) {
	            _this.start();
	        }
	        return _this;
	    }
	    Object.defineProperty(UA.prototype, "transactionsCount", {
	        get: function () {
	            var count = 0;
	            for (var _i = 0, _a = ["nist", "nict", "ist", "ict"]; _i < _a.length; _i++) {
	                var type = _a[_i];
	                count += Object.keys(this.transactions[type]).length;
	            }
	            return count;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(UA.prototype, "nictTransactionsCount", {
	        get: function () {
	            return Object.keys(this.transactions.nict).length;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(UA.prototype, "nistTransactionsCount", {
	        get: function () {
	            return Object.keys(this.transactions.nist).length;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(UA.prototype, "ictTransactionsCount", {
	        get: function () {
	            return Object.keys(this.transactions.ict).length;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(UA.prototype, "istTransactionsCount", {
	        get: function () {
	            return Object.keys(this.transactions.ist).length;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    // =================
	    //  High Level API
	    // =================
	    UA.prototype.register = function (options) {
	        if (options === void 0) { options = {}; }
	        if (options.register) {
	            this.configuration.register = true;
	        }
	        this.registerContext.register(options);
	        return this;
	    };
	    /**
	     * Unregister.
	     *
	     * @param {Boolean} [all] unregister all user bindings.
	     *
	     */
	    UA.prototype.unregister = function (options) {
	        var _this = this;
	        this.configuration.register = false;
	        if (this.transport) {
	            this.transport.afterConnected(function () {
	                _this.registerContext.unregister(options);
	            });
	        }
	        return this;
	    };
	    UA.prototype.isRegistered = function () {
	        return this.registerContext.registered;
	    };
	    /**
	     * Make an outgoing call.
	     *
	     * @param {String} target
	     * @param {Object} views
	     * @param {Object} [options.media] gets passed to SIP.sessionDescriptionHandler.getDescription as mediaHint
	     *
	     * @throws {TypeError}
	     *
	     */
	    UA.prototype.invite = function (target, options, modifiers) {
	        var _this = this;
	        var context = new Session_1.InviteClientContext(this, target, options, modifiers);
	        // Delay sending actual invite until the next 'tick' if we are already
	        // connected, so that API consumers can register to events fired by the
	        // the session.
	        if (this.transport) {
	            this.transport.afterConnected(function () {
	                context.invite();
	                _this.emit("inviteSent", context);
	            });
	        }
	        return context;
	    };
	    UA.prototype.subscribe = function (target, event, options) {
	        var sub = new Subscription_1.Subscription(this, target, event, options);
	        if (this.transport) {
	            this.transport.afterConnected(function () { return sub.subscribe(); });
	        }
	        return sub;
	    };
	    /**
	     * Send PUBLISH Event State Publication (RFC3903)
	     *
	     * @param {String} target
	     * @param {String} event
	     * @param {String} body
	     * @param {Object} [options]
	     *
	     * @throws {SIP.Exceptions.MethodParameterError}
	     */
	    UA.prototype.publish = function (target, event, body, options) {
	        var pub = new PublishContext_1.PublishContext(this, target, event, options);
	        if (this.transport) {
	            this.transport.afterConnected(function () {
	                pub.publish(body);
	            });
	        }
	        return pub;
	    };
	    /**
	     * Send a message.
	     *
	     * @param {String} target
	     * @param {String} body
	     * @param {Object} [options]
	     *
	     * @throws {TypeError}
	     */
	    UA.prototype.message = function (target, body, options) {
	        if (options === void 0) { options = {}; }
	        if (body === undefined) {
	            throw new TypeError("Not enough arguments");
	        }
	        // There is no Message module, so it is okay that the UA handles defaults here.
	        options.contentType = options.contentType || "text/plain";
	        options.body = body;
	        return this.request(Constants.C.MESSAGE, target, options);
	    };
	    UA.prototype.request = function (method, target, options) {
	        var req = new ClientContext_1.ClientContext(this, method, target, options);
	        if (this.transport) {
	            this.transport.afterConnected(function () { return req.send(); });
	        }
	        return req;
	    };
	    /**
	     * Gracefully close.
	     */
	    UA.prototype.stop = function () {
	        var _this = this;
	        this.logger.log("user requested closure...");
	        if (this.status === Enums.UAStatus.STATUS_USER_CLOSED) {
	            this.logger.warn("UA already closed");
	            return this;
	        }
	        // Close registerContext
	        this.logger.log("closing registerContext");
	        this.registerContext.close();
	        // Run  _terminate_ on every Session
	        for (var session in this.sessions) {
	            if (this.sessions[session]) {
	                this.logger.log("closing session " + session);
	                this.sessions[session].terminate();
	            }
	        }
	        // Run _close_ on every confirmed Subscription
	        for (var subscription in this.subscriptions) {
	            if (this.subscriptions[subscription]) {
	                this.logger.log("unsubscribing from subscription " + subscription);
	                this.subscriptions[subscription].close();
	            }
	        }
	        // Run _close_ on every early Subscription
	        for (var earlySubscription in this.earlySubscriptions) {
	            if (this.earlySubscriptions[earlySubscription]) {
	                this.logger.log("unsubscribing from early subscription " + earlySubscription);
	                this.earlySubscriptions[earlySubscription].close();
	            }
	        }
	        // Run _close_ on every Publisher
	        for (var publisher in this.publishers) {
	            if (this.publishers[publisher]) {
	                this.logger.log("unpublish " + publisher);
	                this.publishers[publisher].close();
	            }
	        }
	        // Run  _close_ on every applicant
	        for (var applicant in this.applicants) {
	            if (this.applicants[applicant]) {
	                this.applicants[applicant].close();
	            }
	        }
	        this.status = Enums.UAStatus.STATUS_USER_CLOSED;
	        /*
	         * If the remaining transactions are all INVITE transactions, there is no need to
	         * wait anymore because every session has already been closed by this method.
	         * - locally originated sessions where terminated (CANCEL or BYE)
	         * - remotely originated sessions where rejected (4XX) or terminated (BYE)
	         * Remaining INVITE transactions belong tho sessions that where answered. This are in
	         * 'accepted' state due to timers 'L' and 'M' defined in [RFC 6026]
	         */
	        if (this.nistTransactionsCount === 0 && this.nictTransactionsCount === 0 && this.transport) {
	            this.transport.disconnect();
	        }
	        else {
	            var transactionsListener_1 = function () {
	                if (_this.nistTransactionsCount === 0 && _this.nictTransactionsCount === 0) {
	                    _this.removeListener("transactionDestroyed", transactionsListener_1);
	                    if (_this.transport) {
	                        _this.transport.disconnect();
	                    }
	                }
	            };
	            this.on("transactionDestroyed", transactionsListener_1);
	        }
	        if (typeof environment.removeEventListener === "function") {
	            // Google Chrome Packaged Apps don't allow 'unload' listeners:
	            // unload is not available in packaged apps
	            if (!(commonjsGlobal.chrome && commonjsGlobal.chrome.app && commonjsGlobal.chrome.app.runtime)) {
	                environment.removeEventListener("unload", this.environListener);
	            }
	        }
	        return this;
	    };
	    /**
	     * Connect to the WS server if status = STATUS_INIT.
	     * Resume UA after being closed.
	     *
	     */
	    UA.prototype.start = function () {
	        var _this = this;
	        this.logger.log("user requested startup...");
	        if (this.status === Enums.UAStatus.STATUS_INIT) {
	            this.status = Enums.UAStatus.STATUS_STARTING;
	            if (!this.configuration.transportConstructor) {
	                throw new Exceptions_1.Exceptions.TransportError("Transport constructor not set");
	            }
	            this.transport = new this.configuration.transportConstructor(this.getLogger("sip.transport"), this.configuration.transportOptions);
	            this.setTransportListeners();
	            this.emit("transportCreated", this.transport);
	            this.transport.connect();
	        }
	        else if (this.status === Enums.UAStatus.STATUS_USER_CLOSED) {
	            this.logger.log("resuming");
	            this.status = Enums.UAStatus.STATUS_READY;
	            if (this.transport) {
	                this.transport.connect();
	            }
	        }
	        else if (this.status === Enums.UAStatus.STATUS_STARTING) {
	            this.logger.log("UA is in STARTING status, not opening new connection");
	        }
	        else if (this.status === Enums.UAStatus.STATUS_READY) {
	            this.logger.log("UA is in READY status, not resuming");
	        }
	        else {
	            this.logger.error("Connection is down. Auto-Recovery system is trying to connect");
	        }
	        if (this.configuration.autostop && typeof environment.addEventListener === "function") {
	            // Google Chrome Packaged Apps don't allow 'unload' listeners:
	            // unload is not available in packaged apps
	            if (!(commonjsGlobal.chrome && commonjsGlobal.chrome.app && commonjsGlobal.chrome.app.runtime)) {
	                this.environListener = this.stop;
	                environment.addEventListener("unload", function () { return _this.environListener(); });
	            }
	        }
	        return this;
	    };
	    /**
	     * Normalize a string into a valid SIP request URI
	     *
	     * @param {String} target
	     *
	     * @returns {SIP.URI|undefined}
	     */
	    UA.prototype.normalizeTarget = function (target) {
	        return Utils_1.Utils.normalizeTarget(target, this.configuration.hostportParams);
	    };
	    UA.prototype.getLogger = function (category, label) {
	        return this.log.getLogger(category, label);
	    };
	    UA.prototype.getLoggerFactory = function () {
	        return this.log;
	    };
	    // TODO: Transaction matching currently works circumstanially.
	    //
	    // 17.1.3 Matching Responses to Client Transactions
	    //
	    // When the transport layer in the client receives a response, it has to
	    // determine which client transaction will handle the response, so that
	    // the processing of Sections 17.1.1 and 17.1.2 can take place.  The
	    // branch parameter in the top Via header field is used for this
	    // purpose.  A response matches a client transaction under two
	    // conditions:
	    //
	    //    1.  If the response has the same value of the branch parameter in
	    //        the top Via header field as the branch parameter in the top
	    //        Via header field of the request that created the transaction.
	    //
	    //    2.  If the method parameter in the CSeq header field matches the
	    //        method of the request that created the transaction.  The
	    //        method is needed since a CANCEL request constitutes a
	    //        different transaction, but shares the same value of the branch
	    //        parameter.
	    /**
	     * new Transaction
	     * @private
	     * @param {SIP.Transaction} transaction.
	     */
	    UA.prototype.newTransaction = function (transaction) {
	        this.transactions[transaction.kind][transaction.id] = transaction;
	        this.emit("newTransaction", { transaction: transaction });
	    };
	    /**
	     * destroy Transaction
	     * @param {SIP.Transaction} transaction.
	     */
	    UA.prototype.destroyTransaction = function (transaction) {
	        delete this.transactions[transaction.kind][transaction.id];
	        this.emit("transactionDestroyed", { transaction: transaction });
	    };
	    /**
	     * Get the session to which the request belongs to, if any.
	     * @param {SIP.IncomingRequest} request.
	     * @returns {SIP.OutgoingSession|SIP.IncomingSession|undefined}
	     */
	    UA.prototype.findSession = function (request) {
	        return this.sessions[request.callId + request.fromTag] ||
	            this.sessions[request.callId + request.toTag] ||
	            undefined;
	    };
	    UA.prototype.on = function (name, callback) { return _super.prototype.on.call(this, name, callback); };
	    // ===============================
	    //  Private (For internal use)
	    // ===============================
	    UA.prototype.saveCredentials = function (credentials) {
	        this.cache.credentials[credentials.realm] = this.cache.credentials[credentials.realm] || {};
	        this.cache.credentials[credentials.realm][credentials.uri] = credentials;
	        return this;
	    };
	    UA.prototype.getCredentials = function (request) {
	        var realm = request.ruri.type === Enums.TypeStrings.URI ? request.ruri.host : "";
	        if (realm && this.cache.credentials[realm] && this.cache.credentials[realm][request.ruri.toString()]) {
	            var credentials = this.cache.credentials[realm][request.ruri.toString()];
	            credentials.method = request.method;
	            return credentials;
	        }
	    };
	    // ==============================
	    // Event Handlers
	    // ==============================
	    UA.prototype.onTransportError = function () {
	        if (this.status === Enums.UAStatus.STATUS_USER_CLOSED) {
	            return;
	        }
	        if (!this.error || this.error !== UA.C.NETWORK_ERROR) {
	            this.status = Enums.UAStatus.STATUS_NOT_READY;
	            this.error = UA.C.NETWORK_ERROR;
	        }
	    };
	    /**
	     * Helper function. Sets transport listeners
	     */
	    UA.prototype.setTransportListeners = function () {
	        var _this = this;
	        if (this.transport) {
	            this.transport.on("connected", function () { return _this.onTransportConnected(); });
	            this.transport.on("message", function (message) { return _this.onTransportReceiveMsg(message); });
	            this.transport.on("transportError", function () { return _this.onTransportError(); });
	        }
	    };
	    /**
	     * Transport connection event.
	     * @event
	     * @param {SIP.Transport} transport.
	     */
	    UA.prototype.onTransportConnected = function () {
	        var _this = this;
	        if (this.configuration.register) {
	            // In an effor to maintain behavior from when we "initialized" an
	            // authentication factory, this is in a Promise.then
	            Promise.resolve().then(function () { return _this.registerContext.register(); });
	        }
	    };
	    /**
	     * Handle SIP message received from the transport.
	     * @param messageString The message.
	     */
	    UA.prototype.onTransportReceiveMsg = function (messageString) {
	        var message = Parser_1.Parser.parseMessage(messageString, this);
	        if (!message) {
	            this.logger.warn("UA failed to parse incoming SIP message - discarding.");
	            return;
	        }
	        if (this.status === Enums.UAStatus.STATUS_USER_CLOSED && message instanceof SIPMessage.IncomingRequest) {
	            this.logger.warn("UA received message when status = USER_CLOSED - aborting");
	            return;
	        }
	        if (!this.transport) {
	            this.logger.warn("UA received message without transport - aborting");
	            return;
	        }
	        if (!SanityCheck_1.SanityCheck.sanityCheck(message, this, this.transport)) {
	            return;
	        }
	        if (message instanceof SIPMessage.IncomingRequest) {
	            this.receiveRequestFromTransport(message);
	            return;
	        }
	        if (message instanceof SIPMessage.IncomingResponse) {
	            this.receiveResponseFromTransport(message);
	            return;
	        }
	        throw new Error("Invalid message type.");
	    };
	    UA.prototype.receiveRequestFromTransport = function (request) {
	        // FIXME: Bad hack. SIPMessage needs refactor.
	        request.transport = this.transport;
	        // FIXME: Configuration URI is a bad mix of tyes currently and needs to exist.
	        if (!(this.configuration.uri instanceof URI_1.URI)) {
	            throw new Error("Configuration URI not instance of URI.");
	        }
	        // FIXME: A request should always have an ruri
	        if (!request.ruri) {
	            throw new Error("Request ruri undefined.");
	        }
	        // If the Request-URI uses a scheme not supported by the UAS, it SHOULD
	        // reject the request with a 416 (Unsupported URI Scheme) response.
	        // https://tools.ietf.org/html/rfc3261#section-8.2.2.1
	        if (request.ruri.scheme !== Constants.C.SIP) {
	            request.reply_sl(416);
	            return;
	        }
	        // If the Request-URI does not identify an address that the
	        // UAS is willing to accept requests for, it SHOULD reject
	        // the request with a 404 (Not Found) response.
	        // https://tools.ietf.org/html/rfc3261#section-8.2.2.1
	        var ruri = request.ruri;
	        var ruriMatches = function (uri) {
	            return !!uri && uri.user === ruri.user;
	        };
	        if (!ruriMatches(this.configuration.uri) &&
	            !(ruriMatches(this.contact.uri) || ruriMatches(this.contact.pubGruu) || ruriMatches(this.contact.tempGruu))) {
	            this.logger.warn("Request-URI does not point to us");
	            if (request.method !== Constants.C.ACK) {
	                request.reply_sl(404);
	            }
	            return;
	        }
	        // When a request is received from the network by the server, it has to
	        // be matched to an existing transaction.  This is accomplished in the
	        // following manner.
	        //
	        // The branch parameter in the topmost Via header field of the request
	        // is examined.  If it is present and begins with the magic cookie
	        // "z9hG4bK", the request was generated by a client transaction
	        // compliant to this specification.  Therefore, the branch parameter
	        // will be unique across all transactions sent by that client.  The
	        // request matches a transaction if:
	        //
	        //    1. the branch parameter in the request is equal to the one in the
	        //       top Via header field of the request that created the
	        //       transaction, and
	        //
	        //    2. the sent-by value in the top Via of the request is equal to the
	        //       one in the request that created the transaction, and
	        //
	        //    3. the method of the request matches the one that created the
	        //       transaction, except for ACK, where the method of the request
	        //       that created the transaction is INVITE.
	        //
	        // This matching rule applies to both INVITE and non-INVITE transactions
	        // alike.
	        //
	        //    The sent-by value is used as part of the matching process because
	        //    there could be accidental or malicious duplication of branch
	        //    parameters from different clients.
	        // https://tools.ietf.org/html/rfc3261#section-17.2.3
	        // FIXME: The current transaction layer curently only matches on branch parameter.
	        // Request matches branch parameter of an existing invite server transaction.
	        var ist = this.transactions.ist[request.viaBranch];
	        // Request matches branch parameter of an existing non-invite server transaction.
	        var nist = this.transactions.nist[request.viaBranch];
	        // The CANCEL method requests that the TU at the server side cancel a
	        // pending transaction.  The TU determines the transaction to be
	        // cancelled by taking the CANCEL request, and then assuming that the
	        // request method is anything but CANCEL or ACK and applying the
	        // transaction matching procedures of Section 17.2.3.  The matching
	        // transaction is the one to be cancelled.
	        // https://tools.ietf.org/html/rfc3261#section-9.2
	        if (request.method === Constants.C.CANCEL) {
	            if (ist || nist) {
	                // Regardless of the method of the original request, as long as the
	                // CANCEL matched an existing transaction, the UAS answers the CANCEL
	                // request itself with a 200 (OK) response.
	                // https://tools.ietf.org/html/rfc3261#section-9.2
	                request.reply_sl(200);
	                // If the transaction for the original request still exists, the behavior
	                // of the UAS on receiving a CANCEL request depends on whether it has already
	                // sent a final response for the original request. If it has, the CANCEL
	                // request has no effect on the processing of the original request, no
	                // effect on any session state, and no effect on the responses generated
	                // for the original request. If the UAS has not issued a final response
	                // for the original request, its behavior depends on the method of the
	                // original request. If the original request was an INVITE, the UAS
	                // SHOULD immediately respond to the INVITE with a 487 (Request
	                // Terminated). A CANCEL request has no impact on the processing of
	                // transactions with any other method defined in this specification.
	                // https://tools.ietf.org/html/rfc3261#section-9.2
	                if (ist && ist.state === Transactions.TransactionState.Proceeding) {
	                    // TODO: Review this.
	                    // The cancel request has been replied to, which is an exception.
	                    this.receiveRequest(request);
	                }
	            }
	            else {
	                // If the UAS did not find a matching transaction for the CANCEL
	                // according to the procedure above, it SHOULD respond to the CANCEL
	                // with a 481 (Call Leg/Transaction Does Not Exist).
	                // https://tools.ietf.org/html/rfc3261#section-9.2
	                request.reply_sl(481);
	            }
	            return;
	        }
	        // When receiving an ACK that matches an existing INVITE server
	        // transaction and that does not contain a branch parameter containing
	        // the magic cookie defined in RFC 3261, the matching transaction MUST
	        // be checked to see if it is in the "Accepted" state.  If it is, then
	        // the ACK must be passed directly to the transaction user instead of
	        // being absorbed by the transaction state machine.  This is necessary
	        // as requests from RFC 2543 clients will not include a unique branch
	        // parameter, and the mechanisms for calculating the transaction ID from
	        // such a request will be the same for both INVITE and ACKs.
	        // https://tools.ietf.org/html/rfc6026#section-6
	        // Any ACKs received from the network while in the "Accepted" state MUST be
	        // passed directly to the TU and not absorbed.
	        // https://tools.ietf.org/html/rfc6026#section-7.1
	        if (request.method === Constants.C.ACK) {
	            if (ist && ist.state === Transactions.TransactionState.Accepted) {
	                this.receiveRequest(request);
	                return;
	            }
	        }
	        // If a matching server transaction is found, the request is passed to that
	        // transaction for processing.
	        // https://tools.ietf.org/html/rfc6026#section-8.10
	        if (ist) {
	            ist.receiveRequest(request);
	            return;
	        }
	        if (nist) {
	            nist.receiveRequest(request);
	            return;
	        }
	        // If no match is found, the request is passed to the core, which may decide to
	        // construct a new server transaction for that request.
	        // https://tools.ietf.org/html/rfc6026#section-8.10
	        this.receiveRequest(request);
	    };
	    UA.prototype.receiveResponseFromTransport = function (response) {
	        // When the transport layer in the client receives a response, it has to
	        // determine which client transaction will handle the response, so that
	        // the processing of Sections 17.1.1 and 17.1.2 can take place.  The
	        // branch parameter in the top Via header field is used for this
	        // purpose.  A response matches a client transaction under two
	        // conditions:
	        //
	        //    1.  If the response has the same value of the branch parameter in
	        //        the top Via header field as the branch parameter in the top
	        //        Via header field of the request that created the transaction.
	        //
	        //    2.  If the method parameter in the CSeq header field matches the
	        //        method of the request that created the transaction.  The
	        //        method is needed since a CANCEL request constitutes a
	        //        different transaction, but shares the same value of the branch
	        //        parameter.
	        // https://tools.ietf.org/html/rfc3261#section-17.1.3
	        // The client transport uses the matching procedures of Section
	        // 17.1.3 to attempt to match the response to an existing
	        // transaction.  If there is a match, the response MUST be passed to
	        // that transaction.  Otherwise, any element other than a stateless
	        // proxy MUST silently discard the response.
	        // https://tools.ietf.org/html/rfc6026#section-8.9
	        var transaction;
	        switch (response.method) {
	            case Constants.C.INVITE:
	                transaction = this.transactions.ict[response.viaBranch];
	                break;
	            case Constants.C.ACK:
	                // Just in case ;-)
	                break;
	            default:
	                transaction = this.transactions.nict[response.viaBranch];
	                break;
	        }
	        if (!transaction) {
	            var message = "Discarding unmatched " + response.statusCode + " response to " + response.method + " " + response.viaBranch + ".";
	            this.logger.warn(message);
	            return;
	        }
	        // FIXME: Bad hack. Potentially creating circular dependancy. SIPMessage needs refactor.
	        response.transaction = transaction;
	        // Pass incoming response to matching transaction.
	        transaction.receiveResponse(response);
	    };
	    /**
	     * Request reception
	     * @private
	     * @param {SIP.IncomingRequest} request.
	     */
	    UA.prototype.receiveRequest = function (request) {
	        var _this = this;
	        /* RFC3261 12.2.2
	        * Requests that do not change in any way the state of a dialog may be
	        * received within a dialog (for example, an OPTIONS request).
	        * They are processed as if they had been received outside the dialog.
	        */
	        var method = request.method;
	        var message;
	        if (method === Constants.C.OPTIONS) {
	            var transport = this.transport;
	            if (!transport) {
	                throw new Error("Transport undefined.");
	            }
	            var user = {
	                loggerFactory: this.getLoggerFactory(),
	                onStateChange: function (newState) {
	                    if (newState === Transactions.TransactionState.Terminated) {
	                        _this.destroyTransaction(optionsTransaction_1);
	                    }
	                },
	                onTransportError: function (error) {
	                    _this.logger.error(error.message);
	                }
	            };
	            var optionsTransaction_1 = new Transactions.NonInviteServerTransaction(request, transport, user);
	            this.newTransaction(optionsTransaction_1);
	            request.reply(200, undefined, [
	                "Allow: " + UA.C.ALLOWED_METHODS.toString(),
	                "Accept: " + UA.C.ACCEPTED_BODY_TYPES.toString()
	            ]);
	        }
	        else if (method === Constants.C.MESSAGE) {
	            message = new ServerContext_1.ServerContext(this, request);
	            message.body = request.body;
	            message.contentType = request.getHeader("Content-Type") || "text/plain";
	            request.reply(200, undefined);
	            this.emit("message", message);
	        }
	        else if (method !== Constants.C.INVITE &&
	            method !== Constants.C.ACK) {
	            // Let those methods pass through to normal processing for now.
	            message = new ServerContext_1.ServerContext(this, request);
	        }
	        // Initial Request
	        if (!request.toTag) {
	            switch (method) {
	                case Constants.C.INVITE:
	                    var replaces = this.configuration.replaces !== Constants.C.supported.UNSUPPORTED &&
	                        request.parseHeader("replaces");
	                    var replacedDialog = void 0;
	                    if (replaces) {
	                        replacedDialog = this.dialogs[replaces.call_id + replaces.replaces_to_tag + replaces.replaces_from_tag];
	                        if (!replacedDialog) {
	                            // Replaced header without a matching dialog, reject
	                            request.reply_sl(481, undefined);
	                            return;
	                        }
	                        else if (!(replacedDialog.owner.type === Enums.TypeStrings.Subscription) &&
	                            replacedDialog.owner.status
	                                === Enums.SessionStatus.STATUS_TERMINATED) {
	                            request.reply_sl(603, undefined);
	                            return;
	                        }
	                        else if (replacedDialog.state === Enums.DialogStatus.STATUS_CONFIRMED && replaces.earlyOnly) {
	                            request.reply_sl(486, undefined);
	                            return;
	                        }
	                    }
	                    var newSession = new Session_1.InviteServerContext(this, request);
	                    if (replacedDialog && !(replacedDialog.owner.type === Enums.TypeStrings.Subscription)) {
	                        newSession.replacee = replacedDialog && replacedDialog.owner;
	                    }
	                    this.emit("invite", newSession);
	                    break;
	                case Constants.C.BYE:
	                    // Out of dialog BYE received
	                    request.reply(481);
	                    break;
	                case Constants.C.CANCEL:
	                    var session = this.findSession(request);
	                    if (session) {
	                        session.receiveRequest(request);
	                    }
	                    else {
	                        this.logger.warn("received CANCEL request for a non existent session");
	                    }
	                    break;
	                case Constants.C.ACK:
	                    /* Absorb it.
	                    * ACK request without a corresponding Invite Transaction
	                    * and without To tag.
	                    */
	                    break;
	                case Constants.C.NOTIFY:
	                    if (this.configuration.allowLegacyNotifications && this.listeners("notify").length > 0) {
	                        request.reply(200, undefined);
	                        this.emit("notify", { request: request });
	                    }
	                    else {
	                        request.reply(481, "Subscription does not exist");
	                    }
	                    break;
	                case Constants.C.REFER:
	                    this.logger.log("Received an out of dialog refer");
	                    if (this.configuration.allowOutOfDialogRefers) {
	                        this.logger.log("Allow out of dialog refers is enabled on the UA");
	                        var referContext = new Session_1.ReferServerContext(this, request);
	                        if (this.listeners("outOfDialogReferRequested").length) {
	                            this.emit("outOfDialogReferRequested", referContext);
	                        }
	                        else {
	                            this.logger.log("No outOfDialogReferRequest listeners," +
	                                " automatically accepting and following the out of dialog refer");
	                            referContext.accept({ followRefer: true });
	                        }
	                        break;
	                    }
	                    request.reply(405);
	                    break;
	                default:
	                    request.reply(405);
	                    break;
	            }
	        }
	        else { // In-dialog request
	            var dialog_1 = this.findDialog(request);
	            if (dialog_1) {
	                if (method === Constants.C.INVITE) {
	                    var transport = this.transport;
	                    if (!transport) {
	                        throw new Error("Transport undefined.");
	                    }
	                    var user = {
	                        loggerFactory: this.log,
	                        onStateChange: function (newState) {
	                            if (newState === Transactions.TransactionState.Terminated) {
	                                _this.destroyTransaction(ist_1);
	                            }
	                        },
	                        onTransportError: function (error) {
	                            _this.logger.error(error.message);
	                            dialog_1.owner.onTransportError();
	                        }
	                    };
	                    var ist_1 = new Transactions.InviteServerTransaction(request, transport, user);
	                    this.newTransaction(ist_1);
	                }
	                dialog_1.receiveRequest(request);
	            }
	            else if (method === Constants.C.NOTIFY) {
	                var session = this.findSession(request);
	                var earlySubscription = this.findEarlySubscription(request);
	                if (session) {
	                    session.receiveRequest(request);
	                }
	                else if (earlySubscription) {
	                    earlySubscription.receiveRequest(request);
	                }
	                else {
	                    this.logger.warn("received NOTIFY request for a non existent session or subscription");
	                    request.reply(481, "Subscription does not exist");
	                }
	            }
	            else {
	                /* RFC3261 12.2.2
	                 * Request with to tag, but no matching dialog found.
	                 * Exception: ACK for an Invite request for which a dialog has not
	                 * been created.
	                 */
	                if (method !== Constants.C.ACK) {
	                    request.reply(481);
	                }
	            }
	        }
	    };
	    // =================
	    // Utils
	    // =================
	    /**
	     * Get the dialog to which the request belongs to, if any.
	     * @param {SIP.IncomingRequest}
	     * @returns {SIP.Dialog|undefined}
	     */
	    UA.prototype.findDialog = function (request) {
	        return this.dialogs[request.callId + request.fromTag + request.toTag] ||
	            this.dialogs[request.callId + request.toTag + request.fromTag] ||
	            undefined;
	    };
	    /**
	     * Get the subscription which has not been confirmed to which the request belongs to, if any
	     * @param {SIP.IncomingRequest}
	     * @returns {SIP.Subscription|undefined}
	     */
	    UA.prototype.findEarlySubscription = function (request) {
	        return this.earlySubscriptions[request.callId + request.toTag + request.getHeader("event")] || undefined;
	    };
	    UA.prototype.checkAuthenticationFactory = function (authenticationFactory) {
	        if (!(authenticationFactory instanceof Function)) {
	            return;
	        }
	        if (!authenticationFactory.initialize) {
	            authenticationFactory.initialize = function () {
	                return Promise.resolve();
	            };
	        }
	        return authenticationFactory;
	    };
	    /**
	     * Configuration load.
	     * returns {void}
	     */
	    UA.prototype.loadConfig = function (configuration) {
	        var _this = this;
	        // Settings and default values
	        var settings = {
	            /* Host address
	             * Value to be set in Via sent_by and host part of Contact FQDN
	             */
	            viaHost: Utils_1.Utils.createRandomToken(12) + ".invalid",
	            uri: new URI_1.URI("sip", "anonymous." + Utils_1.Utils.createRandomToken(6), "anonymous.invalid", undefined, undefined),
	            // Custom Configuration Settings
	            custom: {},
	            // Display name
	            displayName: "",
	            // Password
	            password: undefined,
	            register: true,
	            // Registration parameters
	            registerOptions: {},
	            // Transport related parameters
	            transportConstructor: Transport_2$1.Transport,
	            transportOptions: {},
	            // string to be inserted into User-Agent request header
	            userAgentString: Constants.C.USER_AGENT,
	            // Session parameters
	            noAnswerTimeout: 60,
	            // Hacks
	            hackViaTcp: false,
	            hackIpInContact: false,
	            hackWssInTransport: false,
	            hackAllowUnregisteredOptionTags: false,
	            // Session Description Handler Options
	            sessionDescriptionHandlerFactoryOptions: {
	                constraints: {},
	                peerConnectionOptions: {}
	            },
	            extraSupported: [],
	            contactName: Utils_1.Utils.createRandomToken(8),
	            contactTransport: "ws",
	            forceRport: false,
	            // autostarting
	            autostart: true,
	            autostop: true,
	            // Reliable Provisional Responses
	            rel100: Constants.C.supported.UNSUPPORTED,
	            // DTMF type: 'info' or 'rtp' (RFC 4733)
	            // RTP Payload Spec: https://tools.ietf.org/html/rfc4733
	            // WebRTC Audio Spec: https://tools.ietf.org/html/rfc7874
	            dtmfType: Constants.C.dtmfType.INFO,
	            // Replaces header (RFC 3891)
	            // http://tools.ietf.org/html/rfc3891
	            replaces: Constants.C.supported.UNSUPPORTED,
	            sessionDescriptionHandlerFactory: SessionDescriptionHandler_1.SessionDescriptionHandler.defaultFactory,
	            authenticationFactory: this.checkAuthenticationFactory(function (ua) {
	                return new DigestAuthentication_1.DigestAuthentication(ua);
	            }),
	            allowLegacyNotifications: false,
	            allowOutOfDialogRefers: false,
	        };
	        var configCheck = this.getConfigurationCheck();
	        // Check Mandatory parameters
	        for (var parameter in configCheck.mandatory) {
	            if (!configuration.hasOwnProperty(parameter)) {
	                throw new Exceptions_1.Exceptions.ConfigurationError(parameter);
	            }
	            else {
	                var value = configuration[parameter];
	                var checkedValue = configCheck.mandatory[parameter](value);
	                if (checkedValue !== undefined) {
	                    settings[parameter] = checkedValue;
	                }
	                else {
	                    throw new Exceptions_1.Exceptions.ConfigurationError(parameter, value);
	                }
	            }
	        }
	        // Check Optional parameters
	        for (var parameter in configCheck.optional) {
	            if (configuration.hasOwnProperty(parameter)) {
	                var value = configuration[parameter];
	                // If the parameter value is an empty array, but shouldn't be, apply its default value.
	                // If the parameter value is null, empty string, or undefined then apply its default value.
	                // If it's a number with NaN value then also apply its default value.
	                // NOTE: JS does not allow "value === NaN", the following does the work:
	                if ((value instanceof Array && value.length === 0) ||
	                    (value === null || value === "" || value === undefined) ||
	                    (typeof (value) === "number" && isNaN(value))) {
	                    continue;
	                }
	                var checkedValue = configCheck.optional[parameter](value);
	                if (checkedValue !== undefined) {
	                    settings[parameter] = checkedValue;
	                }
	                else {
	                    throw new Exceptions_1.Exceptions.ConfigurationError(parameter, value);
	                }
	            }
	        }
	        // Post Configuration Process
	        // Allow passing 0 number as displayName.
	        if (settings.displayName === 0) {
	            settings.displayName = "0";
	        }
	        // sipjsId instance parameter. Static random tag of length 5
	        settings.sipjsId = Utils_1.Utils.createRandomToken(5);
	        // String containing settings.uri without scheme and user.
	        var hostportParams = settings.uri.clone();
	        hostportParams.user = undefined;
	        settings.hostportParams = hostportParams.toRaw().replace(/^sip:/i, "");
	        /* Check whether authorizationUser is explicitly defined.
	         * Take 'settings.uri.user' value if not.
	         */
	        if (!settings.authorizationUser) {
	            settings.authorizationUser = settings.uri.user;
	        }
	        // User noAnswerTimeout
	        settings.noAnswerTimeout = settings.noAnswerTimeout * 1000;
	        // Via Host
	        if (settings.hackIpInContact) {
	            if (typeof settings.hackIpInContact === "boolean") {
	                var from = 1;
	                var to = 254;
	                var octet = Math.floor(Math.random() * (to - from + 1) + from);
	                // random Test-Net IP (http://tools.ietf.org/html/rfc5735)
	                settings.viaHost = "192.0.2." + octet;
	            }
	            else if (typeof settings.hackIpInContact === "string") {
	                settings.viaHost = settings.hackIpInContact;
	            }
	        }
	        // Contact transport parameter
	        if (settings.hackWssInTransport) {
	            settings.contactTransport = "wss";
	        }
	        this.contact = {
	            pubGruu: undefined,
	            tempGruu: undefined,
	            uri: new URI_1.URI("sip", settings.contactName, settings.viaHost, undefined, { transport: settings.contactTransport }),
	            toString: function (options) {
	                if (options === void 0) { options = {}; }
	                var anonymous = options.anonymous || false;
	                var outbound = options.outbound || false;
	                var contact = "<";
	                if (anonymous) {
	                    contact += (_this.contact.tempGruu ||
	                        ("sip:anonymous@anonymous.invalid;transport=" + settings.contactTransport)).toString();
	                }
	                else {
	                    contact += (_this.contact.pubGruu || _this.contact.uri).toString();
	                }
	                if (outbound) {
	                    contact += ";ob";
	                }
	                contact += ">";
	                return contact;
	            }
	        };
	        var skeleton = {};
	        // Fill the value of the configuration_skeleton
	        for (var parameter in settings) {
	            if (settings.hasOwnProperty(parameter)) {
	                skeleton[parameter] = settings[parameter];
	            }
	        }
	        Object.assign(this.configuration, skeleton);
	        this.logger.log("configuration parameters after validation:");
	        for (var parameter in settings) {
	            if (settings.hasOwnProperty(parameter)) {
	                switch (parameter) {
	                    case "uri":
	                    case "sessionDescriptionHandlerFactory":
	                        this.logger.log("· " + parameter + ": " + settings[parameter]);
	                        break;
	                    case "password":
	                        this.logger.log("· " + parameter + ": " + "NOT SHOWN");
	                        break;
	                    case "transportConstructor":
	                        this.logger.log("· " + parameter + ": " + settings[parameter].name);
	                        break;
	                    default:
	                        this.logger.log("· " + parameter + ": " + JSON.stringify(settings[parameter]));
	                }
	            }
	        }
	        return;
	    };
	    /**
	     * Configuration checker.
	     * @return {Boolean}
	     */
	    UA.prototype.getConfigurationCheck = function () {
	        return {
	            mandatory: {},
	            optional: {
	                uri: function (uri) {
	                    if (!(/^sip:/i).test(uri)) {
	                        uri = Constants.C.SIP + ":" + uri;
	                    }
	                    var parsed = Grammar_1$1.Grammar.URIParse(uri);
	                    if (!parsed || !parsed.user) {
	                        return;
	                    }
	                    else {
	                        return parsed;
	                    }
	                },
	                transportConstructor: function (transportConstructor) {
	                    if (transportConstructor instanceof Function) {
	                        return transportConstructor;
	                    }
	                },
	                transportOptions: function (transportOptions) {
	                    if (typeof transportOptions === "object") {
	                        return transportOptions;
	                    }
	                },
	                authorizationUser: function (authorizationUser) {
	                    if (Grammar_1$1.Grammar.parse('"' + authorizationUser + '"', "quoted_string") === -1) {
	                        return;
	                    }
	                    else {
	                        return authorizationUser;
	                    }
	                },
	                displayName: function (displayName) {
	                    if (Grammar_1$1.Grammar.parse('"' + displayName + '"', "displayName") === -1) {
	                        return;
	                    }
	                    else {
	                        return displayName;
	                    }
	                },
	                dtmfType: function (dtmfType) {
	                    switch (dtmfType) {
	                        case Constants.C.dtmfType.RTP:
	                            return Constants.C.dtmfType.RTP;
	                        case Constants.C.dtmfType.INFO:
	                        // Fall through
	                        default:
	                            return Constants.C.dtmfType.INFO;
	                    }
	                },
	                hackViaTcp: function (hackViaTcp) {
	                    if (typeof hackViaTcp === "boolean") {
	                        return hackViaTcp;
	                    }
	                },
	                hackIpInContact: function (hackIpInContact) {
	                    if (typeof hackIpInContact === "boolean") {
	                        return hackIpInContact;
	                    }
	                    else if (typeof hackIpInContact === "string" && Grammar_1$1.Grammar.parse(hackIpInContact, "host") !== -1) {
	                        return hackIpInContact;
	                    }
	                },
	                hackWssInTransport: function (hackWssInTransport) {
	                    if (typeof hackWssInTransport === "boolean") {
	                        return hackWssInTransport;
	                    }
	                },
	                hackAllowUnregisteredOptionTags: function (hackAllowUnregisteredOptionTags) {
	                    if (typeof hackAllowUnregisteredOptionTags === "boolean") {
	                        return hackAllowUnregisteredOptionTags;
	                    }
	                },
	                contactTransport: function (contactTransport) {
	                    if (typeof contactTransport === "string") {
	                        return contactTransport;
	                    }
	                },
	                extraSupported: function (optionTags) {
	                    if (!(optionTags instanceof Array)) {
	                        return;
	                    }
	                    for (var _i = 0, optionTags_1 = optionTags; _i < optionTags_1.length; _i++) {
	                        var tag = optionTags_1[_i];
	                        if (typeof tag !== "string") {
	                            return;
	                        }
	                    }
	                    return optionTags;
	                },
	                forceRport: function (forceRport) {
	                    if (typeof forceRport === "boolean") {
	                        return forceRport;
	                    }
	                },
	                noAnswerTimeout: function (noAnswerTimeout) {
	                    if (Utils_1.Utils.isDecimal(noAnswerTimeout)) {
	                        var value = Number(noAnswerTimeout);
	                        if (value > 0) {
	                            return value;
	                        }
	                    }
	                },
	                password: function (password) {
	                    return String(password);
	                },
	                rel100: function (rel100) {
	                    if (rel100 === Constants.C.supported.REQUIRED) {
	                        return Constants.C.supported.REQUIRED;
	                    }
	                    else if (rel100 === Constants.C.supported.SUPPORTED) {
	                        return Constants.C.supported.SUPPORTED;
	                    }
	                    else {
	                        return Constants.C.supported.UNSUPPORTED;
	                    }
	                },
	                replaces: function (replaces) {
	                    if (replaces === Constants.C.supported.REQUIRED) {
	                        return Constants.C.supported.REQUIRED;
	                    }
	                    else if (replaces === Constants.C.supported.SUPPORTED) {
	                        return Constants.C.supported.SUPPORTED;
	                    }
	                    else {
	                        return Constants.C.supported.UNSUPPORTED;
	                    }
	                },
	                register: function (register) {
	                    if (typeof register === "boolean") {
	                        return register;
	                    }
	                },
	                registerOptions: function (registerOptions) {
	                    if (typeof registerOptions === "object") {
	                        return registerOptions;
	                    }
	                },
	                userAgentString: function (userAgentString) {
	                    if (typeof userAgentString === "string") {
	                        return userAgentString;
	                    }
	                },
	                autostart: function (autostart) {
	                    if (typeof autostart === "boolean") {
	                        return autostart;
	                    }
	                },
	                autostop: function (autostop) {
	                    if (typeof autostop === "boolean") {
	                        return autostop;
	                    }
	                },
	                sessionDescriptionHandlerFactory: function (sessionDescriptionHandlerFactory) {
	                    if (sessionDescriptionHandlerFactory instanceof Function) {
	                        return sessionDescriptionHandlerFactory;
	                    }
	                },
	                sessionDescriptionHandlerFactoryOptions: function (options) {
	                    if (typeof options === "object") {
	                        return options;
	                    }
	                },
	                authenticationFactory: this.checkAuthenticationFactory,
	                allowLegacyNotifications: function (allowLegacyNotifications) {
	                    if (typeof allowLegacyNotifications === "boolean") {
	                        return allowLegacyNotifications;
	                    }
	                },
	                custom: function (custom) {
	                    if (typeof custom === "object") {
	                        return custom;
	                    }
	                },
	                contactName: function (contactName) {
	                    if (typeof contactName === "string") {
	                        return contactName;
	                    }
	                },
	            }
	        };
	    };
	    UA.C = {
	        // UA status codes
	        STATUS_INIT: 0,
	        STATUS_STARTING: 1,
	        STATUS_READY: 2,
	        STATUS_USER_CLOSED: 3,
	        STATUS_NOT_READY: 4,
	        // UA error codes
	        CONFIGURATION_ERROR: 1,
	        NETWORK_ERROR: 2,
	        ALLOWED_METHODS: [
	            "ACK",
	            "CANCEL",
	            "INVITE",
	            "MESSAGE",
	            "BYE",
	            "OPTIONS",
	            "INFO",
	            "NOTIFY",
	            "REFER"
	        ],
	        ACCEPTED_BODY_TYPES: [
	            "application/sdp",
	            "application/dtmf-relay"
	        ],
	        MAX_FORWARDS: 70,
	        TAG_LENGTH: 10
	    };
	    return UA;
	}(events.EventEmitter));
	exports.UA = UA;
	(function (UA) {
	    var DtmfType;
	    (function (DtmfType) {
	        DtmfType["RTP"] = "rtp";
	        DtmfType["INFO"] = "info";
	    })(DtmfType = UA.DtmfType || (UA.DtmfType = {}));
	})(UA = exports.UA || (exports.UA = {}));
	exports.UA = UA;
	});

	unwrapExports(UA_1);
	var UA_2 = UA_1.UA;

	var Simple_1 = createCommonjsModule(function (module, exports) {
	var __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	Object.defineProperty(exports, "__esModule", { value: true });



	/* Simple
	 * @class Simple
	 */
	var SimpleStatus;
	(function (SimpleStatus) {
	    SimpleStatus[SimpleStatus["STATUS_NULL"] = 0] = "STATUS_NULL";
	    SimpleStatus[SimpleStatus["STATUS_NEW"] = 1] = "STATUS_NEW";
	    SimpleStatus[SimpleStatus["STATUS_CONNECTING"] = 2] = "STATUS_CONNECTING";
	    SimpleStatus[SimpleStatus["STATUS_CONNECTED"] = 3] = "STATUS_CONNECTED";
	    SimpleStatus[SimpleStatus["STATUS_COMPLETED"] = 4] = "STATUS_COMPLETED";
	})(SimpleStatus = exports.SimpleStatus || (exports.SimpleStatus = {}));
	var Simple = /** @class */ (function (_super) {
	    __extends(Simple, _super);
	    function Simple(options) {
	        var _this = _super.call(this) || this;
	        /*
	        *  {
	        *    media: {
	        *      remote: {
	        *        audio: <DOM element>,
	        *        video: <DOM element>
	        *      },
	        *      local: {
	        *        video: <DOM element>
	        *      }
	        *    },
	        *    ua: {
	        *       <UA Configuration Options>
	        *    }
	        *  }
	        */
	        if (options.media.remote.video) {
	            _this.video = true;
	        }
	        else {
	            _this.video = false;
	        }
	        if (options.media.remote.audio) {
	            _this.audio = true;
	        }
	        else {
	            _this.audio = false;
	        }
	        if (!_this.audio && !_this.video) {
	            // Need to do at least audio or video
	            // Error
	            throw new Error("At least one remote audio or video element is required for Simple.");
	        }
	        _this.options = options;
	        // https://stackoverflow.com/questions/7944460/detect-safari-browser
	        var browserUa = commonjsGlobal.navigator.userAgent.toLowerCase();
	        var isSafari = false;
	        var isFirefox = false;
	        if (browserUa.indexOf("safari") > -1 && browserUa.indexOf("chrome") < 0) {
	            isSafari = true;
	        }
	        else if (browserUa.indexOf("firefox") > -1 && browserUa.indexOf("chrome") < 0) {
	            isFirefox = true;
	        }
	        var sessionDescriptionHandlerFactoryOptions = {};
	        if (isSafari) {
	            sessionDescriptionHandlerFactoryOptions.modifiers = [Modifiers.stripG722];
	        }
	        if (isFirefox) {
	            sessionDescriptionHandlerFactoryOptions.alwaysAcquireMediaFirst = true;
	        }
	        if (!_this.options.ua.uri) {
	            _this.anonymous = true;
	        }
	        else {
	            _this.anonymous = false;
	        }
	        _this.ua = new UA_1.UA({
	            // User Configurable Options
	            uri: _this.options.ua.uri,
	            authorizationUser: _this.options.ua.authorizationUser,
	            password: _this.options.ua.password,
	            displayName: _this.options.ua.displayName,
	            // Undocumented "Advanced" Options
	            userAgentString: _this.options.ua.userAgentString,
	            // Fixed Options
	            register: true,
	            sessionDescriptionHandlerFactoryOptions: sessionDescriptionHandlerFactoryOptions,
	            transportOptions: {
	                traceSip: _this.options.ua.traceSip,
	                wsServers: _this.options.ua.wsServers
	            }
	        });
	        _this.state = SimpleStatus.STATUS_NULL;
	        _this.logger = _this.ua.getLogger("sip.simple");
	        _this.ua.on("registered", function () {
	            _this.emit("registered", _this.ua);
	        });
	        _this.ua.on("unregistered", function () {
	            _this.emit("unregistered", _this.ua);
	        });
	        _this.ua.on("registrationFailed", function () {
	            _this.emit("unregistered", _this.ua);
	        });
	        _this.ua.on("invite", function (session) {
	            // If there is already an active session reject the incoming session
	            if (_this.state !== SimpleStatus.STATUS_NULL && _this.state !== SimpleStatus.STATUS_COMPLETED) {
	                _this.logger.warn("Rejecting incoming call. Simple only supports 1 call at a time");
	                session.reject();
	                return;
	            }
	            _this.session = session;
	            _this.setupSession();
	            _this.emit("ringing", _this.session);
	        });
	        _this.ua.on("message", function (message) {
	            _this.emit("message", message);
	        });
	        return _this;
	    }
	    Simple.prototype.call = function (destination) {
	        if (!this.ua || !this.checkRegistration()) {
	            this.logger.warn("A registered UA is required for calling");
	            return;
	        }
	        if (this.state !== SimpleStatus.STATUS_NULL && this.state !== SimpleStatus.STATUS_COMPLETED) {
	            this.logger.warn("Cannot make more than a single call with Simple");
	            return;
	        }
	        // Safari hack, because you cannot call .play() from a non user action
	        if (this.options.media.remote.audio) {
	            this.options.media.remote.audio.autoplay = true;
	        }
	        if (this.options.media.remote.video) {
	            this.options.media.remote.video.autoplay = true;
	        }
	        if (this.options.media.local && this.options.media.local.video) {
	            this.options.media.local.video.autoplay = true;
	            this.options.media.local.video.volume = 0;
	        }
	        this.session = this.ua.invite(destination, {
	            sessionDescriptionHandlerOptions: {
	                constraints: {
	                    audio: this.audio,
	                    video: this.video
	                }
	            }
	        });
	        this.setupSession();
	        return this.session;
	    };
	    Simple.prototype.answer = function () {
	        if (this.state !== SimpleStatus.STATUS_NEW && this.state !== SimpleStatus.STATUS_CONNECTING) {
	            this.logger.warn("No call to answer");
	            return;
	        }
	        // Safari hack, because you cannot call .play() from a non user action
	        if (this.options.media.remote.audio) {
	            this.options.media.remote.audio.autoplay = true;
	        }
	        if (this.options.media.remote.video) {
	            this.options.media.remote.video.autoplay = true;
	        }
	        return this.session.accept({
	            sessionDescriptionHandlerOptions: {
	                constraints: {
	                    audio: this.audio,
	                    video: this.video
	                }
	            }
	        });
	        // emit call is active
	    };
	    Simple.prototype.reject = function () {
	        if (this.state !== SimpleStatus.STATUS_NEW && this.state !== SimpleStatus.STATUS_CONNECTING) {
	            this.logger.warn("Call is already answered");
	            return;
	        }
	        return this.session.reject();
	    };
	    Simple.prototype.hangup = function () {
	        if (this.state !== SimpleStatus.STATUS_CONNECTED &&
	            this.state !== SimpleStatus.STATUS_CONNECTING &&
	            this.state !== SimpleStatus.STATUS_NEW) {
	            this.logger.warn("No active call to hang up on");
	            return;
	        }
	        if (this.state !== SimpleStatus.STATUS_CONNECTED) {
	            return this.session.cancel();
	        }
	        else if (this.session) {
	            return this.session.bye();
	        }
	    };
	    Simple.prototype.hold = function () {
	        if (this.state !== SimpleStatus.STATUS_CONNECTED || !this.session || this.session.localHold) {
	            this.logger.warn("Cannot put call on hold");
	            return;
	        }
	        this.mute();
	        this.logger.log("Placing session on hold");
	        return this.session.hold();
	    };
	    Simple.prototype.unhold = function () {
	        if (this.state !== SimpleStatus.STATUS_CONNECTED || !this.session || !this.session.localHold) {
	            this.logger.warn("Cannot unhold a call that is not on hold");
	            return;
	        }
	        this.unmute();
	        this.logger.log("Placing call off hold");
	        return this.session.unhold();
	    };
	    Simple.prototype.mute = function () {
	        if (this.state !== SimpleStatus.STATUS_CONNECTED) {
	            this.logger.warn("An acitve call is required to mute audio");
	            return;
	        }
	        this.logger.log("Muting Audio");
	        this.toggleMute(true);
	        this.emit("mute", this);
	    };
	    Simple.prototype.unmute = function () {
	        if (this.state !== SimpleStatus.STATUS_CONNECTED) {
	            this.logger.warn("An active call is required to unmute audio");
	            return;
	        }
	        this.logger.log("Unmuting Audio");
	        this.toggleMute(false);
	        this.emit("unmute", this);
	    };
	    Simple.prototype.sendDTMF = function (tone) {
	        if (this.state !== SimpleStatus.STATUS_CONNECTED || !this.session) {
	            this.logger.warn("An active call is required to send a DTMF tone");
	            return;
	        }
	        this.logger.log("Sending DTMF tone: " + tone);
	        this.session.dtmf(tone);
	    };
	    Simple.prototype.message = function (destination, message) {
	        if (!this.ua || !this.checkRegistration()) {
	            this.logger.warn("A registered UA is required to send a message");
	            return;
	        }
	        if (!destination || !message) {
	            this.logger.warn("A destination and message are required to send a message");
	            return;
	        }
	        this.ua.message(destination, message);
	    };
	    // Private Helpers
	    Simple.prototype.checkRegistration = function () {
	        return (this.anonymous || (this.ua && this.ua.isRegistered()));
	    };
	    Simple.prototype.setupRemoteMedia = function () {
	        var _this = this;
	        if (!this.session) {
	            this.logger.warn("No session to set remote media on");
	            return;
	        }
	        // If there is a video track, it will attach the video and audio to the same element
	        var pc = this.session.sessionDescriptionHandler.peerConnection;
	        var remoteStream;
	        if (pc.getReceivers) {
	            remoteStream = new commonjsGlobal.window.MediaStream();
	            pc.getReceivers().forEach(function (receiver) {
	                var track = receiver.track;
	                if (track) {
	                    remoteStream.addTrack(track);
	                }
	            });
	        }
	        else {
	            remoteStream = pc.getRemoteStreams()[0];
	        }
	        if (this.video) {
	            this.options.media.remote.video.srcObject = remoteStream;
	            this.options.media.remote.video.play().catch(function () {
	                _this.logger.log("play was rejected");
	            });
	        }
	        else if (this.audio) {
	            this.options.media.remote.audio.srcObject = remoteStream;
	            this.options.media.remote.audio.play().catch(function () {
	                _this.logger.log("play was rejected");
	            });
	        }
	    };
	    Simple.prototype.setupLocalMedia = function () {
	        if (!this.session) {
	            this.logger.warn("No session to set local media on");
	            return;
	        }
	        if (this.video && this.options.media.local && this.options.media.local.video) {
	            var pc = this.session.sessionDescriptionHandler.peerConnection;
	            var localStream_1;
	            if (pc.getSenders) {
	                localStream_1 = new commonjsGlobal.window.MediaStream();
	                pc.getSenders().forEach(function (sender) {
	                    var track = sender.track;
	                    if (track && track.kind === "video") {
	                        localStream_1.addTrack(track);
	                    }
	                });
	            }
	            else {
	                localStream_1 = pc.getLocalStreams()[0];
	            }
	            this.options.media.local.video.srcObject = localStream_1;
	            this.options.media.local.video.volume = 0;
	            this.options.media.local.video.play();
	        }
	    };
	    Simple.prototype.cleanupMedia = function () {
	        if (this.video) {
	            this.options.media.remote.video.srcObject = null;
	            this.options.media.remote.video.pause();
	            if (this.options.media.local && this.options.media.local.video) {
	                this.options.media.local.video.srcObject = null;
	                this.options.media.local.video.pause();
	            }
	        }
	        if (this.audio) {
	            this.options.media.remote.audio.srcObject = null;
	            this.options.media.remote.audio.pause();
	        }
	    };
	    Simple.prototype.setupSession = function () {
	        var _this = this;
	        if (!this.session) {
	            this.logger.warn("No session to set up");
	            return;
	        }
	        this.state = SimpleStatus.STATUS_NEW;
	        this.emit("new", this.session);
	        this.session.on("progress", function () { return _this.onProgress(); });
	        this.session.on("accepted", function () { return _this.onAccepted(); });
	        this.session.on("rejected", function () { return _this.onEnded(); });
	        this.session.on("failed", function () { return _this.onFailed(); });
	        this.session.on("terminated", function () { return _this.onEnded(); });
	    };
	    Simple.prototype.destroyMedia = function () {
	        if (this.session && this.session.sessionDescriptionHandler) {
	            this.session.sessionDescriptionHandler.close();
	        }
	    };
	    Simple.prototype.toggleMute = function (mute) {
	        if (!this.session) {
	            this.logger.warn("No session to toggle mute");
	            return;
	        }
	        var pc = this.session.sessionDescriptionHandler.peerConnection;
	        if (pc.getSenders) {
	            pc.getSenders().forEach(function (sender) {
	                if (sender.track) {
	                    sender.track.enabled = !mute;
	                }
	            });
	        }
	        else {
	            pc.getLocalStreams().forEach(function (stream) {
	                stream.getAudioTracks().forEach(function (track) {
	                    track.enabled = !mute;
	                });
	                stream.getVideoTracks().forEach(function (track) {
	                    track.enabled = !mute;
	                });
	            });
	        }
	    };
	    Simple.prototype.onAccepted = function () {
	        var _this = this;
	        if (!this.session) {
	            this.logger.warn("No session for accepting");
	            return;
	        }
	        this.state = SimpleStatus.STATUS_CONNECTED;
	        this.emit("connected", this.session);
	        this.setupLocalMedia();
	        this.setupRemoteMedia();
	        if (this.session.sessionDescriptionHandler) {
	            this.session.sessionDescriptionHandler.on("addTrack", function () {
	                _this.logger.log("A track has been added, triggering new remoteMedia setup");
	                _this.setupRemoteMedia();
	            });
	            this.session.sessionDescriptionHandler.on("addStream", function () {
	                _this.logger.log("A stream has been added, trigger new remoteMedia setup");
	                _this.setupRemoteMedia();
	            });
	        }
	        this.session.on("dtmf", function (request, dtmf) {
	            _this.emit("dtmf", dtmf.tone);
	        });
	        this.session.on("bye", function () { return _this.onEnded(); });
	    };
	    Simple.prototype.onProgress = function () {
	        this.state = SimpleStatus.STATUS_CONNECTING;
	        this.emit("connecting", this.session);
	    };
	    Simple.prototype.onFailed = function () {
	        this.onEnded();
	    };
	    Simple.prototype.onEnded = function () {
	        this.state = SimpleStatus.STATUS_COMPLETED;
	        this.emit("ended", this.session);
	        this.cleanupMedia();
	    };
	    Simple.C = SimpleStatus;
	    return Simple;
	}(events.EventEmitter));
	exports.Simple = Simple;
	});

	unwrapExports(Simple_1);
	var Simple_2 = Simple_1.SimpleStatus;
	var Simple_3 = Simple_1.Simple;

	var Web = createCommonjsModule(function (module, exports) {
	Object.defineProperty(exports, "__esModule", { value: true });

	exports.Modifiers = Modifiers;

	exports.Simple = Simple_1.Simple;

	exports.SessionDescriptionHandler = SessionDescriptionHandler_1.SessionDescriptionHandler;

	exports.Transport = Transport_2$1.Transport;
	});

	unwrapExports(Web);
	var Web_1 = Web.Modifiers;
	var Web_2 = Web.Simple;
	var Web_3 = Web.SessionDescriptionHandler;
	var Web_4 = Web.Transport;

	var lib = createCommonjsModule(function (module, exports) {
	Object.defineProperty(exports, "__esModule", { value: true });

	exports.ClientContext = ClientContext_1.ClientContext;

	exports.C = Constants.C;

	exports.Dialog = Dialogs.Dialog;

	exports.DigestAuthentication = DigestAuthentication_1.DigestAuthentication;

	exports.DialogStatus = Enums.DialogStatus;
	exports.SessionStatus = Enums.SessionStatus;
	exports.TypeStrings = Enums.TypeStrings;
	exports.UAStatus = Enums.UAStatus;

	exports.Exceptions = Exceptions_1.Exceptions;

	exports.Grammar = Grammar_1$1.Grammar;

	exports.LoggerFactory = LoggerFactory_1.LoggerFactory;

	exports.NameAddrHeader = NameAddrHeader_1.NameAddrHeader;

	exports.Parser = Parser_1.Parser;

	exports.PublishContext = PublishContext_1.PublishContext;

	exports.RegisterContext = RegisterContext_1.RegisterContext;

	exports.RequestSender = RequestSender_1.RequestSender;

	var sanityCheck = SanityCheck_1.SanityCheck.sanityCheck;
	exports.sanityCheck = sanityCheck;

	exports.ServerContext = ServerContext_1.ServerContext;

	exports.InviteClientContext = Session_1.InviteClientContext;
	exports.InviteServerContext = Session_1.InviteServerContext;
	exports.ReferClientContext = Session_1.ReferClientContext;
	exports.ReferServerContext = Session_1.ReferServerContext;
	exports.Session = Session_1.Session;

	exports.IncomingRequest = SIPMessage.IncomingRequest;
	exports.IncomingResponse = SIPMessage.IncomingResponse;
	exports.OutgoingRequest = SIPMessage.OutgoingRequest;

	exports.Subscription = Subscription_1.Subscription;

	exports.Timers = Timers.Timers;

	var Transactions$1 = {
	    InviteClientTransaction: Transactions.InviteClientTransaction,
	    InviteServerTransaction: Transactions.InviteServerTransaction,
	    NonInviteClientTransaction: Transactions.NonInviteClientTransaction,
	    NonInviteServerTransaction: Transactions.NonInviteServerTransaction
	};
	exports.Transactions = Transactions$1;

	exports.Transport = Transport_1.Transport;

	exports.UA = UA_1.UA;

	exports.URI = URI_1.URI;

	exports.Utils = Utils_1.Utils;

	exports.Web = Web;
	// tslint:disable-next-line:no-var-requires

	var name = pkg.title;
	exports.name = name;
	var version = pkg.version;
	exports.version = version;
	});

	unwrapExports(lib);
	var lib_1 = lib.ClientContext;
	var lib_2 = lib.C;
	var lib_3 = lib.Dialog;
	var lib_4 = lib.DigestAuthentication;
	var lib_5 = lib.DialogStatus;
	var lib_6 = lib.SessionStatus;
	var lib_7 = lib.TypeStrings;
	var lib_8 = lib.UAStatus;
	var lib_9 = lib.Exceptions;
	var lib_10 = lib.Grammar;
	var lib_11 = lib.LoggerFactory;
	var lib_12 = lib.NameAddrHeader;
	var lib_13 = lib.Parser;
	var lib_14 = lib.PublishContext;
	var lib_15 = lib.RegisterContext;
	var lib_16 = lib.RequestSender;
	var lib_17 = lib.sanityCheck;
	var lib_18 = lib.ServerContext;
	var lib_19 = lib.InviteClientContext;
	var lib_20 = lib.InviteServerContext;
	var lib_21 = lib.ReferClientContext;
	var lib_22 = lib.ReferServerContext;
	var lib_23 = lib.Session;
	var lib_24 = lib.IncomingRequest;
	var lib_25 = lib.IncomingResponse;
	var lib_26 = lib.OutgoingRequest;
	var lib_27 = lib.Subscription;
	var lib_28 = lib.Timers;
	var lib_29 = lib.Transactions;
	var lib_30 = lib.Transport;
	var lib_31 = lib.UA;
	var lib_32 = lib.URI;
	var lib_33 = lib.Utils;
	var lib_34 = lib.Web;
	var lib_35 = lib.name;
	var lib_36 = lib.version;

	//      

	class Emitter {
	                             

	  constructor() {
	    this.eventEmitter = new events();
	  }

	  on(event        , callback          ) {
	    this.eventEmitter.on(event, callback);
	  }

	  once(event        , callback          ) {
	    this.eventEmitter.once(event, callback);
	  }

	  off(event        , callback          ) {
	    this.eventEmitter.removeListener(event, callback);
	  }

	  unbind() {
	    this.eventEmitter.removeAllListeners();
	  }
	}

	//      
	/* eslint-disable */
	// Can't use arrow function here due to `apply`
	function once(func           ) {
	  let ran = false;
	  let memo;
	  return function() {
	    if (ran) return memo;
	    ran = true;
	    memo = func && func.apply(this, arguments);
	    func = null;
	    return memo;
	  };
	}

	var navigator$1 = {};
	navigator$1.userAgent = false;

	var window$1 = {};
	/*
	 * jsrsasign(all) 8.0.12 (2018-04-22) (c) 2010-2018 Kenji Urushima | kjur.github.com/jsrsasign/license
	 */

	/*!
	Copyright (c) 2011, Yahoo! Inc. All rights reserved.
	Code licensed under the BSD License:
	http://developer.yahoo.com/yui/license.html
	version: 2.9.0
	*/
	if(YAHOO===undefined){var YAHOO={};}YAHOO.lang={extend:function(g,h,f){if(!h||!g){throw new Error("YAHOO.lang.extend failed, please check that all dependencies are included.")}var d=function(){};d.prototype=h.prototype;g.prototype=new d();g.prototype.constructor=g;g.superclass=h.prototype;if(h.prototype.constructor==Object.prototype.constructor){h.prototype.constructor=h;}if(f){var b;for(b in f){g.prototype[b]=f[b];}var e=function(){},c=["toString","valueOf"];try{if(/MSIE/.test(navigator$1.userAgent)){e=function(j,i){for(b=0;b<c.length;b=b+1){var l=c[b],k=i[l];if(typeof k==="function"&&k!=Object.prototype[l]){j[l]=k;}}};}}catch(a){}e(g.prototype,f);}}};

	/*! CryptoJS v3.1.2 core-fix.js
	 * code.google.com/p/crypto-js
	 * (c) 2009-2013 by Jeff Mott. All rights reserved.
	 * code.google.com/p/crypto-js/wiki/License
	 * THIS IS FIX of 'core.js' to fix Hmac issue.
	 * https://code.google.com/p/crypto-js/issues/detail?id=84
	 * https://crypto-js.googlecode.com/svn-history/r667/branches/3.x/src/core.js
	 */
	var CryptoJS=CryptoJS||(function(e,g){var a={};var b=a.lib={};var j=b.Base=(function(){function n(){}return {extend:function(p){n.prototype=this;var o=new n();if(p){o.mixIn(p);}if(!o.hasOwnProperty("init")){o.init=function(){o.$super.init.apply(this,arguments);};}o.init.prototype=o;o.$super=this;return o},create:function(){var o=this.extend();o.init.apply(o,arguments);return o},init:function(){},mixIn:function(p){for(var o in p){if(p.hasOwnProperty(o)){this[o]=p[o];}}if(p.hasOwnProperty("toString")){this.toString=p.toString;}},clone:function(){return this.init.prototype.extend(this)}}}());var l=b.WordArray=j.extend({init:function(o,n){o=this.words=o||[];if(n!=g){this.sigBytes=n;}else{this.sigBytes=o.length*4;}},toString:function(n){return (n||h).stringify(this)},concat:function(t){var q=this.words;var p=t.words;var n=this.sigBytes;var s=t.sigBytes;this.clamp();if(n%4){for(var r=0;r<s;r++){var o=(p[r>>>2]>>>(24-(r%4)*8))&255;q[(n+r)>>>2]|=o<<(24-((n+r)%4)*8);}}else{for(var r=0;r<s;r+=4){q[(n+r)>>>2]=p[r>>>2];}}this.sigBytes+=s;return this},clamp:function(){var o=this.words;var n=this.sigBytes;o[n>>>2]&=4294967295<<(32-(n%4)*8);o.length=e.ceil(n/4);},clone:function(){var n=j.clone.call(this);n.words=this.words.slice(0);return n},random:function(p){var o=[];for(var n=0;n<p;n+=4){o.push((e.random()*4294967296)|0);}return new l.init(o,p)}});var m=a.enc={};var h=m.Hex={stringify:function(p){var r=p.words;var o=p.sigBytes;var q=[];for(var n=0;n<o;n++){var s=(r[n>>>2]>>>(24-(n%4)*8))&255;q.push((s>>>4).toString(16));q.push((s&15).toString(16));}return q.join("")},parse:function(p){var n=p.length;var q=[];for(var o=0;o<n;o+=2){q[o>>>3]|=parseInt(p.substr(o,2),16)<<(24-(o%8)*4);}return new l.init(q,n/2)}};var d=m.Latin1={stringify:function(q){var r=q.words;var p=q.sigBytes;var n=[];for(var o=0;o<p;o++){var s=(r[o>>>2]>>>(24-(o%4)*8))&255;n.push(String.fromCharCode(s));}return n.join("")},parse:function(p){var n=p.length;var q=[];for(var o=0;o<n;o++){q[o>>>2]|=(p.charCodeAt(o)&255)<<(24-(o%4)*8);}return new l.init(q,n)}};var c=m.Utf8={stringify:function(n){try{return decodeURIComponent(escape(d.stringify(n)))}catch(o){throw new Error("Malformed UTF-8 data")}},parse:function(n){return d.parse(unescape(encodeURIComponent(n)))}};var i=b.BufferedBlockAlgorithm=j.extend({reset:function(){this._data=new l.init();this._nDataBytes=0;},_append:function(n){if(typeof n=="string"){n=c.parse(n);}this._data.concat(n);this._nDataBytes+=n.sigBytes;},_process:function(w){var q=this._data;var x=q.words;var n=q.sigBytes;var t=this.blockSize;var v=t*4;var u=n/v;if(w){u=e.ceil(u);}else{u=e.max((u|0)-this._minBufferSize,0);}var s=u*t;var r=e.min(s*4,n);if(s){for(var p=0;p<s;p+=t){this._doProcessBlock(x,p);}var o=x.splice(0,s);q.sigBytes-=r;}return new l.init(o,r)},clone:function(){var n=j.clone.call(this);n._data=this._data.clone();return n},_minBufferSize:0});var f=b.Hasher=i.extend({cfg:j.extend(),init:function(n){this.cfg=this.cfg.extend(n);this.reset();},reset:function(){i.reset.call(this);this._doReset();},update:function(n){this._append(n);this._process();return this},finalize:function(n){if(n){this._append(n);}var o=this._doFinalize();return o},blockSize:512/32,_createHelper:function(n){return function(p,o){return new n.init(o).finalize(p)}},_createHmacHelper:function(n){return function(p,o){return new k.HMAC.init(n,o).finalize(p)}}});var k=a.algo={};return a}(Math));
	/*
	CryptoJS v3.1.2 x64-core-min.js
	code.google.com/p/crypto-js
	(c) 2009-2013 by Jeff Mott. All rights reserved.
	code.google.com/p/crypto-js/wiki/License
	*/
	(function(g){var a=CryptoJS,f=a.lib,e=f.Base,h=f.WordArray,a=a.x64={};a.Word=e.extend({init:function(b,c){this.high=b;this.low=c;}});a.WordArray=e.extend({init:function(b,c){b=this.words=b||[];this.sigBytes=c!=g?c:8*b.length;},toX32:function(){for(var b=this.words,c=b.length,a=[],d=0;d<c;d++){var e=b[d];a.push(e.high);a.push(e.low);}return h.create(a,this.sigBytes)},clone:function(){for(var b=e.clone.call(this),c=b.words=this.words.slice(0),a=c.length,d=0;d<a;d++)c[d]=c[d].clone();return b}});})();

	/*
	CryptoJS v3.1.2 cipher-core.js
	code.google.com/p/crypto-js
	(c) 2009-2013 by Jeff Mott. All rights reserved.
	code.google.com/p/crypto-js/wiki/License
	*/
	CryptoJS.lib.Cipher||function(u){var g=CryptoJS,f=g.lib,k=f.Base,l=f.WordArray,q=f.BufferedBlockAlgorithm,r=g.enc.Base64,v=g.algo.EvpKDF,n=f.Cipher=q.extend({cfg:k.extend(),createEncryptor:function(a,b){return this.create(this._ENC_XFORM_MODE,a,b)},createDecryptor:function(a,b){return this.create(this._DEC_XFORM_MODE,a,b)},init:function(a,b,c){this.cfg=this.cfg.extend(c);this._xformMode=a;this._key=b;this.reset();},reset:function(){q.reset.call(this);this._doReset();},process:function(a){this._append(a);
	return this._process()},finalize:function(a){a&&this._append(a);return this._doFinalize()},keySize:4,ivSize:4,_ENC_XFORM_MODE:1,_DEC_XFORM_MODE:2,_createHelper:function(a){return {encrypt:function(b,c,d){return ("string"==typeof c?s:j).encrypt(a,b,c,d)},decrypt:function(b,c,d){return ("string"==typeof c?s:j).decrypt(a,b,c,d)}}}});f.StreamCipher=n.extend({_doFinalize:function(){return this._process(!0)},blockSize:1});var m=g.mode={},t=function(a,b,c){var d=this._iv;d?this._iv=u:d=this._prevBlock;for(var e=
	0;e<c;e++)a[b+e]^=d[e];},h=(f.BlockCipherMode=k.extend({createEncryptor:function(a,b){return this.Encryptor.create(a,b)},createDecryptor:function(a,b){return this.Decryptor.create(a,b)},init:function(a,b){this._cipher=a;this._iv=b;}})).extend();h.Encryptor=h.extend({processBlock:function(a,b){var c=this._cipher,d=c.blockSize;t.call(this,a,b,d);c.encryptBlock(a,b);this._prevBlock=a.slice(b,b+d);}});h.Decryptor=h.extend({processBlock:function(a,b){var c=this._cipher,d=c.blockSize,e=a.slice(b,b+d);c.decryptBlock(a,
	b);t.call(this,a,b,d);this._prevBlock=e;}});m=m.CBC=h;h=(g.pad={}).Pkcs7={pad:function(a,b){for(var c=4*b,c=c-a.sigBytes%c,d=c<<24|c<<16|c<<8|c,e=[],f=0;f<c;f+=4)e.push(d);c=l.create(e,c);a.concat(c);},unpad:function(a){a.sigBytes-=a.words[a.sigBytes-1>>>2]&255;}};f.BlockCipher=n.extend({cfg:n.cfg.extend({mode:m,padding:h}),reset:function(){n.reset.call(this);var a=this.cfg,b=a.iv,a=a.mode;if(this._xformMode==this._ENC_XFORM_MODE)var c=a.createEncryptor;else c=a.createDecryptor,this._minBufferSize=1;
	this._mode=c.call(a,this,b&&b.words);},_doProcessBlock:function(a,b){this._mode.processBlock(a,b);},_doFinalize:function(){var a=this.cfg.padding;if(this._xformMode==this._ENC_XFORM_MODE){a.pad(this._data,this.blockSize);var b=this._process(!0);}else b=this._process(!0),a.unpad(b);return b},blockSize:4});var p=f.CipherParams=k.extend({init:function(a){this.mixIn(a);},toString:function(a){return (a||this.formatter).stringify(this)}}),m=(g.format={}).OpenSSL={stringify:function(a){var b=a.ciphertext;a=a.salt;
	return (a?l.create([1398893684,1701076831]).concat(a).concat(b):b).toString(r)},parse:function(a){a=r.parse(a);var b=a.words;if(1398893684==b[0]&&1701076831==b[1]){var c=l.create(b.slice(2,4));b.splice(0,4);a.sigBytes-=16;}return p.create({ciphertext:a,salt:c})}},j=f.SerializableCipher=k.extend({cfg:k.extend({format:m}),encrypt:function(a,b,c,d){d=this.cfg.extend(d);var e=a.createEncryptor(c,d);b=e.finalize(b);e=e.cfg;return p.create({ciphertext:b,key:c,iv:e.iv,algorithm:a,mode:e.mode,padding:e.padding,
	blockSize:a.blockSize,formatter:d.format})},decrypt:function(a,b,c,d){d=this.cfg.extend(d);b=this._parse(b,d.format);return a.createDecryptor(c,d).finalize(b.ciphertext)},_parse:function(a,b){return "string"==typeof a?b.parse(a,this):a}}),g=(g.kdf={}).OpenSSL={execute:function(a,b,c,d){d||(d=l.random(8));a=v.create({keySize:b+c}).compute(a,d);c=l.create(a.words.slice(b),4*c);a.sigBytes=4*b;return p.create({key:a,iv:c,salt:d})}},s=f.PasswordBasedCipher=j.extend({cfg:j.cfg.extend({kdf:g}),encrypt:function(a,
	b,c,d){d=this.cfg.extend(d);c=d.kdf.execute(c,a.keySize,a.ivSize);d.iv=c.iv;a=j.encrypt.call(this,a,b,c.key,d);a.mixIn(c);return a},decrypt:function(a,b,c,d){d=this.cfg.extend(d);b=this._parse(b,d.format);c=d.kdf.execute(c,a.keySize,a.ivSize,b.salt);d.iv=c.iv;return j.decrypt.call(this,a,b,c.key,d)}});}();

	/*
	CryptoJS v3.1.2 aes.js
	code.google.com/p/crypto-js
	(c) 2009-2013 by Jeff Mott. All rights reserved.
	code.google.com/p/crypto-js/wiki/License
	*/
	(function(){for(var q=CryptoJS,x=q.lib.BlockCipher,r=q.algo,j=[],y=[],z=[],A=[],B=[],C=[],s=[],u=[],v=[],w=[],g=[],k=0;256>k;k++)g[k]=128>k?k<<1:k<<1^283;for(var n=0,l=0,k=0;256>k;k++){var f=l^l<<1^l<<2^l<<3^l<<4,f=f>>>8^f&255^99;j[n]=f;y[f]=n;var t=g[n],D=g[t],E=g[D],b=257*g[f]^16843008*f;z[n]=b<<24|b>>>8;A[n]=b<<16|b>>>16;B[n]=b<<8|b>>>24;C[n]=b;b=16843009*E^65537*D^257*t^16843008*n;s[f]=b<<24|b>>>8;u[f]=b<<16|b>>>16;v[f]=b<<8|b>>>24;w[f]=b;n?(n=t^g[g[g[E^t]]],l^=g[g[l]]):n=l=1;}var F=[0,1,2,4,8,
	16,32,64,128,27,54],r=r.AES=x.extend({_doReset:function(){for(var c=this._key,e=c.words,a=c.sigBytes/4,c=4*((this._nRounds=a+6)+1),b=this._keySchedule=[],h=0;h<c;h++)if(h<a)b[h]=e[h];else{var d=b[h-1];h%a?6<a&&4==h%a&&(d=j[d>>>24]<<24|j[d>>>16&255]<<16|j[d>>>8&255]<<8|j[d&255]):(d=d<<8|d>>>24,d=j[d>>>24]<<24|j[d>>>16&255]<<16|j[d>>>8&255]<<8|j[d&255],d^=F[h/a|0]<<24);b[h]=b[h-a]^d;}e=this._invKeySchedule=[];for(a=0;a<c;a++)h=c-a,d=a%4?b[h]:b[h-4],e[a]=4>a||4>=h?d:s[j[d>>>24]]^u[j[d>>>16&255]]^v[j[d>>>
	8&255]]^w[j[d&255]];},encryptBlock:function(c,e){this._doCryptBlock(c,e,this._keySchedule,z,A,B,C,j);},decryptBlock:function(c,e){var a=c[e+1];c[e+1]=c[e+3];c[e+3]=a;this._doCryptBlock(c,e,this._invKeySchedule,s,u,v,w,y);a=c[e+1];c[e+1]=c[e+3];c[e+3]=a;},_doCryptBlock:function(c,e,a,b,h,d,j,m){for(var n=this._nRounds,f=c[e]^a[0],g=c[e+1]^a[1],k=c[e+2]^a[2],p=c[e+3]^a[3],l=4,t=1;t<n;t++)var q=b[f>>>24]^h[g>>>16&255]^d[k>>>8&255]^j[p&255]^a[l++],r=b[g>>>24]^h[k>>>16&255]^d[p>>>8&255]^j[f&255]^a[l++],s=
	b[k>>>24]^h[p>>>16&255]^d[f>>>8&255]^j[g&255]^a[l++],p=b[p>>>24]^h[f>>>16&255]^d[g>>>8&255]^j[k&255]^a[l++],f=q,g=r,k=s;q=(m[f>>>24]<<24|m[g>>>16&255]<<16|m[k>>>8&255]<<8|m[p&255])^a[l++];r=(m[g>>>24]<<24|m[k>>>16&255]<<16|m[p>>>8&255]<<8|m[f&255])^a[l++];s=(m[k>>>24]<<24|m[p>>>16&255]<<16|m[f>>>8&255]<<8|m[g&255])^a[l++];p=(m[p>>>24]<<24|m[f>>>16&255]<<16|m[g>>>8&255]<<8|m[k&255])^a[l++];c[e]=q;c[e+1]=r;c[e+2]=s;c[e+3]=p;},keySize:8});q.AES=x._createHelper(r);})();

	/*
	CryptoJS v3.1.2 tripledes-min.js
	code.google.com/p/crypto-js
	(c) 2009-2013 by Jeff Mott. All rights reserved.
	code.google.com/p/crypto-js/wiki/License
	*/
	(function(){function j(b,c){var a=(this._lBlock>>>b^this._rBlock)&c;this._rBlock^=a;this._lBlock^=a<<b;}function l(b,c){var a=(this._rBlock>>>b^this._lBlock)&c;this._lBlock^=a;this._rBlock^=a<<b;}var h=CryptoJS,e=h.lib,n=e.WordArray,e=e.BlockCipher,g=h.algo,q=[57,49,41,33,25,17,9,1,58,50,42,34,26,18,10,2,59,51,43,35,27,19,11,3,60,52,44,36,63,55,47,39,31,23,15,7,62,54,46,38,30,22,14,6,61,53,45,37,29,21,13,5,28,20,12,4],p=[14,17,11,24,1,5,3,28,15,6,21,10,23,19,12,4,26,8,16,7,27,20,13,2,41,52,31,37,47,
	55,30,40,51,45,33,48,44,49,39,56,34,53,46,42,50,36,29,32],r=[1,2,4,6,8,10,12,14,15,17,19,21,23,25,27,28],s=[{"0":8421888,268435456:32768,536870912:8421378,805306368:2,1073741824:512,1342177280:8421890,1610612736:8389122,1879048192:8388608,2147483648:514,2415919104:8389120,2684354560:33280,2952790016:8421376,3221225472:32770,3489660928:8388610,3758096384:0,4026531840:33282,134217728:0,402653184:8421890,671088640:33282,939524096:32768,1207959552:8421888,1476395008:512,1744830464:8421378,2013265920:2,
	2281701376:8389120,2550136832:33280,2818572288:8421376,3087007744:8389122,3355443200:8388610,3623878656:32770,3892314112:514,4160749568:8388608,1:32768,268435457:2,536870913:8421888,805306369:8388608,1073741825:8421378,1342177281:33280,1610612737:512,1879048193:8389122,2147483649:8421890,2415919105:8421376,2684354561:8388610,2952790017:33282,3221225473:514,3489660929:8389120,3758096385:32770,4026531841:0,134217729:8421890,402653185:8421376,671088641:8388608,939524097:512,1207959553:32768,1476395009:8388610,
	1744830465:2,2013265921:33282,2281701377:32770,2550136833:8389122,2818572289:514,3087007745:8421888,3355443201:8389120,3623878657:0,3892314113:33280,4160749569:8421378},{"0":1074282512,16777216:16384,33554432:524288,50331648:1074266128,67108864:1073741840,83886080:1074282496,100663296:1073758208,117440512:16,134217728:540672,150994944:1073758224,167772160:1073741824,184549376:540688,201326592:524304,218103808:0,234881024:16400,251658240:1074266112,8388608:1073758208,25165824:540688,41943040:16,58720256:1073758224,
	75497472:1074282512,92274688:1073741824,109051904:524288,125829120:1074266128,142606336:524304,159383552:0,176160768:16384,192937984:1074266112,209715200:1073741840,226492416:540672,243269632:1074282496,260046848:16400,268435456:0,285212672:1074266128,301989888:1073758224,318767104:1074282496,335544320:1074266112,352321536:16,369098752:540688,385875968:16384,402653184:16400,419430400:524288,436207616:524304,452984832:1073741840,469762048:540672,486539264:1073758208,503316480:1073741824,520093696:1074282512,
	276824064:540688,293601280:524288,310378496:1074266112,327155712:16384,343932928:1073758208,360710144:1074282512,377487360:16,394264576:1073741824,411041792:1074282496,427819008:1073741840,444596224:1073758224,461373440:524304,478150656:0,494927872:16400,511705088:1074266128,528482304:540672},{"0":260,1048576:0,2097152:67109120,3145728:65796,4194304:65540,5242880:67108868,6291456:67174660,7340032:67174400,8388608:67108864,9437184:67174656,10485760:65792,11534336:67174404,12582912:67109124,13631488:65536,
	14680064:4,15728640:256,524288:67174656,1572864:67174404,2621440:0,3670016:67109120,4718592:67108868,5767168:65536,6815744:65540,7864320:260,8912896:4,9961472:256,11010048:67174400,12058624:65796,13107200:65792,14155776:67109124,15204352:67174660,16252928:67108864,16777216:67174656,17825792:65540,18874368:65536,19922944:67109120,20971520:256,22020096:67174660,23068672:67108868,24117248:0,25165824:67109124,26214400:67108864,27262976:4,28311552:65792,29360128:67174400,30408704:260,31457280:65796,32505856:67174404,
	17301504:67108864,18350080:260,19398656:67174656,20447232:0,21495808:65540,22544384:67109120,23592960:256,24641536:67174404,25690112:65536,26738688:67174660,27787264:65796,28835840:67108868,29884416:67109124,30932992:67174400,31981568:4,33030144:65792},{"0":2151682048,65536:2147487808,131072:4198464,196608:2151677952,262144:0,327680:4198400,393216:2147483712,458752:4194368,524288:2147483648,589824:4194304,655360:64,720896:2147487744,786432:2151678016,851968:4160,917504:4096,983040:2151682112,32768:2147487808,
	98304:64,163840:2151678016,229376:2147487744,294912:4198400,360448:2151682112,425984:0,491520:2151677952,557056:4096,622592:2151682048,688128:4194304,753664:4160,819200:2147483648,884736:4194368,950272:4198464,1015808:2147483712,1048576:4194368,1114112:4198400,1179648:2147483712,1245184:0,1310720:4160,1376256:2151678016,1441792:2151682048,1507328:2147487808,1572864:2151682112,1638400:2147483648,1703936:2151677952,1769472:4198464,1835008:2147487744,1900544:4194304,1966080:64,2031616:4096,1081344:2151677952,
	1146880:2151682112,1212416:0,1277952:4198400,1343488:4194368,1409024:2147483648,1474560:2147487808,1540096:64,1605632:2147483712,1671168:4096,1736704:2147487744,1802240:2151678016,1867776:4160,1933312:2151682048,1998848:4194304,2064384:4198464},{"0":128,4096:17039360,8192:262144,12288:536870912,16384:537133184,20480:16777344,24576:553648256,28672:262272,32768:16777216,36864:537133056,40960:536871040,45056:553910400,49152:553910272,53248:0,57344:17039488,61440:553648128,2048:17039488,6144:553648256,
	10240:128,14336:17039360,18432:262144,22528:537133184,26624:553910272,30720:536870912,34816:537133056,38912:0,43008:553910400,47104:16777344,51200:536871040,55296:553648128,59392:16777216,63488:262272,65536:262144,69632:128,73728:536870912,77824:553648256,81920:16777344,86016:553910272,90112:537133184,94208:16777216,98304:553910400,102400:553648128,106496:17039360,110592:537133056,114688:262272,118784:536871040,122880:0,126976:17039488,67584:553648256,71680:16777216,75776:17039360,79872:537133184,
	83968:536870912,88064:17039488,92160:128,96256:553910272,100352:262272,104448:553910400,108544:0,112640:553648128,116736:16777344,120832:262144,124928:537133056,129024:536871040},{"0":268435464,256:8192,512:270532608,768:270540808,1024:268443648,1280:2097152,1536:2097160,1792:268435456,2048:0,2304:268443656,2560:2105344,2816:8,3072:270532616,3328:2105352,3584:8200,3840:270540800,128:270532608,384:270540808,640:8,896:2097152,1152:2105352,1408:268435464,1664:268443648,1920:8200,2176:2097160,2432:8192,
	2688:268443656,2944:270532616,3200:0,3456:270540800,3712:2105344,3968:268435456,4096:268443648,4352:270532616,4608:270540808,4864:8200,5120:2097152,5376:268435456,5632:268435464,5888:2105344,6144:2105352,6400:0,6656:8,6912:270532608,7168:8192,7424:268443656,7680:270540800,7936:2097160,4224:8,4480:2105344,4736:2097152,4992:268435464,5248:268443648,5504:8200,5760:270540808,6016:270532608,6272:270540800,6528:270532616,6784:8192,7040:2105352,7296:2097160,7552:0,7808:268435456,8064:268443656},{"0":1048576,
	16:33555457,32:1024,48:1049601,64:34604033,80:0,96:1,112:34603009,128:33555456,144:1048577,160:33554433,176:34604032,192:34603008,208:1025,224:1049600,240:33554432,8:34603009,24:0,40:33555457,56:34604032,72:1048576,88:33554433,104:33554432,120:1025,136:1049601,152:33555456,168:34603008,184:1048577,200:1024,216:34604033,232:1,248:1049600,256:33554432,272:1048576,288:33555457,304:34603009,320:1048577,336:33555456,352:34604032,368:1049601,384:1025,400:34604033,416:1049600,432:1,448:0,464:34603008,480:33554433,
	496:1024,264:1049600,280:33555457,296:34603009,312:1,328:33554432,344:1048576,360:1025,376:34604032,392:33554433,408:34603008,424:0,440:34604033,456:1049601,472:1024,488:33555456,504:1048577},{"0":134219808,1:131072,2:134217728,3:32,4:131104,5:134350880,6:134350848,7:2048,8:134348800,9:134219776,10:133120,11:134348832,12:2080,13:0,14:134217760,15:133152,2147483648:2048,2147483649:134350880,2147483650:134219808,2147483651:134217728,2147483652:134348800,2147483653:133120,2147483654:133152,2147483655:32,
	2147483656:134217760,2147483657:2080,2147483658:131104,2147483659:134350848,2147483660:0,2147483661:134348832,2147483662:134219776,2147483663:131072,16:133152,17:134350848,18:32,19:2048,20:134219776,21:134217760,22:134348832,23:131072,24:0,25:131104,26:134348800,27:134219808,28:134350880,29:133120,30:2080,31:134217728,2147483664:131072,2147483665:2048,2147483666:134348832,2147483667:133152,2147483668:32,2147483669:134348800,2147483670:134217728,2147483671:134219808,2147483672:134350880,2147483673:134217760,
	2147483674:134219776,2147483675:0,2147483676:133120,2147483677:2080,2147483678:131104,2147483679:134350848}],t=[4160749569,528482304,33030144,2064384,129024,8064,504,2147483679],m=g.DES=e.extend({_doReset:function(){for(var b=this._key.words,c=[],a=0;56>a;a++){var f=q[a]-1;c[a]=b[f>>>5]>>>31-f%32&1;}b=this._subKeys=[];for(f=0;16>f;f++){for(var d=b[f]=[],e=r[f],a=0;24>a;a++)d[a/6|0]|=c[(p[a]-1+e)%28]<<31-a%6,d[4+(a/6|0)]|=c[28+(p[a+24]-1+e)%28]<<31-a%6;d[0]=d[0]<<1|d[0]>>>31;for(a=1;7>a;a++)d[a]>>>=
	4*(a-1)+3;d[7]=d[7]<<5|d[7]>>>27;}c=this._invSubKeys=[];for(a=0;16>a;a++)c[a]=b[15-a];},encryptBlock:function(b,c){this._doCryptBlock(b,c,this._subKeys);},decryptBlock:function(b,c){this._doCryptBlock(b,c,this._invSubKeys);},_doCryptBlock:function(b,c,a){this._lBlock=b[c];this._rBlock=b[c+1];j.call(this,4,252645135);j.call(this,16,65535);l.call(this,2,858993459);l.call(this,8,16711935);j.call(this,1,1431655765);for(var f=0;16>f;f++){for(var d=a[f],e=this._lBlock,h=this._rBlock,g=0,k=0;8>k;k++)g|=s[k][((h^
	d[k])&t[k])>>>0];this._lBlock=h;this._rBlock=e^g;}a=this._lBlock;this._lBlock=this._rBlock;this._rBlock=a;j.call(this,1,1431655765);l.call(this,8,16711935);l.call(this,2,858993459);j.call(this,16,65535);j.call(this,4,252645135);b[c]=this._lBlock;b[c+1]=this._rBlock;},keySize:2,ivSize:2,blockSize:2});h.DES=e._createHelper(m);g=g.TripleDES=e.extend({_doReset:function(){var b=this._key.words;this._des1=m.createEncryptor(n.create(b.slice(0,2)));this._des2=m.createEncryptor(n.create(b.slice(2,4)));this._des3=
	m.createEncryptor(n.create(b.slice(4,6)));},encryptBlock:function(b,c){this._des1.encryptBlock(b,c);this._des2.decryptBlock(b,c);this._des3.encryptBlock(b,c);},decryptBlock:function(b,c){this._des3.decryptBlock(b,c);this._des2.encryptBlock(b,c);this._des1.decryptBlock(b,c);},keySize:6,ivSize:2,blockSize:2});h.TripleDES=e._createHelper(g);})();

	/*
	CryptoJS v3.1.2 enc-base64.js
	code.google.com/p/crypto-js
	(c) 2009-2013 by Jeff Mott. All rights reserved.
	code.google.com/p/crypto-js/wiki/License
	*/
	(function(){var h=CryptoJS,j=h.lib.WordArray;h.enc.Base64={stringify:function(b){var e=b.words,f=b.sigBytes,c=this._map;b.clamp();b=[];for(var a=0;a<f;a+=3)for(var d=(e[a>>>2]>>>24-8*(a%4)&255)<<16|(e[a+1>>>2]>>>24-8*((a+1)%4)&255)<<8|e[a+2>>>2]>>>24-8*((a+2)%4)&255,g=0;4>g&&a+0.75*g<f;g++)b.push(c.charAt(d>>>6*(3-g)&63));if(e=c.charAt(64))for(;b.length%4;)b.push(e);return b.join("")},parse:function(b){var e=b.length,f=this._map,c=f.charAt(64);c&&(c=b.indexOf(c),-1!=c&&(e=c));for(var c=[],a=0,d=0;d<
	e;d++)if(d%4){var g=f.indexOf(b.charAt(d-1))<<2*(d%4),h=f.indexOf(b.charAt(d))>>>6-2*(d%4);c[a>>>2]|=(g|h)<<24-8*(a%4);a++;}return j.create(c,a)},_map:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/="};})();

	/*
	CryptoJS v3.1.2 md5.js
	code.google.com/p/crypto-js
	(c) 2009-2013 by Jeff Mott. All rights reserved.
	code.google.com/p/crypto-js/wiki/License
	*/
	(function(E){function h(a,f,g,j,p,h,k){a=a+(f&g|~f&j)+p+k;return (a<<h|a>>>32-h)+f}function k(a,f,g,j,p,h,k){a=a+(f&j|g&~j)+p+k;return (a<<h|a>>>32-h)+f}function l(a,f,g,j,h,k,l){a=a+(f^g^j)+h+l;return (a<<k|a>>>32-k)+f}function n(a,f,g,j,h,k,l){a=a+(g^(f|~j))+h+l;return (a<<k|a>>>32-k)+f}for(var r=CryptoJS,q=r.lib,F=q.WordArray,s=q.Hasher,q=r.algo,a=[],t=0;64>t;t++)a[t]=4294967296*E.abs(E.sin(t+1))|0;q=q.MD5=s.extend({_doReset:function(){this._hash=new F.init([1732584193,4023233417,2562383102,271733878]);},
	_doProcessBlock:function(m,f){for(var g=0;16>g;g++){var j=f+g,p=m[j];m[j]=(p<<8|p>>>24)&16711935|(p<<24|p>>>8)&4278255360;}var g=this._hash.words,j=m[f+0],p=m[f+1],q=m[f+2],r=m[f+3],s=m[f+4],t=m[f+5],u=m[f+6],v=m[f+7],w=m[f+8],x=m[f+9],y=m[f+10],z=m[f+11],A=m[f+12],B=m[f+13],C=m[f+14],D=m[f+15],b=g[0],c=g[1],d=g[2],e=g[3],b=h(b,c,d,e,j,7,a[0]),e=h(e,b,c,d,p,12,a[1]),d=h(d,e,b,c,q,17,a[2]),c=h(c,d,e,b,r,22,a[3]),b=h(b,c,d,e,s,7,a[4]),e=h(e,b,c,d,t,12,a[5]),d=h(d,e,b,c,u,17,a[6]),c=h(c,d,e,b,v,22,a[7]),
	b=h(b,c,d,e,w,7,a[8]),e=h(e,b,c,d,x,12,a[9]),d=h(d,e,b,c,y,17,a[10]),c=h(c,d,e,b,z,22,a[11]),b=h(b,c,d,e,A,7,a[12]),e=h(e,b,c,d,B,12,a[13]),d=h(d,e,b,c,C,17,a[14]),c=h(c,d,e,b,D,22,a[15]),b=k(b,c,d,e,p,5,a[16]),e=k(e,b,c,d,u,9,a[17]),d=k(d,e,b,c,z,14,a[18]),c=k(c,d,e,b,j,20,a[19]),b=k(b,c,d,e,t,5,a[20]),e=k(e,b,c,d,y,9,a[21]),d=k(d,e,b,c,D,14,a[22]),c=k(c,d,e,b,s,20,a[23]),b=k(b,c,d,e,x,5,a[24]),e=k(e,b,c,d,C,9,a[25]),d=k(d,e,b,c,r,14,a[26]),c=k(c,d,e,b,w,20,a[27]),b=k(b,c,d,e,B,5,a[28]),e=k(e,b,
	c,d,q,9,a[29]),d=k(d,e,b,c,v,14,a[30]),c=k(c,d,e,b,A,20,a[31]),b=l(b,c,d,e,t,4,a[32]),e=l(e,b,c,d,w,11,a[33]),d=l(d,e,b,c,z,16,a[34]),c=l(c,d,e,b,C,23,a[35]),b=l(b,c,d,e,p,4,a[36]),e=l(e,b,c,d,s,11,a[37]),d=l(d,e,b,c,v,16,a[38]),c=l(c,d,e,b,y,23,a[39]),b=l(b,c,d,e,B,4,a[40]),e=l(e,b,c,d,j,11,a[41]),d=l(d,e,b,c,r,16,a[42]),c=l(c,d,e,b,u,23,a[43]),b=l(b,c,d,e,x,4,a[44]),e=l(e,b,c,d,A,11,a[45]),d=l(d,e,b,c,D,16,a[46]),c=l(c,d,e,b,q,23,a[47]),b=n(b,c,d,e,j,6,a[48]),e=n(e,b,c,d,v,10,a[49]),d=n(d,e,b,c,
	C,15,a[50]),c=n(c,d,e,b,t,21,a[51]),b=n(b,c,d,e,A,6,a[52]),e=n(e,b,c,d,r,10,a[53]),d=n(d,e,b,c,y,15,a[54]),c=n(c,d,e,b,p,21,a[55]),b=n(b,c,d,e,w,6,a[56]),e=n(e,b,c,d,D,10,a[57]),d=n(d,e,b,c,u,15,a[58]),c=n(c,d,e,b,B,21,a[59]),b=n(b,c,d,e,s,6,a[60]),e=n(e,b,c,d,z,10,a[61]),d=n(d,e,b,c,q,15,a[62]),c=n(c,d,e,b,x,21,a[63]);g[0]=g[0]+b|0;g[1]=g[1]+c|0;g[2]=g[2]+d|0;g[3]=g[3]+e|0;},_doFinalize:function(){var a=this._data,f=a.words,g=8*this._nDataBytes,j=8*a.sigBytes;f[j>>>5]|=128<<24-j%32;var h=E.floor(g/
	4294967296);f[(j+64>>>9<<4)+15]=(h<<8|h>>>24)&16711935|(h<<24|h>>>8)&4278255360;f[(j+64>>>9<<4)+14]=(g<<8|g>>>24)&16711935|(g<<24|g>>>8)&4278255360;a.sigBytes=4*(f.length+1);this._process();a=this._hash;f=a.words;for(g=0;4>g;g++)j=f[g],f[g]=(j<<8|j>>>24)&16711935|(j<<24|j>>>8)&4278255360;return a},clone:function(){var a=s.clone.call(this);a._hash=this._hash.clone();return a}});r.MD5=s._createHelper(q);r.HmacMD5=s._createHmacHelper(q);})(Math);

	/*
	CryptoJS v3.1.2 sha1-min.js
	code.google.com/p/crypto-js
	(c) 2009-2013 by Jeff Mott. All rights reserved.
	code.google.com/p/crypto-js/wiki/License
	*/
	(function(){var k=CryptoJS,b=k.lib,m=b.WordArray,l=b.Hasher,d=[],b=k.algo.SHA1=l.extend({_doReset:function(){this._hash=new m.init([1732584193,4023233417,2562383102,271733878,3285377520]);},_doProcessBlock:function(n,p){for(var a=this._hash.words,e=a[0],f=a[1],h=a[2],j=a[3],b=a[4],c=0;80>c;c++){if(16>c)d[c]=n[p+c]|0;else{var g=d[c-3]^d[c-8]^d[c-14]^d[c-16];d[c]=g<<1|g>>>31;}g=(e<<5|e>>>27)+b+d[c];g=20>c?g+((f&h|~f&j)+1518500249):40>c?g+((f^h^j)+1859775393):60>c?g+((f&h|f&j|h&j)-1894007588):g+((f^h^
	j)-899497514);b=j;j=h;h=f<<30|f>>>2;f=e;e=g;}a[0]=a[0]+e|0;a[1]=a[1]+f|0;a[2]=a[2]+h|0;a[3]=a[3]+j|0;a[4]=a[4]+b|0;},_doFinalize:function(){var b=this._data,d=b.words,a=8*this._nDataBytes,e=8*b.sigBytes;d[e>>>5]|=128<<24-e%32;d[(e+64>>>9<<4)+14]=Math.floor(a/4294967296);d[(e+64>>>9<<4)+15]=a;b.sigBytes=4*d.length;this._process();return this._hash},clone:function(){var b=l.clone.call(this);b._hash=this._hash.clone();return b}});k.SHA1=l._createHelper(b);k.HmacSHA1=l._createHmacHelper(b);})();

	/*
	CryptoJS v3.1.2 sha256-min.js
	code.google.com/p/crypto-js
	(c) 2009-2013 by Jeff Mott. All rights reserved.
	code.google.com/p/crypto-js/wiki/License
	*/
	(function(k){for(var g=CryptoJS,h=g.lib,v=h.WordArray,j=h.Hasher,h=g.algo,s=[],t=[],u=function(q){return 4294967296*(q-(q|0))|0},l=2,b=0;64>b;){var d;a:{d=l;for(var w=k.sqrt(d),r=2;r<=w;r++)if(!(d%r)){d=!1;break a}d=!0;}d&&(8>b&&(s[b]=u(k.pow(l,0.5))),t[b]=u(k.pow(l,1/3)),b++);l++;}var n=[],h=h.SHA256=j.extend({_doReset:function(){this._hash=new v.init(s.slice(0));},_doProcessBlock:function(q,h){for(var a=this._hash.words,c=a[0],d=a[1],b=a[2],k=a[3],f=a[4],g=a[5],j=a[6],l=a[7],e=0;64>e;e++){if(16>e)n[e]=
	q[h+e]|0;else{var m=n[e-15],p=n[e-2];n[e]=((m<<25|m>>>7)^(m<<14|m>>>18)^m>>>3)+n[e-7]+((p<<15|p>>>17)^(p<<13|p>>>19)^p>>>10)+n[e-16];}m=l+((f<<26|f>>>6)^(f<<21|f>>>11)^(f<<7|f>>>25))+(f&g^~f&j)+t[e]+n[e];p=((c<<30|c>>>2)^(c<<19|c>>>13)^(c<<10|c>>>22))+(c&d^c&b^d&b);l=j;j=g;g=f;f=k+m|0;k=b;b=d;d=c;c=m+p|0;}a[0]=a[0]+c|0;a[1]=a[1]+d|0;a[2]=a[2]+b|0;a[3]=a[3]+k|0;a[4]=a[4]+f|0;a[5]=a[5]+g|0;a[6]=a[6]+j|0;a[7]=a[7]+l|0;},_doFinalize:function(){var d=this._data,b=d.words,a=8*this._nDataBytes,c=8*d.sigBytes;
	b[c>>>5]|=128<<24-c%32;b[(c+64>>>9<<4)+14]=k.floor(a/4294967296);b[(c+64>>>9<<4)+15]=a;d.sigBytes=4*b.length;this._process();return this._hash},clone:function(){var b=j.clone.call(this);b._hash=this._hash.clone();return b}});g.SHA256=j._createHelper(h);g.HmacSHA256=j._createHmacHelper(h);})(Math);

	/*
	CryptoJS v3.1.2 sha224-min.js
	code.google.com/p/crypto-js
	(c) 2009-2013 by Jeff Mott. All rights reserved.
	code.google.com/p/crypto-js/wiki/License
	*/
	(function(){var b=CryptoJS,d=b.lib.WordArray,a=b.algo,c=a.SHA256,a=a.SHA224=c.extend({_doReset:function(){this._hash=new d.init([3238371032,914150663,812702999,4144912697,4290775857,1750603025,1694076839,3204075428]);},_doFinalize:function(){var a=c._doFinalize.call(this);a.sigBytes-=4;return a}});b.SHA224=c._createHelper(a);b.HmacSHA224=c._createHmacHelper(a);})();

	/*
	CryptoJS v3.1.2 sha512-min.js
	code.google.com/p/crypto-js
	(c) 2009-2013 by Jeff Mott. All rights reserved.
	code.google.com/p/crypto-js/wiki/License
	*/
	(function(){function a(){return d.create.apply(d,arguments)}for(var n=CryptoJS,r=n.lib.Hasher,e=n.x64,d=e.Word,T=e.WordArray,e=n.algo,ea=[a(1116352408,3609767458),a(1899447441,602891725),a(3049323471,3964484399),a(3921009573,2173295548),a(961987163,4081628472),a(1508970993,3053834265),a(2453635748,2937671579),a(2870763221,3664609560),a(3624381080,2734883394),a(310598401,1164996542),a(607225278,1323610764),a(1426881987,3590304994),a(1925078388,4068182383),a(2162078206,991336113),a(2614888103,633803317),
	a(3248222580,3479774868),a(3835390401,2666613458),a(4022224774,944711139),a(264347078,2341262773),a(604807628,2007800933),a(770255983,1495990901),a(1249150122,1856431235),a(1555081692,3175218132),a(1996064986,2198950837),a(2554220882,3999719339),a(2821834349,766784016),a(2952996808,2566594879),a(3210313671,3203337956),a(3336571891,1034457026),a(3584528711,2466948901),a(113926993,3758326383),a(338241895,168717936),a(666307205,1188179964),a(773529912,1546045734),a(1294757372,1522805485),a(1396182291,
	2643833823),a(1695183700,2343527390),a(1986661051,1014477480),a(2177026350,1206759142),a(2456956037,344077627),a(2730485921,1290863460),a(2820302411,3158454273),a(3259730800,3505952657),a(3345764771,106217008),a(3516065817,3606008344),a(3600352804,1432725776),a(4094571909,1467031594),a(275423344,851169720),a(430227734,3100823752),a(506948616,1363258195),a(659060556,3750685593),a(883997877,3785050280),a(958139571,3318307427),a(1322822218,3812723403),a(1537002063,2003034995),a(1747873779,3602036899),
	a(1955562222,1575990012),a(2024104815,1125592928),a(2227730452,2716904306),a(2361852424,442776044),a(2428436474,593698344),a(2756734187,3733110249),a(3204031479,2999351573),a(3329325298,3815920427),a(3391569614,3928383900),a(3515267271,566280711),a(3940187606,3454069534),a(4118630271,4000239992),a(116418474,1914138554),a(174292421,2731055270),a(289380356,3203993006),a(460393269,320620315),a(685471733,587496836),a(852142971,1086792851),a(1017036298,365543100),a(1126000580,2618297676),a(1288033470,
	3409855158),a(1501505948,4234509866),a(1607167915,987167468),a(1816402316,1246189591)],v=[],w=0;80>w;w++)v[w]=a();e=e.SHA512=r.extend({_doReset:function(){this._hash=new T.init([new d.init(1779033703,4089235720),new d.init(3144134277,2227873595),new d.init(1013904242,4271175723),new d.init(2773480762,1595750129),new d.init(1359893119,2917565137),new d.init(2600822924,725511199),new d.init(528734635,4215389547),new d.init(1541459225,327033209)]);},_doProcessBlock:function(a,d){for(var f=this._hash.words,
	F=f[0],e=f[1],n=f[2],r=f[3],G=f[4],H=f[5],I=f[6],f=f[7],w=F.high,J=F.low,X=e.high,K=e.low,Y=n.high,L=n.low,Z=r.high,M=r.low,$=G.high,N=G.low,aa=H.high,O=H.low,ba=I.high,P=I.low,ca=f.high,Q=f.low,k=w,g=J,z=X,x=K,A=Y,y=L,U=Z,B=M,l=$,h=N,R=aa,C=O,S=ba,D=P,V=ca,E=Q,m=0;80>m;m++){var s=v[m];if(16>m)var j=s.high=a[d+2*m]|0,b=s.low=a[d+2*m+1]|0;else{var j=v[m-15],b=j.high,p=j.low,j=(b>>>1|p<<31)^(b>>>8|p<<24)^b>>>7,p=(p>>>1|b<<31)^(p>>>8|b<<24)^(p>>>7|b<<25),u=v[m-2],b=u.high,c=u.low,u=(b>>>19|c<<13)^(b<<
	3|c>>>29)^b>>>6,c=(c>>>19|b<<13)^(c<<3|b>>>29)^(c>>>6|b<<26),b=v[m-7],W=b.high,t=v[m-16],q=t.high,t=t.low,b=p+b.low,j=j+W+(b>>>0<p>>>0?1:0),b=b+c,j=j+u+(b>>>0<c>>>0?1:0),b=b+t,j=j+q+(b>>>0<t>>>0?1:0);s.high=j;s.low=b;}var W=l&R^~l&S,t=h&C^~h&D,s=k&z^k&A^z&A,T=g&x^g&y^x&y,p=(k>>>28|g<<4)^(k<<30|g>>>2)^(k<<25|g>>>7),u=(g>>>28|k<<4)^(g<<30|k>>>2)^(g<<25|k>>>7),c=ea[m],fa=c.high,da=c.low,c=E+((h>>>14|l<<18)^(h>>>18|l<<14)^(h<<23|l>>>9)),q=V+((l>>>14|h<<18)^(l>>>18|h<<14)^(l<<23|h>>>9))+(c>>>0<E>>>0?1:
	0),c=c+t,q=q+W+(c>>>0<t>>>0?1:0),c=c+da,q=q+fa+(c>>>0<da>>>0?1:0),c=c+b,q=q+j+(c>>>0<b>>>0?1:0),b=u+T,s=p+s+(b>>>0<u>>>0?1:0),V=S,E=D,S=R,D=C,R=l,C=h,h=B+c|0,l=U+q+(h>>>0<B>>>0?1:0)|0,U=A,B=y,A=z,y=x,z=k,x=g,g=c+b|0,k=q+s+(g>>>0<c>>>0?1:0)|0;}J=F.low=J+g;F.high=w+k+(J>>>0<g>>>0?1:0);K=e.low=K+x;e.high=X+z+(K>>>0<x>>>0?1:0);L=n.low=L+y;n.high=Y+A+(L>>>0<y>>>0?1:0);M=r.low=M+B;r.high=Z+U+(M>>>0<B>>>0?1:0);N=G.low=N+h;G.high=$+l+(N>>>0<h>>>0?1:0);O=H.low=O+C;H.high=aa+R+(O>>>0<C>>>0?1:0);P=I.low=P+D;
	I.high=ba+S+(P>>>0<D>>>0?1:0);Q=f.low=Q+E;f.high=ca+V+(Q>>>0<E>>>0?1:0);},_doFinalize:function(){var a=this._data,d=a.words,f=8*this._nDataBytes,e=8*a.sigBytes;d[e>>>5]|=128<<24-e%32;d[(e+128>>>10<<5)+30]=Math.floor(f/4294967296);d[(e+128>>>10<<5)+31]=f;a.sigBytes=4*d.length;this._process();return this._hash.toX32()},clone:function(){var a=r.clone.call(this);a._hash=this._hash.clone();return a},blockSize:32});n.SHA512=r._createHelper(e);n.HmacSHA512=r._createHmacHelper(e);})();

	/*
	CryptoJS v3.1.2 sha384-min.js
	code.google.com/p/crypto-js
	(c) 2009-2013 by Jeff Mott. All rights reserved.
	code.google.com/p/crypto-js/wiki/License
	*/
	(function(){var c=CryptoJS,a=c.x64,b=a.Word,e=a.WordArray,a=c.algo,d=a.SHA512,a=a.SHA384=d.extend({_doReset:function(){this._hash=new e.init([new b.init(3418070365,3238371032),new b.init(1654270250,914150663),new b.init(2438529370,812702999),new b.init(355462360,4144912697),new b.init(1731405415,4290775857),new b.init(2394180231,1750603025),new b.init(3675008525,1694076839),new b.init(1203062813,3204075428)]);},_doFinalize:function(){var a=d._doFinalize.call(this);a.sigBytes-=16;return a}});c.SHA384=
	d._createHelper(a);c.HmacSHA384=d._createHmacHelper(a);})();

	/*
	CryptoJS v3.1.2 ripemd160-min.js
	code.google.com/p/crypto-js
	(c) 2009-2013 by Jeff Mott. All rights reserved.
	code.google.com/p/crypto-js/wiki/License
	*/
	/*

	(c) 2012 by Cedric Mesnil. All rights reserved.

	Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:

	    - Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
	    - Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.

	THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*/
	(function(){var q=CryptoJS,d=q.lib,n=d.WordArray,p=d.Hasher,d=q.algo,x=n.create([0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,7,4,13,1,10,6,15,3,12,0,9,5,2,14,11,8,3,10,14,4,9,15,8,1,2,7,0,6,13,11,5,12,1,9,11,10,0,8,12,4,13,3,7,15,14,5,6,2,4,0,5,9,7,12,2,10,14,1,3,8,11,6,15,13]),y=n.create([5,14,7,0,9,2,11,4,13,6,15,8,1,10,3,12,6,11,3,7,0,13,5,10,14,15,8,12,4,9,1,2,15,5,1,3,7,14,6,9,11,8,12,2,10,0,4,13,8,6,4,1,3,11,15,0,5,12,2,13,9,7,10,14,12,15,10,4,1,5,8,7,6,2,13,14,0,3,9,11]),z=n.create([11,14,15,12,
	5,8,7,9,11,13,14,15,6,7,9,8,7,6,8,13,11,9,7,15,7,12,15,9,11,7,13,12,11,13,6,7,14,9,13,15,14,8,13,6,5,12,7,5,11,12,14,15,14,15,9,8,9,14,5,6,8,6,5,12,9,15,5,11,6,8,13,12,5,12,13,14,11,8,5,6]),A=n.create([8,9,9,11,13,15,15,5,7,7,8,11,14,14,12,6,9,13,15,7,12,8,9,11,7,7,12,7,6,15,13,11,9,7,15,11,8,6,6,14,12,13,5,14,13,13,7,5,15,5,8,11,14,14,6,14,6,9,12,9,12,5,15,8,8,5,12,9,12,5,14,6,8,13,6,5,15,13,11,11]),B=n.create([0,1518500249,1859775393,2400959708,2840853838]),C=n.create([1352829926,1548603684,1836072691,
	2053994217,0]),d=d.RIPEMD160=p.extend({_doReset:function(){this._hash=n.create([1732584193,4023233417,2562383102,271733878,3285377520]);},_doProcessBlock:function(e,v){for(var b=0;16>b;b++){var c=v+b,f=e[c];e[c]=(f<<8|f>>>24)&16711935|(f<<24|f>>>8)&4278255360;}var c=this._hash.words,f=B.words,d=C.words,n=x.words,q=y.words,p=z.words,w=A.words,t,g,h,j,r,u,k,l,m,s;u=t=c[0];k=g=c[1];l=h=c[2];m=j=c[3];s=r=c[4];for(var a,b=0;80>b;b+=1)a=t+e[v+n[b]]|0,a=16>b?a+((g^h^j)+f[0]):32>b?a+((g&h|~g&j)+f[1]):48>b?
	a+(((g|~h)^j)+f[2]):64>b?a+((g&j|h&~j)+f[3]):a+((g^(h|~j))+f[4]),a|=0,a=a<<p[b]|a>>>32-p[b],a=a+r|0,t=r,r=j,j=h<<10|h>>>22,h=g,g=a,a=u+e[v+q[b]]|0,a=16>b?a+((k^(l|~m))+d[0]):32>b?a+((k&m|l&~m)+d[1]):48>b?a+(((k|~l)^m)+d[2]):64>b?a+((k&l|~k&m)+d[3]):a+((k^l^m)+d[4]),a|=0,a=a<<w[b]|a>>>32-w[b],a=a+s|0,u=s,s=m,m=l<<10|l>>>22,l=k,k=a;a=c[1]+h+m|0;c[1]=c[2]+j+s|0;c[2]=c[3]+r+u|0;c[3]=c[4]+t+k|0;c[4]=c[0]+g+l|0;c[0]=a;},_doFinalize:function(){var e=this._data,d=e.words,b=8*this._nDataBytes,c=8*e.sigBytes;
	d[c>>>5]|=128<<24-c%32;d[(c+64>>>9<<4)+14]=(b<<8|b>>>24)&16711935|(b<<24|b>>>8)&4278255360;e.sigBytes=4*(d.length+1);this._process();e=this._hash;d=e.words;for(b=0;5>b;b++)c=d[b],d[b]=(c<<8|c>>>24)&16711935|(c<<24|c>>>8)&4278255360;return e},clone:function(){var d=p.clone.call(this);d._hash=this._hash.clone();return d}});q.RIPEMD160=p._createHelper(d);q.HmacRIPEMD160=p._createHmacHelper(d);})();

	/*
	CryptoJS v3.1.2 hmac.js
	code.google.com/p/crypto-js
	(c) 2009-2013 by Jeff Mott. All rights reserved.
	code.google.com/p/crypto-js/wiki/License
	*/
	(function(){var c=CryptoJS,k=c.enc.Utf8;c.algo.HMAC=c.lib.Base.extend({init:function(a,b){a=this._hasher=new a.init;"string"==typeof b&&(b=k.parse(b));var c=a.blockSize,e=4*c;b.sigBytes>e&&(b=a.finalize(b));b.clamp();for(var f=this._oKey=b.clone(),g=this._iKey=b.clone(),h=f.words,j=g.words,d=0;d<c;d++)h[d]^=1549556828,j[d]^=909522486;f.sigBytes=g.sigBytes=e;this.reset();},reset:function(){var a=this._hasher;a.reset();a.update(this._iKey);},update:function(a){this._hasher.update(a);return this},finalize:function(a){var b=
	this._hasher;a=b.finalize(a);b.reset();return b.finalize(this._oKey.clone().concat(a))}});})();

	/*
	CryptoJS v3.1.2 pbkdf2-min.js
	code.google.com/p/crypto-js
	(c) 2009-2013 by Jeff Mott. All rights reserved.
	code.google.com/p/crypto-js/wiki/License
	*/
	(function(){var b=CryptoJS,a=b.lib,d=a.Base,m=a.WordArray,a=b.algo,q=a.HMAC,l=a.PBKDF2=d.extend({cfg:d.extend({keySize:4,hasher:a.SHA1,iterations:1}),init:function(a){this.cfg=this.cfg.extend(a);},compute:function(a,b){for(var c=this.cfg,f=q.create(c.hasher,a),g=m.create(),d=m.create([1]),l=g.words,r=d.words,n=c.keySize,c=c.iterations;l.length<n;){var h=f.update(b).finalize(d);f.reset();for(var j=h.words,s=j.length,k=h,p=1;p<c;p++){k=f.finalize(k);f.reset();for(var t=k.words,e=0;e<s;e++)j[e]^=t[e];}g.concat(h);
	r[0]++;}g.sigBytes=4*n;return g}});b.PBKDF2=function(a,b,c){return l.create(c).compute(a,b)};})();

	/*! (c) Tom Wu | http://www-cs-students.stanford.edu/~tjw/jsbn/
	 */
	var b64map="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";var b64pad="=";function hex2b64(d){var b;var e;var a="";for(b=0;b+3<=d.length;b+=3){e=parseInt(d.substring(b,b+3),16);a+=b64map.charAt(e>>6)+b64map.charAt(e&63);}if(b+1==d.length){e=parseInt(d.substring(b,b+1),16);a+=b64map.charAt(e<<2);}else{if(b+2==d.length){e=parseInt(d.substring(b,b+2),16);a+=b64map.charAt(e>>2)+b64map.charAt((e&3)<<4);}}{while((a.length&3)>0){a+=b64pad;}}return a}function b64tohex(f){var d="";var e;var b=0;var c;var a;for(e=0;e<f.length;++e){if(f.charAt(e)==b64pad){break}a=b64map.indexOf(f.charAt(e));if(a<0){continue}if(b==0){d+=int2char(a>>2);c=a&3;b=1;}else{if(b==1){d+=int2char((c<<2)|(a>>4));c=a&15;b=2;}else{if(b==2){d+=int2char(c);d+=int2char(a>>2);c=a&3;b=3;}else{d+=int2char((c<<2)|(a>>4));d+=int2char(a&15);b=0;}}}}if(b==1){d+=int2char(c<<2);}return d}/*! (c) Tom Wu | http://www-cs-students.stanford.edu/~tjw/jsbn/
	 */
	var dbits;function BigInteger(e,d,f){if(e!=null){if("number"==typeof e){this.fromNumber(e,d,f);}else{if(d==null&&"string"!=typeof e){this.fromString(e,256);}else{this.fromString(e,d);}}}}function nbi(){return new BigInteger(null)}function am1(f,a,b,e,h,g){while(--g>=0){var d=a*this[f++]+b[e]+h;h=Math.floor(d/67108864);b[e++]=d&67108863;}return h}{{BigInteger.prototype.am=am1;dbits=26;}}BigInteger.prototype.DB=dbits;BigInteger.prototype.DM=((1<<dbits)-1);BigInteger.prototype.DV=(1<<dbits);var BI_FP=52;BigInteger.prototype.FV=Math.pow(2,BI_FP);BigInteger.prototype.F1=BI_FP-dbits;BigInteger.prototype.F2=2*dbits-BI_FP;var BI_RM="0123456789abcdefghijklmnopqrstuvwxyz";var BI_RC=new Array();var rr,vv;rr="0".charCodeAt(0);for(vv=0;vv<=9;++vv){BI_RC[rr++]=vv;}rr="a".charCodeAt(0);for(vv=10;vv<36;++vv){BI_RC[rr++]=vv;}rr="A".charCodeAt(0);for(vv=10;vv<36;++vv){BI_RC[rr++]=vv;}function int2char(a){return BI_RM.charAt(a)}function intAt(b,a){var d=BI_RC[b.charCodeAt(a)];return (d==null)?-1:d}function bnpCopyTo(b){for(var a=this.t-1;a>=0;--a){b[a]=this[a];}b.t=this.t;b.s=this.s;}function bnpFromInt(a){this.t=1;this.s=(a<0)?-1:0;if(a>0){this[0]=a;}else{if(a<-1){this[0]=a+this.DV;}else{this.t=0;}}}function nbv(a){var b=nbi();b.fromInt(a);return b}function bnpFromString(h,c){var e;if(c==16){e=4;}else{if(c==8){e=3;}else{if(c==256){e=8;}else{if(c==2){e=1;}else{if(c==32){e=5;}else{if(c==4){e=2;}else{this.fromRadix(h,c);return}}}}}}this.t=0;this.s=0;var g=h.length,d=false,f=0;while(--g>=0){var a=(e==8)?h[g]&255:intAt(h,g);if(a<0){if(h.charAt(g)=="-"){d=true;}continue}d=false;if(f==0){this[this.t++]=a;}else{if(f+e>this.DB){this[this.t-1]|=(a&((1<<(this.DB-f))-1))<<f;this[this.t++]=(a>>(this.DB-f));}else{this[this.t-1]|=a<<f;}}f+=e;if(f>=this.DB){f-=this.DB;}}if(e==8&&(h[0]&128)!=0){this.s=-1;if(f>0){this[this.t-1]|=((1<<(this.DB-f))-1)<<f;}}this.clamp();if(d){BigInteger.ZERO.subTo(this,this);}}function bnpClamp(){var a=this.s&this.DM;while(this.t>0&&this[this.t-1]==a){--this.t;}}function bnToString(c){if(this.s<0){return "-"+this.negate().toString(c)}var e;if(c==16){e=4;}else{if(c==8){e=3;}else{if(c==2){e=1;}else{if(c==32){e=5;}else{if(c==4){e=2;}else{return this.toRadix(c)}}}}}var g=(1<<e)-1,l,a=false,h="",f=this.t;var j=this.DB-(f*this.DB)%e;if(f-->0){if(j<this.DB&&(l=this[f]>>j)>0){a=true;h=int2char(l);}while(f>=0){if(j<e){l=(this[f]&((1<<j)-1))<<(e-j);l|=this[--f]>>(j+=this.DB-e);}else{l=(this[f]>>(j-=e))&g;if(j<=0){j+=this.DB;--f;}}if(l>0){a=true;}if(a){h+=int2char(l);}}}return a?h:"0"}function bnNegate(){var a=nbi();BigInteger.ZERO.subTo(this,a);return a}function bnAbs(){return (this.s<0)?this.negate():this}function bnCompareTo(b){var d=this.s-b.s;if(d!=0){return d}var c=this.t;d=c-b.t;if(d!=0){return (this.s<0)?-d:d}while(--c>=0){if((d=this[c]-b[c])!=0){return d}}return 0}function nbits(a){var c=1,b;if((b=a>>>16)!=0){a=b;c+=16;}if((b=a>>8)!=0){a=b;c+=8;}if((b=a>>4)!=0){a=b;c+=4;}if((b=a>>2)!=0){a=b;c+=2;}if((b=a>>1)!=0){a=b;c+=1;}return c}function bnBitLength(){if(this.t<=0){return 0}return this.DB*(this.t-1)+nbits(this[this.t-1]^(this.s&this.DM))}function bnpDLShiftTo(c,b){var a;for(a=this.t-1;a>=0;--a){b[a+c]=this[a];}for(a=c-1;a>=0;--a){b[a]=0;}b.t=this.t+c;b.s=this.s;}function bnpDRShiftTo(c,b){for(var a=c;a<this.t;++a){b[a-c]=this[a];}b.t=Math.max(this.t-c,0);b.s=this.s;}function bnpLShiftTo(j,e){var b=j%this.DB;var a=this.DB-b;var g=(1<<a)-1;var f=Math.floor(j/this.DB),h=(this.s<<b)&this.DM,d;for(d=this.t-1;d>=0;--d){e[d+f+1]=(this[d]>>a)|h;h=(this[d]&g)<<b;}for(d=f-1;d>=0;--d){e[d]=0;}e[f]=h;e.t=this.t+f+1;e.s=this.s;e.clamp();}function bnpRShiftTo(g,d){d.s=this.s;var e=Math.floor(g/this.DB);if(e>=this.t){d.t=0;return}var b=g%this.DB;var a=this.DB-b;var f=(1<<b)-1;d[0]=this[e]>>b;for(var c=e+1;c<this.t;++c){d[c-e-1]|=(this[c]&f)<<a;d[c-e]=this[c]>>b;}if(b>0){d[this.t-e-1]|=(this.s&f)<<a;}d.t=this.t-e;d.clamp();}function bnpSubTo(d,f){var e=0,g=0,b=Math.min(d.t,this.t);while(e<b){g+=this[e]-d[e];f[e++]=g&this.DM;g>>=this.DB;}if(d.t<this.t){g-=d.s;while(e<this.t){g+=this[e];f[e++]=g&this.DM;g>>=this.DB;}g+=this.s;}else{g+=this.s;while(e<d.t){g-=d[e];f[e++]=g&this.DM;g>>=this.DB;}g-=d.s;}f.s=(g<0)?-1:0;if(g<-1){f[e++]=this.DV+g;}else{if(g>0){f[e++]=g;}}f.t=e;f.clamp();}function bnpMultiplyTo(c,e){var b=this.abs(),f=c.abs();var d=b.t;e.t=d+f.t;while(--d>=0){e[d]=0;}for(d=0;d<f.t;++d){e[d+b.t]=b.am(0,f[d],e,d,0,b.t);}e.s=0;e.clamp();if(this.s!=c.s){BigInteger.ZERO.subTo(e,e);}}function bnpSquareTo(d){var a=this.abs();var b=d.t=2*a.t;while(--b>=0){d[b]=0;}for(b=0;b<a.t-1;++b){var e=a.am(b,a[b],d,2*b,0,1);if((d[b+a.t]+=a.am(b+1,2*a[b],d,2*b+1,e,a.t-b-1))>=a.DV){d[b+a.t]-=a.DV;d[b+a.t+1]=1;}}if(d.t>0){d[d.t-1]+=a.am(b,a[b],d,2*b,0,1);}d.s=0;d.clamp();}function bnpDivRemTo(n,h,g){var w=n.abs();if(w.t<=0){return}var k=this.abs();if(k.t<w.t){if(h!=null){h.fromInt(0);}if(g!=null){this.copyTo(g);}return}if(g==null){g=nbi();}var d=nbi(),a=this.s,l=n.s;var v=this.DB-nbits(w[w.t-1]);if(v>0){w.lShiftTo(v,d);k.lShiftTo(v,g);}else{w.copyTo(d);k.copyTo(g);}var p=d.t;var b=d[p-1];if(b==0){return}var o=b*(1<<this.F1)+((p>1)?d[p-2]>>this.F2:0);var A=this.FV/o,z=(1<<this.F1)/o,x=1<<this.F2;var u=g.t,s=u-p,f=(h==null)?nbi():h;d.dlShiftTo(s,f);if(g.compareTo(f)>=0){g[g.t++]=1;g.subTo(f,g);}BigInteger.ONE.dlShiftTo(p,f);f.subTo(d,d);while(d.t<p){d[d.t++]=0;}while(--s>=0){var c=(g[--u]==b)?this.DM:Math.floor(g[u]*A+(g[u-1]+x)*z);if((g[u]+=d.am(0,c,g,s,0,p))<c){d.dlShiftTo(s,f);g.subTo(f,g);while(g[u]<--c){g.subTo(f,g);}}}if(h!=null){g.drShiftTo(p,h);if(a!=l){BigInteger.ZERO.subTo(h,h);}}g.t=p;g.clamp();if(v>0){g.rShiftTo(v,g);}if(a<0){BigInteger.ZERO.subTo(g,g);}}function bnMod(b){var c=nbi();this.abs().divRemTo(b,null,c);if(this.s<0&&c.compareTo(BigInteger.ZERO)>0){b.subTo(c,c);}return c}function Classic(a){this.m=a;}function cConvert(a){if(a.s<0||a.compareTo(this.m)>=0){return a.mod(this.m)}else{return a}}function cRevert(a){return a}function cReduce(a){a.divRemTo(this.m,null,a);}function cMulTo(a,c,b){a.multiplyTo(c,b);this.reduce(b);}function cSqrTo(a,b){a.squareTo(b);this.reduce(b);}Classic.prototype.convert=cConvert;Classic.prototype.revert=cRevert;Classic.prototype.reduce=cReduce;Classic.prototype.mulTo=cMulTo;Classic.prototype.sqrTo=cSqrTo;function bnpInvDigit(){if(this.t<1){return 0}var a=this[0];if((a&1)==0){return 0}var b=a&3;b=(b*(2-(a&15)*b))&15;b=(b*(2-(a&255)*b))&255;b=(b*(2-(((a&65535)*b)&65535)))&65535;b=(b*(2-a*b%this.DV))%this.DV;return (b>0)?this.DV-b:-b}function Montgomery(a){this.m=a;this.mp=a.invDigit();this.mpl=this.mp&32767;this.mph=this.mp>>15;this.um=(1<<(a.DB-15))-1;this.mt2=2*a.t;}function montConvert(a){var b=nbi();a.abs().dlShiftTo(this.m.t,b);b.divRemTo(this.m,null,b);if(a.s<0&&b.compareTo(BigInteger.ZERO)>0){this.m.subTo(b,b);}return b}function montRevert(a){var b=nbi();a.copyTo(b);this.reduce(b);return b}function montReduce(a){while(a.t<=this.mt2){a[a.t++]=0;}for(var c=0;c<this.m.t;++c){var b=a[c]&32767;var d=(b*this.mpl+(((b*this.mph+(a[c]>>15)*this.mpl)&this.um)<<15))&a.DM;b=c+this.m.t;a[b]+=this.m.am(0,d,a,c,0,this.m.t);while(a[b]>=a.DV){a[b]-=a.DV;a[++b]++;}}a.clamp();a.drShiftTo(this.m.t,a);if(a.compareTo(this.m)>=0){a.subTo(this.m,a);}}function montSqrTo(a,b){a.squareTo(b);this.reduce(b);}function montMulTo(a,c,b){a.multiplyTo(c,b);this.reduce(b);}Montgomery.prototype.convert=montConvert;Montgomery.prototype.revert=montRevert;Montgomery.prototype.reduce=montReduce;Montgomery.prototype.mulTo=montMulTo;Montgomery.prototype.sqrTo=montSqrTo;function bnpIsEven(){return ((this.t>0)?(this[0]&1):this.s)==0}function bnpExp(h,j){if(h>4294967295||h<1){return BigInteger.ONE}var f=nbi(),a=nbi(),d=j.convert(this),c=nbits(h)-1;d.copyTo(f);while(--c>=0){j.sqrTo(f,a);if((h&(1<<c))>0){j.mulTo(a,d,f);}else{var b=f;f=a;a=b;}}return j.revert(f)}function bnModPowInt(b,a){var c;if(b<256||a.isEven()){c=new Classic(a);}else{c=new Montgomery(a);}return this.exp(b,c)}BigInteger.prototype.copyTo=bnpCopyTo;BigInteger.prototype.fromInt=bnpFromInt;BigInteger.prototype.fromString=bnpFromString;BigInteger.prototype.clamp=bnpClamp;BigInteger.prototype.dlShiftTo=bnpDLShiftTo;BigInteger.prototype.drShiftTo=bnpDRShiftTo;BigInteger.prototype.lShiftTo=bnpLShiftTo;BigInteger.prototype.rShiftTo=bnpRShiftTo;BigInteger.prototype.subTo=bnpSubTo;BigInteger.prototype.multiplyTo=bnpMultiplyTo;BigInteger.prototype.squareTo=bnpSquareTo;BigInteger.prototype.divRemTo=bnpDivRemTo;BigInteger.prototype.invDigit=bnpInvDigit;BigInteger.prototype.isEven=bnpIsEven;BigInteger.prototype.exp=bnpExp;BigInteger.prototype.toString=bnToString;BigInteger.prototype.negate=bnNegate;BigInteger.prototype.abs=bnAbs;BigInteger.prototype.compareTo=bnCompareTo;BigInteger.prototype.bitLength=bnBitLength;BigInteger.prototype.mod=bnMod;BigInteger.prototype.modPowInt=bnModPowInt;BigInteger.ZERO=nbv(0);BigInteger.ONE=nbv(1);
	/*! (c) Tom Wu | http://www-cs-students.stanford.edu/~tjw/jsbn/
	 */
	function bnClone(){var a=nbi();this.copyTo(a);return a}function bnIntValue(){if(this.s<0){if(this.t==1){return this[0]-this.DV}else{if(this.t==0){return -1}}}else{if(this.t==1){return this[0]}else{if(this.t==0){return 0}}}return ((this[1]&((1<<(32-this.DB))-1))<<this.DB)|this[0]}function bnByteValue(){return (this.t==0)?this.s:(this[0]<<24)>>24}function bnShortValue(){return (this.t==0)?this.s:(this[0]<<16)>>16}function bnpChunkSize(a){return Math.floor(Math.LN2*this.DB/Math.log(a))}function bnSigNum(){if(this.s<0){return -1}else{if(this.t<=0||(this.t==1&&this[0]<=0)){return 0}else{return 1}}}function bnpToRadix(c){if(c==null){c=10;}if(this.signum()==0||c<2||c>36){return "0"}var f=this.chunkSize(c);var e=Math.pow(c,f);var i=nbv(e),j=nbi(),h=nbi(),g="";this.divRemTo(i,j,h);while(j.signum()>0){g=(e+h.intValue()).toString(c).substr(1)+g;j.divRemTo(i,j,h);}return h.intValue().toString(c)+g}function bnpFromRadix(m,h){this.fromInt(0);if(h==null){h=10;}var f=this.chunkSize(h);var g=Math.pow(h,f),e=false,a=0,l=0;for(var c=0;c<m.length;++c){var k=intAt(m,c);if(k<0){if(m.charAt(c)=="-"&&this.signum()==0){e=true;}continue}l=h*l+k;if(++a>=f){this.dMultiply(g);this.dAddOffset(l,0);a=0;l=0;}}if(a>0){this.dMultiply(Math.pow(h,a));this.dAddOffset(l,0);}if(e){BigInteger.ZERO.subTo(this,this);}}function bnpFromNumber(f,e,h){if("number"==typeof e){if(f<2){this.fromInt(1);}else{this.fromNumber(f,h);if(!this.testBit(f-1)){this.bitwiseTo(BigInteger.ONE.shiftLeft(f-1),op_or,this);}if(this.isEven()){this.dAddOffset(1,0);}while(!this.isProbablePrime(e)){this.dAddOffset(2,0);if(this.bitLength()>f){this.subTo(BigInteger.ONE.shiftLeft(f-1),this);}}}}else{var d=new Array(),g=f&7;d.length=(f>>3)+1;e.nextBytes(d);if(g>0){d[0]&=((1<<g)-1);}else{d[0]=0;}this.fromString(d,256);}}function bnToByteArray(){var b=this.t,c=new Array();c[0]=this.s;var e=this.DB-(b*this.DB)%8,f,a=0;if(b-->0){if(e<this.DB&&(f=this[b]>>e)!=(this.s&this.DM)>>e){c[a++]=f|(this.s<<(this.DB-e));}while(b>=0){if(e<8){f=(this[b]&((1<<e)-1))<<(8-e);f|=this[--b]>>(e+=this.DB-8);}else{f=(this[b]>>(e-=8))&255;if(e<=0){e+=this.DB;--b;}}if((f&128)!=0){f|=-256;}if(a==0&&(this.s&128)!=(f&128)){++a;}if(a>0||f!=this.s){c[a++]=f;}}}return c}function bnEquals(b){return(this.compareTo(b)==0)}function bnMin(b){return (this.compareTo(b)<0)?this:b}function bnMax(b){return (this.compareTo(b)>0)?this:b}function bnpBitwiseTo(c,h,e){var d,g,b=Math.min(c.t,this.t);for(d=0;d<b;++d){e[d]=h(this[d],c[d]);}if(c.t<this.t){g=c.s&this.DM;for(d=b;d<this.t;++d){e[d]=h(this[d],g);}e.t=this.t;}else{g=this.s&this.DM;for(d=b;d<c.t;++d){e[d]=h(g,c[d]);}e.t=c.t;}e.s=h(this.s,c.s);e.clamp();}function op_and(a,b){return a&b}function bnAnd(b){var c=nbi();this.bitwiseTo(b,op_and,c);return c}function op_or(a,b){return a|b}function bnOr(b){var c=nbi();this.bitwiseTo(b,op_or,c);return c}function op_xor(a,b){return a^b}function bnXor(b){var c=nbi();this.bitwiseTo(b,op_xor,c);return c}function op_andnot(a,b){return a&~b}function bnAndNot(b){var c=nbi();this.bitwiseTo(b,op_andnot,c);return c}function bnNot(){var b=nbi();for(var a=0;a<this.t;++a){b[a]=this.DM&~this[a];}b.t=this.t;b.s=~this.s;return b}function bnShiftLeft(b){var a=nbi();if(b<0){this.rShiftTo(-b,a);}else{this.lShiftTo(b,a);}return a}function bnShiftRight(b){var a=nbi();if(b<0){this.lShiftTo(-b,a);}else{this.rShiftTo(b,a);}return a}function lbit(a){if(a==0){return -1}var b=0;if((a&65535)==0){a>>=16;b+=16;}if((a&255)==0){a>>=8;b+=8;}if((a&15)==0){a>>=4;b+=4;}if((a&3)==0){a>>=2;b+=2;}if((a&1)==0){++b;}return b}function bnGetLowestSetBit(){for(var a=0;a<this.t;++a){if(this[a]!=0){return a*this.DB+lbit(this[a])}}if(this.s<0){return this.t*this.DB}return -1}function cbit(a){var b=0;while(a!=0){a&=a-1;++b;}return b}function bnBitCount(){var c=0,a=this.s&this.DM;for(var b=0;b<this.t;++b){c+=cbit(this[b]^a);}return c}function bnTestBit(b){var a=Math.floor(b/this.DB);if(a>=this.t){return(this.s!=0)}return((this[a]&(1<<(b%this.DB)))!=0)}function bnpChangeBit(c,b){var a=BigInteger.ONE.shiftLeft(c);this.bitwiseTo(a,b,a);return a}function bnSetBit(a){return this.changeBit(a,op_or)}function bnClearBit(a){return this.changeBit(a,op_andnot)}function bnFlipBit(a){return this.changeBit(a,op_xor)}function bnpAddTo(d,f){var e=0,g=0,b=Math.min(d.t,this.t);while(e<b){g+=this[e]+d[e];f[e++]=g&this.DM;g>>=this.DB;}if(d.t<this.t){g+=d.s;while(e<this.t){g+=this[e];f[e++]=g&this.DM;g>>=this.DB;}g+=this.s;}else{g+=this.s;while(e<d.t){g+=d[e];f[e++]=g&this.DM;g>>=this.DB;}g+=d.s;}f.s=(g<0)?-1:0;if(g>0){f[e++]=g;}else{if(g<-1){f[e++]=this.DV+g;}}f.t=e;f.clamp();}function bnAdd(b){var c=nbi();this.addTo(b,c);return c}function bnSubtract(b){var c=nbi();this.subTo(b,c);return c}function bnMultiply(b){var c=nbi();this.multiplyTo(b,c);return c}function bnSquare(){var a=nbi();this.squareTo(a);return a}function bnDivide(b){var c=nbi();this.divRemTo(b,c,null);return c}function bnRemainder(b){var c=nbi();this.divRemTo(b,null,c);return c}function bnDivideAndRemainder(b){var d=nbi(),c=nbi();this.divRemTo(b,d,c);return new Array(d,c)}function bnpDMultiply(a){this[this.t]=this.am(0,a-1,this,0,0,this.t);++this.t;this.clamp();}function bnpDAddOffset(b,a){if(b==0){return}while(this.t<=a){this[this.t++]=0;}this[a]+=b;while(this[a]>=this.DV){this[a]-=this.DV;if(++a>=this.t){this[this.t++]=0;}++this[a];}}function NullExp(){}function nNop(a){return a}function nMulTo(a,c,b){a.multiplyTo(c,b);}function nSqrTo(a,b){a.squareTo(b);}NullExp.prototype.convert=nNop;NullExp.prototype.revert=nNop;NullExp.prototype.mulTo=nMulTo;NullExp.prototype.sqrTo=nSqrTo;function bnPow(a){return this.exp(a,new NullExp())}function bnpMultiplyLowerTo(b,f,e){var d=Math.min(this.t+b.t,f);e.s=0;e.t=d;while(d>0){e[--d]=0;}var c;for(c=e.t-this.t;d<c;++d){e[d+this.t]=this.am(0,b[d],e,d,0,this.t);}for(c=Math.min(b.t,f);d<c;++d){this.am(0,b[d],e,d,0,f-d);}e.clamp();}function bnpMultiplyUpperTo(b,e,d){--e;var c=d.t=this.t+b.t-e;d.s=0;while(--c>=0){d[c]=0;}for(c=Math.max(e-this.t,0);c<b.t;++c){d[this.t+c-e]=this.am(e-c,b[c],d,0,0,this.t+c-e);}d.clamp();d.drShiftTo(1,d);}function Barrett(a){this.r2=nbi();this.q3=nbi();BigInteger.ONE.dlShiftTo(2*a.t,this.r2);this.mu=this.r2.divide(a);this.m=a;}function barrettConvert(a){if(a.s<0||a.t>2*this.m.t){return a.mod(this.m)}else{if(a.compareTo(this.m)<0){return a}else{var b=nbi();a.copyTo(b);this.reduce(b);return b}}}function barrettRevert(a){return a}function barrettReduce(a){a.drShiftTo(this.m.t-1,this.r2);if(a.t>this.m.t+1){a.t=this.m.t+1;a.clamp();}this.mu.multiplyUpperTo(this.r2,this.m.t+1,this.q3);this.m.multiplyLowerTo(this.q3,this.m.t+1,this.r2);while(a.compareTo(this.r2)<0){a.dAddOffset(1,this.m.t+1);}a.subTo(this.r2,a);while(a.compareTo(this.m)>=0){a.subTo(this.m,a);}}function barrettSqrTo(a,b){a.squareTo(b);this.reduce(b);}function barrettMulTo(a,c,b){a.multiplyTo(c,b);this.reduce(b);}Barrett.prototype.convert=barrettConvert;Barrett.prototype.revert=barrettRevert;Barrett.prototype.reduce=barrettReduce;Barrett.prototype.mulTo=barrettMulTo;Barrett.prototype.sqrTo=barrettSqrTo;function bnModPow(q,f){var o=q.bitLength(),h,b=nbv(1),v;if(o<=0){return b}else{if(o<18){h=1;}else{if(o<48){h=3;}else{if(o<144){h=4;}else{if(o<768){h=5;}else{h=6;}}}}}if(o<8){v=new Classic(f);}else{if(f.isEven()){v=new Barrett(f);}else{v=new Montgomery(f);}}var p=new Array(),d=3,s=h-1,a=(1<<h)-1;p[1]=v.convert(this);if(h>1){var A=nbi();v.sqrTo(p[1],A);while(d<=a){p[d]=nbi();v.mulTo(A,p[d-2],p[d]);d+=2;}}var l=q.t-1,x,u=true,c=nbi(),y;o=nbits(q[l])-1;while(l>=0){if(o>=s){x=(q[l]>>(o-s))&a;}else{x=(q[l]&((1<<(o+1))-1))<<(s-o);if(l>0){x|=q[l-1]>>(this.DB+o-s);}}d=h;while((x&1)==0){x>>=1;--d;}if((o-=d)<0){o+=this.DB;--l;}if(u){p[x].copyTo(b);u=false;}else{while(d>1){v.sqrTo(b,c);v.sqrTo(c,b);d-=2;}if(d>0){v.sqrTo(b,c);}else{y=b;b=c;c=y;}v.mulTo(c,p[x],b);}while(l>=0&&(q[l]&(1<<o))==0){v.sqrTo(b,c);y=b;b=c;c=y;if(--o<0){o=this.DB-1;--l;}}}return v.revert(b)}function bnGCD(c){var b=(this.s<0)?this.negate():this.clone();var h=(c.s<0)?c.negate():c.clone();if(b.compareTo(h)<0){var e=b;b=h;h=e;}var d=b.getLowestSetBit(),f=h.getLowestSetBit();if(f<0){return b}if(d<f){f=d;}if(f>0){b.rShiftTo(f,b);h.rShiftTo(f,h);}while(b.signum()>0){if((d=b.getLowestSetBit())>0){b.rShiftTo(d,b);}if((d=h.getLowestSetBit())>0){h.rShiftTo(d,h);}if(b.compareTo(h)>=0){b.subTo(h,b);b.rShiftTo(1,b);}else{h.subTo(b,h);h.rShiftTo(1,h);}}if(f>0){h.lShiftTo(f,h);}return h}function bnpModInt(e){if(e<=0){return 0}var c=this.DV%e,b=(this.s<0)?e-1:0;if(this.t>0){if(c==0){b=this[0]%e;}else{for(var a=this.t-1;a>=0;--a){b=(c*b+this[a])%e;}}}return b}function bnModInverse(f){var j=f.isEven();if((this.isEven()&&j)||f.signum()==0){return BigInteger.ZERO}var i=f.clone(),h=this.clone();var g=nbv(1),e=nbv(0),l=nbv(0),k=nbv(1);while(i.signum()!=0){while(i.isEven()){i.rShiftTo(1,i);if(j){if(!g.isEven()||!e.isEven()){g.addTo(this,g);e.subTo(f,e);}g.rShiftTo(1,g);}else{if(!e.isEven()){e.subTo(f,e);}}e.rShiftTo(1,e);}while(h.isEven()){h.rShiftTo(1,h);if(j){if(!l.isEven()||!k.isEven()){l.addTo(this,l);k.subTo(f,k);}l.rShiftTo(1,l);}else{if(!k.isEven()){k.subTo(f,k);}}k.rShiftTo(1,k);}if(i.compareTo(h)>=0){i.subTo(h,i);if(j){g.subTo(l,g);}e.subTo(k,e);}else{h.subTo(i,h);if(j){l.subTo(g,l);}k.subTo(e,k);}}if(h.compareTo(BigInteger.ONE)!=0){return BigInteger.ZERO}if(k.compareTo(f)>=0){return k.subtract(f)}if(k.signum()<0){k.addTo(f,k);}else{return k}if(k.signum()<0){return k.add(f)}else{return k}}var lowprimes=[2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113,127,131,137,139,149,151,157,163,167,173,179,181,191,193,197,199,211,223,227,229,233,239,241,251,257,263,269,271,277,281,283,293,307,311,313,317,331,337,347,349,353,359,367,373,379,383,389,397,401,409,419,421,431,433,439,443,449,457,461,463,467,479,487,491,499,503,509,521,523,541,547,557,563,569,571,577,587,593,599,601,607,613,617,619,631,641,643,647,653,659,661,673,677,683,691,701,709,719,727,733,739,743,751,757,761,769,773,787,797,809,811,821,823,827,829,839,853,857,859,863,877,881,883,887,907,911,919,929,937,941,947,953,967,971,977,983,991,997];var lplim=(1<<26)/lowprimes[lowprimes.length-1];function bnIsProbablePrime(e){var d,b=this.abs();if(b.t==1&&b[0]<=lowprimes[lowprimes.length-1]){for(d=0;d<lowprimes.length;++d){if(b[0]==lowprimes[d]){return true}}return false}if(b.isEven()){return false}d=1;while(d<lowprimes.length){var a=lowprimes[d],c=d+1;while(c<lowprimes.length&&a<lplim){a*=lowprimes[c++];}a=b.modInt(a);while(d<c){if(a%lowprimes[d++]==0){return false}}}return b.millerRabin(e)}function bnpMillerRabin(f){var g=this.subtract(BigInteger.ONE);var c=g.getLowestSetBit();if(c<=0){return false}var h=g.shiftRight(c);f=(f+1)>>1;if(f>lowprimes.length){f=lowprimes.length;}var b=nbi();for(var e=0;e<f;++e){b.fromInt(lowprimes[Math.floor(Math.random()*lowprimes.length)]);var l=b.modPow(h,this);if(l.compareTo(BigInteger.ONE)!=0&&l.compareTo(g)!=0){var d=1;while(d++<c&&l.compareTo(g)!=0){l=l.modPowInt(2,this);if(l.compareTo(BigInteger.ONE)==0){return false}}if(l.compareTo(g)!=0){return false}}}return true}BigInteger.prototype.chunkSize=bnpChunkSize;BigInteger.prototype.toRadix=bnpToRadix;BigInteger.prototype.fromRadix=bnpFromRadix;BigInteger.prototype.fromNumber=bnpFromNumber;BigInteger.prototype.bitwiseTo=bnpBitwiseTo;BigInteger.prototype.changeBit=bnpChangeBit;BigInteger.prototype.addTo=bnpAddTo;BigInteger.prototype.dMultiply=bnpDMultiply;BigInteger.prototype.dAddOffset=bnpDAddOffset;BigInteger.prototype.multiplyLowerTo=bnpMultiplyLowerTo;BigInteger.prototype.multiplyUpperTo=bnpMultiplyUpperTo;BigInteger.prototype.modInt=bnpModInt;BigInteger.prototype.millerRabin=bnpMillerRabin;BigInteger.prototype.clone=bnClone;BigInteger.prototype.intValue=bnIntValue;BigInteger.prototype.byteValue=bnByteValue;BigInteger.prototype.shortValue=bnShortValue;BigInteger.prototype.signum=bnSigNum;BigInteger.prototype.toByteArray=bnToByteArray;BigInteger.prototype.equals=bnEquals;BigInteger.prototype.min=bnMin;BigInteger.prototype.max=bnMax;BigInteger.prototype.and=bnAnd;BigInteger.prototype.or=bnOr;BigInteger.prototype.xor=bnXor;BigInteger.prototype.andNot=bnAndNot;BigInteger.prototype.not=bnNot;BigInteger.prototype.shiftLeft=bnShiftLeft;BigInteger.prototype.shiftRight=bnShiftRight;BigInteger.prototype.getLowestSetBit=bnGetLowestSetBit;BigInteger.prototype.bitCount=bnBitCount;BigInteger.prototype.testBit=bnTestBit;BigInteger.prototype.setBit=bnSetBit;BigInteger.prototype.clearBit=bnClearBit;BigInteger.prototype.flipBit=bnFlipBit;BigInteger.prototype.add=bnAdd;BigInteger.prototype.subtract=bnSubtract;BigInteger.prototype.multiply=bnMultiply;BigInteger.prototype.divide=bnDivide;BigInteger.prototype.remainder=bnRemainder;BigInteger.prototype.divideAndRemainder=bnDivideAndRemainder;BigInteger.prototype.modPow=bnModPow;BigInteger.prototype.modInverse=bnModInverse;BigInteger.prototype.pow=bnPow;BigInteger.prototype.gcd=bnGCD;BigInteger.prototype.isProbablePrime=bnIsProbablePrime;BigInteger.prototype.square=bnSquare;
	/*! (c) Tom Wu | http://www-cs-students.stanford.edu/~tjw/jsbn/
	 */
	function Arcfour(){this.i=0;this.j=0;this.S=new Array();}function ARC4init(d){var c,a,b;for(c=0;c<256;++c){this.S[c]=c;}a=0;for(c=0;c<256;++c){a=(a+this.S[c]+d[c%d.length])&255;b=this.S[c];this.S[c]=this.S[a];this.S[a]=b;}this.i=0;this.j=0;}function ARC4next(){var a;this.i=(this.i+1)&255;this.j=(this.j+this.S[this.i])&255;a=this.S[this.i];this.S[this.i]=this.S[this.j];this.S[this.j]=a;return this.S[(a+this.S[this.i])&255]}Arcfour.prototype.init=ARC4init;Arcfour.prototype.next=ARC4next;function prng_newstate(){return new Arcfour()}var rng_psize=256;
	/*! (c) Tom Wu | http://www-cs-students.stanford.edu/~tjw/jsbn/
	 */
	var rng_state;var rng_pool;var rng_pptr;function rng_seed_int(a){rng_pool[rng_pptr++]^=a&255;rng_pool[rng_pptr++]^=(a>>8)&255;rng_pool[rng_pptr++]^=(a>>16)&255;rng_pool[rng_pptr++]^=(a>>24)&255;if(rng_pptr>=rng_psize){rng_pptr-=rng_psize;}}function rng_seed_time(){rng_seed_int(new Date().getTime());}if(rng_pool==null){rng_pool=new Array();rng_pptr=0;var t;if(window$1!==undefined&&(window$1.msCrypto!==undefined)){var crypto=window$1.msCrypto;if(crypto.getRandomValues){var ua=new Uint8Array(32);crypto.getRandomValues(ua);for(t=0;t<32;++t){rng_pool[rng_pptr++]=ua[t];}}}while(rng_pptr<rng_psize){t=Math.floor(65536*Math.random());rng_pool[rng_pptr++]=t>>>8;rng_pool[rng_pptr++]=t&255;}rng_pptr=0;rng_seed_time();}function rng_get_byte(){if(rng_state==null){rng_seed_time();rng_state=prng_newstate();rng_state.init(rng_pool);for(rng_pptr=0;rng_pptr<rng_pool.length;++rng_pptr){rng_pool[rng_pptr]=0;}rng_pptr=0;}return rng_state.next()}function rng_get_bytes(b){var a;for(a=0;a<b.length;++a){b[a]=rng_get_byte();}}function SecureRandom(){}SecureRandom.prototype.nextBytes=rng_get_bytes;
	/*! (c) Tom Wu | http://www-cs-students.stanford.edu/~tjw/jsbn/
	 */
	function parseBigInt(b,a){return new BigInteger(b,a)}function pkcs1pad2(e,h){if(h<e.length+11){throw"Message too long for RSA";return null}var g=new Array();var d=e.length-1;while(d>=0&&h>0){var f=e.charCodeAt(d--);if(f<128){g[--h]=f;}else{if((f>127)&&(f<2048)){g[--h]=(f&63)|128;g[--h]=(f>>6)|192;}else{g[--h]=(f&63)|128;g[--h]=((f>>6)&63)|128;g[--h]=(f>>12)|224;}}}g[--h]=0;var b=new SecureRandom();var a=new Array();while(h>2){a[0]=0;while(a[0]==0){b.nextBytes(a);}g[--h]=a[0];}g[--h]=2;g[--h]=0;return new BigInteger(g)}function oaep_mgf1_arr(c,a,e){var b="",d=0;while(b.length<a){b+=e(String.fromCharCode.apply(String,c.concat([(d&4278190080)>>24,(d&16711680)>>16,(d&65280)>>8,d&255])));d+=1;}return b}function oaep_pad(q,a,f,l){var c=KJUR.crypto.MessageDigest;var o=KJUR.crypto.Util;var b=null;if(!f){f="sha1";}if(typeof f==="string"){b=c.getCanonicalAlgName(f);l=c.getHashLength(b);f=function(i){return hextorstr(o.hashHex(rstrtohex(i),b))};}if(q.length+2*l+2>a){throw"Message too long for RSA"}var k="",e;for(e=0;e<a-q.length-2*l-2;e+=1){k+="\x00";}var h=f("")+k+"\x01"+q;var g=new Array(l);new SecureRandom().nextBytes(g);var j=oaep_mgf1_arr(g,h.length,f);var p=[];for(e=0;e<h.length;e+=1){p[e]=h.charCodeAt(e)^j.charCodeAt(e);}var m=oaep_mgf1_arr(p,g.length,f);var d=[0];for(e=0;e<g.length;e+=1){d[e+1]=g[e]^m.charCodeAt(e);}return new BigInteger(d.concat(p))}function RSAKey(){this.n=null;this.e=0;this.d=null;this.p=null;this.q=null;this.dmp1=null;this.dmq1=null;this.coeff=null;}function RSASetPublic(b,a){this.isPublic=true;this.isPrivate=false;if(typeof b!=="string"){this.n=b;this.e=a;}else{if(b!=null&&a!=null&&b.length>0&&a.length>0){this.n=parseBigInt(b,16);this.e=parseInt(a,16);}else{throw"Invalid RSA public key"}}}function RSADoPublic(a){return a.modPowInt(this.e,this.n)}function RSAEncrypt(d){var a=pkcs1pad2(d,(this.n.bitLength()+7)>>3);if(a==null){return null}var e=this.doPublic(a);if(e==null){return null}var b=e.toString(16);if((b.length&1)==0){return b}else{return "0"+b}}function RSAEncryptOAEP(f,e,b){var a=oaep_pad(f,(this.n.bitLength()+7)>>3,e,b);if(a==null){return null}var g=this.doPublic(a);if(g==null){return null}var d=g.toString(16);if((d.length&1)==0){return d}else{return "0"+d}}RSAKey.prototype.doPublic=RSADoPublic;RSAKey.prototype.setPublic=RSASetPublic;RSAKey.prototype.encrypt=RSAEncrypt;RSAKey.prototype.encryptOAEP=RSAEncryptOAEP;RSAKey.prototype.type="RSA";
	/*! (c) Tom Wu | http://www-cs-students.stanford.edu/~tjw/jsbn/
	 */
	function pkcs1unpad2(g,j){var a=g.toByteArray();var f=0;while(f<a.length&&a[f]==0){++f;}if(a.length-f!=j-1||a[f]!=2){return null}++f;while(a[f]!=0){if(++f>=a.length){return null}}var e="";while(++f<a.length){var h=a[f]&255;if(h<128){e+=String.fromCharCode(h);}else{if((h>191)&&(h<224)){e+=String.fromCharCode(((h&31)<<6)|(a[f+1]&63));++f;}else{e+=String.fromCharCode(((h&15)<<12)|((a[f+1]&63)<<6)|(a[f+2]&63));f+=2;}}}return e}function oaep_mgf1_str(c,a,e){var b="",d=0;while(b.length<a){b+=e(c+String.fromCharCode.apply(String,[(d&4278190080)>>24,(d&16711680)>>16,(d&65280)>>8,d&255]));d+=1;}return b}function oaep_unpad(o,b,g,p){var e=KJUR.crypto.MessageDigest;var r=KJUR.crypto.Util;var c=null;if(!g){g="sha1";}if(typeof g==="string"){c=e.getCanonicalAlgName(g);p=e.getHashLength(c);g=function(d){return hextorstr(r.hashHex(rstrtohex(d),c))};}o=o.toByteArray();var h;for(h=0;h<o.length;h+=1){o[h]&=255;}while(o.length<b){o.unshift(0);}o=String.fromCharCode.apply(String,o);if(o.length<2*p+2){throw"Cipher too short"}var f=o.substr(1,p);var s=o.substr(p+1);var q=oaep_mgf1_str(s,p,g);var k=[],h;for(h=0;h<f.length;h+=1){k[h]=f.charCodeAt(h)^q.charCodeAt(h);}var l=oaep_mgf1_str(String.fromCharCode.apply(String,k),o.length-p,g);var j=[];for(h=0;h<s.length;h+=1){j[h]=s.charCodeAt(h)^l.charCodeAt(h);}j=String.fromCharCode.apply(String,j);if(j.substr(0,p)!==g("")){throw"Hash mismatch"}j=j.substr(p);var a=j.indexOf("\x01");var m=(a!=-1)?j.substr(0,a).lastIndexOf("\x00"):-1;if(m+1!=a){throw"Malformed data"}return j.substr(a+1)}function RSASetPrivate(c,a,b){this.isPrivate=true;if(typeof c!=="string"){this.n=c;this.e=a;this.d=b;}else{if(c!=null&&a!=null&&c.length>0&&a.length>0){this.n=parseBigInt(c,16);this.e=parseInt(a,16);this.d=parseBigInt(b,16);}else{throw"Invalid RSA private key"}}}function RSASetPrivateEx(g,d,e,c,b,a,h,f){this.isPrivate=true;this.isPublic=false;if(g==null){throw"RSASetPrivateEx N == null"}if(d==null){throw"RSASetPrivateEx E == null"}if(g.length==0){throw"RSASetPrivateEx N.length == 0"}if(d.length==0){throw"RSASetPrivateEx E.length == 0"}if(g!=null&&d!=null&&g.length>0&&d.length>0){this.n=parseBigInt(g,16);this.e=parseInt(d,16);this.d=parseBigInt(e,16);this.p=parseBigInt(c,16);this.q=parseBigInt(b,16);this.dmp1=parseBigInt(a,16);this.dmq1=parseBigInt(h,16);this.coeff=parseBigInt(f,16);}else{throw"Invalid RSA private key in RSASetPrivateEx"}}function RSAGenerate(b,i){var a=new SecureRandom();var f=b>>1;this.e=parseInt(i,16);var c=new BigInteger(i,16);for(;;){for(;;){this.p=new BigInteger(b-f,1,a);if(this.p.subtract(BigInteger.ONE).gcd(c).compareTo(BigInteger.ONE)==0&&this.p.isProbablePrime(10)){break}}for(;;){this.q=new BigInteger(f,1,a);if(this.q.subtract(BigInteger.ONE).gcd(c).compareTo(BigInteger.ONE)==0&&this.q.isProbablePrime(10)){break}}if(this.p.compareTo(this.q)<=0){var h=this.p;this.p=this.q;this.q=h;}var g=this.p.subtract(BigInteger.ONE);var d=this.q.subtract(BigInteger.ONE);var e=g.multiply(d);if(e.gcd(c).compareTo(BigInteger.ONE)==0){this.n=this.p.multiply(this.q);this.d=c.modInverse(e);this.dmp1=this.d.mod(g);this.dmq1=this.d.mod(d);this.coeff=this.q.modInverse(this.p);break}}this.isPrivate=true;}function RSADoPrivate(a){if(this.p==null||this.q==null){return a.modPow(this.d,this.n)}var c=a.mod(this.p).modPow(this.dmp1,this.p);var b=a.mod(this.q).modPow(this.dmq1,this.q);while(c.compareTo(b)<0){c=c.add(this.p);}return c.subtract(b).multiply(this.coeff).mod(this.p).multiply(this.q).add(b)}function RSADecrypt(b){var d=parseBigInt(b,16);var a=this.doPrivate(d);if(a==null){return null}return pkcs1unpad2(a,(this.n.bitLength()+7)>>3)}function RSADecryptOAEP(e,d,b){var f=parseBigInt(e,16);var a=this.doPrivate(f);if(a==null){return null}return oaep_unpad(a,(this.n.bitLength()+7)>>3,d,b)}RSAKey.prototype.doPrivate=RSADoPrivate;RSAKey.prototype.setPrivate=RSASetPrivate;RSAKey.prototype.setPrivateEx=RSASetPrivateEx;RSAKey.prototype.generate=RSAGenerate;RSAKey.prototype.decrypt=RSADecrypt;RSAKey.prototype.decryptOAEP=RSADecryptOAEP;
	/*! (c) Tom Wu | http://www-cs-students.stanford.edu/~tjw/jsbn/
	 */
	function ECFieldElementFp(b,a){this.x=a;this.q=b;}function feFpEquals(a){if(a==this){return true}return(this.q.equals(a.q)&&this.x.equals(a.x))}function feFpToBigInteger(){return this.x}function feFpNegate(){return new ECFieldElementFp(this.q,this.x.negate().mod(this.q))}function feFpAdd(a){return new ECFieldElementFp(this.q,this.x.add(a.toBigInteger()).mod(this.q))}function feFpSubtract(a){return new ECFieldElementFp(this.q,this.x.subtract(a.toBigInteger()).mod(this.q))}function feFpMultiply(a){return new ECFieldElementFp(this.q,this.x.multiply(a.toBigInteger()).mod(this.q))}function feFpSquare(){return new ECFieldElementFp(this.q,this.x.square().mod(this.q))}function feFpDivide(a){return new ECFieldElementFp(this.q,this.x.multiply(a.toBigInteger().modInverse(this.q)).mod(this.q))}ECFieldElementFp.prototype.equals=feFpEquals;ECFieldElementFp.prototype.toBigInteger=feFpToBigInteger;ECFieldElementFp.prototype.negate=feFpNegate;ECFieldElementFp.prototype.add=feFpAdd;ECFieldElementFp.prototype.subtract=feFpSubtract;ECFieldElementFp.prototype.multiply=feFpMultiply;ECFieldElementFp.prototype.square=feFpSquare;ECFieldElementFp.prototype.divide=feFpDivide;function ECPointFp(c,a,d,b){this.curve=c;this.x=a;this.y=d;if(b==null){this.z=BigInteger.ONE;}else{this.z=b;}this.zinv=null;}function pointFpGetX(){if(this.zinv==null){this.zinv=this.z.modInverse(this.curve.q);}return this.curve.fromBigInteger(this.x.toBigInteger().multiply(this.zinv).mod(this.curve.q))}function pointFpGetY(){if(this.zinv==null){this.zinv=this.z.modInverse(this.curve.q);}return this.curve.fromBigInteger(this.y.toBigInteger().multiply(this.zinv).mod(this.curve.q))}function pointFpEquals(a){if(a==this){return true}if(this.isInfinity()){return a.isInfinity()}if(a.isInfinity()){return this.isInfinity()}var c,b;c=a.y.toBigInteger().multiply(this.z).subtract(this.y.toBigInteger().multiply(a.z)).mod(this.curve.q);if(!c.equals(BigInteger.ZERO)){return false}b=a.x.toBigInteger().multiply(this.z).subtract(this.x.toBigInteger().multiply(a.z)).mod(this.curve.q);return b.equals(BigInteger.ZERO)}function pointFpIsInfinity(){if((this.x==null)&&(this.y==null)){return true}return this.z.equals(BigInteger.ZERO)&&!this.y.toBigInteger().equals(BigInteger.ZERO)}function pointFpNegate(){return new ECPointFp(this.curve,this.x,this.y.negate(),this.z)}function pointFpAdd(l){if(this.isInfinity()){return l}if(l.isInfinity()){return this}var p=l.y.toBigInteger().multiply(this.z).subtract(this.y.toBigInteger().multiply(l.z)).mod(this.curve.q);var o=l.x.toBigInteger().multiply(this.z).subtract(this.x.toBigInteger().multiply(l.z)).mod(this.curve.q);if(BigInteger.ZERO.equals(o)){if(BigInteger.ZERO.equals(p)){return this.twice()}return this.curve.getInfinity()}var j=new BigInteger("3");var e=this.x.toBigInteger();var n=this.y.toBigInteger();var c=l.x.toBigInteger();var k=l.y.toBigInteger();var m=o.square();var i=m.multiply(o);var d=e.multiply(m);var g=p.square().multiply(this.z);var a=g.subtract(d.shiftLeft(1)).multiply(l.z).subtract(i).multiply(o).mod(this.curve.q);var h=d.multiply(j).multiply(p).subtract(n.multiply(i)).subtract(g.multiply(p)).multiply(l.z).add(p.multiply(i)).mod(this.curve.q);var f=i.multiply(this.z).multiply(l.z).mod(this.curve.q);return new ECPointFp(this.curve,this.curve.fromBigInteger(a),this.curve.fromBigInteger(h),f)}function pointFpTwice(){if(this.isInfinity()){return this}if(this.y.toBigInteger().signum()==0){return this.curve.getInfinity()}var g=new BigInteger("3");var c=this.x.toBigInteger();var h=this.y.toBigInteger();var e=h.multiply(this.z);var j=e.multiply(h).mod(this.curve.q);var i=this.curve.a.toBigInteger();var k=c.square().multiply(g);if(!BigInteger.ZERO.equals(i)){k=k.add(this.z.square().multiply(i));}k=k.mod(this.curve.q);var b=k.square().subtract(c.shiftLeft(3).multiply(j)).shiftLeft(1).multiply(e).mod(this.curve.q);var f=k.multiply(g).multiply(c).subtract(j.shiftLeft(1)).shiftLeft(2).multiply(j).subtract(k.square().multiply(k)).mod(this.curve.q);var d=e.square().multiply(e).shiftLeft(3).mod(this.curve.q);return new ECPointFp(this.curve,this.curve.fromBigInteger(b),this.curve.fromBigInteger(f),d)}function pointFpMultiply(b){if(this.isInfinity()){return this}if(b.signum()==0){return this.curve.getInfinity()}var g=b;var f=g.multiply(new BigInteger("3"));var l=this.negate();var d=this;var c;for(c=f.bitLength()-2;c>0;--c){d=d.twice();var a=f.testBit(c);var j=g.testBit(c);if(a!=j){d=d.add(a?this:l);}}return d}function pointFpMultiplyTwo(c,a,b){var d;if(c.bitLength()>b.bitLength()){d=c.bitLength()-1;}else{d=b.bitLength()-1;}var f=this.curve.getInfinity();var e=this.add(a);while(d>=0){f=f.twice();if(c.testBit(d)){if(b.testBit(d)){f=f.add(e);}else{f=f.add(this);}}else{if(b.testBit(d)){f=f.add(a);}}--d;}return f}ECPointFp.prototype.getX=pointFpGetX;ECPointFp.prototype.getY=pointFpGetY;ECPointFp.prototype.equals=pointFpEquals;ECPointFp.prototype.isInfinity=pointFpIsInfinity;ECPointFp.prototype.negate=pointFpNegate;ECPointFp.prototype.add=pointFpAdd;ECPointFp.prototype.twice=pointFpTwice;ECPointFp.prototype.multiply=pointFpMultiply;ECPointFp.prototype.multiplyTwo=pointFpMultiplyTwo;function ECCurveFp(e,d,c){this.q=e;this.a=this.fromBigInteger(d);this.b=this.fromBigInteger(c);this.infinity=new ECPointFp(this,null,null);}function curveFpGetQ(){return this.q}function curveFpGetA(){return this.a}function curveFpGetB(){return this.b}function curveFpEquals(a){if(a==this){return true}return(this.q.equals(a.q)&&this.a.equals(a.a)&&this.b.equals(a.b))}function curveFpGetInfinity(){return this.infinity}function curveFpFromBigInteger(a){return new ECFieldElementFp(this.q,a)}function curveFpDecodePointHex(d){switch(parseInt(d.substr(0,2),16)){case 0:return this.infinity;case 2:case 3:return null;case 4:case 6:case 7:var a=(d.length-2)/2;var c=d.substr(2,a);var b=d.substr(a+2,a);return new ECPointFp(this,this.fromBigInteger(new BigInteger(c,16)),this.fromBigInteger(new BigInteger(b,16)));default:return null}}ECCurveFp.prototype.getQ=curveFpGetQ;ECCurveFp.prototype.getA=curveFpGetA;ECCurveFp.prototype.getB=curveFpGetB;ECCurveFp.prototype.equals=curveFpEquals;ECCurveFp.prototype.getInfinity=curveFpGetInfinity;ECCurveFp.prototype.fromBigInteger=curveFpFromBigInteger;ECCurveFp.prototype.decodePointHex=curveFpDecodePointHex;
	/*! (c) Stefan Thomas | https://github.com/bitcoinjs/bitcoinjs-lib
	 */
	ECFieldElementFp.prototype.getByteLength=function(){return Math.floor((this.toBigInteger().bitLength()+7)/8)};ECPointFp.prototype.getEncoded=function(c){var d=function(h,f){var g=h.toByteArrayUnsigned();if(f<g.length){g=g.slice(g.length-f);}else{while(f>g.length){g.unshift(0);}}return g};var a=this.getX().toBigInteger();var e=this.getY().toBigInteger();var b=d(a,32);if(c){if(e.isEven()){b.unshift(2);}else{b.unshift(3);}}else{b.unshift(4);b=b.concat(d(e,32));}return b};ECPointFp.decodeFrom=function(g,c){var f=c[0];var e=c.length-1;var d=c.slice(1,1+e/2);var b=c.slice(1+e/2,1+e);d.unshift(0);b.unshift(0);var a=new BigInteger(d);var h=new BigInteger(b);return new ECPointFp(g,g.fromBigInteger(a),g.fromBigInteger(h))};ECPointFp.decodeFromHex=function(g,c){var f=c.substr(0,2);var e=c.length-2;var d=c.substr(2,e/2);var b=c.substr(2+e/2,e/2);var a=new BigInteger(d,16);var h=new BigInteger(b,16);return new ECPointFp(g,g.fromBigInteger(a),g.fromBigInteger(h))};ECPointFp.prototype.add2D=function(c){if(this.isInfinity()){return c}if(c.isInfinity()){return this}if(this.x.equals(c.x)){if(this.y.equals(c.y)){return this.twice()}return this.curve.getInfinity()}var g=c.x.subtract(this.x);var e=c.y.subtract(this.y);var a=e.divide(g);var d=a.square().subtract(this.x).subtract(c.x);var f=a.multiply(this.x.subtract(d)).subtract(this.y);return new ECPointFp(this.curve,d,f)};ECPointFp.prototype.twice2D=function(){if(this.isInfinity()){return this}if(this.y.toBigInteger().signum()==0){return this.curve.getInfinity()}var b=this.curve.fromBigInteger(BigInteger.valueOf(2));var e=this.curve.fromBigInteger(BigInteger.valueOf(3));var a=this.x.square().multiply(e).add(this.curve.a).divide(this.y.multiply(b));var c=a.square().subtract(this.x.multiply(b));var d=a.multiply(this.x.subtract(c)).subtract(this.y);return new ECPointFp(this.curve,c,d)};ECPointFp.prototype.multiply2D=function(b){if(this.isInfinity()){return this}if(b.signum()==0){return this.curve.getInfinity()}var g=b;var f=g.multiply(new BigInteger("3"));var l=this.negate();var d=this;var c;for(c=f.bitLength()-2;c>0;--c){d=d.twice();var a=f.testBit(c);var j=g.testBit(c);if(a!=j){d=d.add2D(a?this:l);}}return d};ECPointFp.prototype.isOnCurve=function(){var d=this.getX().toBigInteger();var i=this.getY().toBigInteger();var f=this.curve.getA().toBigInteger();var c=this.curve.getB().toBigInteger();var h=this.curve.getQ();var e=i.multiply(i).mod(h);var g=d.multiply(d).multiply(d).add(f.multiply(d)).add(c).mod(h);return e.equals(g)};ECPointFp.prototype.toString=function(){return "("+this.getX().toBigInteger().toString()+","+this.getY().toBigInteger().toString()+")"};ECPointFp.prototype.validate=function(){var c=this.curve.getQ();if(this.isInfinity()){throw new Error("Point is at infinity.")}var a=this.getX().toBigInteger();var b=this.getY().toBigInteger();if(a.compareTo(BigInteger.ONE)<0||a.compareTo(c.subtract(BigInteger.ONE))>0){throw new Error("x coordinate out of bounds")}if(b.compareTo(BigInteger.ONE)<0||b.compareTo(c.subtract(BigInteger.ONE))>0){throw new Error("y coordinate out of bounds")}if(!this.isOnCurve()){throw new Error("Point is not on the curve.")}if(this.multiply(c).isInfinity()){throw new Error("Point is not a scalar multiple of G.")}return true};
	/*! Mike Samuel (c) 2009 | code.google.com/p/json-sans-eval
	 */
	var jsonParse=(function(){var e="(?:-?\\b(?:0|[1-9][0-9]*)(?:\\.[0-9]+)?(?:[eE][+-]?[0-9]+)?\\b)";var j='(?:[^\\0-\\x08\\x0a-\\x1f"\\\\]|\\\\(?:["/\\\\bfnrt]|u[0-9A-Fa-f]{4}))';var i='(?:"'+j+'*")';var d=new RegExp("(?:false|true|null|[\\{\\}\\[\\]]|"+e+"|"+i+")","g");var k=new RegExp("\\\\(?:([^u])|u(.{4}))","g");var g={'"':'"',"/":"/","\\":"\\",b:"\b",f:"\f",n:"\n",r:"\r",t:"\t"};function h(l,m,n){return m?g[m]:String.fromCharCode(parseInt(n,16))}var c=new String("");var a="\\";var b=Object.hasOwnProperty;return function(u,q){var p=u.match(d);var x;var v=p[0];var l=false;if("{"===v){x={};}else{if("["===v){x=[];}else{x=[];l=true;}}var t;var r=[x];for(var o=1-l,m=p.length;o<m;++o){v=p[o];var w;switch(v.charCodeAt(0)){default:w=r[0];w[t||w.length]=+(v);t=void 0;break;case 34:v=v.substring(1,v.length-1);if(v.indexOf(a)!==-1){v=v.replace(k,h);}w=r[0];if(!t){if(w instanceof Array){t=w.length;}else{t=v||c;break}}w[t]=v;t=void 0;break;case 91:w=r[0];r.unshift(w[t||w.length]=[]);t=void 0;break;case 93:r.shift();break;case 102:w=r[0];w[t||w.length]=false;t=void 0;break;case 110:w=r[0];w[t||w.length]=null;t=void 0;break;case 116:w=r[0];w[t||w.length]=true;t=void 0;break;case 123:w=r[0];r.unshift(w[t||w.length]={});t=void 0;break;case 125:r.shift();break}}if(l){if(r.length!==1){throw new Error()}x=x[0];}else{if(r.length){throw new Error()}}if(q){var s=function(C,B){var D=C[B];if(D&&typeof D==="object"){var n=null;for(var z in D){if(b.call(D,z)&&D!==C){var y=s(D,z);if(y!==void 0){D[z]=y;}else{if(!n){n=[];}n.push(z);}}}if(n){for(var A=n.length;--A>=0;){delete D[n[A]];}}}return q.call(C,B,D)};x=s({"":x},"");}return x}})();
	if(typeof KJUR=="undefined"||!KJUR){KJUR={};}if(typeof KJUR.asn1=="undefined"||!KJUR.asn1){KJUR.asn1={};}KJUR.asn1.ASN1Util=new function(){this.integerToByteHex=function(a){var b=a.toString(16);if((b.length%2)==1){b="0"+b;}return b};this.bigIntToMinTwosComplementsHex=function(j){var f=j.toString(16);if(f.substr(0,1)!="-"){if(f.length%2==1){f="0"+f;}else{if(!f.match(/^[0-7]/)){f="00"+f;}}}else{var a=f.substr(1);var e=a.length;if(e%2==1){e+=1;}else{if(!f.match(/^[0-7]/)){e+=2;}}var g="";for(var d=0;d<e;d++){g+="f";}var c=new BigInteger(g,16);var b=c.xor(j).add(BigInteger.ONE);f=b.toString(16).replace(/^-/,"");}return f};this.getPEMStringFromHex=function(a,b){return hextopem(a,b)};this.newObject=function(k){var D=KJUR,n=D.asn1,z=n.DERBoolean,e=n.DERInteger,s=n.DERBitString,h=n.DEROctetString,v=n.DERNull,w=n.DERObjectIdentifier,l=n.DEREnumerated,g=n.DERUTF8String,f=n.DERNumericString,y=n.DERPrintableString,u=n.DERTeletexString,p=n.DERIA5String,C=n.DERUTCTime,j=n.DERGeneralizedTime,m=n.DERSequence,c=n.DERSet,r=n.DERTaggedObject,o=n.ASN1Util.newObject;var t=Object.keys(k);if(t.length!=1){throw"key of param shall be only one."}var F=t[0];if(":bool:int:bitstr:octstr:null:oid:enum:utf8str:numstr:prnstr:telstr:ia5str:utctime:gentime:seq:set:tag:".indexOf(":"+F+":")==-1){throw"undefined key: "+F}if(F=="bool"){return new z(k[F])}if(F=="int"){return new e(k[F])}if(F=="bitstr"){return new s(k[F])}if(F=="octstr"){return new h(k[F])}if(F=="null"){return new v(k[F])}if(F=="oid"){return new w(k[F])}if(F=="enum"){return new l(k[F])}if(F=="utf8str"){return new g(k[F])}if(F=="numstr"){return new f(k[F])}if(F=="prnstr"){return new y(k[F])}if(F=="telstr"){return new u(k[F])}if(F=="ia5str"){return new p(k[F])}if(F=="utctime"){return new C(k[F])}if(F=="gentime"){return new j(k[F])}if(F=="seq"){var d=k[F];var E=[];for(var x=0;x<d.length;x++){var B=o(d[x]);E.push(B);}return new m({array:E})}if(F=="set"){var d=k[F];var E=[];for(var x=0;x<d.length;x++){var B=o(d[x]);E.push(B);}return new c({array:E})}if(F=="tag"){var A=k[F];if(Object.prototype.toString.call(A)==="[object Array]"&&A.length==3){var q=o(A[2]);return new r({tag:A[0],explicit:A[1],obj:q})}else{var b={};if(A.explicit!==undefined){b.explicit=A.explicit;}if(A.tag!==undefined){b.tag=A.tag;}if(A.obj===undefined){throw"obj shall be specified for 'tag'."}b.obj=o(A.obj);return new r(b)}}};this.jsonToASN1HEX=function(b){var a=this.newObject(b);return a.getEncodedHex()};};KJUR.asn1.ASN1Util.oidHexToInt=function(a){var j="";var k=parseInt(a.substr(0,2),16);var d=Math.floor(k/40);var c=k%40;var j=d+"."+c;var e="";for(var f=2;f<a.length;f+=2){var g=parseInt(a.substr(f,2),16);var h=("00000000"+g.toString(2)).slice(-8);e=e+h.substr(1,7);if(h.substr(0,1)=="0"){var b=new BigInteger(e,2);j=j+"."+b.toString(10);e="";}}return j};KJUR.asn1.ASN1Util.oidIntToHex=function(f){var e=function(a){var k=a.toString(16);if(k.length==1){k="0"+k;}return k};var d=function(o){var n="";var k=new BigInteger(o,10);var a=k.toString(2);var l=7-a.length%7;if(l==7){l=0;}var q="";for(var m=0;m<l;m++){q+="0";}a=q+a;for(var m=0;m<a.length-1;m+=7){var p=a.substr(m,7);if(m!=a.length-7){p="1"+p;}n+=e(parseInt(p,2));}return n};if(!f.match(/^[0-9.]+$/)){throw"malformed oid string: "+f}var g="";var b=f.split(".");var j=parseInt(b[0])*40+parseInt(b[1]);g+=e(j);b.splice(0,2);for(var c=0;c<b.length;c++){g+=d(b[c]);}return g};KJUR.asn1.ASN1Object=function(){var a="";this.getLengthHexFromValue=function(){if(typeof this.hV=="undefined"||this.hV==null){throw"this.hV is null or undefined."}if(this.hV.length%2==1){throw"value hex must be even length: n="+a.length+",v="+this.hV}var i=this.hV.length/2;var h=i.toString(16);if(h.length%2==1){h="0"+h;}if(i<128){return h}else{var g=h.length/2;if(g>15){throw"ASN.1 length too long to represent by 8x: n = "+i.toString(16)}var f=128+g;return f.toString(16)+h}};this.getEncodedHex=function(){if(this.hTLV==null||this.isModified){this.hV=this.getFreshValueHex();this.hL=this.getLengthHexFromValue();this.hTLV=this.hT+this.hL+this.hV;this.isModified=false;}return this.hTLV};this.getValueHex=function(){this.getEncodedHex();return this.hV};this.getFreshValueHex=function(){return ""};};KJUR.asn1.DERAbstractString=function(c){KJUR.asn1.DERAbstractString.superclass.constructor.call(this);this.getString=function(){return this.s};this.setString=function(d){this.hTLV=null;this.isModified=true;this.s=d;this.hV=utf8tohex(this.s).toLowerCase();};this.setStringHex=function(d){this.hTLV=null;this.isModified=true;this.s=null;this.hV=d;};this.getFreshValueHex=function(){return this.hV};if(typeof c!="undefined"){if(typeof c=="string"){this.setString(c);}else{if(typeof c.str!="undefined"){this.setString(c.str);}else{if(typeof c.hex!="undefined"){this.setStringHex(c.hex);}}}}};YAHOO.lang.extend(KJUR.asn1.DERAbstractString,KJUR.asn1.ASN1Object);KJUR.asn1.DERAbstractTime=function(c){KJUR.asn1.DERAbstractTime.superclass.constructor.call(this);this.localDateToUTC=function(f){utc=f.getTime()+(f.getTimezoneOffset()*60000);var e=new Date(utc);return e};this.formatDate=function(m,o,e){var g=this.zeroPadding;var n=this.localDateToUTC(m);var p=String(n.getFullYear());if(o=="utc"){p=p.substr(2,2);}var l=g(String(n.getMonth()+1),2);var q=g(String(n.getDate()),2);var h=g(String(n.getHours()),2);var i=g(String(n.getMinutes()),2);var j=g(String(n.getSeconds()),2);var r=p+l+q+h+i+j;if(e===true){var f=n.getMilliseconds();if(f!=0){var k=g(String(f),3);k=k.replace(/[0]+$/,"");r=r+"."+k;}}return r+"Z"};this.zeroPadding=function(e,d){if(e.length>=d){return e}return new Array(d-e.length+1).join("0")+e};this.getString=function(){return this.s};this.setString=function(d){this.hTLV=null;this.isModified=true;this.s=d;this.hV=stohex(d);};this.setByDateValue=function(h,j,e,d,f,g){var i=new Date(Date.UTC(h,j-1,e,d,f,g,0));this.setByDate(i);};this.getFreshValueHex=function(){return this.hV};};YAHOO.lang.extend(KJUR.asn1.DERAbstractTime,KJUR.asn1.ASN1Object);KJUR.asn1.DERAbstractStructured=function(b){KJUR.asn1.DERAbstractString.superclass.constructor.call(this);this.setByASN1ObjectArray=function(c){this.hTLV=null;this.isModified=true;this.asn1Array=c;};this.appendASN1Object=function(c){this.hTLV=null;this.isModified=true;this.asn1Array.push(c);};this.asn1Array=new Array();if(typeof b!="undefined"){if(typeof b.array!="undefined"){this.asn1Array=b.array;}}};YAHOO.lang.extend(KJUR.asn1.DERAbstractStructured,KJUR.asn1.ASN1Object);KJUR.asn1.DERBoolean=function(){KJUR.asn1.DERBoolean.superclass.constructor.call(this);this.hT="01";this.hTLV="0101ff";};YAHOO.lang.extend(KJUR.asn1.DERBoolean,KJUR.asn1.ASN1Object);KJUR.asn1.DERInteger=function(a){KJUR.asn1.DERInteger.superclass.constructor.call(this);this.hT="02";this.setByBigInteger=function(b){this.hTLV=null;this.isModified=true;this.hV=KJUR.asn1.ASN1Util.bigIntToMinTwosComplementsHex(b);};this.setByInteger=function(c){var b=new BigInteger(String(c),10);this.setByBigInteger(b);};this.setValueHex=function(b){this.hV=b;};this.getFreshValueHex=function(){return this.hV};if(typeof a!="undefined"){if(typeof a.bigint!="undefined"){this.setByBigInteger(a.bigint);}else{if(typeof a["int"]!="undefined"){this.setByInteger(a["int"]);}else{if(typeof a=="number"){this.setByInteger(a);}else{if(typeof a.hex!="undefined"){this.setValueHex(a.hex);}}}}}};YAHOO.lang.extend(KJUR.asn1.DERInteger,KJUR.asn1.ASN1Object);KJUR.asn1.DERBitString=function(b){if(b!==undefined&&typeof b.obj!=="undefined"){var a=KJUR.asn1.ASN1Util.newObject(b.obj);b.hex="00"+a.getEncodedHex();}KJUR.asn1.DERBitString.superclass.constructor.call(this);this.hT="03";this.setHexValueIncludingUnusedBits=function(c){this.hTLV=null;this.isModified=true;this.hV=c;};this.setUnusedBitsAndHexValue=function(c,e){if(c<0||7<c){throw"unused bits shall be from 0 to 7: u = "+c}var d="0"+c;this.hTLV=null;this.isModified=true;this.hV=d+e;};this.setByBinaryString=function(e){e=e.replace(/0+$/,"");var f=8-e.length%8;if(f==8){f=0;}for(var g=0;g<=f;g++){e+="0";}var j="";for(var g=0;g<e.length-1;g+=8){var d=e.substr(g,8);var c=parseInt(d,2).toString(16);if(c.length==1){c="0"+c;}j+=c;}this.hTLV=null;this.isModified=true;this.hV="0"+f+j;};this.setByBooleanArray=function(e){var d="";for(var c=0;c<e.length;c++){if(e[c]==true){d+="1";}else{d+="0";}}this.setByBinaryString(d);};this.newFalseArray=function(e){var c=new Array(e);for(var d=0;d<e;d++){c[d]=false;}return c};this.getFreshValueHex=function(){return this.hV};if(typeof b!="undefined"){if(typeof b=="string"&&b.toLowerCase().match(/^[0-9a-f]+$/)){this.setHexValueIncludingUnusedBits(b);}else{if(typeof b.hex!="undefined"){this.setHexValueIncludingUnusedBits(b.hex);}else{if(typeof b.bin!="undefined"){this.setByBinaryString(b.bin);}else{if(typeof b.array!="undefined"){this.setByBooleanArray(b.array);}}}}}};YAHOO.lang.extend(KJUR.asn1.DERBitString,KJUR.asn1.ASN1Object);KJUR.asn1.DEROctetString=function(b){if(b!==undefined&&typeof b.obj!=="undefined"){var a=KJUR.asn1.ASN1Util.newObject(b.obj);b.hex=a.getEncodedHex();}KJUR.asn1.DEROctetString.superclass.constructor.call(this,b);this.hT="04";};YAHOO.lang.extend(KJUR.asn1.DEROctetString,KJUR.asn1.DERAbstractString);KJUR.asn1.DERNull=function(){KJUR.asn1.DERNull.superclass.constructor.call(this);this.hT="05";this.hTLV="0500";};YAHOO.lang.extend(KJUR.asn1.DERNull,KJUR.asn1.ASN1Object);KJUR.asn1.DERObjectIdentifier=function(c){var b=function(d){var e=d.toString(16);if(e.length==1){e="0"+e;}return e};var a=function(k){var j="";var e=new BigInteger(k,10);var d=e.toString(2);var f=7-d.length%7;if(f==7){f=0;}var m="";for(var g=0;g<f;g++){m+="0";}d=m+d;for(var g=0;g<d.length-1;g+=7){var l=d.substr(g,7);if(g!=d.length-7){l="1"+l;}j+=b(parseInt(l,2));}return j};KJUR.asn1.DERObjectIdentifier.superclass.constructor.call(this);this.hT="06";this.setValueHex=function(d){this.hTLV=null;this.isModified=true;this.s=null;this.hV=d;};this.setValueOidString=function(f){if(!f.match(/^[0-9.]+$/)){throw"malformed oid string: "+f}var g="";var d=f.split(".");var j=parseInt(d[0])*40+parseInt(d[1]);g+=b(j);d.splice(0,2);for(var e=0;e<d.length;e++){g+=a(d[e]);}this.hTLV=null;this.isModified=true;this.s=null;this.hV=g;};this.setValueName=function(e){var d=KJUR.asn1.x509.OID.name2oid(e);if(d!==""){this.setValueOidString(d);}else{throw"DERObjectIdentifier oidName undefined: "+e}};this.getFreshValueHex=function(){return this.hV};if(c!==undefined){if(typeof c==="string"){if(c.match(/^[0-2].[0-9.]+$/)){this.setValueOidString(c);}else{this.setValueName(c);}}else{if(c.oid!==undefined){this.setValueOidString(c.oid);}else{if(c.hex!==undefined){this.setValueHex(c.hex);}else{if(c.name!==undefined){this.setValueName(c.name);}}}}}};YAHOO.lang.extend(KJUR.asn1.DERObjectIdentifier,KJUR.asn1.ASN1Object);KJUR.asn1.DEREnumerated=function(a){KJUR.asn1.DEREnumerated.superclass.constructor.call(this);this.hT="0a";this.setByBigInteger=function(b){this.hTLV=null;this.isModified=true;this.hV=KJUR.asn1.ASN1Util.bigIntToMinTwosComplementsHex(b);};this.setByInteger=function(c){var b=new BigInteger(String(c),10);this.setByBigInteger(b);};this.setValueHex=function(b){this.hV=b;};this.getFreshValueHex=function(){return this.hV};if(typeof a!="undefined"){if(typeof a["int"]!="undefined"){this.setByInteger(a["int"]);}else{if(typeof a=="number"){this.setByInteger(a);}else{if(typeof a.hex!="undefined"){this.setValueHex(a.hex);}}}}};YAHOO.lang.extend(KJUR.asn1.DEREnumerated,KJUR.asn1.ASN1Object);KJUR.asn1.DERUTF8String=function(a){KJUR.asn1.DERUTF8String.superclass.constructor.call(this,a);this.hT="0c";};YAHOO.lang.extend(KJUR.asn1.DERUTF8String,KJUR.asn1.DERAbstractString);KJUR.asn1.DERNumericString=function(a){KJUR.asn1.DERNumericString.superclass.constructor.call(this,a);this.hT="12";};YAHOO.lang.extend(KJUR.asn1.DERNumericString,KJUR.asn1.DERAbstractString);KJUR.asn1.DERPrintableString=function(a){KJUR.asn1.DERPrintableString.superclass.constructor.call(this,a);this.hT="13";};YAHOO.lang.extend(KJUR.asn1.DERPrintableString,KJUR.asn1.DERAbstractString);KJUR.asn1.DERTeletexString=function(a){KJUR.asn1.DERTeletexString.superclass.constructor.call(this,a);this.hT="14";};YAHOO.lang.extend(KJUR.asn1.DERTeletexString,KJUR.asn1.DERAbstractString);KJUR.asn1.DERIA5String=function(a){KJUR.asn1.DERIA5String.superclass.constructor.call(this,a);this.hT="16";};YAHOO.lang.extend(KJUR.asn1.DERIA5String,KJUR.asn1.DERAbstractString);KJUR.asn1.DERUTCTime=function(a){KJUR.asn1.DERUTCTime.superclass.constructor.call(this,a);this.hT="17";this.setByDate=function(b){this.hTLV=null;this.isModified=true;this.date=b;this.s=this.formatDate(this.date,"utc");this.hV=stohex(this.s);};this.getFreshValueHex=function(){if(typeof this.date=="undefined"&&typeof this.s=="undefined"){this.date=new Date();this.s=this.formatDate(this.date,"utc");this.hV=stohex(this.s);}return this.hV};if(a!==undefined){if(a.str!==undefined){this.setString(a.str);}else{if(typeof a=="string"&&a.match(/^[0-9]{12}Z$/)){this.setString(a);}else{if(a.hex!==undefined){this.setStringHex(a.hex);}else{if(a.date!==undefined){this.setByDate(a.date);}}}}}};YAHOO.lang.extend(KJUR.asn1.DERUTCTime,KJUR.asn1.DERAbstractTime);KJUR.asn1.DERGeneralizedTime=function(a){KJUR.asn1.DERGeneralizedTime.superclass.constructor.call(this,a);this.hT="18";this.withMillis=false;this.setByDate=function(b){this.hTLV=null;this.isModified=true;this.date=b;this.s=this.formatDate(this.date,"gen",this.withMillis);this.hV=stohex(this.s);};this.getFreshValueHex=function(){if(this.date===undefined&&this.s===undefined){this.date=new Date();this.s=this.formatDate(this.date,"gen",this.withMillis);this.hV=stohex(this.s);}return this.hV};if(a!==undefined){if(a.str!==undefined){this.setString(a.str);}else{if(typeof a=="string"&&a.match(/^[0-9]{14}Z$/)){this.setString(a);}else{if(a.hex!==undefined){this.setStringHex(a.hex);}else{if(a.date!==undefined){this.setByDate(a.date);}}}}if(a.millis===true){this.withMillis=true;}}};YAHOO.lang.extend(KJUR.asn1.DERGeneralizedTime,KJUR.asn1.DERAbstractTime);KJUR.asn1.DERSequence=function(a){KJUR.asn1.DERSequence.superclass.constructor.call(this,a);this.hT="30";this.getFreshValueHex=function(){var c="";for(var b=0;b<this.asn1Array.length;b++){var d=this.asn1Array[b];c+=d.getEncodedHex();}this.hV=c;return this.hV};};YAHOO.lang.extend(KJUR.asn1.DERSequence,KJUR.asn1.DERAbstractStructured);KJUR.asn1.DERSet=function(a){KJUR.asn1.DERSet.superclass.constructor.call(this,a);this.hT="31";this.sortFlag=true;this.getFreshValueHex=function(){var b=new Array();for(var c=0;c<this.asn1Array.length;c++){var d=this.asn1Array[c];b.push(d.getEncodedHex());}if(this.sortFlag==true){b.sort();}this.hV=b.join("");return this.hV};if(typeof a!="undefined"){if(typeof a.sortflag!="undefined"&&a.sortflag==false){this.sortFlag=false;}}};YAHOO.lang.extend(KJUR.asn1.DERSet,KJUR.asn1.DERAbstractStructured);KJUR.asn1.DERTaggedObject=function(a){KJUR.asn1.DERTaggedObject.superclass.constructor.call(this);this.hT="a0";this.hV="";this.isExplicit=true;this.asn1Object=null;this.setASN1Object=function(b,c,d){this.hT=c;this.isExplicit=b;this.asn1Object=d;if(this.isExplicit){this.hV=this.asn1Object.getEncodedHex();this.hTLV=null;this.isModified=true;}else{this.hV=null;this.hTLV=d.getEncodedHex();this.hTLV=this.hTLV.replace(/^../,c);this.isModified=false;}};this.getFreshValueHex=function(){return this.hV};if(typeof a!="undefined"){if(typeof a.tag!="undefined"){this.hT=a.tag;}if(typeof a.explicit!="undefined"){this.isExplicit=a.explicit;}if(typeof a.obj!="undefined"){this.asn1Object=a.obj;this.setASN1Object(this.isExplicit,this.hT,this.asn1Object);}}};YAHOO.lang.extend(KJUR.asn1.DERTaggedObject,KJUR.asn1.ASN1Object);
	var ASN1HEX=new function(){};ASN1HEX.getLblen=function(c,a){if(c.substr(a+2,1)!="8"){return 1}var b=parseInt(c.substr(a+3,1));if(b==0){return -1}if(0<b&&b<10){return b+1}return -2};ASN1HEX.getL=function(c,b){var a=ASN1HEX.getLblen(c,b);if(a<1){return ""}return c.substr(b+2,a*2)};ASN1HEX.getVblen=function(d,a){var c,b;c=ASN1HEX.getL(d,a);if(c==""){return -1}if(c.substr(0,1)==="8"){b=new BigInteger(c.substr(2),16);}else{b=new BigInteger(c,16);}return b.intValue()};ASN1HEX.getVidx=function(c,b){var a=ASN1HEX.getLblen(c,b);if(a<0){return a}return b+(a+1)*2};ASN1HEX.getV=function(d,a){var c=ASN1HEX.getVidx(d,a);var b=ASN1HEX.getVblen(d,a);return d.substr(c,b*2)};ASN1HEX.getTLV=function(b,a){return b.substr(a,2)+ASN1HEX.getL(b,a)+ASN1HEX.getV(b,a)};ASN1HEX.getNextSiblingIdx=function(d,a){var c=ASN1HEX.getVidx(d,a);var b=ASN1HEX.getVblen(d,a);return c+b*2};ASN1HEX.getChildIdx=function(e,f){var j=ASN1HEX;var g=new Array();var i=j.getVidx(e,f);if(e.substr(f,2)=="03"){g.push(i+2);}else{g.push(i);}var l=j.getVblen(e,f);var c=i;var d=0;while(1){var b=j.getNextSiblingIdx(e,c);if(b==null||(b-i>=(l*2))){break}if(d>=200){break}g.push(b);c=b;d++;}return g};ASN1HEX.getNthChildIdx=function(d,b,e){var c=ASN1HEX.getChildIdx(d,b);return c[e]};ASN1HEX.getIdxbyList=function(e,d,c,i){var g=ASN1HEX;var f,b;if(c.length==0){if(i!==undefined){if(e.substr(d,2)!==i){throw"checking tag doesn't match: "+e.substr(d,2)+"!="+i}}return d}f=c.shift();b=g.getChildIdx(e,d);return g.getIdxbyList(e,b[f],c,i)};ASN1HEX.getTLVbyList=function(d,c,b,f){var e=ASN1HEX;var a=e.getIdxbyList(d,c,b);if(a===undefined){throw"can't find nthList object"}if(f!==undefined){if(d.substr(a,2)!=f){throw"checking tag doesn't match: "+d.substr(a,2)+"!="+f}}return e.getTLV(d,a)};ASN1HEX.getVbyList=function(e,c,b,g,i){var f=ASN1HEX;var a,d;a=f.getIdxbyList(e,c,b,g);if(a===undefined){throw"can't find nthList object"}d=f.getV(e,a);if(i===true){d=d.substr(2);}return d};ASN1HEX.hextooidstr=function(e){var h=function(b,a){if(b.length>=a){return b}return new Array(a-b.length+1).join("0")+b};var l=[];var o=e.substr(0,2);var f=parseInt(o,16);l[0]=new String(Math.floor(f/40));l[1]=new String(f%40);var m=e.substr(2);var k=[];for(var g=0;g<m.length/2;g++){k.push(parseInt(m.substr(g*2,2),16));}var j=[];var d="";for(var g=0;g<k.length;g++){if(k[g]&128){d=d+h((k[g]&127).toString(2),7);}else{d=d+h((k[g]&127).toString(2),7);j.push(new String(parseInt(d,2)));d="";}}var n=l.join(".");if(j.length>0){n=n+"."+j.join(".");}return n};ASN1HEX.dump=function(t,c,l,g){var p=ASN1HEX;var j=p.getV;var y=p.dump;var w=p.getChildIdx;var e=t;if(t instanceof KJUR.asn1.ASN1Object){e=t.getEncodedHex();}var q=function(A,i){if(A.length<=i*2){return A}else{var v=A.substr(0,i)+"..(total "+A.length/2+"bytes).."+A.substr(A.length-i,i);return v}};if(c===undefined){c={ommit_long_octet:32};}if(l===undefined){l=0;}if(g===undefined){g="";}var x=c.ommit_long_octet;if(e.substr(l,2)=="01"){var h=j(e,l);if(h=="00"){return g+"BOOLEAN FALSE\n"}else{return g+"BOOLEAN TRUE\n"}}if(e.substr(l,2)=="02"){var h=j(e,l);return g+"INTEGER "+q(h,x)+"\n"}if(e.substr(l,2)=="03"){var h=j(e,l);return g+"BITSTRING "+q(h,x)+"\n"}if(e.substr(l,2)=="04"){var h=j(e,l);if(p.isASN1HEX(h)){var k=g+"OCTETSTRING, encapsulates\n";k=k+y(h,c,0,g+"  ");return k}else{return g+"OCTETSTRING "+q(h,x)+"\n"}}if(e.substr(l,2)=="05"){return g+"NULL\n"}if(e.substr(l,2)=="06"){var m=j(e,l);var a=KJUR.asn1.ASN1Util.oidHexToInt(m);var o=KJUR.asn1.x509.OID.oid2name(a);var b=a.replace(/\./g," ");if(o!=""){return g+"ObjectIdentifier "+o+" ("+b+")\n"}else{return g+"ObjectIdentifier ("+b+")\n"}}if(e.substr(l,2)=="0c"){return g+"UTF8String '"+hextoutf8(j(e,l))+"'\n"}if(e.substr(l,2)=="13"){return g+"PrintableString '"+hextoutf8(j(e,l))+"'\n"}if(e.substr(l,2)=="14"){return g+"TeletexString '"+hextoutf8(j(e,l))+"'\n"}if(e.substr(l,2)=="16"){return g+"IA5String '"+hextoutf8(j(e,l))+"'\n"}if(e.substr(l,2)=="17"){return g+"UTCTime "+hextoutf8(j(e,l))+"\n"}if(e.substr(l,2)=="18"){return g+"GeneralizedTime "+hextoutf8(j(e,l))+"\n"}if(e.substr(l,2)=="30"){if(e.substr(l,4)=="3000"){return g+"SEQUENCE {}\n"}var k=g+"SEQUENCE\n";var d=w(e,l);var f=c;if((d.length==2||d.length==3)&&e.substr(d[0],2)=="06"&&e.substr(d[d.length-1],2)=="04"){var o=p.oidname(j(e,d[0]));var r=JSON.parse(JSON.stringify(c));r.x509ExtName=o;f=r;}for(var u=0;u<d.length;u++){k=k+y(e,f,d[u],g+"  ");}return k}if(e.substr(l,2)=="31"){var k=g+"SET\n";var d=w(e,l);for(var u=0;u<d.length;u++){k=k+y(e,c,d[u],g+"  ");}return k}var z=parseInt(e.substr(l,2),16);if((z&128)!=0){var n=z&31;if((z&32)!=0){var k=g+"["+n+"]\n";var d=w(e,l);for(var u=0;u<d.length;u++){k=k+y(e,c,d[u],g+"  ");}return k}else{var h=j(e,l);if(h.substr(0,8)=="68747470"){h=hextoutf8(h);}if(c.x509ExtName==="subjectAltName"&&n==2){h=hextoutf8(h);}var k=g+"["+n+"] "+h+"\n";return k}}return g+"UNKNOWN("+e.substr(l,2)+") "+j(e,l)+"\n"};ASN1HEX.isASN1HEX=function(e){var d=ASN1HEX;if(e.length%2==1){return false}var c=d.getVblen(e,0);var b=e.substr(0,2);var f=d.getL(e,0);var a=e.length-b.length-f.length;if(a==c*2){return true}return false};ASN1HEX.oidname=function(a){var c=KJUR.asn1;if(KJUR.lang.String.isHex(a)){a=c.ASN1Util.oidHexToInt(a);}var b=c.x509.OID.oid2name(a);if(b===""){b=a;}return b};
	if(typeof KJUR=="undefined"||!KJUR){KJUR={};}if(typeof KJUR.asn1=="undefined"||!KJUR.asn1){KJUR.asn1={};}if(typeof KJUR.asn1.x509=="undefined"||!KJUR.asn1.x509){KJUR.asn1.x509={};}KJUR.asn1.x509.Certificate=function(e){KJUR.asn1.x509.Certificate.superclass.constructor.call(this);var b=KJUR,f=b.crypto,g=b.asn1,d=g.DERSequence,c=g.DERBitString;this.sign=function(){this.asn1SignatureAlg=this.asn1TBSCert.asn1SignatureAlg;var m=new KJUR.crypto.Signature({alg:this.asn1SignatureAlg.nameAlg});m.init(this.prvKey);m.updateHex(this.asn1TBSCert.getEncodedHex());this.hexSig=m.sign();this.asn1Sig=new c({hex:"00"+this.hexSig});var l=new d({array:[this.asn1TBSCert,this.asn1SignatureAlg,this.asn1Sig]});this.hTLV=l.getEncodedHex();this.isModified=false;};this.setSignatureHex=function(l){this.asn1SignatureAlg=this.asn1TBSCert.asn1SignatureAlg;this.hexSig=l;this.asn1Sig=new c({hex:"00"+this.hexSig});var m=new d({array:[this.asn1TBSCert,this.asn1SignatureAlg,this.asn1Sig]});this.hTLV=m.getEncodedHex();this.isModified=false;};this.getEncodedHex=function(){if(this.isModified==false&&this.hTLV!=null){return this.hTLV}throw"not signed yet"};this.getPEMString=function(){var l=hextob64nl(this.getEncodedHex());return "-----BEGIN CERTIFICATE-----\r\n"+l+"\r\n-----END CERTIFICATE-----\r\n"};if(e!==undefined){if(e.tbscertobj!==undefined){this.asn1TBSCert=e.tbscertobj;}if(e.prvkeyobj!==undefined){this.prvKey=e.prvkeyobj;}}};YAHOO.lang.extend(KJUR.asn1.x509.Certificate,KJUR.asn1.ASN1Object);KJUR.asn1.x509.TBSCertificate=function(e){KJUR.asn1.x509.TBSCertificate.superclass.constructor.call(this);var b=KJUR,i=b.asn1,f=i.DERSequence,h=i.DERInteger,c=i.DERTaggedObject,d=i.x509,g=d.Time,a=d.X500Name,j=d.SubjectPublicKeyInfo;this._initialize=function(){this.asn1Array=new Array();this.asn1Version=new c({obj:new h({"int":2})});this.asn1SerialNumber=null;this.asn1SignatureAlg=null;this.asn1Issuer=null;this.asn1NotBefore=null;this.asn1NotAfter=null;this.asn1Subject=null;this.asn1SubjPKey=null;this.extensionsArray=new Array();};this.setSerialNumberByParam=function(k){this.asn1SerialNumber=new h(k);};this.setSignatureAlgByParam=function(k){this.asn1SignatureAlg=new d.AlgorithmIdentifier(k);};this.setIssuerByParam=function(k){this.asn1Issuer=new a(k);};this.setNotBeforeByParam=function(k){this.asn1NotBefore=new g(k);};this.setNotAfterByParam=function(k){this.asn1NotAfter=new g(k);};this.setSubjectByParam=function(k){this.asn1Subject=new a(k);};this.setSubjectPublicKey=function(k){this.asn1SubjPKey=new j(k);};this.setSubjectPublicKeyByGetKey=function(l){var k=KEYUTIL.getKey(l);this.asn1SubjPKey=new j(k);};this.appendExtension=function(k){this.extensionsArray.push(k);};this.appendExtensionByName=function(l,k){KJUR.asn1.x509.Extension.appendByNameToArray(l,k,this.extensionsArray);};this.getEncodedHex=function(){if(this.asn1NotBefore==null||this.asn1NotAfter==null){throw"notBefore and/or notAfter not set"}var l=new f({array:[this.asn1NotBefore,this.asn1NotAfter]});this.asn1Array=new Array();this.asn1Array.push(this.asn1Version);this.asn1Array.push(this.asn1SerialNumber);this.asn1Array.push(this.asn1SignatureAlg);this.asn1Array.push(this.asn1Issuer);this.asn1Array.push(l);this.asn1Array.push(this.asn1Subject);this.asn1Array.push(this.asn1SubjPKey);if(this.extensionsArray.length>0){var m=new f({array:this.extensionsArray});var k=new c({explicit:true,tag:"a3",obj:m});this.asn1Array.push(k);}var n=new f({array:this.asn1Array});this.hTLV=n.getEncodedHex();this.isModified=false;return this.hTLV};this._initialize();};YAHOO.lang.extend(KJUR.asn1.x509.TBSCertificate,KJUR.asn1.ASN1Object);KJUR.asn1.x509.Extension=function(d){KJUR.asn1.x509.Extension.superclass.constructor.call(this);var a=KJUR,e=a.asn1,h=e.DERObjectIdentifier,i=e.DEROctetString,b=e.DERBitString,g=e.DERBoolean,c=e.DERSequence;this.getEncodedHex=function(){var m=new h({oid:this.oid});var l=new i({hex:this.getExtnValueHex()});var k=new Array();k.push(m);if(this.critical){k.push(new g());}k.push(l);var j=new c({array:k});return j.getEncodedHex()};this.critical=false;if(d!==undefined){if(d.critical!==undefined){this.critical=d.critical;}}};YAHOO.lang.extend(KJUR.asn1.x509.Extension,KJUR.asn1.ASN1Object);KJUR.asn1.x509.Extension.appendByNameToArray=function(e,c,b){var g=e.toLowerCase(),f=KJUR.asn1.x509;if(g=="basicconstraints"){var d=new f.BasicConstraints(c);b.push(d);}else{if(g=="keyusage"){var d=new f.KeyUsage(c);b.push(d);}else{if(g=="crldistributionpoints"){var d=new f.CRLDistributionPoints(c);b.push(d);}else{if(g=="extkeyusage"){var d=new f.ExtKeyUsage(c);b.push(d);}else{if(g=="authoritykeyidentifier"){var d=new f.AuthorityKeyIdentifier(c);b.push(d);}else{if(g=="authorityinfoaccess"){var d=new f.AuthorityInfoAccess(c);b.push(d);}else{if(g=="subjectaltname"){var d=new f.SubjectAltName(c);b.push(d);}else{if(g=="issueraltname"){var d=new f.IssuerAltName(c);b.push(d);}else{throw"unsupported extension name: "+e}}}}}}}}};KJUR.asn1.x509.KeyUsage=function(f){KJUR.asn1.x509.KeyUsage.superclass.constructor.call(this,f);var a=X509.KEYUSAGE_NAME;this.getExtnValueHex=function(){return this.asn1ExtnValue.getEncodedHex()};this.oid="2.5.29.15";if(f!==undefined){if(f.bin!==undefined){this.asn1ExtnValue=new KJUR.asn1.DERBitString(f);}if(f.names!==undefined&&f.names.length!==undefined){var e=f.names;var d="000000000";for(var c=0;c<e.length;c++){for(var b=0;b<a.length;b++){if(e[c]===a[b]){d=d.substring(0,b)+"1"+d.substring(b+1,d.length);}}}this.asn1ExtnValue=new KJUR.asn1.DERBitString({bin:d});}}};YAHOO.lang.extend(KJUR.asn1.x509.KeyUsage,KJUR.asn1.x509.Extension);KJUR.asn1.x509.BasicConstraints=function(c){KJUR.asn1.x509.BasicConstraints.superclass.constructor.call(this,c);this.getExtnValueHex=function(){var e=new Array();if(this.cA){e.push(new KJUR.asn1.DERBoolean());}if(this.pathLen>-1){e.push(new KJUR.asn1.DERInteger({"int":this.pathLen}));}var d=new KJUR.asn1.DERSequence({array:e});this.asn1ExtnValue=d;return this.asn1ExtnValue.getEncodedHex()};this.oid="2.5.29.19";this.cA=false;this.pathLen=-1;if(c!==undefined){if(c.cA!==undefined){this.cA=c.cA;}if(c.pathLen!==undefined){this.pathLen=c.pathLen;}}};YAHOO.lang.extend(KJUR.asn1.x509.BasicConstraints,KJUR.asn1.x509.Extension);KJUR.asn1.x509.CRLDistributionPoints=function(d){KJUR.asn1.x509.CRLDistributionPoints.superclass.constructor.call(this,d);var b=KJUR,a=b.asn1,c=a.x509;this.getExtnValueHex=function(){return this.asn1ExtnValue.getEncodedHex()};this.setByDPArray=function(e){this.asn1ExtnValue=new a.DERSequence({array:e});};this.setByOneURI=function(h){var e=new c.GeneralNames([{uri:h}]);var g=new c.DistributionPointName(e);var f=new c.DistributionPoint({dpobj:g});this.setByDPArray([f]);};this.oid="2.5.29.31";if(d!==undefined){if(d.array!==undefined){this.setByDPArray(d.array);}else{if(d.uri!==undefined){this.setByOneURI(d.uri);}}}};YAHOO.lang.extend(KJUR.asn1.x509.CRLDistributionPoints,KJUR.asn1.x509.Extension);KJUR.asn1.x509.ExtKeyUsage=function(c){KJUR.asn1.x509.ExtKeyUsage.superclass.constructor.call(this,c);var b=KJUR,a=b.asn1;this.setPurposeArray=function(d){this.asn1ExtnValue=new a.DERSequence();for(var e=0;e<d.length;e++){var f=new a.DERObjectIdentifier(d[e]);this.asn1ExtnValue.appendASN1Object(f);}};this.getExtnValueHex=function(){return this.asn1ExtnValue.getEncodedHex()};this.oid="2.5.29.37";if(c!==undefined){if(c.array!==undefined){this.setPurposeArray(c.array);}}};YAHOO.lang.extend(KJUR.asn1.x509.ExtKeyUsage,KJUR.asn1.x509.Extension);KJUR.asn1.x509.AuthorityKeyIdentifier=function(d){KJUR.asn1.x509.AuthorityKeyIdentifier.superclass.constructor.call(this,d);var b=KJUR,a=b.asn1,c=a.DERTaggedObject;this.asn1KID=null;this.asn1CertIssuer=null;this.asn1CertSN=null;this.getExtnValueHex=function(){var f=new Array();if(this.asn1KID){f.push(new c({explicit:false,tag:"80",obj:this.asn1KID}));}if(this.asn1CertIssuer){f.push(new c({explicit:false,tag:"a1",obj:this.asn1CertIssuer}));}if(this.asn1CertSN){f.push(new c({explicit:false,tag:"82",obj:this.asn1CertSN}));}var e=new a.DERSequence({array:f});this.asn1ExtnValue=e;return this.asn1ExtnValue.getEncodedHex()};this.setKIDByParam=function(e){this.asn1KID=new KJUR.asn1.DEROctetString(e);};this.setCertIssuerByParam=function(e){this.asn1CertIssuer=new KJUR.asn1.x509.X500Name(e);};this.setCertSNByParam=function(e){this.asn1CertSN=new KJUR.asn1.DERInteger(e);};this.oid="2.5.29.35";if(d!==undefined){if(d.kid!==undefined){this.setKIDByParam(d.kid);}if(d.issuer!==undefined){this.setCertIssuerByParam(d.issuer);}if(d.sn!==undefined){this.setCertSNByParam(d.sn);}}};YAHOO.lang.extend(KJUR.asn1.x509.AuthorityKeyIdentifier,KJUR.asn1.x509.Extension);KJUR.asn1.x509.AuthorityInfoAccess=function(a){KJUR.asn1.x509.AuthorityInfoAccess.superclass.constructor.call(this,a);this.setAccessDescriptionArray=function(k){var j=new Array(),b=KJUR,g=b.asn1,d=g.DERSequence;for(var f=0;f<k.length;f++){var c=new g.DERObjectIdentifier(k[f].accessMethod);var e=new g.x509.GeneralName(k[f].accessLocation);var h=new d({array:[c,e]});j.push(h);}this.asn1ExtnValue=new d({array:j});};this.getExtnValueHex=function(){return this.asn1ExtnValue.getEncodedHex()};this.oid="1.3.6.1.5.5.7.1.1";if(a!==undefined){if(a.array!==undefined){this.setAccessDescriptionArray(a.array);}}};YAHOO.lang.extend(KJUR.asn1.x509.AuthorityInfoAccess,KJUR.asn1.x509.Extension);KJUR.asn1.x509.SubjectAltName=function(a){KJUR.asn1.x509.SubjectAltName.superclass.constructor.call(this,a);this.setNameArray=function(b){this.asn1ExtnValue=new KJUR.asn1.x509.GeneralNames(b);};this.getExtnValueHex=function(){return this.asn1ExtnValue.getEncodedHex()};this.oid="2.5.29.17";if(a!==undefined){if(a.array!==undefined){this.setNameArray(a.array);}}};YAHOO.lang.extend(KJUR.asn1.x509.SubjectAltName,KJUR.asn1.x509.Extension);KJUR.asn1.x509.IssuerAltName=function(a){KJUR.asn1.x509.IssuerAltName.superclass.constructor.call(this,a);this.setNameArray=function(b){this.asn1ExtnValue=new KJUR.asn1.x509.GeneralNames(b);};this.getExtnValueHex=function(){return this.asn1ExtnValue.getEncodedHex()};this.oid="2.5.29.18";if(a!==undefined){if(a.array!==undefined){this.setNameArray(a.array);}}};YAHOO.lang.extend(KJUR.asn1.x509.IssuerAltName,KJUR.asn1.x509.Extension);KJUR.asn1.x509.CRL=function(f){KJUR.asn1.x509.CRL.superclass.constructor.call(this);this.sign=function(){this.asn1SignatureAlg=this.asn1TBSCertList.asn1SignatureAlg;sig=new KJUR.crypto.Signature({alg:"SHA1withRSA",prov:"cryptojs/jsrsa"});sig.init(this.prvKey);sig.updateHex(this.asn1TBSCertList.getEncodedHex());this.hexSig=sig.sign();this.asn1Sig=new KJUR.asn1.DERBitString({hex:"00"+this.hexSig});var g=new KJUR.asn1.DERSequence({array:[this.asn1TBSCertList,this.asn1SignatureAlg,this.asn1Sig]});this.hTLV=g.getEncodedHex();this.isModified=false;};this.getEncodedHex=function(){if(this.isModified==false&&this.hTLV!=null){return this.hTLV}throw"not signed yet"};this.getPEMString=function(){var g=hextob64nl(this.getEncodedHex());return "-----BEGIN X509 CRL-----\r\n"+g+"\r\n-----END X509 CRL-----\r\n"};if(f!==undefined){if(f.tbsobj!==undefined){this.asn1TBSCertList=f.tbsobj;}if(f.prvkeyobj!==undefined){this.prvKey=f.prvkeyobj;}}};YAHOO.lang.extend(KJUR.asn1.x509.CRL,KJUR.asn1.ASN1Object);KJUR.asn1.x509.TBSCertList=function(g){KJUR.asn1.x509.TBSCertList.superclass.constructor.call(this);var d=KJUR,c=d.asn1,b=c.DERSequence,f=c.x509,a=f.Time;this.setSignatureAlgByParam=function(h){this.asn1SignatureAlg=new f.AlgorithmIdentifier(h);};this.setIssuerByParam=function(h){this.asn1Issuer=new f.X500Name(h);};this.setThisUpdateByParam=function(h){this.asn1ThisUpdate=new a(h);};this.setNextUpdateByParam=function(h){this.asn1NextUpdate=new a(h);};this.addRevokedCert=function(h,i){var k={};if(h!=undefined&&h!=null){k.sn=h;}if(i!=undefined&&i!=null){k.time=i;}var j=new f.CRLEntry(k);this.aRevokedCert.push(j);};this.getEncodedHex=function(){this.asn1Array=new Array();if(this.asn1Version!=null){this.asn1Array.push(this.asn1Version);}this.asn1Array.push(this.asn1SignatureAlg);this.asn1Array.push(this.asn1Issuer);this.asn1Array.push(this.asn1ThisUpdate);if(this.asn1NextUpdate!=null){this.asn1Array.push(this.asn1NextUpdate);}if(this.aRevokedCert.length>0){var h=new b({array:this.aRevokedCert});this.asn1Array.push(h);}var i=new b({array:this.asn1Array});this.hTLV=i.getEncodedHex();this.isModified=false;return this.hTLV};this._initialize=function(){this.asn1Version=null;this.asn1SignatureAlg=null;this.asn1Issuer=null;this.asn1ThisUpdate=null;this.asn1NextUpdate=null;this.aRevokedCert=new Array();};this._initialize();};YAHOO.lang.extend(KJUR.asn1.x509.TBSCertList,KJUR.asn1.ASN1Object);KJUR.asn1.x509.CRLEntry=function(e){KJUR.asn1.x509.CRLEntry.superclass.constructor.call(this);var b=KJUR,a=b.asn1;this.setCertSerial=function(f){this.sn=new a.DERInteger(f);};this.setRevocationDate=function(f){this.time=new a.x509.Time(f);};this.getEncodedHex=function(){var f=new a.DERSequence({array:[this.sn,this.time]});this.TLV=f.getEncodedHex();return this.TLV};if(e!==undefined){if(e.time!==undefined){this.setRevocationDate(e.time);}if(e.sn!==undefined){this.setCertSerial(e.sn);}}};YAHOO.lang.extend(KJUR.asn1.x509.CRLEntry,KJUR.asn1.ASN1Object);KJUR.asn1.x509.X500Name=function(f){KJUR.asn1.x509.X500Name.superclass.constructor.call(this);this.asn1Array=new Array();var d=KJUR,c=d.asn1,e=c.x509,b=pemtohex;this.setByString=function(g){var k=g.split("/");k.shift();var j=[];for(var l=0;l<k.length;l++){if(k[l].match(/^[^=]+=.+$/)){j.push(k[l]);}else{var h=j.length-1;j[h]=j[h]+"/"+k[l];}}for(var l=0;l<j.length;l++){this.asn1Array.push(new e.RDN({str:j[l]}));}};this.setByLdapString=function(g){var h=e.X500Name.ldapToOneline(g);this.setByString(h);};this.setByObject=function(i){for(var g in i){if(i.hasOwnProperty(g)){var h=new KJUR.asn1.x509.RDN({str:g+"="+i[g]});this.asn1Array?this.asn1Array.push(h):this.asn1Array=[h];}}};this.getEncodedHex=function(){if(typeof this.hTLV=="string"){return this.hTLV}var g=new c.DERSequence({array:this.asn1Array});this.hTLV=g.getEncodedHex();return this.hTLV};if(f!==undefined){if(f.str!==undefined){this.setByString(f.str);}else{if(f.ldapstr!==undefined){this.setByLdapString(f.ldapstr);}else{if(typeof f==="object"){this.setByObject(f);}}}if(f.certissuer!==undefined){var a=new X509();a.hex=b(f.certissuer);this.hTLV=a.getIssuerHex();}if(f.certsubject!==undefined){var a=new X509();a.hex=b(f.certsubject);this.hTLV=a.getSubjectHex();}}};YAHOO.lang.extend(KJUR.asn1.x509.X500Name,KJUR.asn1.ASN1Object);KJUR.asn1.x509.X500Name.onelineToLDAP=function(d){if(d.substr(0,1)!=="/"){throw"malformed input"}d=d.substr(1);var c=d.split("/");c.reverse();c=c.map(function(a){return a.replace(/,/,"\\,")});return c.join(",")};KJUR.asn1.x509.X500Name.ldapToOneline=function(g){var c=g.split(",");var e=false;var b=[];for(var f=0;c.length>0;f++){var h=c.shift();if(e===true){var d=b.pop();var j=(d+","+h).replace(/\\,/g,",");b.push(j);e=false;}else{b.push(h);}if(h.substr(-1,1)==="\\"){e=true;}}b=b.map(function(a){return a.replace("/","\\/")});b.reverse();return "/"+b.join("/")};KJUR.asn1.x509.RDN=function(a){KJUR.asn1.x509.RDN.superclass.constructor.call(this);this.asn1Array=new Array();this.addByString=function(b){this.asn1Array.push(new KJUR.asn1.x509.AttributeTypeAndValue({str:b}));};this.addByMultiValuedString=function(d){var b=KJUR.asn1.x509.RDN.parseString(d);for(var c=0;c<b.length;c++){this.addByString(b[c]);}};this.getEncodedHex=function(){var b=new KJUR.asn1.DERSet({array:this.asn1Array});this.TLV=b.getEncodedHex();return this.TLV};if(a!==undefined){if(a.str!==undefined){this.addByMultiValuedString(a.str);}}};YAHOO.lang.extend(KJUR.asn1.x509.RDN,KJUR.asn1.ASN1Object);KJUR.asn1.x509.RDN.parseString=function(m){var j=m.split(/\+/);var h=false;var c=[];for(var g=0;j.length>0;g++){var k=j.shift();if(h===true){var f=c.pop();var d=(f+"+"+k).replace(/\\\+/g,"+");c.push(d);h=false;}else{c.push(k);}if(k.substr(-1,1)==="\\"){h=true;}}var l=false;var b=[];for(var g=0;c.length>0;g++){var k=c.shift();if(l===true){var e=b.pop();if(k.match(/"$/)){var d=(e+"+"+k).replace(/^([^=]+)="(.*)"$/,"$1=$2");b.push(d);l=false;}else{b.push(e+"+"+k);}}else{b.push(k);}if(k.match(/^[^=]+="/)){l=true;}}return b};KJUR.asn1.x509.AttributeTypeAndValue=function(d){KJUR.asn1.x509.AttributeTypeAndValue.superclass.constructor.call(this);var a="utf8",c=KJUR,b=c.asn1;this.setByString=function(h){var g=h.match(/^([^=]+)=(.+)$/);if(g){this.setByAttrTypeAndValueStr(g[1],g[2]);}else{throw"malformed attrTypeAndValueStr: "+h}};this.setByAttrTypeAndValueStr=function(i,h){this.typeObj=KJUR.asn1.x509.OID.atype2obj(i);var g=a;if(i=="C"){g="prn";}this.valueObj=this.getValueObj(g,h);};this.getValueObj=function(h,g){if(h=="utf8"){return new b.DERUTF8String({str:g})}if(h=="prn"){return new b.DERPrintableString({str:g})}if(h=="tel"){return new b.DERTeletexString({str:g})}if(h=="ia5"){return new b.DERIA5String({str:g})}throw"unsupported directory string type: type="+h+" value="+g};this.getEncodedHex=function(){var g=new b.DERSequence({array:[this.typeObj,this.valueObj]});this.TLV=g.getEncodedHex();return this.TLV};if(d!==undefined){if(d.str!==undefined){this.setByString(d.str);}}};YAHOO.lang.extend(KJUR.asn1.x509.AttributeTypeAndValue,KJUR.asn1.ASN1Object);KJUR.asn1.x509.SubjectPublicKeyInfo=function(f){KJUR.asn1.x509.SubjectPublicKeyInfo.superclass.constructor.call(this);var a=KJUR,j=a.asn1,i=j.DERInteger,b=j.DERBitString,m=j.DERObjectIdentifier,e=j.DERSequence,h=j.ASN1Util.newObject,d=j.x509,o=d.AlgorithmIdentifier,g=a.crypto,n=g.ECDSA,c=g.DSA;this.getASN1Object=function(){if(this.asn1AlgId==null||this.asn1SubjPKey==null){throw"algId and/or subjPubKey not set"}var p=new e({array:[this.asn1AlgId,this.asn1SubjPKey]});return p};this.getEncodedHex=function(){var p=this.getASN1Object();this.hTLV=p.getEncodedHex();return this.hTLV};this.setPubKey=function(q){try{if(q instanceof RSAKey){var u=h({seq:[{"int":{bigint:q.n}},{"int":{"int":q.e}}]});var s=u.getEncodedHex();this.asn1AlgId=new o({name:"rsaEncryption"});this.asn1SubjPKey=new b({hex:"00"+s});}}catch(p){}try{if(q instanceof KJUR.crypto.ECDSA){var r=new m({name:q.curveName});this.asn1AlgId=new o({name:"ecPublicKey",asn1params:r});this.asn1SubjPKey=new b({hex:"00"+q.pubKeyHex});}}catch(p){}try{if(q instanceof KJUR.crypto.DSA){var r=new h({seq:[{"int":{bigint:q.p}},{"int":{bigint:q.q}},{"int":{bigint:q.g}}]});this.asn1AlgId=new o({name:"dsa",asn1params:r});var t=new i({bigint:q.y});this.asn1SubjPKey=new b({hex:"00"+t.getEncodedHex()});}}catch(p){}};if(f!==undefined){this.setPubKey(f);}};YAHOO.lang.extend(KJUR.asn1.x509.SubjectPublicKeyInfo,KJUR.asn1.ASN1Object);KJUR.asn1.x509.Time=function(f){KJUR.asn1.x509.Time.superclass.constructor.call(this);var d=KJUR,c=d.asn1,b=c.DERUTCTime,g=c.DERGeneralizedTime;this.setTimeParams=function(h){this.timeParams=h;};this.getEncodedHex=function(){var h=null;if(this.timeParams!=null){if(this.type=="utc"){h=new b(this.timeParams);}else{h=new g(this.timeParams);}}else{if(this.type=="utc"){h=new b();}else{h=new g();}}this.TLV=h.getEncodedHex();return this.TLV};this.type="utc";if(f!==undefined){if(f.type!==undefined){this.type=f.type;}else{if(f.str!==undefined){if(f.str.match(/^[0-9]{12}Z$/)){this.type="utc";}if(f.str.match(/^[0-9]{14}Z$/)){this.type="gen";}}}this.timeParams=f;}};YAHOO.lang.extend(KJUR.asn1.x509.Time,KJUR.asn1.ASN1Object);KJUR.asn1.x509.AlgorithmIdentifier=function(d){KJUR.asn1.x509.AlgorithmIdentifier.superclass.constructor.call(this);this.nameAlg=null;this.asn1Alg=null;this.asn1Params=null;this.paramEmpty=false;var b=KJUR,a=b.asn1;this.getEncodedHex=function(){if(this.nameAlg===null&&this.asn1Alg===null){throw"algorithm not specified"}if(this.nameAlg!==null&&this.asn1Alg===null){this.asn1Alg=a.x509.OID.name2obj(this.nameAlg);}var e=[this.asn1Alg];if(this.asn1Params!==null){e.push(this.asn1Params);}var f=new a.DERSequence({array:e});this.hTLV=f.getEncodedHex();return this.hTLV};if(d!==undefined){if(d.name!==undefined){this.nameAlg=d.name;}if(d.asn1params!==undefined){this.asn1Params=d.asn1params;}if(d.paramempty!==undefined){this.paramEmpty=d.paramempty;}}if(this.asn1Params===null&&this.paramEmpty===false&&this.nameAlg!==null){var c=this.nameAlg.toLowerCase();if(c.substr(-7,7)!=="withdsa"&&c.substr(-9,9)!=="withecdsa"){this.asn1Params=new a.DERNull();}}};YAHOO.lang.extend(KJUR.asn1.x509.AlgorithmIdentifier,KJUR.asn1.ASN1Object);KJUR.asn1.x509.GeneralName=function(e){KJUR.asn1.x509.GeneralName.superclass.constructor.call(this);var k={rfc822:"81",dns:"82",dn:"a4",uri:"86",ip:"87"},b=KJUR,g=b.asn1,f=g.DERSequence,j=g.DEROctetString,d=g.DERIA5String,c=g.DERTaggedObject,l=g.ASN1Object,a=g.x509.X500Name,h=pemtohex;this.explicit=false;this.setByParam=function(p){var u=null;if(p===undefined){return}if(p.rfc822!==undefined){this.type="rfc822";u=new d({str:p[this.type]});}if(p.dns!==undefined){this.type="dns";u=new d({str:p[this.type]});}if(p.uri!==undefined){this.type="uri";u=new d({str:p[this.type]});}if(p.dn!==undefined){this.type="dn";this.explicit=true;u=new a({str:p.dn});}if(p.ldapdn!==undefined){this.type="dn";this.explicit=true;u=new a({ldapstr:p.ldapdn});}if(p.certissuer!==undefined){this.type="dn";this.explicit=true;var o=p.certissuer;var w=null;if(o.match(/^[0-9A-Fa-f]+$/));if(o.indexOf("-----BEGIN ")!=-1){w=h(o);}if(w==null){throw"certissuer param not cert"}var t=new X509();t.hex=w;var y=t.getIssuerHex();u=new l();u.hTLV=y;}if(p.certsubj!==undefined){this.type="dn";this.explicit=true;var o=p.certsubj;var w=null;if(o.match(/^[0-9A-Fa-f]+$/));if(o.indexOf("-----BEGIN ")!=-1){w=h(o);}if(w==null){throw"certsubj param not cert"}var t=new X509();t.hex=w;var y=t.getSubjectHex();u=new l();u.hTLV=y;}if(p.ip!==undefined){this.type="ip";this.explicit=false;var q=p.ip;var s;var n="malformed IP address";if(q.match(/^[0-9.]+[.][0-9.]+$/)){s=intarystrtohex("["+q.split(".").join(",")+"]");if(s.length!==8){throw n}}else{if(q.match(/^[0-9A-Fa-f:]+:[0-9A-Fa-f:]+$/)){s=ipv6tohex(q);}else{if(q.match(/^([0-9A-Fa-f][0-9A-Fa-f]){1,}$/)){s=q;}else{throw n}}}u=new j({hex:s});}if(this.type==null){throw"unsupported type in params="+p}this.asn1Obj=new c({explicit:this.explicit,tag:k[this.type],obj:u});};this.getEncodedHex=function(){return this.asn1Obj.getEncodedHex()};if(e!==undefined){this.setByParam(e);}};YAHOO.lang.extend(KJUR.asn1.x509.GeneralName,KJUR.asn1.ASN1Object);KJUR.asn1.x509.GeneralNames=function(d){KJUR.asn1.x509.GeneralNames.superclass.constructor.call(this);var c=KJUR,b=c.asn1;this.setByParamArray=function(g){for(var e=0;e<g.length;e++){var f=new b.x509.GeneralName(g[e]);this.asn1Array.push(f);}};this.getEncodedHex=function(){var e=new b.DERSequence({array:this.asn1Array});return e.getEncodedHex()};this.asn1Array=new Array();if(typeof d!="undefined"){this.setByParamArray(d);}};YAHOO.lang.extend(KJUR.asn1.x509.GeneralNames,KJUR.asn1.ASN1Object);KJUR.asn1.x509.DistributionPointName=function(b){KJUR.asn1.x509.DistributionPointName.superclass.constructor.call(this);var d=KJUR,c=d.asn1,f=c.DERTaggedObject;this.getEncodedHex=function(){if(this.type!="full"){throw"currently type shall be 'full': "+this.type}this.asn1Obj=new f({explicit:false,tag:this.tag,obj:this.asn1V});this.hTLV=this.asn1Obj.getEncodedHex();return this.hTLV};if(b!==undefined){if(c.x509.GeneralNames.prototype.isPrototypeOf(b)){this.type="full";this.tag="a0";this.asn1V=b;}else{throw"This class supports GeneralNames only as argument"}}};YAHOO.lang.extend(KJUR.asn1.x509.DistributionPointName,KJUR.asn1.ASN1Object);KJUR.asn1.x509.DistributionPoint=function(d){KJUR.asn1.x509.DistributionPoint.superclass.constructor.call(this);var c=KJUR,b=c.asn1;this.getEncodedHex=function(){var e=new b.DERSequence();if(this.asn1DP!=null){var f=new b.DERTaggedObject({explicit:true,tag:"a0",obj:this.asn1DP});e.appendASN1Object(f);}this.hTLV=e.getEncodedHex();return this.hTLV};if(d!==undefined){if(d.dpobj!==undefined){this.asn1DP=d.dpobj;}}};YAHOO.lang.extend(KJUR.asn1.x509.DistributionPoint,KJUR.asn1.ASN1Object);KJUR.asn1.x509.OID=new function(a){this.atype2oidList={CN:"2.5.4.3",L:"2.5.4.7",ST:"2.5.4.8",O:"2.5.4.10",OU:"2.5.4.11",C:"2.5.4.6",STREET:"2.5.4.9",DC:"0.9.2342.19200300.100.1.25",UID:"0.9.2342.19200300.100.1.1",SN:"2.5.4.4",T:"2.5.4.12",DN:"2.5.4.49",E:"1.2.840.113549.1.9.1",description:"2.5.4.13",businessCategory:"2.5.4.15",postalCode:"2.5.4.17",serialNumber:"2.5.4.5",uniqueIdentifier:"2.5.4.45",organizationIdentifier:"2.5.4.97",jurisdictionOfIncorporationL:"1.3.6.1.4.1.311.60.2.1.1",jurisdictionOfIncorporationSP:"1.3.6.1.4.1.311.60.2.1.2",jurisdictionOfIncorporationC:"1.3.6.1.4.1.311.60.2.1.3"};this.name2oidList={sha1:"1.3.14.3.2.26",sha256:"2.16.840.1.101.3.4.2.1",sha384:"2.16.840.1.101.3.4.2.2",sha512:"2.16.840.1.101.3.4.2.3",sha224:"2.16.840.1.101.3.4.2.4",md5:"1.2.840.113549.2.5",md2:"1.3.14.7.2.2.1",ripemd160:"1.3.36.3.2.1",MD2withRSA:"1.2.840.113549.1.1.2",MD4withRSA:"1.2.840.113549.1.1.3",MD5withRSA:"1.2.840.113549.1.1.4",SHA1withRSA:"1.2.840.113549.1.1.5",SHA224withRSA:"1.2.840.113549.1.1.14",SHA256withRSA:"1.2.840.113549.1.1.11",SHA384withRSA:"1.2.840.113549.1.1.12",SHA512withRSA:"1.2.840.113549.1.1.13",SHA1withECDSA:"1.2.840.10045.4.1",SHA224withECDSA:"1.2.840.10045.4.3.1",SHA256withECDSA:"1.2.840.10045.4.3.2",SHA384withECDSA:"1.2.840.10045.4.3.3",SHA512withECDSA:"1.2.840.10045.4.3.4",dsa:"1.2.840.10040.4.1",SHA1withDSA:"1.2.840.10040.4.3",SHA224withDSA:"2.16.840.1.101.3.4.3.1",SHA256withDSA:"2.16.840.1.101.3.4.3.2",rsaEncryption:"1.2.840.113549.1.1.1",commonName:"2.5.4.3",countryName:"2.5.4.6",localityName:"2.5.4.7",stateOrProvinceName:"2.5.4.8",streetAddress:"2.5.4.9",organizationName:"2.5.4.10",organizationalUnitName:"2.5.4.11",domainComponent:"0.9.2342.19200300.100.1.25",userId:"0.9.2342.19200300.100.1.1",surname:"2.5.4.4",title:"2.5.4.12",distinguishedName:"2.5.4.49",emailAddress:"1.2.840.113549.1.9.1",description:"2.5.4.13",businessCategory:"2.5.4.15",postalCode:"2.5.4.17",uniqueIdentifier:"2.5.4.45",organizationIdentifier:"2.5.4.97",jurisdictionOfIncorporationL:"1.3.6.1.4.1.311.60.2.1.1",jurisdictionOfIncorporationSP:"1.3.6.1.4.1.311.60.2.1.2",jurisdictionOfIncorporationC:"1.3.6.1.4.1.311.60.2.1.3",subjectKeyIdentifier:"2.5.29.14",keyUsage:"2.5.29.15",subjectAltName:"2.5.29.17",issuerAltName:"2.5.29.18",basicConstraints:"2.5.29.19",nameConstraints:"2.5.29.30",cRLDistributionPoints:"2.5.29.31",certificatePolicies:"2.5.29.32",authorityKeyIdentifier:"2.5.29.35",policyConstraints:"2.5.29.36",extKeyUsage:"2.5.29.37",authorityInfoAccess:"1.3.6.1.5.5.7.1.1",ocsp:"1.3.6.1.5.5.7.48.1",caIssuers:"1.3.6.1.5.5.7.48.2",anyExtendedKeyUsage:"2.5.29.37.0",serverAuth:"1.3.6.1.5.5.7.3.1",clientAuth:"1.3.6.1.5.5.7.3.2",codeSigning:"1.3.6.1.5.5.7.3.3",emailProtection:"1.3.6.1.5.5.7.3.4",timeStamping:"1.3.6.1.5.5.7.3.8",ocspSigning:"1.3.6.1.5.5.7.3.9",ecPublicKey:"1.2.840.10045.2.1",secp256r1:"1.2.840.10045.3.1.7",secp256k1:"1.3.132.0.10",secp384r1:"1.3.132.0.34",pkcs5PBES2:"1.2.840.113549.1.5.13",pkcs5PBKDF2:"1.2.840.113549.1.5.12","des-EDE3-CBC":"1.2.840.113549.3.7",data:"1.2.840.113549.1.7.1","signed-data":"1.2.840.113549.1.7.2","enveloped-data":"1.2.840.113549.1.7.3","digested-data":"1.2.840.113549.1.7.5","encrypted-data":"1.2.840.113549.1.7.6","authenticated-data":"1.2.840.113549.1.9.16.1.2",tstinfo:"1.2.840.113549.1.9.16.1.4",extensionRequest:"1.2.840.113549.1.9.14",};this.objCache={};this.name2obj=function(b){if(typeof this.objCache[b]!="undefined"){return this.objCache[b]}if(typeof this.name2oidList[b]=="undefined"){throw"Name of ObjectIdentifier not defined: "+b}var c=this.name2oidList[b];var d=new KJUR.asn1.DERObjectIdentifier({oid:c});this.objCache[b]=d;return d};this.atype2obj=function(b){if(typeof this.objCache[b]!="undefined"){return this.objCache[b]}if(typeof this.atype2oidList[b]=="undefined"){throw"AttributeType name undefined: "+b}var c=this.atype2oidList[b];var d=new KJUR.asn1.DERObjectIdentifier({oid:c});this.objCache[b]=d;return d};};KJUR.asn1.x509.OID.oid2name=function(b){var c=KJUR.asn1.x509.OID.name2oidList;for(var a in c){if(c[a]==b){return a}}return ""};KJUR.asn1.x509.OID.oid2atype=function(b){var c=KJUR.asn1.x509.OID.atype2oidList;for(var a in c){if(c[a]==b){return a}}return b};KJUR.asn1.x509.OID.name2oid=function(a){var b=KJUR.asn1.x509.OID.name2oidList;if(b[a]===undefined){return ""}return b[a]};KJUR.asn1.x509.X509Util={};KJUR.asn1.x509.X509Util.newCertPEM=function(h){var g=KJUR.asn1.x509,b=g.TBSCertificate,a=g.Certificate;var f=new b();if(h.serial!==undefined){f.setSerialNumberByParam(h.serial);}else{throw"serial number undefined."}if(typeof h.sigalg.name==="string"){f.setSignatureAlgByParam(h.sigalg);}else{throw"unproper signature algorithm name"}if(h.issuer!==undefined){f.setIssuerByParam(h.issuer);}else{throw"issuer name undefined."}if(h.notbefore!==undefined){f.setNotBeforeByParam(h.notbefore);}else{throw"notbefore undefined."}if(h.notafter!==undefined){f.setNotAfterByParam(h.notafter);}else{throw"notafter undefined."}if(h.subject!==undefined){f.setSubjectByParam(h.subject);}else{throw"subject name undefined."}if(h.sbjpubkey!==undefined){f.setSubjectPublicKeyByGetKey(h.sbjpubkey);}else{throw"subject public key undefined."}if(h.ext!==undefined&&h.ext.length!==undefined){for(var d=0;d<h.ext.length;d++){for(key in h.ext[d]){f.appendExtensionByName(key,h.ext[d][key]);}}}if(h.cakey===undefined&&h.sighex===undefined){throw"param cakey and sighex undefined."}var e=null;var c=null;if(h.cakey){if(h.cakey.isPrivate===true){e=h.cakey;}else{e=KEYUTIL.getKey.apply(null,h.cakey);}c=new a({tbscertobj:f,prvkeyobj:e});c.sign();}if(h.sighex){c=new a({tbscertobj:f});c.setSignatureHex(h.sighex);}return c.getPEMString()};
	if(typeof KJUR=="undefined"||!KJUR){KJUR={};}if(typeof KJUR.asn1=="undefined"||!KJUR.asn1){KJUR.asn1={};}if(typeof KJUR.asn1.cms=="undefined"||!KJUR.asn1.cms){KJUR.asn1.cms={};}KJUR.asn1.cms.Attribute=function(d){var c=KJUR,b=c.asn1;b.cms.Attribute.superclass.constructor.call(this);this.getEncodedHex=function(){var h,g,e;h=new b.DERObjectIdentifier({oid:this.attrTypeOid});g=new b.DERSet({array:this.valueList});try{g.getEncodedHex();}catch(f){throw"fail valueSet.getEncodedHex in Attribute(1)/"+f}e=new b.DERSequence({array:[h,g]});try{this.hTLV=e.getEncodedHex();}catch(f){throw"failed seq.getEncodedHex in Attribute(2)/"+f}return this.hTLV};};YAHOO.lang.extend(KJUR.asn1.cms.Attribute,KJUR.asn1.ASN1Object);KJUR.asn1.cms.ContentType=function(d){var c=KJUR,b=c.asn1;b.cms.ContentType.superclass.constructor.call(this);this.attrTypeOid="1.2.840.113549.1.9.3";var a=null;if(typeof d!="undefined"){var a=new b.DERObjectIdentifier(d);this.valueList=[a];}};YAHOO.lang.extend(KJUR.asn1.cms.ContentType,KJUR.asn1.cms.Attribute);KJUR.asn1.cms.MessageDigest=function(d){var b=KJUR,e=b.asn1,g=e.DEROctetString,i=e.cms;i.MessageDigest.superclass.constructor.call(this);this.attrTypeOid="1.2.840.113549.1.9.4";if(d!==undefined){if(d.eciObj instanceof i.EncapsulatedContentInfo&&typeof d.hashAlg==="string"){var h=d.eciObj.eContentValueHex;var c=d.hashAlg;var a=b.crypto.Util.hashHex(h,c);var f=new g({hex:a});f.getEncodedHex();this.valueList=[f];}else{var f=new g(d);f.getEncodedHex();this.valueList=[f];}}};YAHOO.lang.extend(KJUR.asn1.cms.MessageDigest,KJUR.asn1.cms.Attribute);KJUR.asn1.cms.SigningTime=function(e){var d=KJUR,c=d.asn1;c.cms.SigningTime.superclass.constructor.call(this);this.attrTypeOid="1.2.840.113549.1.9.5";if(e!==undefined){var a=new c.x509.Time(e);try{a.getEncodedHex();}catch(b){throw"SigningTime.getEncodedHex() failed/"+b}this.valueList=[a];}};YAHOO.lang.extend(KJUR.asn1.cms.SigningTime,KJUR.asn1.cms.Attribute);KJUR.asn1.cms.SigningCertificate=function(f){var c=KJUR,b=c.asn1,a=b.DERSequence,e=b.cms,d=c.crypto;e.SigningCertificate.superclass.constructor.call(this);this.attrTypeOid="1.2.840.113549.1.9.16.2.12";this.setCerts=function(n){var l=[];for(var k=0;k<n.length;k++){var h=pemtohex(n[k]);var g=c.crypto.Util.hashHex(h,"sha1");var o=new b.DEROctetString({hex:g});o.getEncodedHex();var m=new e.IssuerAndSerialNumber({cert:n[k]});m.getEncodedHex();var p=new a({array:[o,m]});p.getEncodedHex();l.push(p);}var j=new a({array:l});j.getEncodedHex();this.valueList=[j];};if(f!==undefined){if(typeof f.array=="object"){this.setCerts(f.array);}}};YAHOO.lang.extend(KJUR.asn1.cms.SigningCertificate,KJUR.asn1.cms.Attribute);KJUR.asn1.cms.SigningCertificateV2=function(h){var d=KJUR,c=d.asn1,b=c.DERSequence,g=c.x509,f=c.cms,e=d.crypto;f.SigningCertificateV2.superclass.constructor.call(this);this.attrTypeOid="1.2.840.113549.1.9.16.2.47";this.setCerts=function(r,k){var p=[];for(var n=0;n<r.length;n++){var l=pemtohex(r[n]);var t=[];if(k!=="sha256"){t.push(new g.AlgorithmIdentifier({name:k}));}var j=e.Util.hashHex(l,k);var s=new c.DEROctetString({hex:j});s.getEncodedHex();t.push(s);var o=new f.IssuerAndSerialNumber({cert:r[n]});o.getEncodedHex();t.push(o);var q=new b({array:t});q.getEncodedHex();p.push(q);}var m=new b({array:p});m.getEncodedHex();this.valueList=[m];};if(h!==undefined){if(typeof h.array=="object"){var a="sha256";if(typeof h.hashAlg=="string"){a=h.hashAlg;}this.setCerts(h.array,a);}}};YAHOO.lang.extend(KJUR.asn1.cms.SigningCertificateV2,KJUR.asn1.cms.Attribute);KJUR.asn1.cms.IssuerAndSerialNumber=function(e){var b=KJUR,g=b.asn1,f=g.DERInteger,i=g.cms,d=g.x509,a=d.X500Name,c=X509;i.IssuerAndSerialNumber.superclass.constructor.call(this);this.setByCertPEM=function(n){var l=pemtohex(n);var k=new c();k.hex=l;var o=k.getIssuerHex();this.dIssuer=new a();this.dIssuer.hTLV=o;var m=k.getSerialNumberHex();this.dSerial=new f({hex:m});};this.getEncodedHex=function(){var k=new g.DERSequence({array:[this.dIssuer,this.dSerial]});this.hTLV=k.getEncodedHex();return this.hTLV};if(e!==undefined){if(typeof e=="string"&&e.indexOf("-----BEGIN ")!=-1){this.setByCertPEM(e);}if(e.issuer&&e.serial){if(e.issuer instanceof a){this.dIssuer=e.issuer;}else{this.dIssuer=new a(e.issuer);}if(e.serial instanceof f){this.dSerial=e.serial;}else{this.dSerial=new f(e.serial);}}if(typeof e.cert=="string"){this.setByCertPEM(e.cert);}}};YAHOO.lang.extend(KJUR.asn1.cms.IssuerAndSerialNumber,KJUR.asn1.ASN1Object);KJUR.asn1.cms.AttributeList=function(d){var b=KJUR,a=b.asn1,c=a.cms;c.AttributeList.superclass.constructor.call(this);this.list=new Array();this.sortFlag=true;this.add=function(e){if(e instanceof c.Attribute){this.list.push(e);}};this.length=function(){return this.list.length};this.clear=function(){this.list=new Array();this.hTLV=null;this.hV=null;};this.getEncodedHex=function(){if(typeof this.hTLV=="string"){return this.hTLV}var e=new a.DERSet({array:this.list,sortflag:this.sortFlag});this.hTLV=e.getEncodedHex();return this.hTLV};if(d!==undefined){if(typeof d.sortflag!="undefined"&&d.sortflag==false){this.sortFlag=false;}}};YAHOO.lang.extend(KJUR.asn1.cms.AttributeList,KJUR.asn1.ASN1Object);KJUR.asn1.cms.SignerInfo=function(e){var a=KJUR,h=a.asn1,b=h.DERTaggedObject,n=h.cms,j=n.AttributeList,g=n.ContentType,k=n.EncapsulatedContentInfo,c=n.MessageDigest,l=n.SignedData,d=h.x509,m=d.AlgorithmIdentifier,f=a.crypto,i=KEYUTIL;n.SignerInfo.superclass.constructor.call(this);this.dCMSVersion=new h.DERInteger({"int":1});this.dSignerIdentifier=null;this.dDigestAlgorithm=null;this.dSignedAttrs=new j();this.dSigAlg=null;this.dSig=null;this.dUnsignedAttrs=new j();this.setSignerIdentifier=function(p){if(typeof p=="string"&&p.indexOf("CERTIFICATE")!=-1&&p.indexOf("BEGIN")!=-1&&p.indexOf("END")!=-1){this.dSignerIdentifier=new n.IssuerAndSerialNumber({cert:p});}};this.setForContentAndHash=function(o){if(o!==undefined){if(o.eciObj instanceof k){this.dSignedAttrs.add(new g({oid:"1.2.840.113549.1.7.1"}));this.dSignedAttrs.add(new c({eciObj:o.eciObj,hashAlg:o.hashAlg}));}if(o.sdObj!==undefined&&o.sdObj instanceof l){if(o.sdObj.digestAlgNameList.join(":").indexOf(o.hashAlg)==-1){o.sdObj.digestAlgNameList.push(o.hashAlg);}}if(typeof o.hashAlg=="string"){this.dDigestAlgorithm=new m({name:o.hashAlg});}}};this.sign=function(t,p){this.dSigAlg=new m({name:p});var q=this.dSignedAttrs.getEncodedHex();var o=i.getKey(t);var s=new f.Signature({alg:p});s.init(o);s.updateHex(q);var r=s.sign();this.dSig=new h.DEROctetString({hex:r});};this.addUnsigned=function(o){this.hTLV=null;this.dUnsignedAttrs.hTLV=null;this.dUnsignedAttrs.add(o);};this.getEncodedHex=function(){if(this.dSignedAttrs instanceof j&&this.dSignedAttrs.length()==0){throw"SignedAttrs length = 0 (empty)"}var o=new b({obj:this.dSignedAttrs,tag:"a0",explicit:false});var r=null;if(this.dUnsignedAttrs.length()>0){r=new b({obj:this.dUnsignedAttrs,tag:"a1",explicit:false});}var q=[this.dCMSVersion,this.dSignerIdentifier,this.dDigestAlgorithm,o,this.dSigAlg,this.dSig,];if(r!=null){q.push(r);}var p=new h.DERSequence({array:q});this.hTLV=p.getEncodedHex();return this.hTLV};};YAHOO.lang.extend(KJUR.asn1.cms.SignerInfo,KJUR.asn1.ASN1Object);KJUR.asn1.cms.EncapsulatedContentInfo=function(g){var c=KJUR,b=c.asn1,e=b.DERTaggedObject,a=b.DERSequence,h=b.DERObjectIdentifier,d=b.DEROctetString,f=b.cms;f.EncapsulatedContentInfo.superclass.constructor.call(this);this.dEContentType=new h({name:"data"});this.dEContent=null;this.isDetached=false;this.eContentValueHex=null;this.setContentType=function(i){if(i.match(/^[0-2][.][0-9.]+$/)){this.dEContentType=new h({oid:i});}else{this.dEContentType=new h({name:i});}};this.setContentValue=function(i){if(i!==undefined){if(typeof i.hex=="string"){this.eContentValueHex=i.hex;}else{if(typeof i.str=="string"){this.eContentValueHex=utf8tohex(i.str);}}}};this.setContentValueHex=function(i){this.eContentValueHex=i;};this.setContentValueStr=function(i){this.eContentValueHex=utf8tohex(i);};this.getEncodedHex=function(){if(typeof this.eContentValueHex!="string"){throw"eContentValue not yet set"}var k=new d({hex:this.eContentValueHex});this.dEContent=new e({obj:k,tag:"a0",explicit:true});var i=[this.dEContentType];if(!this.isDetached){i.push(this.dEContent);}var j=new a({array:i});this.hTLV=j.getEncodedHex();return this.hTLV};};YAHOO.lang.extend(KJUR.asn1.cms.EncapsulatedContentInfo,KJUR.asn1.ASN1Object);KJUR.asn1.cms.ContentInfo=function(f){var c=KJUR,b=c.asn1,d=b.DERTaggedObject,a=b.DERSequence,e=b.x509;KJUR.asn1.cms.ContentInfo.superclass.constructor.call(this);this.dContentType=null;this.dContent=null;this.setContentType=function(g){if(typeof g=="string"){this.dContentType=e.OID.name2obj(g);}};this.getEncodedHex=function(){var h=new d({obj:this.dContent,tag:"a0",explicit:true});var g=new a({array:[this.dContentType,h]});this.hTLV=g.getEncodedHex();return this.hTLV};if(f!==undefined){if(f.type){this.setContentType(f.type);}if(f.obj&&f.obj instanceof b.ASN1Object){this.dContent=f.obj;}}};YAHOO.lang.extend(KJUR.asn1.cms.ContentInfo,KJUR.asn1.ASN1Object);KJUR.asn1.cms.SignedData=function(e){var a=KJUR,h=a.asn1,j=h.ASN1Object,g=h.DERInteger,m=h.DERSet,f=h.DERSequence,b=h.DERTaggedObject,l=h.cms,i=l.EncapsulatedContentInfo,d=l.SignerInfo,n=l.ContentInfo,c=h.x509,k=c.AlgorithmIdentifier;KJUR.asn1.cms.SignedData.superclass.constructor.call(this);this.dCMSVersion=new g({"int":1});this.dDigestAlgs=null;this.digestAlgNameList=[];this.dEncapContentInfo=new i();this.dCerts=null;this.certificateList=[];this.crlList=[];this.signerInfoList=[new d()];this.addCertificatesByPEM=function(p){var q=pemtohex(p);var r=new j();r.hTLV=q;this.certificateList.push(r);};this.getEncodedHex=function(){if(typeof this.hTLV=="string"){return this.hTLV}if(this.dDigestAlgs==null){var u=[];for(var t=0;t<this.digestAlgNameList.length;t++){var s=this.digestAlgNameList[t];var w=new k({name:s});u.push(w);}this.dDigestAlgs=new m({array:u});}var p=[this.dCMSVersion,this.dDigestAlgs,this.dEncapContentInfo];if(this.dCerts==null){if(this.certificateList.length>0){var v=new m({array:this.certificateList});this.dCerts=new b({obj:v,tag:"a0",explicit:false});}}if(this.dCerts!=null){p.push(this.dCerts);}var r=new m({array:this.signerInfoList});p.push(r);var q=new f({array:p});this.hTLV=q.getEncodedHex();return this.hTLV};this.getContentInfo=function(){this.getEncodedHex();var o=new n({type:"signed-data",obj:this});return o};this.getContentInfoEncodedHex=function(){var o=this.getContentInfo();var p=o.getEncodedHex();return p};this.getPEM=function(){return hextopem(this.getContentInfoEncodedHex(),"CMS")};};YAHOO.lang.extend(KJUR.asn1.cms.SignedData,KJUR.asn1.ASN1Object);KJUR.asn1.cms.CMSUtil=new function(){};KJUR.asn1.cms.CMSUtil.newSignedData=function(d){var b=KJUR,j=b.asn1,q=j.cms,f=q.SignerInfo,n=q.SignedData,o=q.SigningTime,a=q.SigningCertificate,p=q.SigningCertificateV2,c=j.cades,e=c.SignaturePolicyIdentifier;var m=new n();m.dEncapContentInfo.setContentValue(d.content);if(typeof d.certs=="object"){for(var h=0;h<d.certs.length;h++){m.addCertificatesByPEM(d.certs[h]);}}m.signerInfoList=[];for(var h=0;h<d.signerInfos.length;h++){var k=d.signerInfos[h];var g=new f();g.setSignerIdentifier(k.signerCert);g.setForContentAndHash({sdObj:m,eciObj:m.dEncapContentInfo,hashAlg:k.hashAlg});for(attrName in k.sAttr){var r=k.sAttr[attrName];if(attrName=="SigningTime"){var l=new o(r);g.dSignedAttrs.add(l);}if(attrName=="SigningCertificate"){var l=new a(r);g.dSignedAttrs.add(l);}if(attrName=="SigningCertificateV2"){var l=new p(r);g.dSignedAttrs.add(l);}if(attrName=="SignaturePolicyIdentifier"){var l=new e(r);g.dSignedAttrs.add(l);}}g.sign(k.signerPrvKey,k.sigAlg);m.signerInfoList.push(g);}return m};KJUR.asn1.cms.CMSUtil.verifySignedData=function(n){var C=KJUR,p=C.asn1,s=p.cms,D=s.SignerInfo,q=s.SignedData,y=s.SigningTime,b=s.SigningCertificate,d=s.SigningCertificateV2,A=p.cades,u=A.SignaturePolicyIdentifier,i=C.lang.String.isHex,v=ASN1HEX,h=v.getVbyList,a=v.getTLVbyList,t=v.getIdxbyList,z=v.getChildIdx,c=v.getTLV,B=v.oidname,j=C.crypto.Util.hashHex;if(n.cms===undefined&&!i(n.cms));var E=n.cms;var g=function(J,H){var G;for(var I=3;I<6;I++){G=t(J,0,[1,0,I]);if(G!==undefined){var F=J.substr(G,2);if(F==="a0"){H.certsIdx=G;}if(F==="a1"){H.revinfosIdx=G;}if(F==="31"){H.signerinfosIdx=G;}}}};var l=function(I,F){var H=F.signerinfosIdx;if(H===undefined){return}var L=z(I,H);F.signerInfoIdxList=L;for(var G=0;G<L.length;G++){var K=L[G];var J={idx:K};k(I,J);F.signerInfos.push(J);}};var k=function(I,J){var F=J.idx;J.signerid_issuer1=a(I,F,[1,0],"30");J.signerid_serial1=h(I,F,[1,1],"02");J.hashalg=B(h(I,F,[2,0],"06"));var H=t(I,F,[3],"a0");J.idxSignedAttrs=H;f(I,J,H);var G=z(I,F);var K=G.length;if(K<6){throw"malformed SignerInfo"}J.sigalg=B(h(I,F,[K-2,0],"06"));J.sigval=h(I,F,[K-1],"04");};var f=function(L,M,F){var J=z(L,F);M.signedAttrIdxList=J;for(var K=0;K<J.length;K++){var I=J[K];var G=h(L,I,[0],"06");var H;if(G==="2a864886f70d010905"){H=hextoutf8(h(L,I,[1,0]));M.saSigningTime=H;}else{if(G==="2a864886f70d010904"){H=h(L,I,[1,0],"04");M.saMessageDigest=H;}}}};var w=function(G,F){if(h(G,0,[0],"06")!=="2a864886f70d010702"){return F}F.cmsType="signedData";F.econtent=h(G,0,[1,0,2,1,0]);g(G,F);F.signerInfos=[];l(G,F);};var o=function(J,F){var G=F.parse.signerInfos;var L=G.length;var K=true;for(var I=0;I<L;I++){var H=G[I];e(J,F,H);if(!H.isValid){K=false;}}F.isValid=K;};var x=function(F,Q,J,P){var N=Q.parse.certsIdx;var H;if(Q.certs===undefined){H=[];Q.certkeys=[];var K=z(F,N);for(var I=0;I<K.length;I++){var M=c(F,K[I]);var O=new X509();O.readCertHex(M);H[I]=O;Q.certkeys[I]=O.getPublicKey();}Q.certs=H;}else{H=Q.certs;}Q.cccc=H.length;Q.cccci=K.length;for(var I=0;I<H.length;I++){var L=O.getIssuerHex();var G=O.getSerialNumberHex();if(J.signerid_issuer1===L&&J.signerid_serial1===G){J.certkey_idx=I;}}};var e=function(F,R,I,N){I.verifyDetail={};var Q=I.verifyDetail;var K=R.parse.econtent;var G=I.hashalg;var L=I.saMessageDigest;Q.validMessageDigest=false;if(j(K,G)===L){Q.validMessageDigest=true;}x(F,R,I);Q.validSignatureValue=false;var H=I.sigalg;var M="31"+c(F,I.idxSignedAttrs).substr(2);I.signedattrshex=M;var J=R.certs[I.certkey_idx].getPublicKey();var P=new KJUR.crypto.Signature({alg:H});P.init(J);P.updateHex(M);var O=P.verify(I.sigval);Q.validSignatureValue_isValid=O;if(O===true){Q.validSignatureValue=true;}I.isValid=false;if(Q.validMessageDigest&&Q.validSignatureValue){I.isValid=true;}};var r={isValid:false,parse:{}};w(E,r.parse);o(E,r);return r};
	if(typeof KJUR=="undefined"||!KJUR){KJUR={};}if(typeof KJUR.asn1=="undefined"||!KJUR.asn1){KJUR.asn1={};}if(typeof KJUR.asn1.tsp=="undefined"||!KJUR.asn1.tsp){KJUR.asn1.tsp={};}KJUR.asn1.tsp.Accuracy=function(f){var c=KJUR,b=c.asn1,e=b.DERInteger,a=b.DERSequence,d=b.DERTaggedObject;b.tsp.Accuracy.superclass.constructor.call(this);this.seconds=null;this.millis=null;this.micros=null;this.getEncodedHex=function(){var i=null;var k=null;var m=null;var g=[];if(this.seconds!=null){i=new e({"int":this.seconds});g.push(i);}if(this.millis!=null){var l=new e({"int":this.millis});k=new d({obj:l,tag:"80",explicit:false});g.push(k);}if(this.micros!=null){var j=new e({"int":this.micros});m=new d({obj:j,tag:"81",explicit:false});g.push(m);}var h=new a({array:g});this.hTLV=h.getEncodedHex();return this.hTLV};if(f!==undefined){if(typeof f.seconds=="number"){this.seconds=f.seconds;}if(typeof f.millis=="number"){this.millis=f.millis;}if(typeof f.micros=="number"){this.micros=f.micros;}}};YAHOO.lang.extend(KJUR.asn1.tsp.Accuracy,KJUR.asn1.ASN1Object);KJUR.asn1.tsp.MessageImprint=function(g){var c=KJUR,b=c.asn1,a=b.DERSequence,d=b.DEROctetString,f=b.x509,e=f.AlgorithmIdentifier;b.tsp.MessageImprint.superclass.constructor.call(this);this.dHashAlg=null;this.dHashValue=null;this.getEncodedHex=function(){if(typeof this.hTLV=="string"){return this.hTLV}var h=new a({array:[this.dHashAlg,this.dHashValue]});return h.getEncodedHex()};if(g!==undefined){if(typeof g.hashAlg=="string"){this.dHashAlg=new e({name:g.hashAlg});}if(typeof g.hashValue=="string"){this.dHashValue=new d({hex:g.hashValue});}}};YAHOO.lang.extend(KJUR.asn1.tsp.MessageImprint,KJUR.asn1.ASN1Object);KJUR.asn1.tsp.TimeStampReq=function(c){var a=KJUR,f=a.asn1,d=f.DERSequence,e=f.DERInteger,g=f.DERBoolean,i=f.DERObjectIdentifier,h=f.tsp,b=h.MessageImprint;h.TimeStampReq.superclass.constructor.call(this);this.dVersion=new e({"int":1});this.dMessageImprint=null;this.dPolicy=null;this.dNonce=null;this.certReq=true;this.setMessageImprint=function(j){if(j instanceof b){this.dMessageImprint=j;return}if(typeof j=="object"){this.dMessageImprint=new b(j);}};this.getEncodedHex=function(){if(this.dMessageImprint==null){throw"messageImprint shall be specified"}var j=[this.dVersion,this.dMessageImprint];if(this.dPolicy!=null){j.push(this.dPolicy);}if(this.dNonce!=null){j.push(this.dNonce);}if(this.certReq){j.push(new g());}var k=new d({array:j});this.hTLV=k.getEncodedHex();return this.hTLV};if(c!==undefined){if(typeof c.mi=="object"){this.setMessageImprint(c.mi);}if(typeof c.policy=="object"){this.dPolicy=new i(c.policy);}if(typeof c.nonce=="object"){this.dNonce=new e(c.nonce);}if(typeof c.certreq=="boolean"){this.certReq=c.certreq;}}};YAHOO.lang.extend(KJUR.asn1.tsp.TimeStampReq,KJUR.asn1.ASN1Object);KJUR.asn1.tsp.TSTInfo=function(e){var c=KJUR,i=c.asn1,f=i.DERSequence,h=i.DERInteger,k=i.DERBoolean,g=i.DERGeneralizedTime,l=i.DERObjectIdentifier,j=i.tsp,d=j.MessageImprint,b=j.Accuracy,a=i.x509.X500Name;j.TSTInfo.superclass.constructor.call(this);this.dVersion=new h({"int":1});this.dPolicy=null;this.dMessageImprint=null;this.dSerialNumber=null;this.dGenTime=null;this.dAccuracy=null;this.dOrdering=null;this.dNonce=null;this.dTsa=null;this.getEncodedHex=function(){var m=[this.dVersion];if(this.dPolicy==null){throw"policy shall be specified."}m.push(this.dPolicy);if(this.dMessageImprint==null){throw"messageImprint shall be specified."}m.push(this.dMessageImprint);if(this.dSerialNumber==null){throw"serialNumber shall be specified."}m.push(this.dSerialNumber);if(this.dGenTime==null){throw"genTime shall be specified."}m.push(this.dGenTime);if(this.dAccuracy!=null){m.push(this.dAccuracy);}if(this.dOrdering!=null){m.push(this.dOrdering);}if(this.dNonce!=null){m.push(this.dNonce);}if(this.dTsa!=null){m.push(this.dTsa);}var n=new f({array:m});this.hTLV=n.getEncodedHex();return this.hTLV};if(e!==undefined){if(typeof e.policy=="string"){if(!e.policy.match(/^[0-9.]+$/)){throw"policy shall be oid like 0.1.4.134"}this.dPolicy=new l({oid:e.policy});}if(e.messageImprint!==undefined){this.dMessageImprint=new d(e.messageImprint);}if(e.serialNumber!==undefined){this.dSerialNumber=new h(e.serialNumber);}if(e.genTime!==undefined){this.dGenTime=new g(e.genTime);}if(e.accuracy!==undefined){this.dAccuracy=new b(e.accuracy);}if(e.ordering!==undefined&&e.ordering==true){this.dOrdering=new k();}if(e.nonce!==undefined){this.dNonce=new h(e.nonce);}if(e.tsa!==undefined){this.dTsa=new a(e.tsa);}}};YAHOO.lang.extend(KJUR.asn1.tsp.TSTInfo,KJUR.asn1.ASN1Object);KJUR.asn1.tsp.TimeStampResp=function(g){var e=KJUR,d=e.asn1,c=d.DERSequence,f=d.ASN1Object,a=d.tsp,b=a.PKIStatusInfo;a.TimeStampResp.superclass.constructor.call(this);this.dStatus=null;this.dTST=null;this.getEncodedHex=function(){if(this.dStatus==null){throw"status shall be specified"}var h=[this.dStatus];if(this.dTST!=null){h.push(this.dTST);}var i=new c({array:h});this.hTLV=i.getEncodedHex();return this.hTLV};if(g!==undefined){if(typeof g.status=="object"){this.dStatus=new b(g.status);}if(g.tst!==undefined&&g.tst instanceof f){this.dTST=g.tst.getContentInfo();}}};YAHOO.lang.extend(KJUR.asn1.tsp.TimeStampResp,KJUR.asn1.ASN1Object);KJUR.asn1.tsp.PKIStatusInfo=function(h){var g=KJUR,f=g.asn1,e=f.DERSequence,a=f.tsp,d=a.PKIStatus,c=a.PKIFreeText,b=a.PKIFailureInfo;a.PKIStatusInfo.superclass.constructor.call(this);this.dStatus=null;this.dStatusString=null;this.dFailureInfo=null;this.getEncodedHex=function(){if(this.dStatus==null){throw"status shall be specified"}var i=[this.dStatus];if(this.dStatusString!=null){i.push(this.dStatusString);}if(this.dFailureInfo!=null){i.push(this.dFailureInfo);}var j=new e({array:i});this.hTLV=j.getEncodedHex();return this.hTLV};if(h!==undefined){if(typeof h.status=="object"){this.dStatus=new d(h.status);}if(typeof h.statstr=="object"){this.dStatusString=new c({array:h.statstr});}if(typeof h.failinfo=="object"){this.dFailureInfo=new b(h.failinfo);}}};YAHOO.lang.extend(KJUR.asn1.tsp.PKIStatusInfo,KJUR.asn1.ASN1Object);KJUR.asn1.tsp.PKIStatus=function(h){var d=KJUR,c=d.asn1,g=c.DERInteger,a=c.tsp,b=a.PKIStatus;a.PKIStatus.superclass.constructor.call(this);this.getEncodedHex=function(){this.hTLV=this.dStatus.getEncodedHex();return this.hTLV};if(h!==undefined){if(h.name!==undefined){var e=b.valueList;if(e[h.name]===undefined){throw"name undefined: "+h.name}this.dStatus=new g({"int":e[h.name]});}else{this.dStatus=new g(h);}}};YAHOO.lang.extend(KJUR.asn1.tsp.PKIStatus,KJUR.asn1.ASN1Object);KJUR.asn1.tsp.PKIStatus.valueList={granted:0,grantedWithMods:1,rejection:2,waiting:3,revocationWarning:4,revocationNotification:5};KJUR.asn1.tsp.PKIFreeText=function(f){var e=KJUR,d=e.asn1,b=d.DERSequence,c=d.DERUTF8String,a=d.tsp;a.PKIFreeText.superclass.constructor.call(this);this.textList=[];this.getEncodedHex=function(){var g=[];for(var j=0;j<this.textList.length;j++){g.push(new c({str:this.textList[j]}));}var h=new b({array:g});this.hTLV=h.getEncodedHex();return this.hTLV};if(f!==undefined){if(typeof f.array=="object"){this.textList=f.array;}}};YAHOO.lang.extend(KJUR.asn1.tsp.PKIFreeText,KJUR.asn1.ASN1Object);KJUR.asn1.tsp.PKIFailureInfo=function(g){var d=KJUR,c=d.asn1,f=c.DERBitString,a=c.tsp,b=a.PKIFailureInfo;b.superclass.constructor.call(this);this.value=null;this.getEncodedHex=function(){if(this.value==null){throw"value shall be specified"}var h=new Number(this.value).toString(2);var i=new f();i.setByBinaryString(h);this.hTLV=i.getEncodedHex();return this.hTLV};if(g!==undefined){if(typeof g.name=="string"){var e=b.valueList;if(e[g.name]===undefined){throw"name undefined: "+g.name}this.value=e[g.name];}else{if(typeof g["int"]=="number"){this.value=g["int"];}}}};YAHOO.lang.extend(KJUR.asn1.tsp.PKIFailureInfo,KJUR.asn1.ASN1Object);KJUR.asn1.tsp.PKIFailureInfo.valueList={badAlg:0,badRequest:2,badDataFormat:5,timeNotAvailable:14,unacceptedPolicy:15,unacceptedExtension:16,addInfoNotAvailable:17,systemFailure:25};KJUR.asn1.tsp.AbstractTSAAdapter=function(a){this.getTSTHex=function(c,b){throw"not implemented yet"};};KJUR.asn1.tsp.SimpleTSAAdapter=function(e){var d=KJUR,c=d.asn1,a=c.tsp,b=d.crypto.Util.hashHex;a.SimpleTSAAdapter.superclass.constructor.call(this);this.params=null;this.serial=0;this.getTSTHex=function(g,f){var i=b(g,f);this.params.tstInfo.messageImprint={hashAlg:f,hashValue:i};this.params.tstInfo.serialNumber={"int":this.serial++};var h=Math.floor(Math.random()*1000000000);this.params.tstInfo.nonce={"int":h};var j=a.TSPUtil.newTimeStampToken(this.params);return j.getContentInfoEncodedHex()};if(e!==undefined){this.params=e;}};YAHOO.lang.extend(KJUR.asn1.tsp.SimpleTSAAdapter,KJUR.asn1.tsp.AbstractTSAAdapter);KJUR.asn1.tsp.FixedTSAAdapter=function(e){var d=KJUR,c=d.asn1,a=c.tsp,b=d.crypto.Util.hashHex;a.FixedTSAAdapter.superclass.constructor.call(this);this.params=null;this.getTSTHex=function(g,f){var h=b(g,f);this.params.tstInfo.messageImprint={hashAlg:f,hashValue:h};var i=a.TSPUtil.newTimeStampToken(this.params);return i.getContentInfoEncodedHex()};if(e!==undefined){this.params=e;}};YAHOO.lang.extend(KJUR.asn1.tsp.FixedTSAAdapter,KJUR.asn1.tsp.AbstractTSAAdapter);KJUR.asn1.tsp.TSPUtil=new function(){};KJUR.asn1.tsp.TSPUtil.newTimeStampToken=function(c){var b=KJUR,h=b.asn1,m=h.cms,k=h.tsp,a=h.tsp.TSTInfo;var j=new m.SignedData();var g=new a(c.tstInfo);var f=g.getEncodedHex();j.dEncapContentInfo.setContentValue({hex:f});j.dEncapContentInfo.setContentType("tstinfo");if(typeof c.certs=="object"){for(var e=0;e<c.certs.length;e++){j.addCertificatesByPEM(c.certs[e]);}}var d=j.signerInfoList[0];d.setSignerIdentifier(c.signerCert);d.setForContentAndHash({sdObj:j,eciObj:j.dEncapContentInfo,hashAlg:c.hashAlg});var l=new m.SigningCertificate({array:[c.signerCert]});d.dSignedAttrs.add(l);d.sign(c.signerPrvKey,c.sigAlg);return j};KJUR.asn1.tsp.TSPUtil.parseTimeStampReq=function(m){var l=ASN1HEX;var h=l.getChildIdx;var f=l.getV;var b=l.getTLV;var j={};j.certreq=false;var a=h(m,0);if(a.length<2){throw"TimeStampReq must have at least 2 items"}var e=b(m,a[1]);j.mi=KJUR.asn1.tsp.TSPUtil.parseMessageImprint(e);for(var d=2;d<a.length;d++){var g=a[d];var k=m.substr(g,2);if(k=="06"){var c=f(m,g);j.policy=l.hextooidstr(c);}if(k=="02"){j.nonce=f(m,g);}if(k=="01"){j.certreq=true;}}return j};KJUR.asn1.tsp.TSPUtil.parseMessageImprint=function(c){var m=ASN1HEX;var j=m.getChildIdx;var i=m.getV;var g=m.getIdxbyList;var k={};if(c.substr(0,2)!="30"){throw"head of messageImprint hex shall be '30'"}var a=j(c,0);var l=g(c,0,[0,0]);var e=i(c,l);var d=m.hextooidstr(e);var h=KJUR.asn1.x509.OID.oid2name(d);if(h==""){throw"hashAlg name undefined: "+d}var b=h;var f=g(c,0,[1]);k.hashAlg=b;k.hashValue=i(c,f);return k};
	if(typeof KJUR=="undefined"||!KJUR){KJUR={};}if(typeof KJUR.asn1=="undefined"||!KJUR.asn1){KJUR.asn1={};}if(typeof KJUR.asn1.cades=="undefined"||!KJUR.asn1.cades){KJUR.asn1.cades={};}KJUR.asn1.cades.SignaturePolicyIdentifier=function(f){var b=KJUR,h=b.asn1,i=h.DERObjectIdentifier,g=h.DERSequence,e=h.cades,c=e.OtherHashAlgAndValue;e.SignaturePolicyIdentifier.superclass.constructor.call(this);this.attrTypeOid="1.2.840.113549.1.9.16.2.15";if(f!==undefined){if(typeof f.oid=="string"&&typeof f.hash=="object"){var d=new i({oid:f.oid});var a=new c(f.hash);var j=new g({array:[d,a]});this.valueList=[j];}}};YAHOO.lang.extend(KJUR.asn1.cades.SignaturePolicyIdentifier,KJUR.asn1.cms.Attribute);KJUR.asn1.cades.OtherHashAlgAndValue=function(e){var a=KJUR,g=a.asn1,f=g.DERSequence,h=g.DEROctetString,d=g.x509,i=d.AlgorithmIdentifier,c=g.cades,b=c.OtherHashAlgAndValue;b.superclass.constructor.call(this);this.dAlg=null;this.dHash=null;this.getEncodedHex=function(){var j=new f({array:[this.dAlg,this.dHash]});this.hTLV=j.getEncodedHex();return this.hTLV};if(e!==undefined){if(typeof e.alg=="string"&&typeof e.hash=="string"){this.dAlg=new i({name:e.alg});this.dHash=new h({hex:e.hash});}}};YAHOO.lang.extend(KJUR.asn1.cades.OtherHashAlgAndValue,KJUR.asn1.ASN1Object);KJUR.asn1.cades.SignatureTimeStamp=function(h){var c=KJUR,b=c.asn1,e=b.ASN1Object,g=b.x509,a=b.cades;a.SignatureTimeStamp.superclass.constructor.call(this);this.attrTypeOid="1.2.840.113549.1.9.16.2.14";this.tstHex=null;if(h!==undefined){if(h.res!==undefined){if(typeof h.res=="string"&&h.res.match(/^[0-9A-Fa-f]+$/));else{if(h.res instanceof e);else{throw"res param shall be ASN1Object or hex string"}}}if(h.tst!==undefined){if(typeof h.tst=="string"&&h.tst.match(/^[0-9A-Fa-f]+$/)){var f=new e();this.tstHex=h.tst;f.hTLV=this.tstHex;f.getEncodedHex();this.valueList=[f];}else{if(h.tst instanceof e);else{throw"tst param shall be ASN1Object or hex string"}}}}};YAHOO.lang.extend(KJUR.asn1.cades.SignatureTimeStamp,KJUR.asn1.cms.Attribute);KJUR.asn1.cades.CompleteCertificateRefs=function(d){var c=KJUR,b=c.asn1,a=b.cades;a.CompleteCertificateRefs.superclass.constructor.call(this);this.attrTypeOid="1.2.840.113549.1.9.16.2.21";this.setByArray=function(e){this.valueList=[];for(var f=0;f<e.length;f++){var g=new a.OtherCertID(e[f]);this.valueList.push(g);}};if(d!==undefined){if(typeof d=="object"&&typeof d.length=="number"){this.setByArray(d);}}};YAHOO.lang.extend(KJUR.asn1.cades.CompleteCertificateRefs,KJUR.asn1.cms.Attribute);KJUR.asn1.cades.OtherCertID=function(e){var c=KJUR,b=c.asn1,d=b.cms,a=b.cades;a.OtherCertID.superclass.constructor.call(this);this.hasIssuerSerial=true;this.dOtherCertHash=null;this.dIssuerSerial=null;this.setByCertPEM=function(f){this.dOtherCertHash=new a.OtherHash(f);if(this.hasIssuerSerial){this.dIssuerSerial=new d.IssuerAndSerialNumber(f);}};this.getEncodedHex=function(){if(this.hTLV!=null){return this.hTLV}if(this.dOtherCertHash==null){throw"otherCertHash not set"}var f=[this.dOtherCertHash];if(this.dIssuerSerial!=null){f.push(this.dIssuerSerial);}var g=new b.DERSequence({array:f});this.hTLV=g.getEncodedHex();return this.hTLV};if(e!==undefined){if(typeof e=="string"&&e.indexOf("-----BEGIN ")!=-1){this.setByCertPEM(e);}if(typeof e=="object"){if(e.hasis===false){this.hasIssuerSerial=false;}if(typeof e.cert=="string"){this.setByCertPEM(e.cert);}}}};YAHOO.lang.extend(KJUR.asn1.cades.OtherCertID,KJUR.asn1.ASN1Object);KJUR.asn1.cades.OtherHash=function(f){var d=KJUR,c=d.asn1,e=c.cms,b=c.cades,g=b.OtherHashAlgAndValue,a=d.crypto.Util.hashHex;b.OtherHash.superclass.constructor.call(this);this.alg="sha256";this.dOtherHash=null;this.setByCertPEM=function(h){if(h.indexOf("-----BEGIN ")==-1){throw"certPEM not to seem PEM format"}var i=pemtohex(h);var j=a(i,this.alg);this.dOtherHash=new g({alg:this.alg,hash:j});};this.getEncodedHex=function(){if(this.dOtherHash==null){throw"OtherHash not set"}return this.dOtherHash.getEncodedHex()};if(f!==undefined){if(typeof f=="string"){if(f.indexOf("-----BEGIN ")!=-1){this.setByCertPEM(f);}else{if(f.match(/^[0-9A-Fa-f]+$/)){this.dOtherHash=new c.DEROctetString({hex:f});}else{throw"unsupported string value for params"}}}else{if(typeof f=="object"){if(typeof f.cert=="string"){if(typeof f.alg=="string"){this.alg=f.alg;}this.setByCertPEM(f.cert);}else{this.dOtherHash=new g(f);}}}}};YAHOO.lang.extend(KJUR.asn1.cades.OtherHash,KJUR.asn1.ASN1Object);KJUR.asn1.cades.CAdESUtil=new function(){};KJUR.asn1.cades.CAdESUtil.addSigTS=function(c,b,a){};KJUR.asn1.cades.CAdESUtil.parseSignedDataForAddingUnsigned=function(e){var p=ASN1HEX,u=p.getChildIdx,b=p.getTLV,a=p.getTLVbyList,k=p.getIdxbyList,A=KJUR,g=A.asn1,l=g.ASN1Object,j=g.cms,h=j.SignedData,v=g.cades,z=v.CAdESUtil;var m={};if(a(e,0,[0])!="06092a864886f70d010702"){throw"hex is not CMS SignedData"}var y=k(e,0,[1,0]);var B=u(e,y);if(B.length<4){throw"num of SignedData elem shall be 4 at least"}var d=B.shift();m.version=b(e,d);var w=B.shift();m.algs=b(e,w);var c=B.shift();m.encapcontent=b(e,c);m.certs=null;m.revs=null;m.si=[];var o=B.shift();if(e.substr(o,2)=="a0"){m.certs=b(e,o);o=B.shift();}if(e.substr(o,2)=="a1"){m.revs=b(e,o);o=B.shift();}var t=o;if(e.substr(t,2)!="31"){throw"Can't find signerInfos"}var f=u(e,t);for(var q=0;q<f.length;q++){var s=f[q];var n=z.parseSignerInfoForAddingUnsigned(e,s,q);m.si[q]=n;}var x=null;m.obj=new h();x=new l();x.hTLV=m.version;m.obj.dCMSVersion=x;x=new l();x.hTLV=m.algs;m.obj.dDigestAlgs=x;x=new l();x.hTLV=m.encapcontent;m.obj.dEncapContentInfo=x;x=new l();x.hTLV=m.certs;m.obj.dCerts=x;m.obj.signerInfoList=[];for(var q=0;q<m.si.length;q++){m.obj.signerInfoList.push(m.si[q].obj);}return m};KJUR.asn1.cades.CAdESUtil.parseSignerInfoForAddingUnsigned=function(g,q,c){var p=ASN1HEX,s=p.getChildIdx,a=p.getTLV,l=p.getV,v=KJUR,h=v.asn1,n=h.ASN1Object,j=h.cms,k=j.AttributeList,w=j.SignerInfo;var o={};var t=s(g,q);if(t.length!=6){throw"not supported items for SignerInfo (!=6)"}var d=t.shift();o.version=a(g,d);var e=t.shift();o.si=a(g,e);var m=t.shift();o.digalg=a(g,m);var f=t.shift();o.sattrs=a(g,f);var i=t.shift();o.sigalg=a(g,i);var b=t.shift();o.sig=a(g,b);o.sigval=l(g,b);var u=null;o.obj=new w();u=new n();u.hTLV=o.version;o.obj.dCMSVersion=u;u=new n();u.hTLV=o.si;o.obj.dSignerIdentifier=u;u=new n();u.hTLV=o.digalg;o.obj.dDigestAlgorithm=u;u=new n();u.hTLV=o.sattrs;o.obj.dSignedAttrs=u;u=new n();u.hTLV=o.sigalg;o.obj.dSigAlg=u;u=new n();u.hTLV=o.sig;o.obj.dSig=u;o.obj.dUnsignedAttrs=new k();return o};
	if(typeof KJUR.asn1.csr=="undefined"||!KJUR.asn1.csr){KJUR.asn1.csr={};}KJUR.asn1.csr.CertificationRequest=function(d){var a=KJUR,f=a.asn1,b=f.DERBitString,e=f.DERSequence,k=f.csr,c=f.x509;k.CertificationRequest.superclass.constructor.call(this);this.sign=function(o,n){if(this.prvKey==null){this.prvKey=n;}this.asn1SignatureAlg=new c.AlgorithmIdentifier({name:o});sig=new a.crypto.Signature({alg:o});sig.init(this.prvKey);sig.updateHex(this.asn1CSRInfo.getEncodedHex());this.hexSig=sig.sign();this.asn1Sig=new b({hex:"00"+this.hexSig});var m=new e({array:[this.asn1CSRInfo,this.asn1SignatureAlg,this.asn1Sig]});this.hTLV=m.getEncodedHex();this.isModified=false;};this.getPEMString=function(){return hextopem(this.getEncodedHex(),"CERTIFICATE REQUEST")};this.getEncodedHex=function(){if(this.isModified==false&&this.hTLV!=null){return this.hTLV}throw"not signed yet"};if(d!==undefined&&d.csrinfo!==undefined){this.asn1CSRInfo=d.csrinfo;}};YAHOO.lang.extend(KJUR.asn1.csr.CertificationRequest,KJUR.asn1.ASN1Object);KJUR.asn1.csr.CertificationRequestInfo=function(e){var b=KJUR,h=b.asn1,g=h.DERInteger,f=h.DERSequence,m=h.DERSet,j=h.DERNull,c=h.DERTaggedObject,k=h.DERObjectIdentifier,l=h.csr,d=h.x509,a=d.X500Name,n=d.Extension,i=KEYUTIL;l.CertificationRequestInfo.superclass.constructor.call(this);this._initialize=function(){this.asn1Array=new Array();this.asn1Version=new g({"int":0});this.asn1Subject=null;this.asn1SubjPKey=null;this.extensionsArray=new Array();};this.setSubjectByParam=function(o){this.asn1Subject=new a(o);};this.setSubjectPublicKeyByGetKey=function(p){var o=i.getKey(p);this.asn1SubjPKey=new d.SubjectPublicKeyInfo(o);};this.appendExtensionByName=function(p,o){n.appendByNameToArray(p,o,this.extensionsArray);};this.getEncodedHex=function(){this.asn1Array=new Array();this.asn1Array.push(this.asn1Version);this.asn1Array.push(this.asn1Subject);this.asn1Array.push(this.asn1SubjPKey);if(this.extensionsArray.length>0){var s=new f({array:this.extensionsArray});var r=new m({array:[s]});var q=new f({array:[new k({oid:"1.2.840.113549.1.9.14"}),r]});var p=new c({explicit:true,tag:"a0",obj:q});this.asn1Array.push(p);}else{var p=new c({explicit:false,tag:"a0",obj:new j()});this.asn1Array.push(p);}var t=new f({array:this.asn1Array});this.hTLV=t.getEncodedHex();this.isModified=false;return this.hTLV};this._initialize();};YAHOO.lang.extend(KJUR.asn1.csr.CertificationRequestInfo,KJUR.asn1.ASN1Object);KJUR.asn1.csr.CSRUtil=new function(){};KJUR.asn1.csr.CSRUtil.newCSRPEM=function(h){var c=KEYUTIL,b=KJUR.asn1.csr;if(h.subject===undefined){throw"parameter subject undefined"}if(h.sbjpubkey===undefined){throw"parameter sbjpubkey undefined"}if(h.sigalg===undefined){throw"parameter sigalg undefined"}if(h.sbjprvkey===undefined){throw"parameter sbjpubkey undefined"}var d=new b.CertificationRequestInfo();d.setSubjectByParam(h.subject);d.setSubjectPublicKeyByGetKey(h.sbjpubkey);if(h.ext!==undefined&&h.ext.length!==undefined){for(var e=0;e<h.ext.length;e++){for(key in h.ext[e]){d.appendExtensionByName(key,h.ext[e][key]);}}}var f=new b.CertificationRequest({csrinfo:d});var a=c.getKey(h.sbjprvkey);f.sign(h.sigalg,a);var g=f.getPEMString();return g};KJUR.asn1.csr.CSRUtil.getInfo=function(b){var d=ASN1HEX;var e=d.getTLVbyList;var a={};a.subject={};a.pubkey={};if(b.indexOf("-----BEGIN CERTIFICATE REQUEST")==-1){throw"argument is not PEM file"}var c=pemtohex(b,"CERTIFICATE REQUEST");a.subject.hex=e(c,0,[0,1]);a.subject.name=X509.hex2dn(a.subject.hex);a.pubkey.hex=e(c,0,[0,2]);a.pubkey.obj=KEYUTIL.getKey(a.pubkey.hex,null,"pkcs8pub");return a};
	if(typeof KJUR=="undefined"||!KJUR){KJUR={};}if(typeof KJUR.asn1=="undefined"||!KJUR.asn1){KJUR.asn1={};}if(typeof KJUR.asn1.ocsp=="undefined"||!KJUR.asn1.ocsp){KJUR.asn1.ocsp={};}KJUR.asn1.ocsp.DEFAULT_HASH="sha1";KJUR.asn1.ocsp.CertID=function(g){var d=KJUR,k=d.asn1,m=k.DEROctetString,j=k.DERInteger,h=k.DERSequence,f=k.x509,n=f.AlgorithmIdentifier,o=k.ocsp,l=o.DEFAULT_HASH,i=d.crypto,e=i.Util.hashHex,c=X509,q=ASN1HEX;o.CertID.superclass.constructor.call(this);this.dHashAlg=null;this.dIssuerNameHash=null;this.dIssuerKeyHash=null;this.dSerialNumber=null;this.setByValue=function(t,s,p,r){if(r===undefined){r=l;}this.dHashAlg=new n({name:r});this.dIssuerNameHash=new m({hex:t});this.dIssuerKeyHash=new m({hex:s});this.dSerialNumber=new j({hex:p});};this.setByCert=function(x,t,v){if(v===undefined){v=l;}var p=new c();p.readCertPEM(t);var y=new c();y.readCertPEM(x);var z=y.getPublicKeyHex();var w=q.getTLVbyList(z,0,[1,0],"30");var r=p.getSerialNumberHex();var s=e(y.getSubjectHex(),v);var u=e(w,v);this.setByValue(s,u,r,v);this.hoge=p.getSerialNumberHex();};this.getEncodedHex=function(){if(this.dHashAlg===null&&this.dIssuerNameHash===null&&this.dIssuerKeyHash===null&&this.dSerialNumber===null){throw"not yet set values"}var p=[this.dHashAlg,this.dIssuerNameHash,this.dIssuerKeyHash,this.dSerialNumber];var r=new h({array:p});this.hTLV=r.getEncodedHex();return this.hTLV};if(g!==undefined){var b=g;if(b.issuerCert!==undefined&&b.subjectCert!==undefined){var a=l;if(b.alg===undefined){a=undefined;}this.setByCert(b.issuerCert,b.subjectCert,a);}else{if(b.namehash!==undefined&&b.keyhash!==undefined&&b.serial!==undefined){var a=l;if(b.alg===undefined){a=undefined;}this.setByValue(b.namehash,b.keyhash,b.serial,a);}else{throw"invalid constructor arguments"}}}};YAHOO.lang.extend(KJUR.asn1.ocsp.CertID,KJUR.asn1.ASN1Object);KJUR.asn1.ocsp.Request=function(f){var c=KJUR,b=c.asn1,a=b.DERSequence,d=b.ocsp;d.Request.superclass.constructor.call(this);this.dReqCert=null;this.dExt=null;this.getEncodedHex=function(){var g=[];if(this.dReqCert===null){throw"reqCert not set"}g.push(this.dReqCert);var h=new a({array:g});this.hTLV=h.getEncodedHex();return this.hTLV};if(typeof f!=="undefined"){var e=new d.CertID(f);this.dReqCert=e;}};YAHOO.lang.extend(KJUR.asn1.ocsp.Request,KJUR.asn1.ASN1Object);KJUR.asn1.ocsp.TBSRequest=function(e){var c=KJUR,b=c.asn1,a=b.DERSequence,d=b.ocsp;d.TBSRequest.superclass.constructor.call(this);this.version=0;this.dRequestorName=null;this.dRequestList=[];this.dRequestExt=null;this.setRequestListByParam=function(h){var f=[];for(var g=0;g<h.length;g++){var j=new d.Request(h[0]);f.push(j);}this.dRequestList=f;};this.getEncodedHex=function(){var f=[];if(this.version!==0){throw"not supported version: "+this.version}if(this.dRequestorName!==null){throw"requestorName not supported"}var h=new a({array:this.dRequestList});f.push(h);if(this.dRequestExt!==null){throw"requestExtensions not supported"}var g=new a({array:f});this.hTLV=g.getEncodedHex();return this.hTLV};if(e!==undefined){if(e.reqList!==undefined){this.setRequestListByParam(e.reqList);}}};YAHOO.lang.extend(KJUR.asn1.ocsp.TBSRequest,KJUR.asn1.ASN1Object);KJUR.asn1.ocsp.OCSPRequest=function(f){var c=KJUR,b=c.asn1,a=b.DERSequence,d=b.ocsp;d.OCSPRequest.superclass.constructor.call(this);this.dTbsRequest=null;this.dOptionalSignature=null;this.getEncodedHex=function(){var g=[];if(this.dTbsRequest!==null){g.push(this.dTbsRequest);}else{throw"tbsRequest not set"}if(this.dOptionalSignature!==null){throw"optionalSignature not supported"}var h=new a({array:g});this.hTLV=h.getEncodedHex();return this.hTLV};if(f!==undefined){if(f.reqList!==undefined){var e=new d.TBSRequest(f);this.dTbsRequest=e;}}};YAHOO.lang.extend(KJUR.asn1.ocsp.OCSPRequest,KJUR.asn1.ASN1Object);KJUR.asn1.ocsp.OCSPUtil={};KJUR.asn1.ocsp.OCSPUtil.getRequestHex=function(a,b,h){var d=KJUR,c=d.asn1,e=c.ocsp;if(h===undefined){h=e.DEFAULT_HASH;}var g={alg:h,issuerCert:a,subjectCert:b};var f=new e.OCSPRequest({reqList:[g]});return f.getEncodedHex()};KJUR.asn1.ocsp.OCSPUtil.getOCSPResponseInfo=function(b){var k=ASN1HEX;var c=k.getVbyList;var d=k.getIdxbyList;var c=k.getVbyList;var f=k.getV;var l={};try{var i=c(b,0,[0],"0a");l.responseStatus=parseInt(i,16);}catch(e){}if(l.responseStatus!==0){return l}try{var g=d(b,0,[1,0,1,0,0,2,0,1]);if(b.substr(g,2)==="80"){l.certStatus="good";}else{if(b.substr(g,2)==="a1"){l.certStatus="revoked";l.revocationTime=hextoutf8(c(b,g,[0]));}else{if(b.substr(g,2)==="82"){l.certStatus="unknown";}}}}catch(e){}try{var a=d(b,0,[1,0,1,0,0,2,0,2]);l.thisUpdate=hextoutf8(f(b,a));}catch(e){}try{var j=d(b,0,[1,0,1,0,0,2,0,3]);if(b.substr(j,2)==="a0"){l.nextUpdate=hextoutf8(c(b,j,[0]));}}catch(e){}return l};
	var KJUR;if(typeof KJUR=="undefined"||!KJUR){KJUR={};}if(typeof KJUR.lang=="undefined"||!KJUR.lang){KJUR.lang={};}KJUR.lang.String=function(){};function stoBA(d){var b=new Array();for(var c=0;c<d.length;c++){b[c]=d.charCodeAt(c);}return b}function BAtohex(b){var e="";for(var d=0;d<b.length;d++){var c=b[d].toString(16);if(c.length==1){c="0"+c;}e=e+c;}return e}function stohex(a){return BAtohex(stoBA(a))}function b64tob64u(a){a=a.replace(/\=/g,"");a=a.replace(/\+/g,"-");a=a.replace(/\//g,"_");return a}function b64utob64(a){if(a.length%4==2){a=a+"==";}else{if(a.length%4==3){a=a+"=";}}a=a.replace(/-/g,"+");a=a.replace(/_/g,"/");return a}function hextob64u(a){if(a.length%2==1){a="0"+a;}return b64tob64u(hex2b64(a))}function b64utohex(a){return b64tohex(b64utob64(a))}var utf8tob64u,b64utoutf8;if(typeof Buffer==="function"){utf8tob64u=function(a){return b64tob64u(new Buffer(a,"utf8").toString("base64"))};b64utoutf8=function(a){return new Buffer(b64utob64(a),"base64").toString("utf8")};}else{utf8tob64u=function(a){return hextob64u(uricmptohex(encodeURIComponentAll(a)))};b64utoutf8=function(a){return decodeURIComponent(hextouricmp(b64utohex(a)))};}function utf8tohex(a){return uricmptohex(encodeURIComponentAll(a))}function hextoutf8(a){return decodeURIComponent(hextouricmp(a))}function hextorstr(c){var b="";for(var a=0;a<c.length-1;a+=2){b+=String.fromCharCode(parseInt(c.substr(a,2),16));}return b}function rstrtohex(c){var a="";for(var b=0;b<c.length;b++){a+=("0"+c.charCodeAt(b).toString(16)).slice(-2);}return a}function hextob64(a){return hex2b64(a)}function hextob64nl(b){var a=hextob64(b);var c=a.replace(/(.{64})/g,"$1\r\n");c=c.replace(/\r\n$/,"");return c}function b64nltohex(b){var a=b.replace(/[^0-9A-Za-z\/+=]*/g,"");var c=b64tohex(a);return c}function hextopem(a,b){var c=hextob64nl(a);return "-----BEGIN "+b+"-----\r\n"+c+"\r\n-----END "+b+"-----\r\n"}function pemtohex(a,b){if(a.indexOf("-----BEGIN ")==-1){throw"can't find PEM header: "+b}if(b!==undefined){a=a.replace("-----BEGIN "+b+"-----","");a=a.replace("-----END "+b+"-----","");}else{a=a.replace(/-----BEGIN [^-]+-----/,"");a=a.replace(/-----END [^-]+-----/,"");}return b64nltohex(a)}function zulutomsec(n){var l,j,m,e,f,i,b;var a,h,g,c;c=n.match(/^(\d{2}|\d{4})(\d\d)(\d\d)(\d\d)(\d\d)(\d\d)(|\.\d+)Z$/);if(c){a=c[1];l=parseInt(a);if(a.length===2){if(50<=l&&l<100){l=1900+l;}else{if(0<=l&&l<50){l=2000+l;}}}j=parseInt(c[2])-1;m=parseInt(c[3]);e=parseInt(c[4]);f=parseInt(c[5]);i=parseInt(c[6]);b=0;h=c[7];if(h!==""){g=(h.substr(1)+"00").substr(0,3);b=parseInt(g);}return Date.UTC(l,j,m,e,f,i,b)}throw"unsupported zulu format: "+n}function zulutosec(a){var b=zulutomsec(a);return ~~(b/1000)}function uricmptohex(a){return a.replace(/%/g,"")}function hextouricmp(a){return a.replace(/(..)/g,"%$1")}function ipv6tohex(g){var b="malformed IPv6 address";if(!g.match(/^[0-9A-Fa-f:]+$/)){throw b}g=g.toLowerCase();var d=g.split(":").length-1;if(d<2){throw b}var e=":".repeat(7-d+2);g=g.replace("::",e);var c=g.split(":");if(c.length!=8){throw b}for(var f=0;f<8;f++){c[f]=("0000"+c[f]).slice(-4);}return c.join("")}function hextoipv6(e){if(!e.match(/^[0-9A-Fa-f]{32}$/)){throw"malformed IPv6 address octet"}e=e.toLowerCase();var b=e.match(/.{1,4}/g);for(var d=0;d<8;d++){b[d]=b[d].replace(/^0+/,"");if(b[d]==""){b[d]="0";}}e=":"+b.join(":")+":";var c=e.match(/:(0:){2,}/g);if(c===null){return e.slice(1,-1)}var f="";for(var d=0;d<c.length;d++){if(c[d].length>f.length){f=c[d];}}e=e.replace(f,"::");return e.slice(1,-1)}function hextoip(b){var d="malformed hex value";if(!b.match(/^([0-9A-Fa-f][0-9A-Fa-f]){1,}$/)){throw d}if(b.length==8){var c;try{c=parseInt(b.substr(0,2),16)+"."+parseInt(b.substr(2,2),16)+"."+parseInt(b.substr(4,2),16)+"."+parseInt(b.substr(6,2),16);return c}catch(a){throw d}}else{if(b.length==32){return hextoipv6(b)}else{return b}}}function encodeURIComponentAll(a){var d=encodeURIComponent(a);var b="";for(var c=0;c<d.length;c++){if(d[c]=="%"){b=b+d.substr(c,3);c=c+2;}else{b=b+"%"+stohex(d[c]);}}return b}KJUR.lang.String.isInteger=function(a){if(a.match(/^[0-9]+$/)){return true}else{if(a.match(/^-[0-9]+$/)){return true}else{return false}}};KJUR.lang.String.isHex=function(a){if(a.length%2==0&&(a.match(/^[0-9a-f]+$/)||a.match(/^[0-9A-F]+$/))){return true}else{return false}};KJUR.lang.String.isBase64=function(a){a=a.replace(/\s+/g,"");if(a.match(/^[0-9A-Za-z+\/]+={0,3}$/)&&a.length%4==0){return true}else{return false}};KJUR.lang.String.isBase64URL=function(a){if(a.match(/[+/=]/)){return false}a=b64utob64(a);return KJUR.lang.String.isBase64(a)};KJUR.lang.String.isIntegerArray=function(a){a=a.replace(/\s+/g,"");if(a.match(/^\[[0-9,]+\]$/)){return true}else{return false}};function hextoposhex(a){if(a.length%2==1){return "0"+a}if(a.substr(0,1)>"7"){return "00"+a}return a}function intarystrtohex(b){b=b.replace(/^\s*\[\s*/,"");b=b.replace(/\s*\]\s*$/,"");b=b.replace(/\s*/g,"");try{var c=b.split(/,/).map(function(g,e,h){var f=parseInt(g);if(f<0||255<f){throw"integer not in range 0-255"}var d=("00"+f.toString(16)).slice(-2);return d}).join("");return c}catch(a){throw"malformed integer array string: "+a}}if(typeof KJUR=="undefined"||!KJUR){KJUR={};}if(typeof KJUR.crypto=="undefined"||!KJUR.crypto){KJUR.crypto={};}KJUR.crypto.Util=new function(){this.DIGESTINFOHEAD={sha1:"3021300906052b0e03021a05000414",sha224:"302d300d06096086480165030402040500041c",sha256:"3031300d060960864801650304020105000420",sha384:"3041300d060960864801650304020205000430",sha512:"3051300d060960864801650304020305000440",md2:"3020300c06082a864886f70d020205000410",md5:"3020300c06082a864886f70d020505000410",ripemd160:"3021300906052b2403020105000414",};this.DEFAULTPROVIDER={md5:"cryptojs",sha1:"cryptojs",sha224:"cryptojs",sha256:"cryptojs",sha384:"cryptojs",sha512:"cryptojs",ripemd160:"cryptojs",hmacmd5:"cryptojs",hmacsha1:"cryptojs",hmacsha224:"cryptojs",hmacsha256:"cryptojs",hmacsha384:"cryptojs",hmacsha512:"cryptojs",hmacripemd160:"cryptojs",MD5withRSA:"cryptojs/jsrsa",SHA1withRSA:"cryptojs/jsrsa",SHA224withRSA:"cryptojs/jsrsa",SHA256withRSA:"cryptojs/jsrsa",SHA384withRSA:"cryptojs/jsrsa",SHA512withRSA:"cryptojs/jsrsa",RIPEMD160withRSA:"cryptojs/jsrsa",MD5withECDSA:"cryptojs/jsrsa",SHA1withECDSA:"cryptojs/jsrsa",SHA224withECDSA:"cryptojs/jsrsa",SHA256withECDSA:"cryptojs/jsrsa",SHA384withECDSA:"cryptojs/jsrsa",SHA512withECDSA:"cryptojs/jsrsa",RIPEMD160withECDSA:"cryptojs/jsrsa",SHA1withDSA:"cryptojs/jsrsa",SHA224withDSA:"cryptojs/jsrsa",SHA256withDSA:"cryptojs/jsrsa",MD5withRSAandMGF1:"cryptojs/jsrsa",SHA1withRSAandMGF1:"cryptojs/jsrsa",SHA224withRSAandMGF1:"cryptojs/jsrsa",SHA256withRSAandMGF1:"cryptojs/jsrsa",SHA384withRSAandMGF1:"cryptojs/jsrsa",SHA512withRSAandMGF1:"cryptojs/jsrsa",RIPEMD160withRSAandMGF1:"cryptojs/jsrsa",};this.CRYPTOJSMESSAGEDIGESTNAME={md5:CryptoJS.algo.MD5,sha1:CryptoJS.algo.SHA1,sha224:CryptoJS.algo.SHA224,sha256:CryptoJS.algo.SHA256,sha384:CryptoJS.algo.SHA384,sha512:CryptoJS.algo.SHA512,ripemd160:CryptoJS.algo.RIPEMD160};this.getDigestInfoHex=function(a,b){if(typeof this.DIGESTINFOHEAD[b]=="undefined"){throw"alg not supported in Util.DIGESTINFOHEAD: "+b}return this.DIGESTINFOHEAD[b]+a};this.getPaddedDigestInfoHex=function(h,a,j){var c=this.getDigestInfoHex(h,a);var d=j/4;if(c.length+22>d){throw"key is too short for SigAlg: keylen="+j+","+a}var b="0001";var k="00"+c;var g="";var l=d-b.length-k.length;for(var f=0;f<l;f+=2){g+="ff";}var e=b+g+k;return e};this.hashString=function(a,c){var b=new KJUR.crypto.MessageDigest({alg:c});return b.digestString(a)};this.hashHex=function(b,c){var a=new KJUR.crypto.MessageDigest({alg:c});return a.digestHex(b)};this.sha1=function(a){var b=new KJUR.crypto.MessageDigest({alg:"sha1",prov:"cryptojs"});return b.digestString(a)};this.sha256=function(a){var b=new KJUR.crypto.MessageDigest({alg:"sha256",prov:"cryptojs"});return b.digestString(a)};this.sha256Hex=function(a){var b=new KJUR.crypto.MessageDigest({alg:"sha256",prov:"cryptojs"});return b.digestHex(a)};this.sha512=function(a){var b=new KJUR.crypto.MessageDigest({alg:"sha512",prov:"cryptojs"});return b.digestString(a)};this.sha512Hex=function(a){var b=new KJUR.crypto.MessageDigest({alg:"sha512",prov:"cryptojs"});return b.digestHex(a)};};KJUR.crypto.Util.md5=function(a){var b=new KJUR.crypto.MessageDigest({alg:"md5",prov:"cryptojs"});return b.digestString(a)};KJUR.crypto.Util.ripemd160=function(a){var b=new KJUR.crypto.MessageDigest({alg:"ripemd160",prov:"cryptojs"});return b.digestString(a)};KJUR.crypto.Util.SECURERANDOMGEN=new SecureRandom();KJUR.crypto.Util.getRandomHexOfNbytes=function(b){var a=new Array(b);KJUR.crypto.Util.SECURERANDOMGEN.nextBytes(a);return BAtohex(a)};KJUR.crypto.Util.getRandomBigIntegerOfNbytes=function(a){return new BigInteger(KJUR.crypto.Util.getRandomHexOfNbytes(a),16)};KJUR.crypto.Util.getRandomHexOfNbits=function(d){var c=d%8;var a=(d-c)/8;var b=new Array(a+1);KJUR.crypto.Util.SECURERANDOMGEN.nextBytes(b);b[0]=(((255<<c)&255)^255)&b[0];return BAtohex(b)};KJUR.crypto.Util.getRandomBigIntegerOfNbits=function(a){return new BigInteger(KJUR.crypto.Util.getRandomHexOfNbits(a),16)};KJUR.crypto.Util.getRandomBigIntegerZeroToMax=function(b){var a=b.bitLength();while(1){var c=KJUR.crypto.Util.getRandomBigIntegerOfNbits(a);if(b.compareTo(c)!=-1){return c}}};KJUR.crypto.Util.getRandomBigIntegerMinToMax=function(e,b){var c=e.compareTo(b);if(c==1){throw"biMin is greater than biMax"}if(c==0){return e}var a=b.subtract(e);var d=KJUR.crypto.Util.getRandomBigIntegerZeroToMax(a);return d.add(e)};KJUR.crypto.MessageDigest=function(c){this.setAlgAndProvider=function(g,f){g=KJUR.crypto.MessageDigest.getCanonicalAlgName(g);if(g!==null&&f===undefined){f=KJUR.crypto.Util.DEFAULTPROVIDER[g];}if(":md5:sha1:sha224:sha256:sha384:sha512:ripemd160:".indexOf(g)!=-1&&f=="cryptojs"){try{this.md=KJUR.crypto.Util.CRYPTOJSMESSAGEDIGESTNAME[g].create();}catch(e){throw"setAlgAndProvider hash alg set fail alg="+g+"/"+e}this.updateString=function(h){this.md.update(h);};this.updateHex=function(h){var i=CryptoJS.enc.Hex.parse(h);this.md.update(i);};this.digest=function(){var h=this.md.finalize();return h.toString(CryptoJS.enc.Hex)};this.digestString=function(h){this.updateString(h);return this.digest()};this.digestHex=function(h){this.updateHex(h);return this.digest()};}if(":sha256:".indexOf(g)!=-1&&f=="sjcl"){try{this.md=new sjcl.hash.sha256();}catch(e){throw"setAlgAndProvider hash alg set fail alg="+g+"/"+e}this.updateString=function(h){this.md.update(h);};this.updateHex=function(i){var h=sjcl.codec.hex.toBits(i);this.md.update(h);};this.digest=function(){var h=this.md.finalize();return sjcl.codec.hex.fromBits(h)};this.digestString=function(h){this.updateString(h);return this.digest()};this.digestHex=function(h){this.updateHex(h);return this.digest()};}};this.updateString=function(e){throw"updateString(str) not supported for this alg/prov: "+this.algName+"/"+this.provName};this.updateHex=function(e){throw"updateHex(hex) not supported for this alg/prov: "+this.algName+"/"+this.provName};this.digest=function(){throw"digest() not supported for this alg/prov: "+this.algName+"/"+this.provName};this.digestString=function(e){throw"digestString(str) not supported for this alg/prov: "+this.algName+"/"+this.provName};this.digestHex=function(e){throw"digestHex(hex) not supported for this alg/prov: "+this.algName+"/"+this.provName};if(c!==undefined){if(c.alg!==undefined){this.algName=c.alg;if(c.prov===undefined){this.provName=KJUR.crypto.Util.DEFAULTPROVIDER[this.algName];}this.setAlgAndProvider(this.algName,this.provName);}}};KJUR.crypto.MessageDigest.getCanonicalAlgName=function(a){if(typeof a==="string"){a=a.toLowerCase();a=a.replace(/-/,"");}return a};KJUR.crypto.MessageDigest.getHashLength=function(c){var b=KJUR.crypto.MessageDigest;var a=b.getCanonicalAlgName(c);if(b.HASHLENGTH[a]===undefined){throw"not supported algorithm: "+c}return b.HASHLENGTH[a]};KJUR.crypto.MessageDigest.HASHLENGTH={md5:16,sha1:20,sha224:28,sha256:32,sha384:48,sha512:64,ripemd160:20};KJUR.crypto.Mac=function(d){this.setAlgAndProvider=function(k,i){k=k.toLowerCase();if(k==null){k="hmacsha1";}k=k.toLowerCase();if(k.substr(0,4)!="hmac"){throw"setAlgAndProvider unsupported HMAC alg: "+k}if(i===undefined){i=KJUR.crypto.Util.DEFAULTPROVIDER[k];}this.algProv=k+"/"+i;var g=k.substr(4);if(":md5:sha1:sha224:sha256:sha384:sha512:ripemd160:".indexOf(g)!=-1&&i=="cryptojs"){try{var j=KJUR.crypto.Util.CRYPTOJSMESSAGEDIGESTNAME[g];this.mac=CryptoJS.algo.HMAC.create(j,this.pass);}catch(h){throw"setAlgAndProvider hash alg set fail hashAlg="+g+"/"+h}this.updateString=function(l){this.mac.update(l);};this.updateHex=function(l){var m=CryptoJS.enc.Hex.parse(l);this.mac.update(m);};this.doFinal=function(){var l=this.mac.finalize();return l.toString(CryptoJS.enc.Hex)};this.doFinalString=function(l){this.updateString(l);return this.doFinal()};this.doFinalHex=function(l){this.updateHex(l);return this.doFinal()};}};this.updateString=function(g){throw"updateString(str) not supported for this alg/prov: "+this.algProv};this.updateHex=function(g){throw"updateHex(hex) not supported for this alg/prov: "+this.algProv};this.doFinal=function(){throw"digest() not supported for this alg/prov: "+this.algProv};this.doFinalString=function(g){throw"digestString(str) not supported for this alg/prov: "+this.algProv};this.doFinalHex=function(g){throw"digestHex(hex) not supported for this alg/prov: "+this.algProv};this.setPassword=function(h){if(typeof h=="string"){var g=h;if(h.length%2==1||!h.match(/^[0-9A-Fa-f]+$/)){g=rstrtohex(h);}this.pass=CryptoJS.enc.Hex.parse(g);return}if(typeof h!="object"){throw"KJUR.crypto.Mac unsupported password type: "+h}var g=null;if(h.hex!==undefined){if(h.hex.length%2!=0||!h.hex.match(/^[0-9A-Fa-f]+$/)){throw"Mac: wrong hex password: "+h.hex}g=h.hex;}if(h.utf8!==undefined){g=utf8tohex(h.utf8);}if(h.rstr!==undefined){g=rstrtohex(h.rstr);}if(h.b64!==undefined){g=b64tohex(h.b64);}if(h.b64u!==undefined){g=b64utohex(h.b64u);}if(g==null){throw"KJUR.crypto.Mac unsupported password type: "+h}this.pass=CryptoJS.enc.Hex.parse(g);};if(d!==undefined){if(d.pass!==undefined){this.setPassword(d.pass);}if(d.alg!==undefined){this.algName=d.alg;if(d.prov===undefined){this.provName=KJUR.crypto.Util.DEFAULTPROVIDER[this.algName];}this.setAlgAndProvider(this.algName,this.provName);}}};KJUR.crypto.Signature=function(o){var q=null;this._setAlgNames=function(){var s=this.algName.match(/^(.+)with(.+)$/);if(s){this.mdAlgName=s[1].toLowerCase();this.pubkeyAlgName=s[2].toLowerCase();}};this._zeroPaddingOfSignature=function(x,w){var v="";var t=w/4-x.length;for(var u=0;u<t;u++){v=v+"0";}return v+x};this.setAlgAndProvider=function(u,t){this._setAlgNames();if(t!="cryptojs/jsrsa"){throw"provider not supported: "+t}if(":md5:sha1:sha224:sha256:sha384:sha512:ripemd160:".indexOf(this.mdAlgName)!=-1){try{this.md=new KJUR.crypto.MessageDigest({alg:this.mdAlgName});}catch(s){throw"setAlgAndProvider hash alg set fail alg="+this.mdAlgName+"/"+s}this.init=function(w,x){var y=null;try{if(x===undefined){y=KEYUTIL.getKey(w);}else{y=KEYUTIL.getKey(w,x);}}catch(v){throw"init failed:"+v}if(y.isPrivate===true){this.prvKey=y;this.state="SIGN";}else{if(y.isPublic===true){this.pubKey=y;this.state="VERIFY";}else{throw"init failed.:"+y}}};this.updateString=function(v){this.md.updateString(v);};this.updateHex=function(v){this.md.updateHex(v);};this.sign=function(){this.sHashHex=this.md.digest();if(typeof this.ecprvhex!="undefined"&&typeof this.eccurvename!="undefined"){var v=new KJUR.crypto.ECDSA({curve:this.eccurvename});this.hSign=v.signHex(this.sHashHex,this.ecprvhex);}else{if(this.prvKey instanceof RSAKey&&this.pubkeyAlgName==="rsaandmgf1"){this.hSign=this.prvKey.signWithMessageHashPSS(this.sHashHex,this.mdAlgName,this.pssSaltLen);}else{if(this.prvKey instanceof RSAKey&&this.pubkeyAlgName==="rsa"){this.hSign=this.prvKey.signWithMessageHash(this.sHashHex,this.mdAlgName);}else{if(this.prvKey instanceof KJUR.crypto.ECDSA){this.hSign=this.prvKey.signWithMessageHash(this.sHashHex);}else{if(this.prvKey instanceof KJUR.crypto.DSA){this.hSign=this.prvKey.signWithMessageHash(this.sHashHex);}else{throw"Signature: unsupported private key alg: "+this.pubkeyAlgName}}}}}return this.hSign};this.signString=function(v){this.updateString(v);return this.sign()};this.signHex=function(v){this.updateHex(v);return this.sign()};this.verify=function(v){this.sHashHex=this.md.digest();if(typeof this.ecpubhex!="undefined"&&typeof this.eccurvename!="undefined"){var w=new KJUR.crypto.ECDSA({curve:this.eccurvename});return w.verifyHex(this.sHashHex,v,this.ecpubhex)}else{if(this.pubKey instanceof RSAKey&&this.pubkeyAlgName==="rsaandmgf1"){return this.pubKey.verifyWithMessageHashPSS(this.sHashHex,v,this.mdAlgName,this.pssSaltLen)}else{if(this.pubKey instanceof RSAKey&&this.pubkeyAlgName==="rsa"){return this.pubKey.verifyWithMessageHash(this.sHashHex,v)}else{if(KJUR.crypto.ECDSA!==undefined&&this.pubKey instanceof KJUR.crypto.ECDSA){return this.pubKey.verifyWithMessageHash(this.sHashHex,v)}else{if(KJUR.crypto.DSA!==undefined&&this.pubKey instanceof KJUR.crypto.DSA){return this.pubKey.verifyWithMessageHash(this.sHashHex,v)}else{throw"Signature: unsupported public key alg: "+this.pubkeyAlgName}}}}}};}};this.init=function(s,t){throw"init(key, pass) not supported for this alg:prov="+this.algProvName};this.updateString=function(s){throw"updateString(str) not supported for this alg:prov="+this.algProvName};this.updateHex=function(s){throw"updateHex(hex) not supported for this alg:prov="+this.algProvName};this.sign=function(){throw"sign() not supported for this alg:prov="+this.algProvName};this.signString=function(s){throw"digestString(str) not supported for this alg:prov="+this.algProvName};this.signHex=function(s){throw"digestHex(hex) not supported for this alg:prov="+this.algProvName};this.verify=function(s){throw"verify(hSigVal) not supported for this alg:prov="+this.algProvName};this.initParams=o;if(o!==undefined){if(o.alg!==undefined){this.algName=o.alg;if(o.prov===undefined){this.provName=KJUR.crypto.Util.DEFAULTPROVIDER[this.algName];}else{this.provName=o.prov;}this.algProvName=this.algName+":"+this.provName;this.setAlgAndProvider(this.algName,this.provName);this._setAlgNames();}if(o.psssaltlen!==undefined){this.pssSaltLen=o.psssaltlen;}if(o.prvkeypem!==undefined){if(o.prvkeypas!==undefined){throw"both prvkeypem and prvkeypas parameters not supported"}else{try{var q=KEYUTIL.getKey(o.prvkeypem);this.init(q);}catch(m){throw"fatal error to load pem private key: "+m}}}}};KJUR.crypto.Cipher=function(a){};KJUR.crypto.Cipher.encrypt=function(e,f,d){if(f instanceof RSAKey&&f.isPublic){var c=KJUR.crypto.Cipher.getAlgByKeyAndName(f,d);if(c==="RSA"){return f.encrypt(e)}if(c==="RSAOAEP"){return f.encryptOAEP(e,"sha1")}var b=c.match(/^RSAOAEP(\d+)$/);if(b!==null){return f.encryptOAEP(e,"sha"+b[1])}throw"Cipher.encrypt: unsupported algorithm for RSAKey: "+d}else{throw"Cipher.encrypt: unsupported key or algorithm"}};KJUR.crypto.Cipher.decrypt=function(e,f,d){if(f instanceof RSAKey&&f.isPrivate){var c=KJUR.crypto.Cipher.getAlgByKeyAndName(f,d);if(c==="RSA"){return f.decrypt(e)}if(c==="RSAOAEP"){return f.decryptOAEP(e,"sha1")}var b=c.match(/^RSAOAEP(\d+)$/);if(b!==null){return f.decryptOAEP(e,"sha"+b[1])}throw"Cipher.decrypt: unsupported algorithm for RSAKey: "+d}else{throw"Cipher.decrypt: unsupported key or algorithm"}};KJUR.crypto.Cipher.getAlgByKeyAndName=function(b,a){if(b instanceof RSAKey){if(":RSA:RSAOAEP:RSAOAEP224:RSAOAEP256:RSAOAEP384:RSAOAEP512:".indexOf(a)!=-1){return a}if(a===null||a===undefined){return "RSA"}throw"getAlgByKeyAndName: not supported algorithm name for RSAKey: "+a}throw"getAlgByKeyAndName: not supported algorithm name: "+a};KJUR.crypto.OID=new function(){this.oidhex2name={"2a864886f70d010101":"rsaEncryption","2a8648ce3d0201":"ecPublicKey","2a8648ce380401":"dsa","2a8648ce3d030107":"secp256r1","2b8104001f":"secp192k1","2b81040021":"secp224r1","2b8104000a":"secp256k1","2b81040023":"secp521r1","2b81040022":"secp384r1","2a8648ce380403":"SHA1withDSA","608648016503040301":"SHA224withDSA","608648016503040302":"SHA256withDSA",};};
	if(typeof KJUR=="undefined"||!KJUR){KJUR={};}if(typeof KJUR.crypto=="undefined"||!KJUR.crypto){KJUR.crypto={};}KJUR.crypto.ECDSA=function(h){var e="secp256r1";var a=new SecureRandom();this.type="EC";this.isPrivate=false;this.isPublic=false;this.getBigRandom=function(i){return new BigInteger(i.bitLength(),a).mod(i.subtract(BigInteger.ONE)).add(BigInteger.ONE)};this.setNamedCurve=function(i){this.ecparams=KJUR.crypto.ECParameterDB.getByName(i);this.prvKeyHex=null;this.pubKeyHex=null;this.curveName=i;};this.setPrivateKeyHex=function(i){this.isPrivate=true;this.prvKeyHex=i;};this.setPublicKeyHex=function(i){this.isPublic=true;this.pubKeyHex=i;};this.getPublicKeyXYHex=function(){var k=this.pubKeyHex;if(k.substr(0,2)!=="04"){throw"this method supports uncompressed format(04) only"}var j=this.ecparams.keylen/4;if(k.length!==2+j*2){throw"malformed public key hex length"}var i={};i.x=k.substr(2,j);i.y=k.substr(2+j);return i};this.getShortNISTPCurveName=function(){var i=this.curveName;if(i==="secp256r1"||i==="NIST P-256"||i==="P-256"||i==="prime256v1"){return "P-256"}if(i==="secp384r1"||i==="NIST P-384"||i==="P-384"){return "P-384"}return null};this.generateKeyPairHex=function(){var k=this.ecparams.n;var n=this.getBigRandom(k);var l=this.ecparams.G.multiply(n);var q=l.getX().toBigInteger();var o=l.getY().toBigInteger();var i=this.ecparams.keylen/4;var m=("0000000000"+n.toString(16)).slice(-i);var r=("0000000000"+q.toString(16)).slice(-i);var p=("0000000000"+o.toString(16)).slice(-i);var j="04"+r+p;this.setPrivateKeyHex(m);this.setPublicKeyHex(j);return {ecprvhex:m,ecpubhex:j}};this.signWithMessageHash=function(i){return this.signHex(i,this.prvKeyHex)};this.signHex=function(o,j){var t=new BigInteger(j,16);var l=this.ecparams.n;var q=new BigInteger(o,16);do{var m=this.getBigRandom(l);var u=this.ecparams.G;var p=u.multiply(m);var i=p.getX().toBigInteger().mod(l);}while(i.compareTo(BigInteger.ZERO)<=0);var v=m.modInverse(l).multiply(q.add(t.multiply(i))).mod(l);return KJUR.crypto.ECDSA.biRSSigToASN1Sig(i,v)};this.sign=function(m,u){var q=u;var j=this.ecparams.n;var p=BigInteger.fromByteArrayUnsigned(m);do{var l=this.getBigRandom(j);var t=this.ecparams.G;var o=t.multiply(l);var i=o.getX().toBigInteger().mod(j);}while(i.compareTo(BigInteger.ZERO)<=0);var v=l.modInverse(j).multiply(p.add(q.multiply(i))).mod(j);return this.serializeSig(i,v)};this.verifyWithMessageHash=function(j,i){return this.verifyHex(j,i,this.pubKeyHex)};this.verifyHex=function(m,i,p){var l,j;var o=KJUR.crypto.ECDSA.parseSigHex(i);l=o.r;j=o.s;var k;k=ECPointFp.decodeFromHex(this.ecparams.curve,p);var n=new BigInteger(m,16);return this.verifyRaw(n,l,j,k)};this.verify=function(o,p,j){var l,i;if(Bitcoin.Util.isArray(p)){var n=this.parseSig(p);l=n.r;i=n.s;}else{if("object"===typeof p&&p.r&&p.s){l=p.r;i=p.s;}else{throw"Invalid value for signature"}}var k;if(j instanceof ECPointFp){k=j;}else{if(Bitcoin.Util.isArray(j)){k=ECPointFp.decodeFrom(this.ecparams.curve,j);}else{throw"Invalid format for pubkey value, must be byte array or ECPointFp"}}var m=BigInteger.fromByteArrayUnsigned(o);return this.verifyRaw(m,l,i,k)};this.verifyRaw=function(o,i,w,m){var l=this.ecparams.n;var u=this.ecparams.G;if(i.compareTo(BigInteger.ONE)<0||i.compareTo(l)>=0){return false}if(w.compareTo(BigInteger.ONE)<0||w.compareTo(l)>=0){return false}var p=w.modInverse(l);var k=o.multiply(p).mod(l);var j=i.multiply(p).mod(l);var q=u.multiply(k).add(m.multiply(j));var t=q.getX().toBigInteger().mod(l);return t.equals(i)};this.serializeSig=function(k,j){var l=k.toByteArraySigned();var i=j.toByteArraySigned();var m=[];m.push(2);m.push(l.length);m=m.concat(l);m.push(2);m.push(i.length);m=m.concat(i);m.unshift(m.length);m.unshift(48);return m};this.parseSig=function(n){var m;if(n[0]!=48){throw new Error("Signature not a valid DERSequence")}m=2;if(n[m]!=2){throw new Error("First element in signature must be a DERInteger")}var l=n.slice(m+2,m+2+n[m+1]);m+=2+n[m+1];if(n[m]!=2){throw new Error("Second element in signature must be a DERInteger")}var i=n.slice(m+2,m+2+n[m+1]);m+=2+n[m+1];var k=BigInteger.fromByteArrayUnsigned(l);var j=BigInteger.fromByteArrayUnsigned(i);return {r:k,s:j}};this.parseSigCompact=function(m){if(m.length!==65){throw"Signature has the wrong length"}var j=m[0]-27;if(j<0||j>7){throw"Invalid signature type"}var o=this.ecparams.n;var l=BigInteger.fromByteArrayUnsigned(m.slice(1,33)).mod(o);var k=BigInteger.fromByteArrayUnsigned(m.slice(33,65)).mod(o);return {r:l,s:k,i:j}};this.readPKCS5PrvKeyHex=function(l){var n=ASN1HEX;var m=KJUR.crypto.ECDSA.getName;var p=n.getVbyList;if(n.isASN1HEX(l)===false){throw"not ASN.1 hex string"}var i,k,o;try{i=p(l,0,[2,0],"06");k=p(l,0,[1],"04");try{o=p(l,0,[3,0],"03").substr(2);}catch(j){}}catch(j){throw"malformed PKCS#1/5 plain ECC private key"}this.curveName=m(i);if(this.curveName===undefined){throw"unsupported curve name"}this.setNamedCurve(this.curveName);this.setPublicKeyHex(o);this.setPrivateKeyHex(k);this.isPublic=false;};this.readPKCS8PrvKeyHex=function(l){var q=ASN1HEX;var i=KJUR.crypto.ECDSA.getName;var n=q.getVbyList;if(q.isASN1HEX(l)===false){throw"not ASN.1 hex string"}var j,p,m,k;try{j=n(l,0,[1,0],"06");p=n(l,0,[1,1],"06");m=n(l,0,[2,0,1],"04");try{k=n(l,0,[2,0,2,0],"03").substr(2);}catch(o){}}catch(o){throw"malformed PKCS#8 plain ECC private key"}this.curveName=i(p);if(this.curveName===undefined){throw"unsupported curve name"}this.setNamedCurve(this.curveName);this.setPublicKeyHex(k);this.setPrivateKeyHex(m);this.isPublic=false;};this.readPKCS8PubKeyHex=function(l){var n=ASN1HEX;var m=KJUR.crypto.ECDSA.getName;var p=n.getVbyList;if(n.isASN1HEX(l)===false){throw"not ASN.1 hex string"}var k,i,o;try{k=p(l,0,[0,0],"06");i=p(l,0,[0,1],"06");o=p(l,0,[1],"03").substr(2);}catch(j){throw"malformed PKCS#8 ECC public key"}this.curveName=m(i);if(this.curveName===null){throw"unsupported curve name"}this.setNamedCurve(this.curveName);this.setPublicKeyHex(o);};this.readCertPubKeyHex=function(k,p){if(p!==5){p=6;}var m=ASN1HEX;var l=KJUR.crypto.ECDSA.getName;var o=m.getVbyList;if(m.isASN1HEX(k)===false){throw"not ASN.1 hex string"}var i,n;try{i=o(k,0,[0,p,0,1],"06");n=o(k,0,[0,p,1],"03").substr(2);}catch(j){throw"malformed X.509 certificate ECC public key"}this.curveName=l(i);if(this.curveName===null){throw"unsupported curve name"}this.setNamedCurve(this.curveName);this.setPublicKeyHex(n);};if(h!==undefined){if(h.curve!==undefined){this.curveName=h.curve;}}if(this.curveName===undefined){this.curveName=e;}this.setNamedCurve(this.curveName);if(h!==undefined){if(h.prv!==undefined){this.setPrivateKeyHex(h.prv);}if(h.pub!==undefined){this.setPublicKeyHex(h.pub);}}};KJUR.crypto.ECDSA.parseSigHex=function(a){var b=KJUR.crypto.ECDSA.parseSigHexInHexRS(a);var d=new BigInteger(b.r,16);var c=new BigInteger(b.s,16);return {r:d,s:c}};KJUR.crypto.ECDSA.parseSigHexInHexRS=function(f){var j=ASN1HEX;var i=j.getChildIdx;var g=j.getV;if(f.substr(0,2)!="30"){throw"signature is not a ASN.1 sequence"}var h=i(f,0);if(h.length!=2){throw"number of signature ASN.1 sequence elements seem wrong"}var e=h[0];var d=h[1];if(f.substr(e,2)!="02"){throw"1st item of sequene of signature is not ASN.1 integer"}if(f.substr(d,2)!="02"){throw"2nd item of sequene of signature is not ASN.1 integer"}var c=g(f,e);var b=g(f,d);return {r:c,s:b}};KJUR.crypto.ECDSA.asn1SigToConcatSig=function(c){var d=KJUR.crypto.ECDSA.parseSigHexInHexRS(c);var b=d.r;var a=d.s;if(b.substr(0,2)=="00"&&(b.length%32)==2){b=b.substr(2);}if(a.substr(0,2)=="00"&&(a.length%32)==2){a=a.substr(2);}if((b.length%32)==30){b="00"+b;}if((a.length%32)==30){a="00"+a;}if(b.length%32!=0){throw"unknown ECDSA sig r length error"}if(a.length%32!=0){throw"unknown ECDSA sig s length error"}return b+a};KJUR.crypto.ECDSA.concatSigToASN1Sig=function(a){if((((a.length/2)*8)%(16*8))!=0){throw"unknown ECDSA concatinated r-s sig  length error"}var c=a.substr(0,a.length/2);var b=a.substr(a.length/2);return KJUR.crypto.ECDSA.hexRSSigToASN1Sig(c,b)};KJUR.crypto.ECDSA.hexRSSigToASN1Sig=function(b,a){var d=new BigInteger(b,16);var c=new BigInteger(a,16);return KJUR.crypto.ECDSA.biRSSigToASN1Sig(d,c)};KJUR.crypto.ECDSA.biRSSigToASN1Sig=function(f,d){var c=KJUR.asn1;var b=new c.DERInteger({bigint:f});var a=new c.DERInteger({bigint:d});var e=new c.DERSequence({array:[b,a]});return e.getEncodedHex()};KJUR.crypto.ECDSA.getName=function(a){if(a==="2a8648ce3d030107"){return "secp256r1"}if(a==="2b8104000a"){return "secp256k1"}if(a==="2b81040022"){return "secp384r1"}if("|secp256r1|NIST P-256|P-256|prime256v1|".indexOf(a)!==-1){return "secp256r1"}if("|secp256k1|".indexOf(a)!==-1){return "secp256k1"}if("|secp384r1|NIST P-384|P-384|".indexOf(a)!==-1){return "secp384r1"}return null};
	if(typeof KJUR=="undefined"||!KJUR){KJUR={};}if(typeof KJUR.crypto=="undefined"||!KJUR.crypto){KJUR.crypto={};}KJUR.crypto.ECParameterDB=new function(){var b={};var c={};function a(d){return new BigInteger(d,16)}this.getByName=function(e){var d=e;if(typeof c[d]!="undefined"){d=c[e];}if(typeof b[d]!="undefined"){return b[d]}throw"unregistered EC curve name: "+d};this.regist=function(A,l,o,g,m,e,j,f,k,u,d,x){b[A]={};var s=a(o);var z=a(g);var y=a(m);var t=a(e);var w=a(j);var r=new ECCurveFp(s,z,y);var q=r.decodePointHex("04"+f+k);b[A]["name"]=A;b[A]["keylen"]=l;b[A]["curve"]=r;b[A]["G"]=q;b[A]["n"]=t;b[A]["h"]=w;b[A]["oid"]=d;b[A]["info"]=x;for(var v=0;v<u.length;v++){c[u[v]]=A;}};};KJUR.crypto.ECParameterDB.regist("secp128r1",128,"FFFFFFFDFFFFFFFFFFFFFFFFFFFFFFFF","FFFFFFFDFFFFFFFFFFFFFFFFFFFFFFFC","E87579C11079F43DD824993C2CEE5ED3","FFFFFFFE0000000075A30D1B9038A115","1","161FF7528B899B2D0C28607CA52C5B86","CF5AC8395BAFEB13C02DA292DDED7A83",[],"","secp128r1 : SECG curve over a 128 bit prime field");KJUR.crypto.ECParameterDB.regist("secp160k1",160,"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFAC73","0","7","0100000000000000000001B8FA16DFAB9ACA16B6B3","1","3B4C382CE37AA192A4019E763036F4F5DD4D7EBB","938CF935318FDCED6BC28286531733C3F03C4FEE",[],"","secp160k1 : SECG curve over a 160 bit prime field");KJUR.crypto.ECParameterDB.regist("secp160r1",160,"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF7FFFFFFF","FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF7FFFFFFC","1C97BEFC54BD7A8B65ACF89F81D4D4ADC565FA45","0100000000000000000001F4C8F927AED3CA752257","1","4A96B5688EF573284664698968C38BB913CBFC82","23A628553168947D59DCC912042351377AC5FB32",[],"","secp160r1 : SECG curve over a 160 bit prime field");KJUR.crypto.ECParameterDB.regist("secp192k1",192,"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFEE37","0","3","FFFFFFFFFFFFFFFFFFFFFFFE26F2FC170F69466A74DEFD8D","1","DB4FF10EC057E9AE26B07D0280B7F4341DA5D1B1EAE06C7D","9B2F2F6D9C5628A7844163D015BE86344082AA88D95E2F9D",[]);KJUR.crypto.ECParameterDB.regist("secp192r1",192,"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFF","FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFC","64210519E59C80E70FA7E9AB72243049FEB8DEECC146B9B1","FFFFFFFFFFFFFFFFFFFFFFFF99DEF836146BC9B1B4D22831","1","188DA80EB03090F67CBF20EB43A18800F4FF0AFD82FF1012","07192B95FFC8DA78631011ED6B24CDD573F977A11E794811",[]);KJUR.crypto.ECParameterDB.regist("secp224r1",224,"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF000000000000000000000001","FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFFFFFFFFFE","B4050A850C04B3ABF54132565044B0B7D7BFD8BA270B39432355FFB4","FFFFFFFFFFFFFFFFFFFFFFFFFFFF16A2E0B8F03E13DD29455C5C2A3D","1","B70E0CBD6BB4BF7F321390B94A03C1D356C21122343280D6115C1D21","BD376388B5F723FB4C22DFE6CD4375A05A07476444D5819985007E34",[]);KJUR.crypto.ECParameterDB.regist("secp256k1",256,"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F","0","7","FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141","1","79BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F81798","483ADA7726A3C4655DA4FBFC0E1108A8FD17B448A68554199C47D08FFB10D4B8",[]);KJUR.crypto.ECParameterDB.regist("secp256r1",256,"FFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFF","FFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFC","5AC635D8AA3A93E7B3EBBD55769886BC651D06B0CC53B0F63BCE3C3E27D2604B","FFFFFFFF00000000FFFFFFFFFFFFFFFFBCE6FAADA7179E84F3B9CAC2FC632551","1","6B17D1F2E12C4247F8BCE6E563A440F277037D812DEB33A0F4A13945D898C296","4FE342E2FE1A7F9B8EE7EB4A7C0F9E162BCE33576B315ECECBB6406837BF51F5",["NIST P-256","P-256","prime256v1"]);KJUR.crypto.ECParameterDB.regist("secp384r1",384,"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFF0000000000000000FFFFFFFF","FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFF0000000000000000FFFFFFFC","B3312FA7E23EE7E4988E056BE3F82D19181D9C6EFE8141120314088F5013875AC656398D8A2ED19D2A85C8EDD3EC2AEF","FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFC7634D81F4372DDF581A0DB248B0A77AECEC196ACCC52973","1","AA87CA22BE8B05378EB1C71EF320AD746E1D3B628BA79B9859F741E082542A385502F25DBF55296C3A545E3872760AB7","3617de4a96262c6f5d9e98bf9292dc29f8f41dbd289a147ce9da3113b5f0b8c00a60b1ce1d7e819d7a431d7c90ea0e5f",["NIST P-384","P-384"]);KJUR.crypto.ECParameterDB.regist("secp521r1",521,"1FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF","1FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFC","051953EB9618E1C9A1F929A21A0B68540EEA2DA725B99B315F3B8B489918EF109E156193951EC7E937B1652C0BD3BB1BF073573DF883D2C34F1EF451FD46B503F00","1FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFA51868783BF2F966B7FCC0148F709A5D03BB5C9B8899C47AEBB6FB71E91386409","1","C6858E06B70404E9CD9E3ECB662395B4429C648139053FB521F828AF606B4D3DBAA14B5E77EFE75928FE1DC127A2FFA8DE3348B3C1856A429BF97E7E31C2E5BD66","011839296a789a3bc0045c8a5fb42c7d1bd998f54449579b446817afbd17273e662c97ee72995ef42640c550b9013fad0761353c7086a272c24088be94769fd16650",["NIST P-521","P-521"]);
	if(typeof KJUR=="undefined"||!KJUR){KJUR={};}if(typeof KJUR.crypto=="undefined"||!KJUR.crypto){KJUR.crypto={};}KJUR.crypto.DSA=function(){this.p=null;this.q=null;this.g=null;this.y=null;this.x=null;this.type="DSA";this.isPrivate=false;this.isPublic=false;this.setPrivate=function(d,c,b,e,a){this.isPrivate=true;this.p=d;this.q=c;this.g=b;this.y=e;this.x=a;};this.setPrivateHex=function(d,b,f,i,j){var c,a,e,g,h;c=new BigInteger(d,16);a=new BigInteger(b,16);e=new BigInteger(f,16);if(typeof i==="string"&&i.length>1){g=new BigInteger(i,16);}else{g=null;}h=new BigInteger(j,16);this.setPrivate(c,a,e,g,h);};this.setPublic=function(c,b,a,d){this.isPublic=true;this.p=c;this.q=b;this.g=a;this.y=d;this.x=null;};this.setPublicHex=function(f,e,d,g){var b,a,h,c;b=new BigInteger(f,16);a=new BigInteger(e,16);h=new BigInteger(d,16);c=new BigInteger(g,16);this.setPublic(b,a,h,c);};this.signWithMessageHash=function(d){var c=this.p;var b=this.q;var f=this.g;var i=this.y;var j=this.x;var e=KJUR.crypto.Util.getRandomBigIntegerMinToMax(BigInteger.ONE.add(BigInteger.ONE),b.subtract(BigInteger.ONE));var l=d.substr(0,b.bitLength()/4);var h=new BigInteger(l,16);var a=(f.modPow(e,c)).mod(b);var n=(e.modInverse(b).multiply(h.add(j.multiply(a)))).mod(b);var m=KJUR.asn1.ASN1Util.jsonToASN1HEX({seq:[{"int":{bigint:a}},{"int":{bigint:n}}]});return m};this.verifyWithMessageHash=function(h,f){var d=this.p;var b=this.q;var j=this.g;var l=this.y;var i=this.parseASN1Signature(f);var a=i[0];var t=i[1];var o=h.substr(0,b.bitLength()/4);var k=new BigInteger(o,16);if(BigInteger.ZERO.compareTo(a)>0||a.compareTo(b)>0){throw"invalid DSA signature"}if(BigInteger.ZERO.compareTo(t)>=0||t.compareTo(b)>0){throw"invalid DSA signature"}var m=t.modInverse(b);var e=k.multiply(m).mod(b);var c=a.multiply(m).mod(b);var n=j.modPow(e,d).multiply(l.modPow(c,d)).mod(d).mod(b);return n.compareTo(a)==0};this.parseASN1Signature=function(a){try{var d=new BigInteger(ASN1HEX.getVbyList(a,0,[0],"02"),16);var c=new BigInteger(ASN1HEX.getVbyList(a,0,[1],"02"),16);return [d,c]}catch(b){throw"malformed ASN.1 DSA signature"}};this.readPKCS5PrvKeyHex=function(c){var b,a,f,g,i;var j=ASN1HEX;var d=j.getVbyList;if(j.isASN1HEX(c)===false){throw"not ASN.1 hex string"}try{b=d(c,0,[1],"02");a=d(c,0,[2],"02");f=d(c,0,[3],"02");g=d(c,0,[4],"02");i=d(c,0,[5],"02");}catch(e){console.log("EXCEPTION:"+e);throw"malformed PKCS#1/5 plain DSA private key"}this.setPrivateHex(b,a,f,g,i);};this.readPKCS8PrvKeyHex=function(d){var f,c,b,g;var e=ASN1HEX;var i=e.getVbyList;if(e.isASN1HEX(d)===false){throw"not ASN.1 hex string"}try{f=i(d,0,[1,1,0],"02");c=i(d,0,[1,1,1],"02");b=i(d,0,[1,1,2],"02");g=i(d,0,[2,0],"02");}catch(a){console.log("EXCEPTION:"+a);throw"malformed PKCS#8 plain DSA private key"}this.setPrivateHex(f,c,b,null,g);};this.readPKCS8PubKeyHex=function(d){var f,c,b,g;var e=ASN1HEX;var i=e.getVbyList;if(e.isASN1HEX(d)===false){throw"not ASN.1 hex string"}try{f=i(d,0,[0,1,0],"02");c=i(d,0,[0,1,1],"02");b=i(d,0,[0,1,2],"02");g=i(d,0,[1,0],"02");}catch(a){console.log("EXCEPTION:"+a);throw"malformed PKCS#8 DSA public key"}this.setPublicHex(f,c,b,g);};this.readCertPubKeyHex=function(c,f){if(f!==5){f=6;}var b,a,g,i;var j=ASN1HEX;var d=j.getVbyList;if(j.isASN1HEX(c)===false){throw"not ASN.1 hex string"}try{b=d(c,0,[0,f,0,1,0],"02");a=d(c,0,[0,f,0,1,1],"02");g=d(c,0,[0,f,0,1,2],"02");i=d(c,0,[0,f,1,0],"02");}catch(e){console.log("EXCEPTION:"+e);throw"malformed X.509 certificate DSA public key"}this.setPublicHex(b,a,g,i);};};
	var KEYUTIL=function(){var d=function(p,r,q){return k(CryptoJS.AES,p,r,q)};var e=function(p,r,q){return k(CryptoJS.TripleDES,p,r,q)};var a=function(p,r,q){return k(CryptoJS.DES,p,r,q)};var k=function(s,x,u,q){var r=CryptoJS.enc.Hex.parse(x);var w=CryptoJS.enc.Hex.parse(u);var p=CryptoJS.enc.Hex.parse(q);var t={};t.key=w;t.iv=p;t.ciphertext=r;var v=s.decrypt(t,w,{iv:p});return CryptoJS.enc.Hex.stringify(v)};var l=function(p,r,q){return g(CryptoJS.AES,p,r,q)};var o=function(p,r,q){return g(CryptoJS.TripleDES,p,r,q)};var f=function(p,r,q){return g(CryptoJS.DES,p,r,q)};var g=function(t,y,v,q){var s=CryptoJS.enc.Hex.parse(y);var x=CryptoJS.enc.Hex.parse(v);var p=CryptoJS.enc.Hex.parse(q);var w=t.encrypt(s,x,{iv:p});var r=CryptoJS.enc.Hex.parse(w.toString());var u=CryptoJS.enc.Base64.stringify(r);return u};var i={"AES-256-CBC":{proc:d,eproc:l,keylen:32,ivlen:16},"AES-192-CBC":{proc:d,eproc:l,keylen:24,ivlen:16},"AES-128-CBC":{proc:d,eproc:l,keylen:16,ivlen:16},"DES-EDE3-CBC":{proc:e,eproc:o,keylen:24,ivlen:8},"DES-CBC":{proc:a,eproc:f,keylen:8,ivlen:8}};var m=function(p){var r=CryptoJS.lib.WordArray.random(p);var q=CryptoJS.enc.Hex.stringify(r);return q};var n=function(v){var w={};var q=v.match(new RegExp("DEK-Info: ([^,]+),([0-9A-Fa-f]+)","m"));if(q){w.cipher=q[1];w.ivsalt=q[2];}var p=v.match(new RegExp("-----BEGIN ([A-Z]+) PRIVATE KEY-----"));if(p){w.type=p[1];}var u=-1;var x=0;if(v.indexOf("\r\n\r\n")!=-1){u=v.indexOf("\r\n\r\n");x=2;}if(v.indexOf("\n\n")!=-1){u=v.indexOf("\n\n");x=1;}var t=v.indexOf("-----END");if(u!=-1&&t!=-1){var r=v.substring(u+x*2,t-x);r=r.replace(/\s+/g,"");w.data=r;}return w};var j=function(q,y,p){var v=p.substring(0,16);var t=CryptoJS.enc.Hex.parse(v);var r=CryptoJS.enc.Utf8.parse(y);var u=i[q]["keylen"]+i[q]["ivlen"];var x="";var w=null;for(;;){var s=CryptoJS.algo.MD5.create();if(w!=null){s.update(w);}s.update(r);s.update(t);w=s.finalize();x=x+CryptoJS.enc.Hex.stringify(w);if(x.length>=u*2){break}}var z={};z.keyhex=x.substr(0,i[q]["keylen"]*2);z.ivhex=x.substr(i[q]["keylen"]*2,i[q]["ivlen"]*2);return z};var b=function(p,v,r,w){var s=CryptoJS.enc.Base64.parse(p);var q=CryptoJS.enc.Hex.stringify(s);var u=i[v]["proc"];var t=u(q,r,w);return t};var h=function(p,s,q,u){var r=i[s]["eproc"];var t=r(p,q,u);return t};return {version:"1.0.0",parsePKCS5PEM:function(p){return n(p)},getKeyAndUnusedIvByPasscodeAndIvsalt:function(q,p,r){return j(q,p,r)},decryptKeyB64:function(p,r,q,s){return b(p,r,q,s)},getDecryptedKeyHex:function(y,x){var q=n(y);var r=q.cipher;var p=q.ivsalt;var s=q.data;var w=j(r,x,p);var v=w.keyhex;var u=b(s,r,v,p);return u},getEncryptedPKCS5PEMFromPrvKeyHex:function(x,s,A,t,r){var p="";if(typeof t=="undefined"||t==null){t="AES-256-CBC";}if(typeof i[t]=="undefined"){throw"KEYUTIL unsupported algorithm: "+t}if(typeof r=="undefined"||r==null){var v=i[t]["ivlen"];var u=m(v);r=u.toUpperCase();}var z=j(t,A,r);var y=z.keyhex;var w=h(s,t,y,r);var q=w.replace(/(.{64})/g,"$1\r\n");var p="-----BEGIN "+x+" PRIVATE KEY-----\r\n";p+="Proc-Type: 4,ENCRYPTED\r\n";p+="DEK-Info: "+t+","+r+"\r\n";p+="\r\n";p+=q;p+="\r\n-----END "+x+" PRIVATE KEY-----\r\n";return p},parseHexOfEncryptedPKCS8:function(y){var B=ASN1HEX;var z=B.getChildIdx;var w=B.getV;var t={};var r=z(y,0);if(r.length!=2){throw"malformed format: SEQUENCE(0).items != 2: "+r.length}t.ciphertext=w(y,r[1]);var A=z(y,r[0]);if(A.length!=2){throw"malformed format: SEQUENCE(0.0).items != 2: "+A.length}if(w(y,A[0])!="2a864886f70d01050d"){throw"this only supports pkcs5PBES2"}var p=z(y,A[1]);if(A.length!=2){throw"malformed format: SEQUENCE(0.0.1).items != 2: "+p.length}var q=z(y,p[1]);if(q.length!=2){throw"malformed format: SEQUENCE(0.0.1.1).items != 2: "+q.length}if(w(y,q[0])!="2a864886f70d0307"){throw"this only supports TripleDES"}t.encryptionSchemeAlg="TripleDES";t.encryptionSchemeIV=w(y,q[1]);var s=z(y,p[0]);if(s.length!=2){throw"malformed format: SEQUENCE(0.0.1.0).items != 2: "+s.length}if(w(y,s[0])!="2a864886f70d01050c"){throw"this only supports pkcs5PBKDF2"}var x=z(y,s[1]);if(x.length<2){throw"malformed format: SEQUENCE(0.0.1.0.1).items < 2: "+x.length}t.pbkdf2Salt=w(y,x[0]);var u=w(y,x[1]);try{t.pbkdf2Iter=parseInt(u,16);}catch(v){throw"malformed format pbkdf2Iter: "+u}return t},getPBKDF2KeyHexFromParam:function(u,p){var t=CryptoJS.enc.Hex.parse(u.pbkdf2Salt);var q=u.pbkdf2Iter;var s=CryptoJS.PBKDF2(p,t,{keySize:192/32,iterations:q});var r=CryptoJS.enc.Hex.stringify(s);return r},_getPlainPKCS8HexFromEncryptedPKCS8PEM:function(x,y){var r=pemtohex(x,"ENCRYPTED PRIVATE KEY");var p=this.parseHexOfEncryptedPKCS8(r);var u=KEYUTIL.getPBKDF2KeyHexFromParam(p,y);var v={};v.ciphertext=CryptoJS.enc.Hex.parse(p.ciphertext);var t=CryptoJS.enc.Hex.parse(u);var s=CryptoJS.enc.Hex.parse(p.encryptionSchemeIV);var w=CryptoJS.TripleDES.decrypt(v,t,{iv:s});var q=CryptoJS.enc.Hex.stringify(w);return q},getKeyFromEncryptedPKCS8PEM:function(s,q){var p=this._getPlainPKCS8HexFromEncryptedPKCS8PEM(s,q);var r=this.getKeyFromPlainPrivatePKCS8Hex(p);return r},parsePlainPrivatePKCS8Hex:function(s){var v=ASN1HEX;var u=v.getChildIdx;var t=v.getV;var q={};q.algparam=null;if(s.substr(0,2)!="30"){throw"malformed plain PKCS8 private key(code:001)"}var r=u(s,0);if(r.length!=3){throw"malformed plain PKCS8 private key(code:002)"}if(s.substr(r[1],2)!="30"){throw"malformed PKCS8 private key(code:003)"}var p=u(s,r[1]);if(p.length!=2){throw"malformed PKCS8 private key(code:004)"}if(s.substr(p[0],2)!="06"){throw"malformed PKCS8 private key(code:005)"}q.algoid=t(s,p[0]);if(s.substr(p[1],2)=="06"){q.algparam=t(s,p[1]);}if(s.substr(r[2],2)!="04"){throw"malformed PKCS8 private key(code:006)"}q.keyidx=v.getVidx(s,r[2]);return q},getKeyFromPlainPrivatePKCS8PEM:function(q){var p=pemtohex(q,"PRIVATE KEY");var r=this.getKeyFromPlainPrivatePKCS8Hex(p);return r},getKeyFromPlainPrivatePKCS8Hex:function(p){var q=this.parsePlainPrivatePKCS8Hex(p);var r;if(q.algoid=="2a864886f70d010101"){r=new RSAKey();}else{if(q.algoid=="2a8648ce380401"){r=new KJUR.crypto.DSA();}else{if(q.algoid=="2a8648ce3d0201"){r=new KJUR.crypto.ECDSA();}else{throw"unsupported private key algorithm"}}}r.readPKCS8PrvKeyHex(p);return r},_getKeyFromPublicPKCS8Hex:function(q){var p;var r=ASN1HEX.getVbyList(q,0,[0,0],"06");if(r==="2a864886f70d010101"){p=new RSAKey();}else{if(r==="2a8648ce380401"){p=new KJUR.crypto.DSA();}else{if(r==="2a8648ce3d0201"){p=new KJUR.crypto.ECDSA();}else{throw"unsupported PKCS#8 public key hex"}}}p.readPKCS8PubKeyHex(q);return p},parsePublicRawRSAKeyHex:function(r){var u=ASN1HEX;var t=u.getChildIdx;var s=u.getV;var p={};if(r.substr(0,2)!="30"){throw"malformed RSA key(code:001)"}var q=t(r,0);if(q.length!=2){throw"malformed RSA key(code:002)"}if(r.substr(q[0],2)!="02"){throw"malformed RSA key(code:003)"}p.n=s(r,q[0]);if(r.substr(q[1],2)!="02"){throw"malformed RSA key(code:004)"}p.e=s(r,q[1]);return p},parsePublicPKCS8Hex:function(t){var v=ASN1HEX;var u=v.getChildIdx;var s=v.getV;var q={};q.algparam=null;var r=u(t,0);if(r.length!=2){throw"outer DERSequence shall have 2 elements: "+r.length}var w=r[0];if(t.substr(w,2)!="30"){throw"malformed PKCS8 public key(code:001)"}var p=u(t,w);if(p.length!=2){throw"malformed PKCS8 public key(code:002)"}if(t.substr(p[0],2)!="06"){throw"malformed PKCS8 public key(code:003)"}q.algoid=s(t,p[0]);if(t.substr(p[1],2)=="06"){q.algparam=s(t,p[1]);}else{if(t.substr(p[1],2)=="30"){q.algparam={};q.algparam.p=v.getVbyList(t,p[1],[0],"02");q.algparam.q=v.getVbyList(t,p[1],[1],"02");q.algparam.g=v.getVbyList(t,p[1],[2],"02");}}if(t.substr(r[1],2)!="03"){throw"malformed PKCS8 public key(code:004)"}q.key=s(t,r[1]).substr(2);return q},}}();KEYUTIL.getKey=function(l,k,n){var G=ASN1HEX,L=G.getChildIdx,v=G.getV,d=G.getVbyList,c=KJUR.crypto,i=c.ECDSA,C=c.DSA,w=RSAKey,M=pemtohex,F=KEYUTIL;if(typeof w!="undefined"&&l instanceof w){return l}if(typeof i!="undefined"&&l instanceof i){return l}if(typeof C!="undefined"&&l instanceof C){return l}if(l.curve!==undefined&&l.xy!==undefined&&l.d===undefined){return new i({pub:l.xy,curve:l.curve})}if(l.curve!==undefined&&l.d!==undefined){return new i({prv:l.d,curve:l.curve})}if(l.kty===undefined&&l.n!==undefined&&l.e!==undefined&&l.d===undefined){var P=new w();P.setPublic(l.n,l.e);return P}if(l.kty===undefined&&l.n!==undefined&&l.e!==undefined&&l.d!==undefined&&l.p!==undefined&&l.q!==undefined&&l.dp!==undefined&&l.dq!==undefined&&l.co!==undefined&&l.qi===undefined){var P=new w();P.setPrivateEx(l.n,l.e,l.d,l.p,l.q,l.dp,l.dq,l.co);return P}if(l.kty===undefined&&l.n!==undefined&&l.e!==undefined&&l.d!==undefined&&l.p===undefined){var P=new w();P.setPrivate(l.n,l.e,l.d);return P}if(l.p!==undefined&&l.q!==undefined&&l.g!==undefined&&l.y!==undefined&&l.x===undefined){var P=new C();P.setPublic(l.p,l.q,l.g,l.y);return P}if(l.p!==undefined&&l.q!==undefined&&l.g!==undefined&&l.y!==undefined&&l.x!==undefined){var P=new C();P.setPrivate(l.p,l.q,l.g,l.y,l.x);return P}if(l.kty==="RSA"&&l.n!==undefined&&l.e!==undefined&&l.d===undefined){var P=new w();P.setPublic(b64utohex(l.n),b64utohex(l.e));return P}if(l.kty==="RSA"&&l.n!==undefined&&l.e!==undefined&&l.d!==undefined&&l.p!==undefined&&l.q!==undefined&&l.dp!==undefined&&l.dq!==undefined&&l.qi!==undefined){var P=new w();P.setPrivateEx(b64utohex(l.n),b64utohex(l.e),b64utohex(l.d),b64utohex(l.p),b64utohex(l.q),b64utohex(l.dp),b64utohex(l.dq),b64utohex(l.qi));return P}if(l.kty==="RSA"&&l.n!==undefined&&l.e!==undefined&&l.d!==undefined){var P=new w();P.setPrivate(b64utohex(l.n),b64utohex(l.e),b64utohex(l.d));return P}if(l.kty==="EC"&&l.crv!==undefined&&l.x!==undefined&&l.y!==undefined&&l.d===undefined){var j=new i({curve:l.crv});var t=j.ecparams.keylen/4;var B=("0000000000"+b64utohex(l.x)).slice(-t);var z=("0000000000"+b64utohex(l.y)).slice(-t);var u="04"+B+z;j.setPublicKeyHex(u);return j}if(l.kty==="EC"&&l.crv!==undefined&&l.x!==undefined&&l.y!==undefined&&l.d!==undefined){var j=new i({curve:l.crv});var t=j.ecparams.keylen/4;var B=("0000000000"+b64utohex(l.x)).slice(-t);var z=("0000000000"+b64utohex(l.y)).slice(-t);var u="04"+B+z;var b=("0000000000"+b64utohex(l.d)).slice(-t);j.setPublicKeyHex(u);j.setPrivateKeyHex(b);return j}if(n==="pkcs5prv"){var J=l,G=ASN1HEX,N,P;N=L(J,0);if(N.length===9){P=new w();P.readPKCS5PrvKeyHex(J);}else{if(N.length===6){P=new C();P.readPKCS5PrvKeyHex(J);}else{if(N.length>2&&J.substr(N[1],2)==="04"){P=new i();P.readPKCS5PrvKeyHex(J);}else{throw"unsupported PKCS#1/5 hexadecimal key"}}}return P}if(n==="pkcs8prv"){var P=F.getKeyFromPlainPrivatePKCS8Hex(l);return P}if(n==="pkcs8pub"){return F._getKeyFromPublicPKCS8Hex(l)}if(n==="x509pub"){return X509.getPublicKeyFromCertHex(l)}if(l.indexOf("-END CERTIFICATE-",0)!=-1||l.indexOf("-END X509 CERTIFICATE-",0)!=-1||l.indexOf("-END TRUSTED CERTIFICATE-",0)!=-1){return X509.getPublicKeyFromCertPEM(l)}if(l.indexOf("-END PUBLIC KEY-")!=-1){var O=pemtohex(l,"PUBLIC KEY");return F._getKeyFromPublicPKCS8Hex(O)}if(l.indexOf("-END RSA PRIVATE KEY-")!=-1&&l.indexOf("4,ENCRYPTED")==-1){var m=M(l,"RSA PRIVATE KEY");return F.getKey(m,null,"pkcs5prv")}if(l.indexOf("-END DSA PRIVATE KEY-")!=-1&&l.indexOf("4,ENCRYPTED")==-1){var I=M(l,"DSA PRIVATE KEY");var E=d(I,0,[1],"02");var D=d(I,0,[2],"02");var K=d(I,0,[3],"02");var r=d(I,0,[4],"02");var s=d(I,0,[5],"02");var P=new C();P.setPrivate(new BigInteger(E,16),new BigInteger(D,16),new BigInteger(K,16),new BigInteger(r,16),new BigInteger(s,16));return P}if(l.indexOf("-END PRIVATE KEY-")!=-1){return F.getKeyFromPlainPrivatePKCS8PEM(l)}if(l.indexOf("-END RSA PRIVATE KEY-")!=-1&&l.indexOf("4,ENCRYPTED")!=-1){var o=F.getDecryptedKeyHex(l,k);var H=new RSAKey();H.readPKCS5PrvKeyHex(o);return H}if(l.indexOf("-END EC PRIVATE KEY-")!=-1&&l.indexOf("4,ENCRYPTED")!=-1){var I=F.getDecryptedKeyHex(l,k);var P=d(I,0,[1],"04");var f=d(I,0,[2,0],"06");var A=d(I,0,[3,0],"03").substr(2);var e="";if(KJUR.crypto.OID.oidhex2name[f]!==undefined){e=KJUR.crypto.OID.oidhex2name[f];}else{throw"undefined OID(hex) in KJUR.crypto.OID: "+f}var j=new i({curve:e});j.setPublicKeyHex(A);j.setPrivateKeyHex(P);j.isPublic=false;return j}if(l.indexOf("-END DSA PRIVATE KEY-")!=-1&&l.indexOf("4,ENCRYPTED")!=-1){var I=F.getDecryptedKeyHex(l,k);var E=d(I,0,[1],"02");var D=d(I,0,[2],"02");var K=d(I,0,[3],"02");var r=d(I,0,[4],"02");var s=d(I,0,[5],"02");var P=new C();P.setPrivate(new BigInteger(E,16),new BigInteger(D,16),new BigInteger(K,16),new BigInteger(r,16),new BigInteger(s,16));return P}if(l.indexOf("-END ENCRYPTED PRIVATE KEY-")!=-1){return F.getKeyFromEncryptedPKCS8PEM(l,k)}throw"not supported argument"};KEYUTIL.generateKeypair=function(a,c){if(a=="RSA"){var b=c;var h=new RSAKey();h.generate(b,"10001");h.isPrivate=true;h.isPublic=true;var f=new RSAKey();var e=h.n.toString(16);var i=h.e.toString(16);f.setPublic(e,i);f.isPrivate=false;f.isPublic=true;var k={};k.prvKeyObj=h;k.pubKeyObj=f;return k}else{if(a=="EC"){var d=c;var g=new KJUR.crypto.ECDSA({curve:d});var j=g.generateKeyPairHex();var h=new KJUR.crypto.ECDSA({curve:d});h.setPublicKeyHex(j.ecpubhex);h.setPrivateKeyHex(j.ecprvhex);h.isPrivate=true;h.isPublic=false;var f=new KJUR.crypto.ECDSA({curve:d});f.setPublicKeyHex(j.ecpubhex);f.isPrivate=false;f.isPublic=true;var k={};k.prvKeyObj=h;k.pubKeyObj=f;return k}else{throw"unknown algorithm: "+a}}};KEYUTIL.getPEM=function(b,D,y,m,q,j){var F=KJUR,k=F.asn1,z=k.DERObjectIdentifier,f=k.DERInteger,l=k.ASN1Util.newObject,a=k.x509,C=a.SubjectPublicKeyInfo,e=F.crypto,u=e.DSA,r=e.ECDSA,n=RSAKey;function A(s){var G=l({seq:[{"int":0},{"int":{bigint:s.n}},{"int":s.e},{"int":{bigint:s.d}},{"int":{bigint:s.p}},{"int":{bigint:s.q}},{"int":{bigint:s.dmp1}},{"int":{bigint:s.dmq1}},{"int":{bigint:s.coeff}}]});return G}function B(G){var s=l({seq:[{"int":1},{octstr:{hex:G.prvKeyHex}},{tag:["a0",true,{oid:{name:G.curveName}}]},{tag:["a1",true,{bitstr:{hex:"00"+G.pubKeyHex}}]}]});return s}function x(s){var G=l({seq:[{"int":0},{"int":{bigint:s.p}},{"int":{bigint:s.q}},{"int":{bigint:s.g}},{"int":{bigint:s.y}},{"int":{bigint:s.x}}]});return G}if(((n!==undefined&&b instanceof n)||(u!==undefined&&b instanceof u)||(r!==undefined&&b instanceof r))&&b.isPublic==true&&(D===undefined||D=="PKCS8PUB")){var E=new C(b);var w=E.getEncodedHex();return hextopem(w,"PUBLIC KEY")}if(D=="PKCS1PRV"&&n!==undefined&&b instanceof n&&(y===undefined||y==null)&&b.isPrivate==true){var E=A(b);var w=E.getEncodedHex();return hextopem(w,"RSA PRIVATE KEY")}if(D=="PKCS1PRV"&&r!==undefined&&b instanceof r&&(y===undefined||y==null)&&b.isPrivate==true){var i=new z({name:b.curveName});var v=i.getEncodedHex();var h=B(b);var t=h.getEncodedHex();var p="";p+=hextopem(v,"EC PARAMETERS");p+=hextopem(t,"EC PRIVATE KEY");return p}if(D=="PKCS1PRV"&&u!==undefined&&b instanceof u&&(y===undefined||y==null)&&b.isPrivate==true){var E=x(b);var w=E.getEncodedHex();return hextopem(w,"DSA PRIVATE KEY")}if(D=="PKCS5PRV"&&n!==undefined&&b instanceof n&&(y!==undefined&&y!=null)&&b.isPrivate==true){var E=A(b);var w=E.getEncodedHex();if(m===undefined){m="DES-EDE3-CBC";}return this.getEncryptedPKCS5PEMFromPrvKeyHex("RSA",w,y,m,j)}if(D=="PKCS5PRV"&&r!==undefined&&b instanceof r&&(y!==undefined&&y!=null)&&b.isPrivate==true){var E=B(b);var w=E.getEncodedHex();if(m===undefined){m="DES-EDE3-CBC";}return this.getEncryptedPKCS5PEMFromPrvKeyHex("EC",w,y,m,j)}if(D=="PKCS5PRV"&&u!==undefined&&b instanceof u&&(y!==undefined&&y!=null)&&b.isPrivate==true){var E=x(b);var w=E.getEncodedHex();if(m===undefined){m="DES-EDE3-CBC";}return this.getEncryptedPKCS5PEMFromPrvKeyHex("DSA",w,y,m,j)}var o=function(G,s){var I=c(G,s);var H=new l({seq:[{seq:[{oid:{name:"pkcs5PBES2"}},{seq:[{seq:[{oid:{name:"pkcs5PBKDF2"}},{seq:[{octstr:{hex:I.pbkdf2Salt}},{"int":I.pbkdf2Iter}]}]},{seq:[{oid:{name:"des-EDE3-CBC"}},{octstr:{hex:I.encryptionSchemeIV}}]}]}]},{octstr:{hex:I.ciphertext}}]});return H.getEncodedHex()};var c=function(N,O){var H=100;var M=CryptoJS.lib.WordArray.random(8);var L="DES-EDE3-CBC";var s=CryptoJS.lib.WordArray.random(8);var I=CryptoJS.PBKDF2(O,M,{keySize:192/32,iterations:H});var J=CryptoJS.enc.Hex.parse(N);var K=CryptoJS.TripleDES.encrypt(J,I,{iv:s})+"";var G={};G.ciphertext=K;G.pbkdf2Salt=CryptoJS.enc.Hex.stringify(M);G.pbkdf2Iter=H;G.encryptionSchemeAlg=L;G.encryptionSchemeIV=CryptoJS.enc.Hex.stringify(s);return G};if(D=="PKCS8PRV"&&n!=undefined&&b instanceof n&&b.isPrivate==true){var g=A(b);var d=g.getEncodedHex();var E=l({seq:[{"int":0},{seq:[{oid:{name:"rsaEncryption"}},{"null":true}]},{octstr:{hex:d}}]});var w=E.getEncodedHex();if(y===undefined||y==null){return hextopem(w,"PRIVATE KEY")}else{var t=o(w,y);return hextopem(t,"ENCRYPTED PRIVATE KEY")}}if(D=="PKCS8PRV"&&r!==undefined&&b instanceof r&&b.isPrivate==true){var g=new l({seq:[{"int":1},{octstr:{hex:b.prvKeyHex}},{tag:["a1",true,{bitstr:{hex:"00"+b.pubKeyHex}}]}]});var d=g.getEncodedHex();var E=l({seq:[{"int":0},{seq:[{oid:{name:"ecPublicKey"}},{oid:{name:b.curveName}}]},{octstr:{hex:d}}]});var w=E.getEncodedHex();if(y===undefined||y==null){return hextopem(w,"PRIVATE KEY")}else{var t=o(w,y);return hextopem(t,"ENCRYPTED PRIVATE KEY")}}if(D=="PKCS8PRV"&&u!==undefined&&b instanceof u&&b.isPrivate==true){var g=new f({bigint:b.x});var d=g.getEncodedHex();var E=l({seq:[{"int":0},{seq:[{oid:{name:"dsa"}},{seq:[{"int":{bigint:b.p}},{"int":{bigint:b.q}},{"int":{bigint:b.g}}]}]},{octstr:{hex:d}}]});var w=E.getEncodedHex();if(y===undefined||y==null){return hextopem(w,"PRIVATE KEY")}else{var t=o(w,y);return hextopem(t,"ENCRYPTED PRIVATE KEY")}}throw"unsupported object nor format"};KEYUTIL.getKeyFromCSRPEM=function(b){var a=pemtohex(b,"CERTIFICATE REQUEST");var c=KEYUTIL.getKeyFromCSRHex(a);return c};KEYUTIL.getKeyFromCSRHex=function(a){var c=KEYUTIL.parseCSRHex(a);var b=KEYUTIL.getKey(c.p8pubkeyhex,null,"pkcs8pub");return b};KEYUTIL.parseCSRHex=function(d){var i=ASN1HEX;var f=i.getChildIdx;var c=i.getTLV;var b={};var g=d;if(g.substr(0,2)!="30"){throw"malformed CSR(code:001)"}var e=f(g,0);if(e.length<1){throw"malformed CSR(code:002)"}if(g.substr(e[0],2)!="30"){throw"malformed CSR(code:003)"}var a=f(g,e[0]);if(a.length<3){throw"malformed CSR(code:004)"}b.p8pubkeyhex=c(g,a[2]);return b};KEYUTIL.getJWKFromKey=function(d){var b={};if(d instanceof RSAKey&&d.isPrivate){b.kty="RSA";b.n=hextob64u(d.n.toString(16));b.e=hextob64u(d.e.toString(16));b.d=hextob64u(d.d.toString(16));b.p=hextob64u(d.p.toString(16));b.q=hextob64u(d.q.toString(16));b.dp=hextob64u(d.dmp1.toString(16));b.dq=hextob64u(d.dmq1.toString(16));b.qi=hextob64u(d.coeff.toString(16));return b}else{if(d instanceof RSAKey&&d.isPublic){b.kty="RSA";b.n=hextob64u(d.n.toString(16));b.e=hextob64u(d.e.toString(16));return b}else{if(d instanceof KJUR.crypto.ECDSA&&d.isPrivate){var a=d.getShortNISTPCurveName();if(a!=="P-256"&&a!=="P-384"){throw"unsupported curve name for JWT: "+a}var c=d.getPublicKeyXYHex();b.kty="EC";b.crv=a;b.x=hextob64u(c.x);b.y=hextob64u(c.y);b.d=hextob64u(d.prvKeyHex);return b}else{if(d instanceof KJUR.crypto.ECDSA&&d.isPublic){var a=d.getShortNISTPCurveName();if(a!=="P-256"&&a!=="P-384"){throw"unsupported curve name for JWT: "+a}var c=d.getPublicKeyXYHex();b.kty="EC";b.crv=a;b.x=hextob64u(c.x);b.y=hextob64u(c.y);return b}}}}throw"not supported key object"};
	RSAKey.getPosArrayOfChildrenFromHex=function(a){return ASN1HEX.getChildIdx(a,0)};RSAKey.getHexValueArrayOfChildrenFromHex=function(f){var n=ASN1HEX;var i=n.getV;var k=RSAKey.getPosArrayOfChildrenFromHex(f);var e=i(f,k[0]);var j=i(f,k[1]);var b=i(f,k[2]);var c=i(f,k[3]);var h=i(f,k[4]);var g=i(f,k[5]);var m=i(f,k[6]);var l=i(f,k[7]);var d=i(f,k[8]);var k=new Array();k.push(e,j,b,c,h,g,m,l,d);return k};RSAKey.prototype.readPrivateKeyFromPEMString=function(d){var c=pemtohex(d);var b=RSAKey.getHexValueArrayOfChildrenFromHex(c);this.setPrivateEx(b[1],b[2],b[3],b[4],b[5],b[6],b[7],b[8]);};RSAKey.prototype.readPKCS5PrvKeyHex=function(c){var b=RSAKey.getHexValueArrayOfChildrenFromHex(c);this.setPrivateEx(b[1],b[2],b[3],b[4],b[5],b[6],b[7],b[8]);};RSAKey.prototype.readPKCS8PrvKeyHex=function(e){var c,j,l,b,a,f,d,k;var m=ASN1HEX;var g=m.getVbyList;if(m.isASN1HEX(e)===false){throw"not ASN.1 hex string"}try{c=g(e,0,[2,0,1],"02");j=g(e,0,[2,0,2],"02");l=g(e,0,[2,0,3],"02");b=g(e,0,[2,0,4],"02");a=g(e,0,[2,0,5],"02");f=g(e,0,[2,0,6],"02");d=g(e,0,[2,0,7],"02");k=g(e,0,[2,0,8],"02");}catch(i){throw"malformed PKCS#8 plain RSA private key"}this.setPrivateEx(c,j,l,b,a,f,d,k);};RSAKey.prototype.readPKCS5PubKeyHex=function(c){var e=ASN1HEX;var b=e.getV;if(e.isASN1HEX(c)===false){throw"keyHex is not ASN.1 hex string"}var a=e.getChildIdx(c,0);if(a.length!==2||c.substr(a[0],2)!=="02"||c.substr(a[1],2)!=="02"){throw"wrong hex for PKCS#5 public key"}var f=b(c,a[0]);var d=b(c,a[1]);this.setPublic(f,d);};RSAKey.prototype.readPKCS8PubKeyHex=function(b){var c=ASN1HEX;if(c.isASN1HEX(b)===false){throw"not ASN.1 hex string"}if(c.getTLVbyList(b,0,[0,0])!=="06092a864886f70d010101"){throw"not PKCS8 RSA public key"}var a=c.getTLVbyList(b,0,[1,0]);this.readPKCS5PubKeyHex(a);};RSAKey.prototype.readCertPubKeyHex=function(b,d){var a,c;a=new X509();a.readCertHex(b);c=a.getPublicKeyHex();this.readPKCS8PubKeyHex(c);};
	var _RE_HEXDECONLY=new RegExp("");_RE_HEXDECONLY.compile("[^0-9a-f]","gi");function _zeroPaddingOfSignature(e,d){var c="";var a=d/4-e.length;for(var b=0;b<a;b++){c=c+"0";}return c+e}RSAKey.prototype.sign=function(d,a){var b=function(e){return KJUR.crypto.Util.hashString(e,a)};var c=b(d);return this.signWithMessageHash(c,a)};RSAKey.prototype.signWithMessageHash=function(e,c){var f=KJUR.crypto.Util.getPaddedDigestInfoHex(e,c,this.n.bitLength());var b=parseBigInt(f,16);var d=this.doPrivate(b);var a=d.toString(16);return _zeroPaddingOfSignature(a,this.n.bitLength())};function pss_mgf1_str(c,a,e){var b="",d=0;while(b.length<a){b+=hextorstr(e(rstrtohex(c+String.fromCharCode.apply(String,[(d&4278190080)>>24,(d&16711680)>>16,(d&65280)>>8,d&255]))));d+=1;}return b}RSAKey.prototype.signPSS=function(e,a,d){var c=function(f){return KJUR.crypto.Util.hashHex(f,a)};var b=c(rstrtohex(e));if(d===undefined){d=-1;}return this.signWithMessageHashPSS(b,a,d)};RSAKey.prototype.signWithMessageHashPSS=function(l,a,k){var b=hextorstr(l);var g=b.length;var m=this.n.bitLength()-1;var c=Math.ceil(m/8);var d;var o=function(i){return KJUR.crypto.Util.hashHex(i,a)};if(k===-1||k===undefined){k=g;}else{if(k===-2){k=c-g-2;}else{if(k<-2){throw"invalid salt length"}}}if(c<(g+k+2)){throw"data too long"}var f="";if(k>0){f=new Array(k);new SecureRandom().nextBytes(f);f=String.fromCharCode.apply(String,f);}var n=hextorstr(o(rstrtohex("\x00\x00\x00\x00\x00\x00\x00\x00"+b+f)));var j=[];for(d=0;d<c-k-g-2;d+=1){j[d]=0;}var e=String.fromCharCode.apply(String,j)+"\x01"+f;var h=pss_mgf1_str(n,e.length,o);var q=[];for(d=0;d<e.length;d+=1){q[d]=e.charCodeAt(d)^h.charCodeAt(d);}var p=(65280>>(8*c-m))&255;q[0]&=~p;for(d=0;d<g;d++){q.push(n.charCodeAt(d));}q.push(188);return _zeroPaddingOfSignature(this.doPrivate(new BigInteger(q)).toString(16),this.n.bitLength())};function _rsasign_getAlgNameAndHashFromHexDisgestInfo(f){for(var e in KJUR.crypto.Util.DIGESTINFOHEAD){var d=KJUR.crypto.Util.DIGESTINFOHEAD[e];var b=d.length;if(f.substring(0,b)==d){var c=[e,f.substring(b)];return c}}return []}RSAKey.prototype.verify=function(f,j){j=j.replace(_RE_HEXDECONLY,"");j=j.replace(/[ \n]+/g,"");var b=parseBigInt(j,16);if(b.bitLength()>this.n.bitLength()){return 0}var i=this.doPublic(b);var e=i.toString(16).replace(/^1f+00/,"");var g=_rsasign_getAlgNameAndHashFromHexDisgestInfo(e);if(g.length==0){return false}var d=g[0];var h=g[1];var a=function(k){return KJUR.crypto.Util.hashString(k,d)};var c=a(f);return(h==c)};RSAKey.prototype.verifyWithMessageHash=function(e,a){a=a.replace(_RE_HEXDECONLY,"");a=a.replace(/[ \n]+/g,"");var b=parseBigInt(a,16);if(b.bitLength()>this.n.bitLength()){return 0}var h=this.doPublic(b);var g=h.toString(16).replace(/^1f+00/,"");var c=_rsasign_getAlgNameAndHashFromHexDisgestInfo(g);if(c.length==0){return false}var d=c[0];var f=c[1];return(f==e)};RSAKey.prototype.verifyPSS=function(c,b,a,f){var e=function(g){return KJUR.crypto.Util.hashHex(g,a)};var d=e(rstrtohex(c));if(f===undefined){f=-1;}return this.verifyWithMessageHashPSS(d,b,a,f)};RSAKey.prototype.verifyWithMessageHashPSS=function(f,s,l,c){var k=new BigInteger(s,16);if(k.bitLength()>this.n.bitLength()){return false}var r=function(i){return KJUR.crypto.Util.hashHex(i,l)};var j=hextorstr(f);var h=j.length;var g=this.n.bitLength()-1;var m=Math.ceil(g/8);var q;if(c===-1||c===undefined){c=h;}else{if(c===-2){c=m-h-2;}else{if(c<-2){throw"invalid salt length"}}}if(m<(h+c+2)){throw"data too long"}var a=this.doPublic(k).toByteArray();for(q=0;q<a.length;q+=1){a[q]&=255;}while(a.length<m){a.unshift(0);}if(a[m-1]!==188){throw"encoded message does not end in 0xbc"}a=String.fromCharCode.apply(String,a);var d=a.substr(0,m-h-1);var e=a.substr(d.length,h);var p=(65280>>(8*m-g))&255;if((d.charCodeAt(0)&p)!==0){throw"bits beyond keysize not zero"}var n=pss_mgf1_str(e,d.length,r);var o=[];for(q=0;q<d.length;q+=1){o[q]=d.charCodeAt(q)^n.charCodeAt(q);}o[0]&=~p;var b=m-h-c-2;for(q=0;q<b;q+=1){if(o[q]!==0){throw"leftmost octets not zero"}}if(o[b]!==1){throw"0x01 marker not found"}return e===hextorstr(r(rstrtohex("\x00\x00\x00\x00\x00\x00\x00\x00"+j+String.fromCharCode.apply(String,o.slice(-c)))))};RSAKey.SALT_LEN_HLEN=-1;RSAKey.SALT_LEN_MAX=-2;RSAKey.SALT_LEN_RECOVER=-2;
	function X509(){var k=ASN1HEX,j=k.getChildIdx,h=k.getV,b=k.getTLV,f=k.getVbyList,c=k.getTLVbyList,g=k.getIdxbyList,d=k.getVidx,i=k.oidname,a=X509,e=pemtohex;this.hex=null;this.version=0;this.foffset=0;this.aExtInfo=null;this.getVersion=function(){if(this.hex===null||this.version!==0){return this.version}if(c(this.hex,0,[0,0])!=="a003020102"){this.version=1;this.foffset=-1;return 1}this.version=3;return 3};this.getSerialNumberHex=function(){return f(this.hex,0,[0,1+this.foffset],"02")};this.getSignatureAlgorithmField=function(){return i(f(this.hex,0,[0,2+this.foffset,0],"06"))};this.getIssuerHex=function(){return c(this.hex,0,[0,3+this.foffset],"30")};this.getIssuerString=function(){return a.hex2dn(this.getIssuerHex())};this.getSubjectHex=function(){return c(this.hex,0,[0,5+this.foffset],"30")};this.getSubjectString=function(){return a.hex2dn(this.getSubjectHex())};this.getNotBefore=function(){var l=f(this.hex,0,[0,4+this.foffset,0]);l=l.replace(/(..)/g,"%$1");l=decodeURIComponent(l);return l};this.getNotAfter=function(){var l=f(this.hex,0,[0,4+this.foffset,1]);l=l.replace(/(..)/g,"%$1");l=decodeURIComponent(l);return l};this.getPublicKeyHex=function(){return k.getTLVbyList(this.hex,0,[0,6+this.foffset],"30")};this.getPublicKeyIdx=function(){return g(this.hex,0,[0,6+this.foffset],"30")};this.getPublicKeyContentIdx=function(){var l=this.getPublicKeyIdx();return g(this.hex,l,[1,0],"30")};this.getPublicKey=function(){return KEYUTIL.getKey(this.getPublicKeyHex(),null,"pkcs8pub")};this.getSignatureAlgorithmName=function(){return i(f(this.hex,0,[1,0],"06"))};this.getSignatureValueHex=function(){return f(this.hex,0,[2],"03",true)};this.verifySignature=function(n){var o=this.getSignatureAlgorithmName();var l=this.getSignatureValueHex();var m=c(this.hex,0,[0],"30");var p=new KJUR.crypto.Signature({alg:o});p.init(n);p.updateHex(m);return p.verify(l)};this.parseExt=function(){if(this.version!==3){return -1}var p=g(this.hex,0,[0,7,0],"30");var m=j(this.hex,p);this.aExtInfo=new Array();for(var n=0;n<m.length;n++){var q={};q.critical=false;var l=j(this.hex,m[n]);var r=0;if(l.length===3){q.critical=true;r=1;}q.oid=k.hextooidstr(f(this.hex,m[n],[0],"06"));var o=g(this.hex,m[n],[1+r]);q.vidx=d(this.hex,o);this.aExtInfo.push(q);}};this.getExtInfo=function(n){var l=this.aExtInfo;var o=n;if(!n.match(/^[0-9.]+$/)){o=KJUR.asn1.x509.OID.name2oid(n);}if(o===""){return undefined}for(var m=0;m<l.length;m++){if(l[m].oid===o){return l[m]}}return undefined};this.getExtBasicConstraints=function(){var n=this.getExtInfo("basicConstraints");if(n===undefined){return n}var l=h(this.hex,n.vidx);if(l===""){return {}}if(l==="0101ff"){return {cA:true}}if(l.substr(0,8)==="0101ff02"){var o=h(l,6);var m=parseInt(o,16);return {cA:true,pathLen:m}}throw"basicConstraints parse error"};this.getExtKeyUsageBin=function(){var o=this.getExtInfo("keyUsage");if(o===undefined){return ""}var m=h(this.hex,o.vidx);if(m.length%2!=0||m.length<=2){throw"malformed key usage value"}var l=parseInt(m.substr(0,2));var n=parseInt(m.substr(2),16).toString(2);return n.substr(0,n.length-l)};this.getExtKeyUsageString=function(){var n=this.getExtKeyUsageBin();var l=new Array();for(var m=0;m<n.length;m++){if(n.substr(m,1)=="1"){l.push(X509.KEYUSAGE_NAME[m]);}}return l.join(",")};this.getExtSubjectKeyIdentifier=function(){var l=this.getExtInfo("subjectKeyIdentifier");if(l===undefined){return l}return h(this.hex,l.vidx)};this.getExtAuthorityKeyIdentifier=function(){var p=this.getExtInfo("authorityKeyIdentifier");if(p===undefined){return p}var l={};var o=b(this.hex,p.vidx);var m=j(o,0);for(var n=0;n<m.length;n++){if(o.substr(m[n],2)==="80"){l.kid=h(o,m[n]);}}return l};this.getExtExtKeyUsageName=function(){var p=this.getExtInfo("extKeyUsage");if(p===undefined){return p}var l=new Array();var o=b(this.hex,p.vidx);if(o===""){return l}var m=j(o,0);for(var n=0;n<m.length;n++){l.push(i(h(o,m[n])));}return l};this.getExtSubjectAltName=function(){var m=this.getExtSubjectAltName2();var l=new Array();for(var n=0;n<m.length;n++){if(m[n][0]==="DNS"){l.push(m[n][1]);}}return l};this.getExtSubjectAltName2=function(){var p,s,r;var q=this.getExtInfo("subjectAltName");if(q===undefined){return q}var l=new Array();var o=b(this.hex,q.vidx);var m=j(o,0);for(var n=0;n<m.length;n++){r=o.substr(m[n],2);p=h(o,m[n]);if(r==="81"){s=hextoutf8(p);l.push(["MAIL",s]);}if(r==="82"){s=hextoutf8(p);l.push(["DNS",s]);}if(r==="84"){s=X509.hex2dn(p,0);l.push(["DN",s]);}if(r==="86"){s=hextoutf8(p);l.push(["URI",s]);}if(r==="87"){s=hextoip(p);l.push(["IP",s]);}}return l};this.getExtCRLDistributionPointsURI=function(){var q=this.getExtInfo("cRLDistributionPoints");if(q===undefined){return q}var l=new Array();var m=j(this.hex,q.vidx);for(var o=0;o<m.length;o++){try{var r=f(this.hex,m[o],[0,0,0],"86");var p=hextoutf8(r);l.push(p);}catch(n){}}return l};this.getExtAIAInfo=function(){var p=this.getExtInfo("authorityInfoAccess");if(p===undefined){return p}var l={ocsp:[],caissuer:[]};var m=j(this.hex,p.vidx);for(var n=0;n<m.length;n++){var q=f(this.hex,m[n],[0],"06");var o=f(this.hex,m[n],[1],"86");if(q==="2b06010505073001"){l.ocsp.push(hextoutf8(o));}if(q==="2b06010505073002"){l.caissuer.push(hextoutf8(o));}}return l};this.getExtCertificatePolicies=function(){var o=this.getExtInfo("certificatePolicies");if(o===undefined){return o}var l=b(this.hex,o.vidx);var u=[];var s=j(l,0);for(var r=0;r<s.length;r++){var t={};var n=j(l,s[r]);t.id=i(h(l,n[0]));if(n.length===2){var m=j(l,n[1]);for(var q=0;q<m.length;q++){var p=f(l,m[q],[0],"06");if(p==="2b06010505070201"){t.cps=hextoutf8(f(l,m[q],[1]));}else{if(p==="2b06010505070202"){t.unotice=hextoutf8(f(l,m[q],[1,0]));}}}}u.push(t);}return u};this.readCertPEM=function(l){this.readCertHex(e(l));};this.readCertHex=function(l){this.hex=l;this.getVersion();try{g(this.hex,0,[0,7],"a3");this.parseExt();}catch(m){}};this.getInfo=function(){var B,u,z;B="Basic Fields\n";B+="  serial number: "+this.getSerialNumberHex()+"\n";B+="  signature algorithm: "+this.getSignatureAlgorithmField()+"\n";B+="  issuer: "+this.getIssuerString()+"\n";B+="  notBefore: "+this.getNotBefore()+"\n";B+="  notAfter: "+this.getNotAfter()+"\n";B+="  subject: "+this.getSubjectString()+"\n";B+="  subject public key info: \n";u=this.getPublicKey();B+="    key algorithm: "+u.type+"\n";if(u.type==="RSA"){B+="    n="+hextoposhex(u.n.toString(16)).substr(0,16)+"...\n";B+="    e="+hextoposhex(u.e.toString(16))+"\n";}z=this.aExtInfo;if(z!==undefined&&z!==null){B+="X509v3 Extensions:\n";for(var r=0;r<z.length;r++){var n=z[r];var A=KJUR.asn1.x509.OID.oid2name(n.oid);if(A===""){A=n.oid;}var x="";if(n.critical===true){x="CRITICAL";}B+="  "+A+" "+x+":\n";if(A==="basicConstraints"){var v=this.getExtBasicConstraints();if(v.cA===undefined){B+="    {}\n";}else{B+="    cA=true";if(v.pathLen!==undefined){B+=", pathLen="+v.pathLen;}B+="\n";}}else{if(A==="keyUsage"){B+="    "+this.getExtKeyUsageString()+"\n";}else{if(A==="subjectKeyIdentifier"){B+="    "+this.getExtSubjectKeyIdentifier()+"\n";}else{if(A==="authorityKeyIdentifier"){var l=this.getExtAuthorityKeyIdentifier();if(l.kid!==undefined){B+="    kid="+l.kid+"\n";}}else{if(A==="extKeyUsage"){var w=this.getExtExtKeyUsageName();B+="    "+w.join(", ")+"\n";}else{if(A==="subjectAltName"){var t=this.getExtSubjectAltName2();B+="    "+t+"\n";}else{if(A==="cRLDistributionPoints"){var y=this.getExtCRLDistributionPointsURI();B+="    "+y+"\n";}else{if(A==="authorityInfoAccess"){var p=this.getExtAIAInfo();if(p.ocsp!==undefined){B+="    ocsp: "+p.ocsp.join(",")+"\n";}if(p.caissuer!==undefined){B+="    caissuer: "+p.caissuer.join(",")+"\n";}}else{if(A==="certificatePolicies"){var o=this.getExtCertificatePolicies();for(var q=0;q<o.length;q++){if(o[q].id!==undefined){B+="    policy oid: "+o[q].id+"\n";}if(o[q].cps!==undefined){B+="    cps: "+o[q].cps+"\n";}}}}}}}}}}}}}B+="signature algorithm: "+this.getSignatureAlgorithmName()+"\n";B+="signature: "+this.getSignatureValueHex().substr(0,16)+"...\n";return B};}X509.hex2dn=function(f,b){if(b===undefined){b=0;}if(f.substr(b,2)!=="30"){throw"malformed DN"}var c=new Array();var d=ASN1HEX.getChildIdx(f,b);for(var e=0;e<d.length;e++){c.push(X509.hex2rdn(f,d[e]));}c=c.map(function(a){return a.replace("/","\\/")});return "/"+c.join("/")};X509.hex2rdn=function(f,b){if(b===undefined){b=0;}if(f.substr(b,2)!=="31"){throw"malformed RDN"}var c=new Array();var d=ASN1HEX.getChildIdx(f,b);for(var e=0;e<d.length;e++){c.push(X509.hex2attrTypeValue(f,d[e]));}c=c.map(function(a){return a.replace("+","\\+")});return c.join("+")};X509.hex2attrTypeValue=function(d,i){var j=ASN1HEX;var h=j.getV;if(i===undefined){i=0;}if(d.substr(i,2)!=="30"){throw"malformed attribute type and value"}var g=j.getChildIdx(d,i);if(g.length!==2||d.substr(g[0],2)!=="06");var b=h(d,g[0]);var f=KJUR.asn1.ASN1Util.oidHexToInt(b);var e=KJUR.asn1.x509.OID.oid2atype(f);var a=h(d,g[1]);var c=hextorstr(a);return e+"="+c};X509.getPublicKeyFromCertHex=function(b){var a=new X509();a.readCertHex(b);return a.getPublicKey()};X509.getPublicKeyFromCertPEM=function(b){var a=new X509();a.readCertPEM(b);return a.getPublicKey()};X509.getPublicKeyInfoPropOfCertPEM=function(c){var e=ASN1HEX;var g=e.getVbyList;var b={};var a,f;b.algparam=null;a=new X509();a.readCertPEM(c);f=a.getPublicKeyHex();b.keyhex=g(f,0,[1],"03").substr(2);b.algoid=g(f,0,[0,0],"06");if(b.algoid==="2a8648ce3d0201"){b.algparam=g(f,0,[0,1],"06");}return b};X509.KEYUSAGE_NAME=["digitalSignature","nonRepudiation","keyEncipherment","dataEncipherment","keyAgreement","keyCertSign","cRLSign","encipherOnly","decipherOnly"];
	if(typeof KJUR=="undefined"||!KJUR){KJUR={};}if(typeof KJUR.jws=="undefined"||!KJUR.jws){KJUR.jws={};}KJUR.jws.JWS=function(){var b=KJUR,a=b.jws.JWS,c=a.isSafeJSONString;this.parseJWS=function(g,j){if((this.parsedJWS!==undefined)&&(j||(this.parsedJWS.sigvalH!==undefined))){return}var i=g.match(/^([^.]+)\.([^.]+)\.([^.]+)$/);if(i==null){throw"JWS signature is not a form of 'Head.Payload.SigValue'."}var k=i[1];var e=i[2];var l=i[3];var n=k+"."+e;this.parsedJWS={};this.parsedJWS.headB64U=k;this.parsedJWS.payloadB64U=e;this.parsedJWS.sigvalB64U=l;this.parsedJWS.si=n;if(!j){var h=b64utohex(l);var f=parseBigInt(h,16);this.parsedJWS.sigvalH=h;this.parsedJWS.sigvalBI=f;}var d=b64utoutf8(k);var m=b64utoutf8(e);this.parsedJWS.headS=d;this.parsedJWS.payloadS=m;if(!c(d,this.parsedJWS,"headP")){throw"malformed JSON string for JWS Head: "+d}};};KJUR.jws.JWS.sign=function(i,v,y,z,a){var w=KJUR,m=w.jws,q=m.JWS,g=q.readSafeJSONString,p=q.isSafeJSONString,d=w.crypto,k=d.ECDSA,o=d.Mac,c=d.Signature,t=JSON;var s,j,n;if(typeof v!="string"&&typeof v!="object"){throw"spHeader must be JSON string or object: "+v}if(typeof v=="object"){j=v;s=t.stringify(j);}if(typeof v=="string"){s=v;if(!p(s)){throw"JWS Head is not safe JSON string: "+s}j=g(s);}n=y;if(typeof y=="object"){n=t.stringify(y);}if((i==""||i==null)&&j.alg!==undefined){i=j.alg;}if((i!=""&&i!=null)&&j.alg===undefined){j.alg=i;s=t.stringify(j);}if(i!==j.alg){throw"alg and sHeader.alg doesn't match: "+i+"!="+j.alg}var r=null;if(q.jwsalg2sigalg[i]===undefined){throw"unsupported alg name: "+i}else{r=q.jwsalg2sigalg[i];}var e=utf8tob64u(s);var l=utf8tob64u(n);var b=e+"."+l;var x="";if(r.substr(0,4)=="Hmac"){if(z===undefined){throw"mac key shall be specified for HS* alg"}var h=new o({alg:r,prov:"cryptojs",pass:z});h.updateString(b);x=h.doFinal();}else{if(r.indexOf("withECDSA")!=-1){var f=new c({alg:r});f.init(z,a);f.updateString(b);hASN1Sig=f.sign();x=KJUR.crypto.ECDSA.asn1SigToConcatSig(hASN1Sig);}else{if(r!="none"){var f=new c({alg:r});f.init(z,a);f.updateString(b);x=f.sign();}}}var u=hextob64u(x);return b+"."+u};KJUR.jws.JWS.verify=function(w,B,n){var x=KJUR,q=x.jws,t=q.JWS,i=t.readSafeJSONString,e=x.crypto,p=e.ECDSA,s=e.Mac,d=e.Signature,m;if(typeof RSAKey!==undefined){m=RSAKey;}var y=w.split(".");if(y.length!==3){return false}var f=y[0];var r=y[1];var c=f+"."+r;var A=b64utohex(y[2]);var l=i(b64utoutf8(y[0]));var k=null;var z=null;if(l.alg===undefined){throw"algorithm not specified in header"}else{k=l.alg;z=k.substr(0,2);}if(n!=null&&Object.prototype.toString.call(n)==="[object Array]"&&n.length>0){var b=":"+n.join(":")+":";if(b.indexOf(":"+k+":")==-1){throw"algorithm '"+k+"' not accepted in the list"}}if(k!="none"&&B===null){throw"key shall be specified to verify."}if(typeof B=="string"&&B.indexOf("-----BEGIN ")!=-1){B=KEYUTIL.getKey(B);}if(z=="RS"||z=="PS"){if(!(B instanceof m)){throw"key shall be a RSAKey obj for RS* and PS* algs"}}if(z=="ES"){if(!(B instanceof p)){throw"key shall be a ECDSA obj for ES* algs"}}var u=null;if(t.jwsalg2sigalg[l.alg]===undefined){throw"unsupported alg name: "+k}else{u=t.jwsalg2sigalg[k];}if(u=="none"){throw"not supported"}else{if(u.substr(0,4)=="Hmac"){var o=null;if(B===undefined){throw"hexadecimal key shall be specified for HMAC"}var j=new s({alg:u,pass:B});j.updateString(c);o=j.doFinal();return A==o}else{if(u.indexOf("withECDSA")!=-1){var h=null;try{h=p.concatSigToASN1Sig(A);}catch(v){return false}var g=new d({alg:u});g.init(B);g.updateString(c);return g.verify(h)}else{var g=new d({alg:u});g.init(B);g.updateString(c);return g.verify(A)}}}};KJUR.jws.JWS.parse=function(g){var c=g.split(".");var b={};var f,e,d;if(c.length!=2&&c.length!=3){throw"malformed sJWS: wrong number of '.' splitted elements"}f=c[0];e=c[1];if(c.length==3){d=c[2];}b.headerObj=KJUR.jws.JWS.readSafeJSONString(b64utoutf8(f));b.payloadObj=KJUR.jws.JWS.readSafeJSONString(b64utoutf8(e));b.headerPP=JSON.stringify(b.headerObj,null,"  ");if(b.payloadObj==null){b.payloadPP=b64utoutf8(e);}else{b.payloadPP=JSON.stringify(b.payloadObj,null,"  ");}if(d!==undefined){b.sigHex=b64utohex(d);}return b};KJUR.jws.JWS.verifyJWT=function(e,l,r){var d=KJUR,j=d.jws,o=j.JWS,n=o.readSafeJSONString,p=o.inArray,f=o.includedArray;var k=e.split(".");var c=k[0];var i=k[1];var m=b64utohex(k[2]);var h=n(b64utoutf8(c));var g=n(b64utoutf8(i));if(h.alg===undefined){return false}if(r.alg===undefined){throw"acceptField.alg shall be specified"}if(!p(h.alg,r.alg)){return false}if(g.iss!==undefined&&typeof r.iss==="object"){if(!p(g.iss,r.iss)){return false}}if(g.sub!==undefined&&typeof r.sub==="object"){if(!p(g.sub,r.sub)){return false}}if(g.aud!==undefined&&typeof r.aud==="object"){if(typeof g.aud=="string"){if(!p(g.aud,r.aud)){return false}}else{if(typeof g.aud=="object"){if(!f(g.aud,r.aud)){return false}}}}var b=j.IntDate.getNow();if(r.verifyAt!==undefined&&typeof r.verifyAt==="number"){b=r.verifyAt;}if(r.gracePeriod===undefined||typeof r.gracePeriod!=="number"){r.gracePeriod=0;}if(g.exp!==undefined&&typeof g.exp=="number"){if(g.exp+r.gracePeriod<b){return false}}if(g.nbf!==undefined&&typeof g.nbf=="number"){if(b<g.nbf-r.gracePeriod){return false}}if(g.iat!==undefined&&typeof g.iat=="number"){if(b<g.iat-r.gracePeriod){return false}}if(g.jti!==undefined&&r.jti!==undefined){if(g.jti!==r.jti){return false}}if(!o.verify(e,l,r.alg)){return false}return true};KJUR.jws.JWS.includedArray=function(b,a){var c=KJUR.jws.JWS.inArray;if(b===null){return false}if(typeof b!=="object"){return false}if(typeof b.length!=="number"){return false}for(var d=0;d<b.length;d++){if(!c(b[d],a)){return false}}return true};KJUR.jws.JWS.inArray=function(d,b){if(b===null){return false}if(typeof b!=="object"){return false}if(typeof b.length!=="number"){return false}for(var c=0;c<b.length;c++){if(b[c]==d){return true}}return false};KJUR.jws.JWS.jwsalg2sigalg={HS256:"HmacSHA256",HS384:"HmacSHA384",HS512:"HmacSHA512",RS256:"SHA256withRSA",RS384:"SHA384withRSA",RS512:"SHA512withRSA",ES256:"SHA256withECDSA",ES384:"SHA384withECDSA",PS256:"SHA256withRSAandMGF1",PS384:"SHA384withRSAandMGF1",PS512:"SHA512withRSAandMGF1",none:"none",};KJUR.jws.JWS.isSafeJSONString=function(c,b,d){var e=null;try{e=jsonParse(c);if(typeof e!="object"){return 0}if(e.constructor===Array){return 0}if(b){b[d]=e;}return 1}catch(a){return 0}};KJUR.jws.JWS.readSafeJSONString=function(b){var c=null;try{c=jsonParse(b);if(typeof c!="object"){return null}if(c.constructor===Array){return null}return c}catch(a){return null}};KJUR.jws.JWS.getEncodedSignatureValueFromJWS=function(b){var a=b.match(/^[^.]+\.[^.]+\.([^.]+)$/);if(a==null){throw"JWS signature is not a form of 'Head.Payload.SigValue'."}return a[1]};KJUR.jws.JWS.getJWKthumbprint=function(d){if(d.kty!=="RSA"&&d.kty!=="EC"&&d.kty!=="oct"){throw"unsupported algorithm for JWK Thumprint"}var a="{";if(d.kty==="RSA"){if(typeof d.n!="string"||typeof d.e!="string"){throw"wrong n and e value for RSA key"}a+='"e":"'+d.e+'",';a+='"kty":"'+d.kty+'",';a+='"n":"'+d.n+'"}';}else{if(d.kty==="EC"){if(typeof d.crv!="string"||typeof d.x!="string"||typeof d.y!="string"){throw"wrong crv, x and y value for EC key"}a+='"crv":"'+d.crv+'",';a+='"kty":"'+d.kty+'",';a+='"x":"'+d.x+'",';a+='"y":"'+d.y+'"}';}else{if(d.kty==="oct"){if(typeof d.k!="string"){throw"wrong k value for oct(symmetric) key"}a+='"kty":"'+d.kty+'",';a+='"k":"'+d.k+'"}';}}}var b=rstrtohex(a);var c=KJUR.crypto.Util.hashHex(b,"sha256");var e=hextob64u(c);return e};KJUR.jws.IntDate={};KJUR.jws.IntDate.get=function(c){var b=KJUR.jws.IntDate,d=b.getNow,a=b.getZulu;if(c=="now"){return d()}else{if(c=="now + 1hour"){return d()+60*60}else{if(c=="now + 1day"){return d()+60*60*24}else{if(c=="now + 1month"){return d()+60*60*24*30}else{if(c=="now + 1year"){return d()+60*60*24*365}else{if(c.match(/Z$/)){return a(c)}else{if(c.match(/^[0-9]+$/)){return parseInt(c)}}}}}}}throw"unsupported format: "+c};KJUR.jws.IntDate.getZulu=function(a){return zulutosec(a)};KJUR.jws.IntDate.getNow=function(){var a=~~(new Date()/1000);return a};KJUR.jws.IntDate.intDate2UTCString=function(a){var b=new Date(a*1000);return b.toUTCString()};KJUR.jws.IntDate.intDate2Zulu=function(e){var i=new Date(e*1000),h=("0000"+i.getUTCFullYear()).slice(-4),g=("00"+(i.getUTCMonth()+1)).slice(-2),b=("00"+i.getUTCDate()).slice(-2),a=("00"+i.getUTCHours()).slice(-2),c=("00"+i.getUTCMinutes()).slice(-2),f=("00"+i.getUTCSeconds()).slice(-2);return h+g+b+a+c+f+"Z"};
	if(typeof KJUR=="undefined"||!KJUR){KJUR={};}if(typeof KJUR.jws=="undefined"||!KJUR.jws){KJUR.jws={};}KJUR.jws.JWSJS=function(){var c=KJUR,b=c.jws,a=b.JWS,d=a.readSafeJSONString;this.aHeader=[];this.sPayload="";this.aSignature=[];this.init=function(){this.aHeader=[];this.sPayload=undefined;this.aSignature=[];};this.initWithJWS=function(f){this.init();var e=f.split(".");if(e.length!=3){throw"malformed input JWS"}this.aHeader.push(e[0]);this.sPayload=e[1];this.aSignature.push(e[2]);};this.addSignature=function(e,h,m,k){if(this.sPayload===undefined||this.sPayload===null){throw"there's no JSON-JS signature to add."}var l=this.aHeader.length;if(this.aHeader.length!=this.aSignature.length){throw"aHeader.length != aSignature.length"}try{var f=KJUR.jws.JWS.sign(e,h,this.sPayload,m,k);var j=f.split(".");var n=j[0];var g=j[2];this.aHeader.push(j[0]);this.aSignature.push(j[2]);}catch(i){if(this.aHeader.length>l){this.aHeader.pop();}if(this.aSignature.length>l){this.aSignature.pop();}throw"addSignature failed: "+i}};this.verifyAll=function(h){if(this.aHeader.length!==h.length||this.aSignature.length!==h.length){return false}for(var g=0;g<h.length;g++){var f=h[g];if(f.length!==2){return false}var e=this.verifyNth(g,f[0],f[1]);if(e===false){return false}}return true};this.verifyNth=function(f,j,g){if(this.aHeader.length<=f||this.aSignature.length<=f){return false}var h=this.aHeader[f];var k=this.aSignature[f];var l=h+"."+this.sPayload+"."+k;var e=false;try{e=a.verify(l,j,g);}catch(i){return false}return e};this.readJWSJS=function(g){if(typeof g==="string"){var f=d(g);if(f==null){throw"argument is not safe JSON object string"}this.aHeader=f.headers;this.sPayload=f.payload;this.aSignature=f.signatures;}else{try{if(g.headers.length>0){this.aHeader=g.headers;}else{throw"malformed header"}if(typeof g.payload==="string"){this.sPayload=g.payload;}else{throw"malformed signatures"}if(g.signatures.length>0){this.aSignatures=g.signatures;}else{throw"malformed signatures"}}catch(e){throw"malformed JWS-JS JSON object: "+e}}};this.getJSON=function(){return {headers:this.aHeader,payload:this.sPayload,signatures:this.aSignature}};this.isEmpty=function(){if(this.aHeader.length==0){return 1}return 0};};
	var ECDSA = KJUR.crypto.ECDSA;
	var DSA = KJUR.crypto.DSA;
	var Signature = KJUR.crypto.Signature;
	var MessageDigest = KJUR.crypto.MessageDigest;
	var Mac = KJUR.crypto.Mac;
	var Cipher = KJUR.crypto.Cipher;
	var KEYUTIL_1 = KEYUTIL;
	var b64utoutf8_1 = b64utoutf8;
	var crypto_1 = KJUR.crypto;
	var asn1 = KJUR.asn1;
	var jws = KJUR.jws;
	var lang = KJUR.lang;

	//      

	const swarmPublicKey  = `-----BEGIN PUBLIC KEY-----
MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAmkXOuNfY8u5xoTiIhkb8
djnbIwG/Wrz3vpo8BZir8L5e1a1nSy740qBjP7ZINBQoALDhFfmdOfJnCyEGiHuz
ZW6jbG6C3PryE3Bu6GKwqSmD6k3q4Zk27fpwYAnNl+rWhYYM563rJZBda/INyHNN
pK7M1mixWi7gNdjjXwoEXSSBx+VpYMkY6LiAB2mvHXTY9M1qI14dvgGoQISZQoKi
NMTRCg5UP2ic0Dd9nSz/XpcOxGfa+0fwIl1F7RC1tJXOqvkGGPTOV4LLfg/Yta3h
nUPX9EZZDIX6vO/0IBV1LzjSl2A1bYFYAjJfowv3i1CpvONBOClHjSY5t9Y8MH6p
BwIDAQAB
-----END PUBLIC KEY-----`;

	//      

	var newFrom = (instance     , ToClass     ) => {
	  const args = {};
	  Object.getOwnPropertyNames(instance).forEach(prop => {
	    args[prop] = instance[prop];
	  });

	  return new ToClass(args);
	};

	//      

	                  
	                  
	                
	             
	                                               
	  

	                        
	             
	                                              
	                    
	  

	                     
	                             
	                           
	                          
	                               
	             
	  

	                      
	             
	                               
	                                   
	                                 
	                                
	  

	class Line {
	             
	                               
	                                  
	                                
	                               

	  static parse(plain              )       {
	    return new Line({
	      id: plain.id,
	      extensions: plain.extensions,
	      endpointCustom: plain.endpoint_custom || null,
	      endpointSccp: plain.endpoint_sccp || null,
	      endpointSip: plain.endpoint_sip || null,
	    });
	  }

	  static newFrom(profile      ) {
	    return newFrom(profile, Line);
	  }

	  is(line      ) {
	    return this.id === line.id;
	  }

	  hasExtension(extension        ) {
	    return this.extensions.some(ext => ext.exten === extension);
	  }

	  constructor({ id, extensions, endpointCustom, endpointSccp, endpointSip }                = {}) {
	    this.id = id;
	    this.extensions = extensions;
	    this.endpointCustom = endpointCustom || null;
	    this.endpointSccp = endpointSccp || null;
	    this.endpointSip = endpointSip || null;
	  }
	}

	//      

	                 
	                      
	                   
	  

	const FORWARD_KEYS = {
	  BUSY: 'busy',
	  NO_ANSWER: 'noanswer',
	  UNCONDITIONAL: 'unconditional',
	};

	                               
	                      
	                   
	              
	  

	class ForwardOption {
	                      
	                   
	              

	  static parse(plain          , key        )                {
	    return new ForwardOption({
	      destination: plain.destination || '',
	      enabled: plain.enabled,
	      key,
	    });
	  }

	  static newFrom(profile               ) {
	    return newFrom(profile, ForwardOption);
	  }

	  constructor({ destination, enabled, key }                         = {}) {
	    this.destination = destination;
	    this.enabled = enabled;
	    this.key = key;
	  }

	  setDestination(number        )                {
	    this.destination = number;

	    return this;
	  }

	  setEnabled(enabled         )                {
	    this.enabled = enabled;

	    return this;
	  }

	  is(other               ) {
	    return this.key === other.key;
	  }
	}

	//      
	                                       

	const PRESENCE = {
	  AVAILABLE: 'available',
	  DO_NOT_DISTURB: 'donotdisturb',
	  DISCONNECTED: 'disconnected',
	};

	const STATE = {
	  AVAILABLE: 'available',
	  UNAVAILABLE: 'unavailable',
	  INVISIBLE: 'invisible',
	  AWAY: 'away',
	};

	const LINE_STATE = {
	  AVAILABLE: 'available',
	  HOLDING: 'holding',
	  RINGING: 'ringing',
	  TALKING: 'talking',
	  UNAVAILABLE: 'unavailable',
	};

	                        
	                                              
	                    
	                     
	                   
	                    
	               
	                
	               
	                                                                                                                    
	                                      
	                                    
	                                   
	     
	             
	                   
	                    
	                   
	                
	             
	           
	                          
	                       
	      
	               
	                          
	                       
	      
	                    
	                          
	                       
	      
	    
	                               
	                             
	             
	          
	                       
	      
	    
	                           
	               
	               
	                 
	    
	  

	                         
	             
	                    
	                   
	                
	                     
	                   
	                       
	                                 
	                         
	                    
	                 
	                            
	               
	               
	                 
	    
	                           
	  

	class Profile {
	             
	                    
	                   
	                
	                     
	                   
	                       
	                                 
	                         
	                    
	                                           
	                 
	                            
	                           

	  static parse(plain                 )          {
	    return new Profile({
	      id: plain.uuid,
	      firstName: plain.firstName || plain.firstname || '',
	      lastName: plain.lastName || plain.lastname || '',
	      email: plain.email,
	      lines: plain.lines.map(line => Line.parse(line)),
	      username: plain.username,
	      mobileNumber: plain.mobile_phone_number || '',
	      forwards: [
	        ForwardOption.parse(plain.forwards.unconditional, FORWARD_KEYS.UNCONDITIONAL),
	        ForwardOption.parse(plain.forwards.noanswer, FORWARD_KEYS.NO_ANSWER),
	        ForwardOption.parse(plain.forwards.busy, FORWARD_KEYS.BUSY),
	      ],
	      doNotDisturb: plain.services.dnd.enabled,
	      subscriptionType: plain.subscription_type,
	      voicemail: plain.voicemail,
	      switchboards: plain.switchboards || [],
	      status: '',
	    });
	  }

	  static newFrom(profile         ) {
	    return newFrom(profile, Profile);
	  }

	  constructor({
	    id,
	    firstName,
	    lastName,
	    email,
	    lines,
	    username,
	    mobileNumber,
	    forwards,
	    doNotDisturb,
	    presence,
	    subscriptionType,
	    voicemail,
	    switchboards,
	    status,
	  }                           = {}) {
	    this.id = id;
	    this.firstName = firstName;
	    this.lastName = lastName;
	    this.email = email;
	    this.lines = lines;
	    this.username = username;
	    this.mobileNumber = mobileNumber;
	    this.forwards = forwards;
	    this.doNotDisturb = doNotDisturb;
	    this.presence = presence;
	    this.voicemail = voicemail;
	    this.subscriptionType = subscriptionType;
	    this.switchboards = switchboards;
	    this.status = status;
	  }

	  static getLinesState(lines               ) {
	    let result = LINE_STATE.UNAVAILABLE;

	    // eslint-disable-next-line
	    for (const line of lines) {
	      if (line.state === LINE_STATE.RINGING) {
	        result = LINE_STATE.RINGING;
	        break;
	      }

	      if (line.state === LINE_STATE.TALKING) {
	        result = LINE_STATE.TALKING;
	        break;
	      }

	      if (line.state === LINE_STATE.AVAILABLE) {
	        result = LINE_STATE.AVAILABLE;
	      }
	    }

	    return result;
	  }

	  hasId(id        ) {
	    return id === this.id;
	  }

	  setMobileNumber(number        ) {
	    this.mobileNumber = number;

	    return this;
	  }

	  setForwardOption(forwardOption               ) {
	    const updatedForwardOptions = this.forwards.slice();
	    const index = updatedForwardOptions.findIndex(forward => forward.is(forwardOption));
	    updatedForwardOptions.splice(index, 1, forwardOption);

	    this.forwards = updatedForwardOptions;

	    return this;
	  }

	  setDoNotDisturb(enabled         ) {
	    this.doNotDisturb = enabled;

	    return this;
	  }

	  setPresence(presence        ) {
	    this.presence = presence;

	    return this;
	  }
	}

	//      
	                                                         

	const BACKEND = {
	  OFFICE365: 'office365',
	  PERSONAL: 'personal',
	  GOOGLE: 'google',
	  WAZO: 'wazo',
	};

	                          
	                    
	                   
	                      
	                 
	                   
	                      
	                    
	                
	  

	                               
	                 
	                  
	                            
	              
	                    
	                    
	                      
	                        
	                      
	                            
	    
	  

	                                
	                               
	               
	                                
	                                  
	  

	                                       
	             
	                     
	                    
	                  
	                                                     
	                 
	                                                    
	                      
	                    
	                   
	                
	                    
	                     
	                    
	                   
	  

	// @see: https://github.com/rt2zz/react-native-contacts#example-contact-record
	                                     
	                   
	                  
	                         
	                  
	                  
	     
	                    
	                     
	                     
	                   
	               
	                       
	                  
	                
	     
	                       
	                  
	                   
	     
	                        
	                        
	                          
	                   
	                 
	                  
	                   
	                     
	                    
	                  
	     
	             
	                 
	                  
	                
	    
	  

	                         
	              
	                
	                
	                  
	                                                     
	                      
	                 
	                                                   
	                      
	                    
	                   
	                
	                      
	                     
	                    
	                  
	                    
	                  
	                      
	                
	                   
	                          
	  

	                          
	                     
	                
	                       
	                        
	                             
	                         
	                    
	                       
	                   
	                          
	                  
	                      
	                                                           
	                 
	                  
	                 
	                   
	                       
	             
	                   
	                
	                
	                               
	               
	                  
	                      
	                
	                      
	                    
	                         
	                        
	                  
	                  
	                  
	             
	                       
	                     
	                   
	  

	                     
	                
	                
	                    
	                   
	                           
	               
	             
	                        
	  
	                           
	                  
	               
	             
	                                                        
	                                                     
	  

	                       
	                   
	             
	               
	                    
	                        
	  

	const SOURCE_MOBILE = 'mobile';

	class Contact {
	              
	                
	                
	                  
	                                                     
	                      
	                 
	                                                   
	                      
	                    
	                   
	                
	                      
	                     
	                    
	                  
	                   
	                  
	                   
	                         

	  static merge(oldContacts                , newContacts                )                 {
	    return newContacts.map(current => {
	      const old = oldContacts.find(contact => contact.is(current));

	      return typeof old !== 'undefined' ? current.merge(old) : current;
	    });
	  }

	  static sortContacts(a         , b         ) {
	    const aNames = a.separateName();
	    const bNames = b.separateName();
	    const aLastName = aNames.lastName;
	    const bLastName = bNames.lastName;

	    // last Name can be empty
	    if (aLastName === bLastName) {
	      return aNames.firstName.localeCompare(bNames.firstName);
	    }

	    return aLastName.localeCompare(bLastName);
	  }

	  static parseMany(response                  )                 {
	    return response.results.map(r => Contact.parse(r, response.column_types));
	  }

	  static parseMultipleNumber(plain                 , columns                ) {
	    const numberColumns = columns
	      .map((e, index) => ({ index, columnName: e }))
	      .filter(e => e.columnName === 'number')
	      .map(e => e.index);

	    const number = plain.column_values.find((e, index) => numberColumns.some(i => i === index) && e !== null);

	    return number || '';
	  }

	  static parse(plain                 , columns                )          {
	    const number = Contact.parseMultipleNumber(plain, columns);
	    const email = plain.column_values[columns.indexOf('email')];
	    return new Contact({
	      name: plain.column_values[columns.indexOf('name')],
	      number: number || '',
	      numbers: number ? [{ label: 'primary', number }] : [],
	      favorited: plain.column_values[columns.indexOf('favorite')],
	      email: email || '',
	      emails: email ? [{ label: 'primary', email }] : [],
	      entreprise: plain.column_values[columns.indexOf('entreprise')] || '',
	      birthday: plain.column_values[columns.indexOf('birthday')] || '',
	      address: plain.column_values[columns.indexOf('address')] || '',
	      note: plain.column_values[columns.indexOf('note')] || '',
	      endpointId: plain.relations.endpoint_id,
	      personal: plain.column_values[columns.indexOf('personal')],
	      source: plain.source,
	      sourceId: plain.relations.source_entry_id,
	      uuid: plain.relations.user_uuid,
	      backend: plain.backend || '',
	    });
	  }

	  static parseManyPersonal(results                                )                  {
	    return results.map(r => Contact.parsePersonal(r));
	  }

	  static parsePersonal(plain                         )          {
	    return new Contact({
	      name: `${plain.firstName || plain.firstname || ''} ${plain.lastName || plain.lastname || ''}`,
	      number: plain.number || '',
	      numbers: plain.number ? [{ label: 'primary', number: plain.number }] : [],
	      email: plain.email || '',
	      emails: plain.email ? [{ label: 'primary', email: plain.email }] : [],
	      source: 'personal',
	      sourceId: plain.id,
	      entreprise: plain.entreprise || '',
	      birthday: plain.birthday || '',
	      address: plain.address || '',
	      note: plain.note || '',
	      favorited: false,
	      personal: true,
	      backend: plain.backend || BACKEND.PERSONAL,
	    });
	  }

	  static parseMobile(plain                       )          {
	    let address = '';
	    if (plain.postalAddresses.length) {
	      const postalAddress = plain.postalAddresses[0];

	      address = `${postalAddress.street} ${postalAddress.city} ${postalAddress.postCode} ${postalAddress.country}`;
	    }

	    return new Contact({
	      name: `${plain.givenName || ''} ${plain.familyName || ''}`,
	      number: plain.phoneNumbers.length ? plain.phoneNumbers[0].number : '',
	      numbers: plain.phoneNumbers.length ? [{ label: 'primary', number: plain.phoneNumbers[0].number }] : [],
	      email: plain.emailAddresses.length ? plain.emailAddresses[0].email : '',
	      emails: plain.emailAddresses.length ? [{ label: 'primary', email: plain.emailAddresses[0].email }] : [],
	      source: SOURCE_MOBILE,
	      sourceId: plain.recordID,
	      birthday: plain.birthday ? `${plain.birthday.year}-${plain.birthday.month}-${plain.birthday.day}` : '',
	      address,
	      note: plain.note || '',
	      favorited: false,
	      personal: true,
	    });
	  }

	  static parseManyOffice365(response                     , source                 )                 {
	    return response.map(r => Contact.parseOffice365(r, source));
	  }

	  static parseOffice365(single                   , source                 )          {
	    const emails = [];
	    const numbers = [];

	    if (single.emailAddresses) {
	      const formattedEmails = single.emailAddresses.map(email => ({ label: 'email', email: email.address }));
	      emails.push(...formattedEmails);
	    }

	    if (single.homePhones) {
	      const formattedPhones = single.homePhones.map(phone => ({ label: 'home', number: phone }));
	      numbers.push(...formattedPhones);
	    }

	    if (single.mobilePhone) {
	      numbers.push({ label: 'mobile', number: single.mobilePhone });
	    }

	    return new Contact({
	      sourceId: single.id,
	      name: single.displayName,
	      numbers,
	      emails,
	      source: source.name,
	      backend: BACKEND.OFFICE365,
	    });
	  }

	  static parseManyGoogle(response                  , source                 )                 {
	    return response.map(r => Contact.parseGoogle(r, source));
	  }

	  static parseGoogle(single                , source                 )          {
	    const emails = [];
	    const numbers = [];

	    if (single.emails) {
	      const formattedEmails = single.emails.map(email => ({ label: 'email', email }));
	      emails.push(...formattedEmails);
	    }

	    if (single.numbers) {
	      const formattedPhones = single.numbers.map(phone => ({ label: 'mobile', number: phone }));
	      numbers.push(...formattedPhones);
	    }

	    return new Contact({
	      sourceId: single.id,
	      name: single.name,
	      numbers,
	      emails,
	      source: source.name,
	      backend: BACKEND.GOOGLE,
	    });
	  }

	  static parseManyWazo(response                , source                 )                 {
	    return response.map(r => Contact.parseWazo(r, source));
	  }

	  static parseWazo(single              , source                 )          {
	    const emails = [];
	    const numbers = [];

	    if (single.email) {
	      emails.push({ label: 'email', email: single.email });
	    }

	    if (single.exten) {
	      numbers.push({ label: 'exten', number: single.exten });
	    }

	    if (single.mobile_phone_number) {
	      numbers.push({ label: 'mobile', number: single.mobile_phone_number });
	    }

	    return new Contact({
	      uuid: single.uuid,
	      sourceId: String(single.id),
	      name: `${single.firstname} ${single.lastname}`,
	      numbers,
	      emails,
	      source: source.name,
	      backend: BACKEND.WAZO,
	    });
	  }

	  static parseManyConference(response                      , source                 )                 {
	    return response.map(r => Contact.parseConference(r, source));
	  }

	  static parseConference(single                    , source                 )          {
	    const numbers = [];

	    if (single.extensions.length > 0 && single.extensions[0].exten) {
	      numbers.push({ label: 'exten', number: single.extensions[0].exten });
	    }

	    return new Contact({
	      sourceId: String(single.id),
	      name: single.name,
	      numbers,
	      source: source.name,
	      backend: 'conference',
	    });
	  }

	  static newFrom(profile         ) {
	    return newFrom(profile, Contact);
	  }

	  constructor({
	    id,
	    uuid,
	    name,
	    number,
	    numbers,
	    email,
	    emails,
	    source,
	    sourceId,
	    entreprise,
	    birthday,
	    address,
	    note,
	    presence,
	    status,
	    endpointId,
	    personal,
	    favorited,
	    backend,
	    personalStatus,
	  }                   = {}) {
	    this.id = id;
	    this.uuid = uuid;
	    this.name = name;
	    this.number = number;
	    this.numbers = numbers;
	    this.email = email;
	    this.emails = emails;
	    this.source = source;
	    this.sourceId = sourceId || '';
	    this.entreprise = entreprise;
	    this.birthday = birthday;
	    this.address = address;
	    this.note = note;
	    this.presence = presence;
	    this.status = status;
	    this.endpointId = endpointId;
	    this.personal = personal;
	    this.favorited = favorited;
	    this.backend = backend;
	    this.personalStatus = personalStatus || '';
	  }

	  setFavorite(value         ) {
	    this.favorited = value;

	    return this;
	  }

	  is(other         )          {
	    const sameSourceId = !!this.sourceId && !!other.sourceId && this.sourceId === other.sourceId;
	    const sameUuid = !!this.uuid && !!other.uuid && this.uuid === other.uuid;

	    const hasSameId = sameSourceId || sameUuid;
	    const hasSameBackend = !!this.backend && !!other.backend && this.backend === other.backend;
	    const hasSameSource = !!this.source && !!other.source && this.source === other.source;

	    return !!other && hasSameId && hasSameBackend && hasSameSource;
	  }

	  hasId(id        )          {
	    return this.uuid === id;
	  }

	  hasNumber(number        )          {
	    return this.number === number;
	  }

	  hasEndpointId(endpointId        )          {
	    return this.endpointId === endpointId;
	  }

	  isAvailable()          {
	    return this.presence === STATE.AVAILABLE;
	  }

	  isAway()          {
	    return this.presence === STATE.AWAY;
	  }

	  isUnavailable()          {
	    return this.presence === STATE.UNAVAILABLE;
	  }

	  isInvisible()          {
	    return this.presence === STATE.INVISIBLE;
	  }

	  isDoNotDisturb()          {
	    return this.presence === PRESENCE.DO_NOT_DISTURB;
	  }

	  isDisconnected()          {
	    return this.presence === PRESENCE.DISCONNECTED;
	  }

	  isInCall()          {
	    return this.status === LINE_STATE.TALKING || this.status === LINE_STATE.HOLDING;
	  }

	  isRinging()          {
	    return this.status === LINE_STATE.RINGING;
	  }

	  isInUseOrRinging()          {
	    return this.status === LINE_STATE.TALKING || this.status === LINE_STATE.RINGING;
	  }

	  merge(old         )          {
	    this.presence = old.presence;
	    this.status = old.status;

	    return this;
	  }

	  isIntern()          {
	    return !!this.uuid;
	  }

	  isCallable(session         )          {
	    return !!this.number && !!session && !session.is(this);
	  }

	  isFromMobile() {
	    return this.source === SOURCE_MOBILE;
	  }

	  isFavorite() {
	    return this.favorited;
	  }

	  separateName()                                          {
	    if (!this.name) {
	      return {
	        firstName: '',
	        lastName: '',
	      };
	    }
	    const names = this.name.split(/\s+/);
	    const firstName = names[0];
	    const lastName = names.slice(1).join(' ');

	    return {
	      firstName,
	      lastName,
	    };
	  }
	}

	//      

	const swarmKey = KEYUTIL_1.getKey(swarmPublicKey);
	const MINIMUM_WAZO_ENGINE_VERSION_FOR_DEFAULT_CONTEXT = 19.08;

	                 
	         
	                 
	                        
	                           
	                      
	                      
	                    
	                       
	                            
	                
	                   
	                        
	                 
	                         
	                            
	                             
	                       
	                                      
	                     
	      
	    
	  

	                      
	               
	                                                  
	                   
	  

	                         
	                
	                 
	                       
	                     
	                  
	                                        
	                          
	  

	class Session {
	                
	                
	                      
	                         
	                    
	                  
	                                       

	  static parse(plain          )           {
	    const token = plain.data.metadata ? plain.data.metadata.jwt : null;
	    let authorizations = [];

	    // Add authorizations from JWT
	    if (token) {
	      const isValid = jws.JWS.verifyJWT(token, swarmKey, { alg: ['RS256'], verifyAt: new Date() });
	      if (isValid) {
	        const decodedToken = jws.JWS.readSafeJSONString(b64utoutf8_1(token.split('.')[1]));
	        authorizations = decodedToken ? decodedToken.authorizations : [];
	      }
	    }

	    return new Session({
	      token: plain.data.token,
	      uuid: plain.data.metadata ? plain.data.metadata.uuid : null,
	      authorizations,
	      tenantUuid: plain.data.metadata ? plain.data.metadata.tenant_uuid : undefined,
	      expiresAt: new Date(`${plain.data.utc_expires_at}z`),
	    });
	  }

	  static newFrom(profile         ) {
	    return newFrom(profile, Session);
	  }

	  constructor({ token, uuid, tenantUuid, profile, expiresAt, authorizations, engineVersion }                   = {}) {
	    this.token = token;
	    this.uuid = uuid;
	    this.tenantUuid = tenantUuid || null;
	    this.profile = profile;
	    this.expiresAt = expiresAt;
	    this.authorizations = authorizations || [];
	    this.engineVersion = engineVersion;
	  }

	  hasExpired(date       = new Date())          {
	    return date >= this.expiresAt;
	  }

	  is(contact         )          {
	    return Boolean(contact) && this.uuid === contact.uuid;
	  }

	  using(profile         )          {
	    this.profile = profile;

	    return this;
	  }

	  hasAuthorizations() {
	    return this.authorizations && !!this.authorizations.length;
	  }

	  displayName()         {
	    return this.profile ? `${this.profile.firstName} ${this.profile.lastName}` : '';
	  }

	  hasAccessToVoicemail()          {
	    if (!this.profile) {
	      return false;
	    }
	    return !!this.profile.voicemail;
	  }

	  primaryLine()        {
	    return this.profile && this.profile.lines.length > 0 ? this.profile.lines[0] : null;
	  }

	  primaryContext()         {
	    if (this.engineVersion) {
	      const versionNumber = Number(this.engineVersion);

	      if (versionNumber && versionNumber >= MINIMUM_WAZO_ENGINE_VERSION_FOR_DEFAULT_CONTEXT) {
	        return 'default';
	      }
	    }

	    const line = this.primaryLine();

	    return line && line.extensions.length > 0 ? line.extensions[0].context : 'default';
	  }

	  primaryNumber()          {
	    const line = this.primaryLine();

	    return line ? line.extensions[0].exten : null;
	  }

	  allLines()         {
	    return this.profile ? this.profile.lines || [] : [];
	  }

	  allNumbers()           {
	    const extensions = this.allLines().map(line => line.extensions.map(extension => extension.exten));
	    if (!extensions.length) {
	      return [];
	    }

	    return extensions.reduce((a, b) => a.concat(b));
	  }

	  hasExtension(extension        )          {
	    return this.allNumbers().some(number => number === extension);
	  }
	}

	var base64 = createCommonjsModule(function (module, exports) {
	(function (global, factory) {
	     module.exports = factory(global)
	        ;
	}((
	    typeof self !== 'undefined' ? self
	        : typeof window !== 'undefined' ? window
	        : typeof commonjsGlobal !== 'undefined' ? commonjsGlobal
	: commonjsGlobal
	), function(global) {
	    // existing version for noConflict()
	    global = global || {};
	    var _Base64 = global.Base64;
	    var version = "2.5.1";
	    // if node.js and NOT React Native, we use Buffer
	    var buffer;
	    if ( module.exports) {
	        try {
	            buffer = eval("require('buffer').Buffer");
	        } catch (err) {
	            buffer = undefined;
	        }
	    }
	    // constants
	    var b64chars
	        = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
	    var b64tab = function(bin) {
	        var t = {};
	        for (var i = 0, l = bin.length; i < l; i++) t[bin.charAt(i)] = i;
	        return t;
	    }(b64chars);
	    var fromCharCode = String.fromCharCode;
	    // encoder stuff
	    var cb_utob = function(c) {
	        if (c.length < 2) {
	            var cc = c.charCodeAt(0);
	            return cc < 0x80 ? c
	                : cc < 0x800 ? (fromCharCode(0xc0 | (cc >>> 6))
	                                + fromCharCode(0x80 | (cc & 0x3f)))
	                : (fromCharCode(0xe0 | ((cc >>> 12) & 0x0f))
	                   + fromCharCode(0x80 | ((cc >>>  6) & 0x3f))
	                   + fromCharCode(0x80 | ( cc         & 0x3f)));
	        } else {
	            var cc = 0x10000
	                + (c.charCodeAt(0) - 0xD800) * 0x400
	                + (c.charCodeAt(1) - 0xDC00);
	            return (fromCharCode(0xf0 | ((cc >>> 18) & 0x07))
	                    + fromCharCode(0x80 | ((cc >>> 12) & 0x3f))
	                    + fromCharCode(0x80 | ((cc >>>  6) & 0x3f))
	                    + fromCharCode(0x80 | ( cc         & 0x3f)));
	        }
	    };
	    var re_utob = /[\uD800-\uDBFF][\uDC00-\uDFFFF]|[^\x00-\x7F]/g;
	    var utob = function(u) {
	        return u.replace(re_utob, cb_utob);
	    };
	    var cb_encode = function(ccc) {
	        var padlen = [0, 2, 1][ccc.length % 3],
	        ord = ccc.charCodeAt(0) << 16
	            | ((ccc.length > 1 ? ccc.charCodeAt(1) : 0) << 8)
	            | ((ccc.length > 2 ? ccc.charCodeAt(2) : 0)),
	        chars = [
	            b64chars.charAt( ord >>> 18),
	            b64chars.charAt((ord >>> 12) & 63),
	            padlen >= 2 ? '=' : b64chars.charAt((ord >>> 6) & 63),
	            padlen >= 1 ? '=' : b64chars.charAt(ord & 63)
	        ];
	        return chars.join('');
	    };
	    var btoa = global.btoa ? function(b) {
	        return global.btoa(b);
	    } : function(b) {
	        return b.replace(/[\s\S]{1,3}/g, cb_encode);
	    };
	    var _encode = buffer ?
	        buffer.from && Uint8Array && buffer.from !== Uint8Array.from
	        ? function (u) {
	            return (u.constructor === buffer.constructor ? u : buffer.from(u))
	                .toString('base64')
	        }
	        :  function (u) {
	            return (u.constructor === buffer.constructor ? u : new  buffer(u))
	                .toString('base64')
	        }
	        : function (u) { return btoa(utob(u)) }
	    ;
	    var encode = function(u, urisafe) {
	        return !urisafe
	            ? _encode(String(u))
	            : _encode(String(u)).replace(/[+\/]/g, function(m0) {
	                return m0 == '+' ? '-' : '_';
	            }).replace(/=/g, '');
	    };
	    var encodeURI = function(u) { return encode(u, true) };
	    // decoder stuff
	    var re_btou = new RegExp([
	        '[\xC0-\xDF][\x80-\xBF]',
	        '[\xE0-\xEF][\x80-\xBF]{2}',
	        '[\xF0-\xF7][\x80-\xBF]{3}'
	    ].join('|'), 'g');
	    var cb_btou = function(cccc) {
	        switch(cccc.length) {
	        case 4:
	            var cp = ((0x07 & cccc.charCodeAt(0)) << 18)
	                |    ((0x3f & cccc.charCodeAt(1)) << 12)
	                |    ((0x3f & cccc.charCodeAt(2)) <<  6)
	                |     (0x3f & cccc.charCodeAt(3)),
	            offset = cp - 0x10000;
	            return (fromCharCode((offset  >>> 10) + 0xD800)
	                    + fromCharCode((offset & 0x3FF) + 0xDC00));
	        case 3:
	            return fromCharCode(
	                ((0x0f & cccc.charCodeAt(0)) << 12)
	                    | ((0x3f & cccc.charCodeAt(1)) << 6)
	                    |  (0x3f & cccc.charCodeAt(2))
	            );
	        default:
	            return  fromCharCode(
	                ((0x1f & cccc.charCodeAt(0)) << 6)
	                    |  (0x3f & cccc.charCodeAt(1))
	            );
	        }
	    };
	    var btou = function(b) {
	        return b.replace(re_btou, cb_btou);
	    };
	    var cb_decode = function(cccc) {
	        var len = cccc.length,
	        padlen = len % 4,
	        n = (len > 0 ? b64tab[cccc.charAt(0)] << 18 : 0)
	            | (len > 1 ? b64tab[cccc.charAt(1)] << 12 : 0)
	            | (len > 2 ? b64tab[cccc.charAt(2)] <<  6 : 0)
	            | (len > 3 ? b64tab[cccc.charAt(3)]       : 0),
	        chars = [
	            fromCharCode( n >>> 16),
	            fromCharCode((n >>>  8) & 0xff),
	            fromCharCode( n         & 0xff)
	        ];
	        chars.length -= [0, 0, 2, 1][padlen];
	        return chars.join('');
	    };
	    var _atob = global.atob ? function(a) {
	        return global.atob(a);
	    } : function(a){
	        return a.replace(/\S{1,4}/g, cb_decode);
	    };
	    var atob = function(a) {
	        return _atob(String(a).replace(/[^A-Za-z0-9\+\/]/g, ''));
	    };
	    var _decode = buffer ?
	        buffer.from && Uint8Array && buffer.from !== Uint8Array.from
	        ? function(a) {
	            return (a.constructor === buffer.constructor
	                    ? a : buffer.from(a, 'base64')).toString();
	        }
	        : function(a) {
	            return (a.constructor === buffer.constructor
	                    ? a : new buffer(a, 'base64')).toString();
	        }
	        : function(a) { return btou(_atob(a)) };
	    var decode = function(a){
	        return _decode(
	            String(a).replace(/[-_]/g, function(m0) { return m0 == '-' ? '+' : '/' })
	                .replace(/[^A-Za-z0-9\+\/]/g, '')
	        );
	    };
	    var noConflict = function() {
	        var Base64 = global.Base64;
	        global.Base64 = _Base64;
	        return Base64;
	    };
	    // export Base64
	    global.Base64 = {
	        VERSION: version,
	        atob: atob,
	        btoa: btoa,
	        fromBase64: decode,
	        toBase64: encode,
	        utob: utob,
	        encode: encode,
	        encodeURI: encodeURI,
	        btou: btou,
	        decode: decode,
	        noConflict: noConflict,
	        __buffer__: buffer
	    };
	    // if ES5 is available, make Base64.extendString() available
	    if (typeof Object.defineProperty === 'function') {
	        var noEnum = function(v){
	            return {value:v,enumerable:false,writable:true,configurable:true};
	        };
	        global.Base64.extendString = function () {
	            Object.defineProperty(
	                String.prototype, 'fromBase64', noEnum(function () {
	                    return decode(this)
	                }));
	            Object.defineProperty(
	                String.prototype, 'toBase64', noEnum(function (urisafe) {
	                    return encode(this, urisafe)
	                }));
	            Object.defineProperty(
	                String.prototype, 'toBase64URI', noEnum(function () {
	                    return encode(this, true)
	                }));
	        };
	    }
	    //
	    // export Base64 to the namespace
	    //
	    if (global['Meteor']) { // Meteor.js
	        Base64 = global.Base64;
	    }
	    // module.exports and AMD are mutually exclusive.
	    // module.exports has precedence.
	    if ( module.exports) {
	        module.exports.Base64 = global.Base64;
	    }
	    // that's it!
	    return {Base64: global.Base64}
	}));
	});
	var base64_1 = base64.Base64;

	/*       */

	class BadResponse extends Error {
	  static fromResponse(error        , status        ) {
	    return new BadResponse(error.message, status, error.timestamp, error.error_id, error.details);
	  }

	  static fromText(response        , status        ) {
	    return new BadResponse(response, status);
	  }

	                  
	                 
	                     
	                   
	                   

	  constructor(
	    message        ,
	    status        ,
	    timestamp          = null,
	    errorId          = null,
	    details          = null,
	  ) {
	    super(message);

	    this.timestamp = timestamp;
	    this.status = status;
	    this.errorId = errorId;
	    this.details = details;
	  }
	}

	/*       */

	class ServerError extends BadResponse {
	  static fromResponse(error        , status        ) {
	    return new ServerError(error.message, status, error.timestamp, error.error_id, error.details);
	  }

	  static fromText(response        , status        ) {
	    return new ServerError(response, status);
	  }
	}

	/*       */

	class Logger {
	  static hasDebug() {
	    return typeof process !== 'undefined' && (+process.env.DEBUG === 1 || process.env.DEBUG === 'true');
	  }

	  static logRequest(url        , { method, body, headers }        , response        ) {
	    if (!Logger.hasDebug()) {
	      return;
	    }

	    const { status } = response;

	    let curl = `${status} - curl ${method !== 'get' ? `-X ${method.toUpperCase()}` : ''}`;
	    Object.keys(headers).forEach(headerName => {
	      curl += ` -H '${headerName}: ${headers[headerName]}'`;
	    });

	    curl += ` ${url}`;

	    if (body) {
	      curl += ` -d '${body}'`;
	    }

	    console.info(curl);
	  }
	}

	/*       */
	                                             

	const methods = ['head', 'get', 'post', 'put', 'delete'];

	// Use a function here to be able to mock it in tests
	const realFetch = () => {
	  if (typeof document !== 'undefined') {
	    // Browser
	    return window.fetch;
	  }

	  if (typeof navigator !== 'undefined' && navigator.product === 'ReactNative') {
	    // React native
	    return fetch;
	  }

	  // nodejs
	  // this package is disable for react-native in package.json because it requires nodejs modules
	  return require('node-fetch/lib/index');
	};

	class ApiRequester {
	                 
	                 

	                 
	                
	                 
	                
	                   

	  // eslint-disable-next-line
	  static successResponseParser(response        , isJson         ) {
	    return response.status === 204;
	  }

	  static defaultParser(response        ) {
	    return response.json().then((data        ) => data);
	  }

	  static getHeaders(header                  )         {
	    if (header instanceof Object) {
	      return header;
	    }

	    return {
	      'X-Auth-Token': header,
	      Accept: 'application/json',
	      'Content-Type': 'application/json',
	    };
	  }

	  static getQueryString(obj        )         {
	    return Object.keys(obj)
	      .filter(key => obj[key])
	      .map(key => `${key}=${encodeURIComponent(obj[key])}`)
	      .join('&');
	  }

	  static base64Encode(str        )         {
	    return typeof btoa !== 'undefined' ? btoa(str) : base64_1.encode(str);
	  }

	  // @see https://github.com/facebook/flow/issues/183#issuecomment-358607052
	  constructor({ server, agent = null }                                              ) {
	    this.server = server;
	    this.agent = agent;

	    methods.forEach(method => {
	      // $FlowFixMe
	      ApiRequester.prototype[method] = function sugar(...args) {
	        // Add method in arguments passed to `call`
	        args.splice(1, 0, method);

	        return this.call.call(this, ...args);
	      };
	    });
	  }

	  call(
	    path        ,
	    method         = 'get',
	    body          = null,
	    headers                    = null,
	    parse           = ApiRequester.defaultParser,
	  )               {
	    const url = this.computeUrl(method, path, body);
	    const newHeaders = headers ? ApiRequester.getHeaders(headers) : {};
	    let newBody = method === 'get' ? null : body;
	    if (newBody && newHeaders['Content-Type'] === 'application/json') {
	      newBody = JSON.stringify(newBody);
	    }
	    const isHead = method === 'head';
	    const hasEmptyResponse = method === 'delete' || isHead;
	    const newParse = hasEmptyResponse ? ApiRequester.successResponseParser : parse;
	    const options = {
	      method,
	      body: newBody,
	      headers: headers ? ApiRequester.getHeaders(headers) : {},
	      agent: this.agent,
	    };

	    return realFetch()(url, options).then(response => {
	      const contentType = response.headers.get('content-type') || '';
	      const isJson = contentType.indexOf('application/json') !== -1;

	      Logger.logRequest(url, options, response);

	      // Throw an error only if status >= 500
	      if ((isHead && response.status >= 500) || (!isHead && response.status >= 400)) {
	        const promise = isJson ? response.json() : response.text();
	        const exceptionClass = response.status >= 500 ? ServerError : BadResponse;

	        return promise.then(err => {
	          throw typeof err === 'string'
	            ? exceptionClass.fromText(err, response.status)
	            : exceptionClass.fromResponse(err, response.status);
	        });
	      }

	      return newParse(response, isJson);
	    });
	  }

	  computeUrl(method        , path        , body         )         {
	    const url = `${this.baseUrl}/${path}`;

	    return method === 'get' && body && Object.keys(body).length ? `${url}?${ApiRequester.getQueryString(body)}` : url;
	  }

	  get baseUrl()         {
	    return `https://${this.server}/api`;
	  }
	}

	/*       */

	const DEFAULT_BACKEND_USER = 'wazo_user';
	const DETAULT_EXPIRATION = 3600;

	var authMethods = (client              , baseUrl        ) => ({
	  checkToken(token       )                   {
	    return client.head(`${baseUrl}/token/${token}`, null, {});
	  },

	  authenticate(token       )                    {
	    return client.get(`${baseUrl}/token/${token}`, null, {}).then(response => Session.parse(response));
	  },

	  logIn(params   
	                     
	                     
	                    
	                       
	                     
	   )                    {
	    const body = {
	      backend: params.backend || DEFAULT_BACKEND_USER,
	      expiration: params.expiration || DETAULT_EXPIRATION,
	    };
	    const headers         = {
	      Authorization: `Basic ${ApiRequester.base64Encode(`${params.username}:${params.password}`)}`,
	      'Content-Type': 'application/json',
	    };

	    if (params.mobile) {
	      headers['Wazo-Session-Type'] = 'mobile';
	    }

	    return client.post(`${baseUrl}/token`, body, headers).then(response => Session.parse(response));
	  },

	  logOut(token       )                          {
	    return client.delete(`${baseUrl}/token/${token}`, null, {}, ApiRequester.successResponseParser);
	  },

	  updatePassword(token       , userUuid      , oldPassword        , newPassword        )                   {
	    const body = {
	      new_password: newPassword,
	      old_password: oldPassword,
	    };

	    return client.put(`${baseUrl}/users/${userUuid}/password`, body, token, ApiRequester.successResponseParser);
	  },

	  sendDeviceToken(token       , userUuid      , deviceToken        , apnsToken         ) {
	    const body         = {
	      token: deviceToken,
	    };

	    if (apnsToken) {
	      body.apns_token = apnsToken;
	    }

	    return client.post(`${baseUrl}/users/${userUuid}/external/mobile`, body, token);
	  },

	  getPushNotificationSenderId(token       , userUuid      ) {
	    return client
	      .get(`${baseUrl}/users/${userUuid}/external/mobile/sender_id`, null, token)
	      .then(response => response.sender_id);
	  },

	  /**
	   * `username` or `email` should be set.
	   */
	  sendResetPasswordEmail({ username, email }                                       ) {
	    const body = {};
	    if (username) {
	      body.username = username;
	    }
	    if (email) {
	      body.email = email;
	    }

	    return client.get(`${baseUrl}/users/password/reset`, body, {}, ApiRequester.successResponseParser);
	  },

	  resetPassword(token        , userUuid        , password        ) {
	    const body = {
	      password,
	    };

	    return client.post(
	      `${baseUrl}/users/password/reset?user_uuid=${userUuid}`,
	      body,
	      token,
	      ApiRequester.successResponseParser,
	    );
	  },

	  removeDeviceToken(token       , userUuid      ) {
	    return client.delete(`${baseUrl}/users/${userUuid}/external/mobile`, null, token);
	  },

	  createUser(
	    token       ,
	    username        ,
	    password        ,
	    firstname        ,
	    lastname        ,
	  )                               {
	    const body = {
	      username,
	      password,
	      firstname,
	      lastname,
	    };

	    return client.post(`${baseUrl}/users`, body, token);
	  },

	  addUserEmail(token       , userUuid      , email        , main          ) {
	    const body = {
	      emails: [
	        {
	          address: email,
	          main,
	        },
	      ],
	    };

	    return client.put(`${baseUrl}/users/${userUuid}/emails`, body, token);
	  },

	  addUserPolicy(token       , userUuid      , policyUuid      ) {
	    return client.put(`${baseUrl}/users/${userUuid}/policies/${policyUuid}`, null, token);
	  },

	  deleteUserPolicy(token       , userUuid      , policyUuid      ) {
	    return client.delete(`${baseUrl}/users/${userUuid}/policies/${policyUuid}`, null, token);
	  },

	  addUserGroup(token       , userUuid      , groupUuid      ) {
	    return client.put(`${baseUrl}/groups/${groupUuid}/users/${userUuid}`, null, token);
	  },

	  listUsersGroup(token       , groupUuid      ) {
	    return client.get(`${baseUrl}/groups/${groupUuid}/users`, null, token);
	  },

	  deleteUserGroup(token       , userUuid      , groupUuid      ) {
	    return client.delete(`${baseUrl}/groups/${groupUuid}/users/${userUuid}`, null, token);
	  },

	  getUser(token       , userUuid      )                           {
	    return client.get(`${baseUrl}/users/${userUuid}`, null, token);
	  },

	  getUserSession(token       , userUuid      ) {
	    return client.get(`${baseUrl}/users/${userUuid}/sessions`, null, token);
	  },

	  listUsers(token       )                             {
	    return client.get(`${baseUrl}/users`, null, token);
	  },

	  deleteUser(token       , userUuid      )                                  {
	    return client.delete(`${baseUrl}/users/${userUuid}`, null, token);
	  },

	  listTenants(token       )                               {
	    return client.get(`${baseUrl}/tenants`, null, token);
	  },

	  getTenant(token       , tenantUuid      )                             {
	    return client.get(`${baseUrl}/tenants/${tenantUuid}`, null, token);
	  },

	  createTenant(token       , name        )                                 {
	    return client.post(`${baseUrl}/tenants`, { name }, token);
	  },

	  updateTenant(
	    token       ,
	    uuid      ,
	    name        ,
	    contact        ,
	    phone        ,
	    address               ,
	  )                                 {
	    const body = {
	      name,
	      contact,
	      phone,
	      address,
	    };

	    return client.put(`${baseUrl}/tenants/${uuid}`, body, token);
	  },

	  deleteTenant(token       , uuid      )                                  {
	    return client.delete(`${baseUrl}/tenants/${uuid}`, null, token);
	  },

	  createGroup(token       , name        ) {
	    return client.post(`${baseUrl}/groups`, { name }, token);
	  },

	  listGroups(token       )                              {
	    return client.get(`${baseUrl}/groups`, null, token);
	  },

	  deleteGroup(token       , uuid      )                                  {
	    return client.delete(`${baseUrl}/groups/${uuid}`, null, token);
	  },

	  createPolicy(token       , name        , description        , aclTemplates               ) {
	    const body = {
	      name,
	      description,
	      acl_templates: aclTemplates,
	    };

	    return client.post(`${baseUrl}/policies`, body, token);
	  },

	  listPolicies(token       )                                {
	    return client.get(`${baseUrl}/policies`, null, token);
	  },

	  deletePolicy(token       , policyUuid      )                                  {
	    return client.delete(`${baseUrl}/policies/${policyUuid}`, null, token);
	  },

	  getProviders(token       , userUuid      ) {
	    return client.get(`${baseUrl}/users/${userUuid}/external`, null, token);
	  },

	  getProviderToken(token       , userUuid      , provider        ) {
	    return client.get(`${baseUrl}/users/${userUuid}/external/${provider}`, null, token);
	  },

	  getProviderAuthUrl(token       , userUuid      , provider        ) {
	    return client.post(`${baseUrl}/users/${userUuid}/external/${provider}`, {}, token);
	  },

	  deleteProviderToken(token       , userUuid      , provider        ) {
	    return client.delete(`${baseUrl}/users/${userUuid}/external/${provider}`, null, token);
	  },
	});

	/*       */
	                                                                                       

	var applicationMethods = (client              , baseUrl        ) => ({
	  answerCall(
	    token        ,
	    applicationUuid        ,
	    callId        ,
	    context        ,
	    exten        ,
	    autoanswer        ,
	    displayed_caller_id_number         ,
	  ) {
	    const url = `${baseUrl}/${applicationUuid}/nodes`;
	    const body = { calls: [{ id: callId }] };

	    return client
	      .post(url, body, token, res => res.json().then(response => response.uuid))
	      .then(nodeUuid =>
	        client
	          .post(`${url}/${nodeUuid}/calls`, { context, exten, autoanswer, displayed_caller_id_number }, token)
	          .then(data => ({
	            nodeUuid,
	            data,
	          })));
	  },

	  calls(token       , applicationUuid        ) {
	    return client.get(`${baseUrl}/${applicationUuid}/calls`, null, token);
	  },

	  hangupCall(token       , applicationUuid        , callId        ) {
	    const url = `${baseUrl}/${applicationUuid}/calls/${callId}`;

	    return client.delete(url, null, token);
	  },

	  playCall(token       , applicationUuid        , callId        , language        , uri        ) {
	    return client.post(`${baseUrl}/${applicationUuid}/calls/${callId}/playbacks`, { language, uri }, token);
	  },

	  addCallNodes(token       , applicationUuid        , nodeUuid        , callId        )                   {
	    return client.put(`${baseUrl}/${applicationUuid}/nodes/${nodeUuid}/calls/${callId}`, null, token);
	  },

	  addNewCallNodes(
	    token       ,
	    applicationUuid        ,
	    nodeUuid        ,
	    context        ,
	    exten        ,
	    autoanswer        ,
	  ) {
	    const data = { context, exten, autoanswer };

	    return client.post(`${baseUrl}/${applicationUuid}/nodes/${nodeUuid}/calls`, data, token);
	  },

	  listCallsNodes(token       , applicationUuid        , nodeUuid        )                                 {
	    return client.get(`${baseUrl}/${applicationUuid}/nodes/${nodeUuid}`, null, token);
	  },

	  listNodes(token       , applicationUuid        )                             {
	    return client.get(`${baseUrl}/${applicationUuid}/nodes`, null, token);
	  },

	  removeNode(token       , applicationUuid        , nodeUuid        ) {
	    return client.delete(`${baseUrl}/${applicationUuid}/nodes/${nodeUuid}`, null, token);
	  },

	  removeCallNodes(token       , applicationUuid        , nodeUuid        , callId        ) {
	    return client.delete(`${baseUrl}/${applicationUuid}/nodes/${nodeUuid}/calls/${callId}`, null, token);
	  },
	});

	/*       */

	var confdMethods = (client              , baseUrl        ) => ({
	  listUsers(token       )                                  {
	    return client.get(`${baseUrl}/users`, null, token);
	  },

	  getUser(token       , userUuid        )                   {
	    return client.get(`${baseUrl}/users/${userUuid}`, null, token).then(response => Profile.parse(response));
	  },

	  updateUser(token       , userUuid        , profile         )                   {
	    const body = {
	      firstname: profile.firstName,
	      lastname: profile.lastName,
	      email: profile.email,
	      mobile_phone_number: profile.mobileNumber,
	    };

	    return client.put(`${baseUrl}/users/${userUuid}`, body, token, ApiRequester.successResponseParser);
	  },

	  updateForwardOption(
	    token       ,
	    userUuid        ,
	    key        ,
	    destination        ,
	    enabled         ,
	  )                   {
	    const url = `${baseUrl}/users/${userUuid}/forwards/${key}`;
	    return client.put(url, { destination, enabled }, token, ApiRequester.successResponseParser);
	  },

	  updateDoNotDisturb(token       , userUuid      , enabled         )                   {
	    const url = `${baseUrl}/users/${userUuid}/services/dnd`;

	    return client.put(url, { enabled }, token, ApiRequester.successResponseParser);
	  },

	  // @TODO: type response
	  getUserLineSip(token       , userUuid        , lineId        ) {
	    return client.get(`${baseUrl}/users/${userUuid}/lines/${lineId}/associated/endpoints/sip`, null, token);
	  },

	  getUserLineSipFromToken(token       , userUuid        ) {
	    return this.getUser(token, userUuid).then(user => {
	      if (!user.lines.length) {
	        console.warn(`No sip line for user: ${userUuid}`);
	        return null;
	      }
	      const line = user.lines[0];

	      return this.getUserLineSip(token, userUuid, line.id);
	    });
	  },

	  listApplications(token       )                                    {
	    const url = `${baseUrl}/applications?recurse=true`;

	    return client.get(url, null, token);
	  },

	  getSIP(token       , userUuid      , lineId        )                        {
	    return client.get(`${baseUrl}/users/${userUuid}/lines/${lineId}/associated/endpoints/sip`, null, token);
	  },

	  getInfos(token       )                                                  {
	    return client.get(`${baseUrl}/infos`, null, token);
	  },
	});

	/*       */

	var accessdMethods = (client              , baseUrl        ) => ({
	  listSubscriptions(token        ) {
	    return client.get(`${baseUrl}/subscriptions?recurse=true`, null, token);
	  },
	  createSubscription(token        , { productSku, name, startDate, contractDate, autoRenew, term }        ) {
	    const body = {
	      product_sku: productSku,
	      name,
	      start_date: startDate,
	      contract_date: contractDate,
	      auto_renew: autoRenew,
	      term,
	    };

	    return client.post(`${baseUrl}/subscriptions`, body, token);
	  },
	  getSubscription(token        , uuid        ) {
	    return client.get(`${baseUrl}/subscriptions/${uuid}`, null, token);
	  },
	  deleteSubscription(token        , uuid        ) {
	    return client.delete(`${baseUrl}/subscriptions/${uuid}`, null, token);
	  },
	  createSubscriptionToken(token        ) {
	    return client.post(`${baseUrl}/subscriptions/token`, null, token);
	  },
	  listAuthorizations(token        , subscriptionUuid        ) {
	    return client.get(`${baseUrl}/subscriptions/${subscriptionUuid}/authorizations`, null, token);
	  },
	  getAuthorization(token        , subscriptionUuid        , uuid        ) {
	    return client.get(`${baseUrl}/subscriptions/${subscriptionUuid}/authorizations/${uuid}`, null, token);
	  },
	  deleteAuthorization(token        , subscriptionUuid        , uuid        ) {
	    return client.delete(`${baseUrl}/subscriptions/${subscriptionUuid}/authorizations/${uuid}`, null, token);
	  },
	  createAuthorization(token        , subscriptionUuid        , { startDate, term, service, rules, autoRenew }        ) {
	    const url = `${baseUrl}/subscriptions/${subscriptionUuid}/authorizations`;
	    const body = {
	      start_date: startDate,
	      term,
	      service,
	      rules,
	      auto_renew: autoRenew,
	    };

	    return client.post(url, body, token);
	  },
	});

	var hookCallback;

	function hooks () {
	    return hookCallback.apply(null, arguments);
	}

	// This is done to register the method called with moment()
	// without creating circular dependencies.
	function setHookCallback (callback) {
	    hookCallback = callback;
	}

	function isArray(input) {
	    return input instanceof Array || Object.prototype.toString.call(input) === '[object Array]';
	}

	function isObject(input) {
	    // IE8 will treat undefined and null as object if it wasn't for
	    // input != null
	    return input != null && Object.prototype.toString.call(input) === '[object Object]';
	}

	function isObjectEmpty(obj) {
	    if (Object.getOwnPropertyNames) {
	        return (Object.getOwnPropertyNames(obj).length === 0);
	    } else {
	        var k;
	        for (k in obj) {
	            if (obj.hasOwnProperty(k)) {
	                return false;
	            }
	        }
	        return true;
	    }
	}

	function isUndefined(input) {
	    return input === void 0;
	}

	function isNumber(input) {
	    return typeof input === 'number' || Object.prototype.toString.call(input) === '[object Number]';
	}

	function isDate(input) {
	    return input instanceof Date || Object.prototype.toString.call(input) === '[object Date]';
	}

	function map(arr, fn) {
	    var res = [], i;
	    for (i = 0; i < arr.length; ++i) {
	        res.push(fn(arr[i], i));
	    }
	    return res;
	}

	function hasOwnProp(a, b) {
	    return Object.prototype.hasOwnProperty.call(a, b);
	}

	function extend(a, b) {
	    for (var i in b) {
	        if (hasOwnProp(b, i)) {
	            a[i] = b[i];
	        }
	    }

	    if (hasOwnProp(b, 'toString')) {
	        a.toString = b.toString;
	    }

	    if (hasOwnProp(b, 'valueOf')) {
	        a.valueOf = b.valueOf;
	    }

	    return a;
	}

	function createUTC (input, format, locale, strict) {
	    return createLocalOrUTC(input, format, locale, strict, true).utc();
	}

	function defaultParsingFlags() {
	    // We need to deep clone this object.
	    return {
	        empty           : false,
	        unusedTokens    : [],
	        unusedInput     : [],
	        overflow        : -2,
	        charsLeftOver   : 0,
	        nullInput       : false,
	        invalidMonth    : null,
	        invalidFormat   : false,
	        userInvalidated : false,
	        iso             : false,
	        parsedDateParts : [],
	        meridiem        : null,
	        rfc2822         : false,
	        weekdayMismatch : false
	    };
	}

	function getParsingFlags(m) {
	    if (m._pf == null) {
	        m._pf = defaultParsingFlags();
	    }
	    return m._pf;
	}

	var some;
	if (Array.prototype.some) {
	    some = Array.prototype.some;
	} else {
	    some = function (fun) {
	        var t = Object(this);
	        var len = t.length >>> 0;

	        for (var i = 0; i < len; i++) {
	            if (i in t && fun.call(this, t[i], i, t)) {
	                return true;
	            }
	        }

	        return false;
	    };
	}

	function isValid(m) {
	    if (m._isValid == null) {
	        var flags = getParsingFlags(m);
	        var parsedParts = some.call(flags.parsedDateParts, function (i) {
	            return i != null;
	        });
	        var isNowValid = !isNaN(m._d.getTime()) &&
	            flags.overflow < 0 &&
	            !flags.empty &&
	            !flags.invalidMonth &&
	            !flags.invalidWeekday &&
	            !flags.weekdayMismatch &&
	            !flags.nullInput &&
	            !flags.invalidFormat &&
	            !flags.userInvalidated &&
	            (!flags.meridiem || (flags.meridiem && parsedParts));

	        if (m._strict) {
	            isNowValid = isNowValid &&
	                flags.charsLeftOver === 0 &&
	                flags.unusedTokens.length === 0 &&
	                flags.bigHour === undefined;
	        }

	        if (Object.isFrozen == null || !Object.isFrozen(m)) {
	            m._isValid = isNowValid;
	        }
	        else {
	            return isNowValid;
	        }
	    }
	    return m._isValid;
	}

	function createInvalid (flags) {
	    var m = createUTC(NaN);
	    if (flags != null) {
	        extend(getParsingFlags(m), flags);
	    }
	    else {
	        getParsingFlags(m).userInvalidated = true;
	    }

	    return m;
	}

	// Plugins that add properties should also add the key here (null value),
	// so we can properly clone ourselves.
	var momentProperties = hooks.momentProperties = [];

	function copyConfig(to, from) {
	    var i, prop, val;

	    if (!isUndefined(from._isAMomentObject)) {
	        to._isAMomentObject = from._isAMomentObject;
	    }
	    if (!isUndefined(from._i)) {
	        to._i = from._i;
	    }
	    if (!isUndefined(from._f)) {
	        to._f = from._f;
	    }
	    if (!isUndefined(from._l)) {
	        to._l = from._l;
	    }
	    if (!isUndefined(from._strict)) {
	        to._strict = from._strict;
	    }
	    if (!isUndefined(from._tzm)) {
	        to._tzm = from._tzm;
	    }
	    if (!isUndefined(from._isUTC)) {
	        to._isUTC = from._isUTC;
	    }
	    if (!isUndefined(from._offset)) {
	        to._offset = from._offset;
	    }
	    if (!isUndefined(from._pf)) {
	        to._pf = getParsingFlags(from);
	    }
	    if (!isUndefined(from._locale)) {
	        to._locale = from._locale;
	    }

	    if (momentProperties.length > 0) {
	        for (i = 0; i < momentProperties.length; i++) {
	            prop = momentProperties[i];
	            val = from[prop];
	            if (!isUndefined(val)) {
	                to[prop] = val;
	            }
	        }
	    }

	    return to;
	}

	var updateInProgress = false;

	// Moment prototype object
	function Moment(config) {
	    copyConfig(this, config);
	    this._d = new Date(config._d != null ? config._d.getTime() : NaN);
	    if (!this.isValid()) {
	        this._d = new Date(NaN);
	    }
	    // Prevent infinite loop in case updateOffset creates new moment
	    // objects.
	    if (updateInProgress === false) {
	        updateInProgress = true;
	        hooks.updateOffset(this);
	        updateInProgress = false;
	    }
	}

	function isMoment (obj) {
	    return obj instanceof Moment || (obj != null && obj._isAMomentObject != null);
	}

	function absFloor (number) {
	    if (number < 0) {
	        // -0 -> 0
	        return Math.ceil(number) || 0;
	    } else {
	        return Math.floor(number);
	    }
	}

	function toInt(argumentForCoercion) {
	    var coercedNumber = +argumentForCoercion,
	        value = 0;

	    if (coercedNumber !== 0 && isFinite(coercedNumber)) {
	        value = absFloor(coercedNumber);
	    }

	    return value;
	}

	// compare two arrays, return the number of differences
	function compareArrays(array1, array2, dontConvert) {
	    var len = Math.min(array1.length, array2.length),
	        lengthDiff = Math.abs(array1.length - array2.length),
	        diffs = 0,
	        i;
	    for (i = 0; i < len; i++) {
	        if ((dontConvert && array1[i] !== array2[i]) ||
	            (!dontConvert && toInt(array1[i]) !== toInt(array2[i]))) {
	            diffs++;
	        }
	    }
	    return diffs + lengthDiff;
	}

	function warn(msg) {
	    if (hooks.suppressDeprecationWarnings === false &&
	            (typeof console !==  'undefined') && console.warn) {
	        console.warn('Deprecation warning: ' + msg);
	    }
	}

	function deprecate(msg, fn) {
	    var firstTime = true;

	    return extend(function () {
	        if (hooks.deprecationHandler != null) {
	            hooks.deprecationHandler(null, msg);
	        }
	        if (firstTime) {
	            var args = [];
	            var arg;
	            for (var i = 0; i < arguments.length; i++) {
	                arg = '';
	                if (typeof arguments[i] === 'object') {
	                    arg += '\n[' + i + '] ';
	                    for (var key in arguments[0]) {
	                        arg += key + ': ' + arguments[0][key] + ', ';
	                    }
	                    arg = arg.slice(0, -2); // Remove trailing comma and space
	                } else {
	                    arg = arguments[i];
	                }
	                args.push(arg);
	            }
	            warn(msg + '\nArguments: ' + Array.prototype.slice.call(args).join('') + '\n' + (new Error()).stack);
	            firstTime = false;
	        }
	        return fn.apply(this, arguments);
	    }, fn);
	}

	var deprecations = {};

	function deprecateSimple(name, msg) {
	    if (hooks.deprecationHandler != null) {
	        hooks.deprecationHandler(name, msg);
	    }
	    if (!deprecations[name]) {
	        warn(msg);
	        deprecations[name] = true;
	    }
	}

	hooks.suppressDeprecationWarnings = false;
	hooks.deprecationHandler = null;

	function isFunction(input) {
	    return input instanceof Function || Object.prototype.toString.call(input) === '[object Function]';
	}

	function set (config) {
	    var prop, i;
	    for (i in config) {
	        prop = config[i];
	        if (isFunction(prop)) {
	            this[i] = prop;
	        } else {
	            this['_' + i] = prop;
	        }
	    }
	    this._config = config;
	    // Lenient ordinal parsing accepts just a number in addition to
	    // number + (possibly) stuff coming from _dayOfMonthOrdinalParse.
	    // TODO: Remove "ordinalParse" fallback in next major release.
	    this._dayOfMonthOrdinalParseLenient = new RegExp(
	        (this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) +
	            '|' + (/\d{1,2}/).source);
	}

	function mergeConfigs(parentConfig, childConfig) {
	    var res = extend({}, parentConfig), prop;
	    for (prop in childConfig) {
	        if (hasOwnProp(childConfig, prop)) {
	            if (isObject(parentConfig[prop]) && isObject(childConfig[prop])) {
	                res[prop] = {};
	                extend(res[prop], parentConfig[prop]);
	                extend(res[prop], childConfig[prop]);
	            } else if (childConfig[prop] != null) {
	                res[prop] = childConfig[prop];
	            } else {
	                delete res[prop];
	            }
	        }
	    }
	    for (prop in parentConfig) {
	        if (hasOwnProp(parentConfig, prop) &&
	                !hasOwnProp(childConfig, prop) &&
	                isObject(parentConfig[prop])) {
	            // make sure changes to properties don't modify parent config
	            res[prop] = extend({}, res[prop]);
	        }
	    }
	    return res;
	}

	function Locale(config) {
	    if (config != null) {
	        this.set(config);
	    }
	}

	var keys;

	if (Object.keys) {
	    keys = Object.keys;
	} else {
	    keys = function (obj) {
	        var i, res = [];
	        for (i in obj) {
	            if (hasOwnProp(obj, i)) {
	                res.push(i);
	            }
	        }
	        return res;
	    };
	}

	var defaultCalendar = {
	    sameDay : '[Today at] LT',
	    nextDay : '[Tomorrow at] LT',
	    nextWeek : 'dddd [at] LT',
	    lastDay : '[Yesterday at] LT',
	    lastWeek : '[Last] dddd [at] LT',
	    sameElse : 'L'
	};

	function calendar (key, mom, now) {
	    var output = this._calendar[key] || this._calendar['sameElse'];
	    return isFunction(output) ? output.call(mom, now) : output;
	}

	var defaultLongDateFormat = {
	    LTS  : 'h:mm:ss A',
	    LT   : 'h:mm A',
	    L    : 'MM/DD/YYYY',
	    LL   : 'MMMM D, YYYY',
	    LLL  : 'MMMM D, YYYY h:mm A',
	    LLLL : 'dddd, MMMM D, YYYY h:mm A'
	};

	function longDateFormat (key) {
	    var format = this._longDateFormat[key],
	        formatUpper = this._longDateFormat[key.toUpperCase()];

	    if (format || !formatUpper) {
	        return format;
	    }

	    this._longDateFormat[key] = formatUpper.replace(/MMMM|MM|DD|dddd/g, function (val) {
	        return val.slice(1);
	    });

	    return this._longDateFormat[key];
	}

	var defaultInvalidDate = 'Invalid date';

	function invalidDate () {
	    return this._invalidDate;
	}

	var defaultOrdinal = '%d';
	var defaultDayOfMonthOrdinalParse = /\d{1,2}/;

	function ordinal (number) {
	    return this._ordinal.replace('%d', number);
	}

	var defaultRelativeTime = {
	    future : 'in %s',
	    past   : '%s ago',
	    s  : 'a few seconds',
	    ss : '%d seconds',
	    m  : 'a minute',
	    mm : '%d minutes',
	    h  : 'an hour',
	    hh : '%d hours',
	    d  : 'a day',
	    dd : '%d days',
	    M  : 'a month',
	    MM : '%d months',
	    y  : 'a year',
	    yy : '%d years'
	};

	function relativeTime (number, withoutSuffix, string, isFuture) {
	    var output = this._relativeTime[string];
	    return (isFunction(output)) ?
	        output(number, withoutSuffix, string, isFuture) :
	        output.replace(/%d/i, number);
	}

	function pastFuture (diff, output) {
	    var format = this._relativeTime[diff > 0 ? 'future' : 'past'];
	    return isFunction(format) ? format(output) : format.replace(/%s/i, output);
	}

	var aliases = {};

	function addUnitAlias (unit, shorthand) {
	    var lowerCase = unit.toLowerCase();
	    aliases[lowerCase] = aliases[lowerCase + 's'] = aliases[shorthand] = unit;
	}

	function normalizeUnits(units) {
	    return typeof units === 'string' ? aliases[units] || aliases[units.toLowerCase()] : undefined;
	}

	function normalizeObjectUnits(inputObject) {
	    var normalizedInput = {},
	        normalizedProp,
	        prop;

	    for (prop in inputObject) {
	        if (hasOwnProp(inputObject, prop)) {
	            normalizedProp = normalizeUnits(prop);
	            if (normalizedProp) {
	                normalizedInput[normalizedProp] = inputObject[prop];
	            }
	        }
	    }

	    return normalizedInput;
	}

	var priorities = {};

	function addUnitPriority(unit, priority) {
	    priorities[unit] = priority;
	}

	function getPrioritizedUnits(unitsObj) {
	    var units = [];
	    for (var u in unitsObj) {
	        units.push({unit: u, priority: priorities[u]});
	    }
	    units.sort(function (a, b) {
	        return a.priority - b.priority;
	    });
	    return units;
	}

	function zeroFill(number, targetLength, forceSign) {
	    var absNumber = '' + Math.abs(number),
	        zerosToFill = targetLength - absNumber.length,
	        sign = number >= 0;
	    return (sign ? (forceSign ? '+' : '') : '-') +
	        Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;
	}

	var formattingTokens = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g;

	var localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g;

	var formatFunctions = {};

	var formatTokenFunctions = {};

	// token:    'M'
	// padded:   ['MM', 2]
	// ordinal:  'Mo'
	// callback: function () { this.month() + 1 }
	function addFormatToken (token, padded, ordinal, callback) {
	    var func = callback;
	    if (typeof callback === 'string') {
	        func = function () {
	            return this[callback]();
	        };
	    }
	    if (token) {
	        formatTokenFunctions[token] = func;
	    }
	    if (padded) {
	        formatTokenFunctions[padded[0]] = function () {
	            return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
	        };
	    }
	    if (ordinal) {
	        formatTokenFunctions[ordinal] = function () {
	            return this.localeData().ordinal(func.apply(this, arguments), token);
	        };
	    }
	}

	function removeFormattingTokens(input) {
	    if (input.match(/\[[\s\S]/)) {
	        return input.replace(/^\[|\]$/g, '');
	    }
	    return input.replace(/\\/g, '');
	}

	function makeFormatFunction(format) {
	    var array = format.match(formattingTokens), i, length;

	    for (i = 0, length = array.length; i < length; i++) {
	        if (formatTokenFunctions[array[i]]) {
	            array[i] = formatTokenFunctions[array[i]];
	        } else {
	            array[i] = removeFormattingTokens(array[i]);
	        }
	    }

	    return function (mom) {
	        var output = '', i;
	        for (i = 0; i < length; i++) {
	            output += isFunction(array[i]) ? array[i].call(mom, format) : array[i];
	        }
	        return output;
	    };
	}

	// format date using native date object
	function formatMoment(m, format) {
	    if (!m.isValid()) {
	        return m.localeData().invalidDate();
	    }

	    format = expandFormat(format, m.localeData());
	    formatFunctions[format] = formatFunctions[format] || makeFormatFunction(format);

	    return formatFunctions[format](m);
	}

	function expandFormat(format, locale) {
	    var i = 5;

	    function replaceLongDateFormatTokens(input) {
	        return locale.longDateFormat(input) || input;
	    }

	    localFormattingTokens.lastIndex = 0;
	    while (i >= 0 && localFormattingTokens.test(format)) {
	        format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);
	        localFormattingTokens.lastIndex = 0;
	        i -= 1;
	    }

	    return format;
	}

	var match1         = /\d/;            //       0 - 9
	var match2         = /\d\d/;          //      00 - 99
	var match3         = /\d{3}/;         //     000 - 999
	var match4         = /\d{4}/;         //    0000 - 9999
	var match6         = /[+-]?\d{6}/;    // -999999 - 999999
	var match1to2      = /\d\d?/;         //       0 - 99
	var match3to4      = /\d\d\d\d?/;     //     999 - 9999
	var match5to6      = /\d\d\d\d\d\d?/; //   99999 - 999999
	var match1to3      = /\d{1,3}/;       //       0 - 999
	var match1to4      = /\d{1,4}/;       //       0 - 9999
	var match1to6      = /[+-]?\d{1,6}/;  // -999999 - 999999

	var matchUnsigned  = /\d+/;           //       0 - inf
	var matchSigned    = /[+-]?\d+/;      //    -inf - inf

	var matchOffset    = /Z|[+-]\d\d:?\d\d/gi; // +00:00 -00:00 +0000 -0000 or Z
	var matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi; // +00 -00 +00:00 -00:00 +0000 -0000 or Z

	var matchTimestamp = /[+-]?\d+(\.\d{1,3})?/; // 123456789 123456789.123

	// any word (or two) characters or numbers including two/three word month in arabic.
	// includes scottish gaelic two word and hyphenated months
	var matchWord = /[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i;

	var regexes = {};

	function addRegexToken (token, regex, strictRegex) {
	    regexes[token] = isFunction(regex) ? regex : function (isStrict, localeData) {
	        return (isStrict && strictRegex) ? strictRegex : regex;
	    };
	}

	function getParseRegexForToken (token, config) {
	    if (!hasOwnProp(regexes, token)) {
	        return new RegExp(unescapeFormat(token));
	    }

	    return regexes[token](config._strict, config._locale);
	}

	// Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript
	function unescapeFormat(s) {
	    return regexEscape(s.replace('\\', '').replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function (matched, p1, p2, p3, p4) {
	        return p1 || p2 || p3 || p4;
	    }));
	}

	function regexEscape(s) {
	    return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
	}

	var tokens = {};

	function addParseToken (token, callback) {
	    var i, func = callback;
	    if (typeof token === 'string') {
	        token = [token];
	    }
	    if (isNumber(callback)) {
	        func = function (input, array) {
	            array[callback] = toInt(input);
	        };
	    }
	    for (i = 0; i < token.length; i++) {
	        tokens[token[i]] = func;
	    }
	}

	function addWeekParseToken (token, callback) {
	    addParseToken(token, function (input, array, config, token) {
	        config._w = config._w || {};
	        callback(input, config._w, config, token);
	    });
	}

	function addTimeToArrayFromToken(token, input, config) {
	    if (input != null && hasOwnProp(tokens, token)) {
	        tokens[token](input, config._a, config, token);
	    }
	}

	var YEAR = 0;
	var MONTH = 1;
	var DATE = 2;
	var HOUR = 3;
	var MINUTE = 4;
	var SECOND = 5;
	var MILLISECOND = 6;
	var WEEK = 7;
	var WEEKDAY = 8;

	// FORMATTING

	addFormatToken('Y', 0, 0, function () {
	    var y = this.year();
	    return y <= 9999 ? '' + y : '+' + y;
	});

	addFormatToken(0, ['YY', 2], 0, function () {
	    return this.year() % 100;
	});

	addFormatToken(0, ['YYYY',   4],       0, 'year');
	addFormatToken(0, ['YYYYY',  5],       0, 'year');
	addFormatToken(0, ['YYYYYY', 6, true], 0, 'year');

	// ALIASES

	addUnitAlias('year', 'y');

	// PRIORITIES

	addUnitPriority('year', 1);

	// PARSING

	addRegexToken('Y',      matchSigned);
	addRegexToken('YY',     match1to2, match2);
	addRegexToken('YYYY',   match1to4, match4);
	addRegexToken('YYYYY',  match1to6, match6);
	addRegexToken('YYYYYY', match1to6, match6);

	addParseToken(['YYYYY', 'YYYYYY'], YEAR);
	addParseToken('YYYY', function (input, array) {
	    array[YEAR] = input.length === 2 ? hooks.parseTwoDigitYear(input) : toInt(input);
	});
	addParseToken('YY', function (input, array) {
	    array[YEAR] = hooks.parseTwoDigitYear(input);
	});
	addParseToken('Y', function (input, array) {
	    array[YEAR] = parseInt(input, 10);
	});

	// HELPERS

	function daysInYear(year) {
	    return isLeapYear(year) ? 366 : 365;
	}

	function isLeapYear(year) {
	    return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;
	}

	// HOOKS

	hooks.parseTwoDigitYear = function (input) {
	    return toInt(input) + (toInt(input) > 68 ? 1900 : 2000);
	};

	// MOMENTS

	var getSetYear = makeGetSet('FullYear', true);

	function getIsLeapYear () {
	    return isLeapYear(this.year());
	}

	function makeGetSet (unit, keepTime) {
	    return function (value) {
	        if (value != null) {
	            set$1(this, unit, value);
	            hooks.updateOffset(this, keepTime);
	            return this;
	        } else {
	            return get(this, unit);
	        }
	    };
	}

	function get (mom, unit) {
	    return mom.isValid() ?
	        mom._d['get' + (mom._isUTC ? 'UTC' : '') + unit]() : NaN;
	}

	function set$1 (mom, unit, value) {
	    if (mom.isValid() && !isNaN(value)) {
	        if (unit === 'FullYear' && isLeapYear(mom.year()) && mom.month() === 1 && mom.date() === 29) {
	            mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value, mom.month(), daysInMonth(value, mom.month()));
	        }
	        else {
	            mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value);
	        }
	    }
	}

	// MOMENTS

	function stringGet (units) {
	    units = normalizeUnits(units);
	    if (isFunction(this[units])) {
	        return this[units]();
	    }
	    return this;
	}


	function stringSet (units, value) {
	    if (typeof units === 'object') {
	        units = normalizeObjectUnits(units);
	        var prioritized = getPrioritizedUnits(units);
	        for (var i = 0; i < prioritized.length; i++) {
	            this[prioritized[i].unit](units[prioritized[i].unit]);
	        }
	    } else {
	        units = normalizeUnits(units);
	        if (isFunction(this[units])) {
	            return this[units](value);
	        }
	    }
	    return this;
	}

	function mod(n, x) {
	    return ((n % x) + x) % x;
	}

	var indexOf;

	if (Array.prototype.indexOf) {
	    indexOf = Array.prototype.indexOf;
	} else {
	    indexOf = function (o) {
	        // I know
	        var i;
	        for (i = 0; i < this.length; ++i) {
	            if (this[i] === o) {
	                return i;
	            }
	        }
	        return -1;
	    };
	}

	function daysInMonth(year, month) {
	    if (isNaN(year) || isNaN(month)) {
	        return NaN;
	    }
	    var modMonth = mod(month, 12);
	    year += (month - modMonth) / 12;
	    return modMonth === 1 ? (isLeapYear(year) ? 29 : 28) : (31 - modMonth % 7 % 2);
	}

	// FORMATTING

	addFormatToken('M', ['MM', 2], 'Mo', function () {
	    return this.month() + 1;
	});

	addFormatToken('MMM', 0, 0, function (format) {
	    return this.localeData().monthsShort(this, format);
	});

	addFormatToken('MMMM', 0, 0, function (format) {
	    return this.localeData().months(this, format);
	});

	// ALIASES

	addUnitAlias('month', 'M');

	// PRIORITY

	addUnitPriority('month', 8);

	// PARSING

	addRegexToken('M',    match1to2);
	addRegexToken('MM',   match1to2, match2);
	addRegexToken('MMM',  function (isStrict, locale) {
	    return locale.monthsShortRegex(isStrict);
	});
	addRegexToken('MMMM', function (isStrict, locale) {
	    return locale.monthsRegex(isStrict);
	});

	addParseToken(['M', 'MM'], function (input, array) {
	    array[MONTH] = toInt(input) - 1;
	});

	addParseToken(['MMM', 'MMMM'], function (input, array, config, token) {
	    var month = config._locale.monthsParse(input, token, config._strict);
	    // if we didn't find a month name, mark the date as invalid.
	    if (month != null) {
	        array[MONTH] = month;
	    } else {
	        getParsingFlags(config).invalidMonth = input;
	    }
	});

	// LOCALES

	var MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/;
	var defaultLocaleMonths = 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_');
	function localeMonths (m, format) {
	    if (!m) {
	        return isArray(this._months) ? this._months :
	            this._months['standalone'];
	    }
	    return isArray(this._months) ? this._months[m.month()] :
	        this._months[(this._months.isFormat || MONTHS_IN_FORMAT).test(format) ? 'format' : 'standalone'][m.month()];
	}

	var defaultLocaleMonthsShort = 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_');
	function localeMonthsShort (m, format) {
	    if (!m) {
	        return isArray(this._monthsShort) ? this._monthsShort :
	            this._monthsShort['standalone'];
	    }
	    return isArray(this._monthsShort) ? this._monthsShort[m.month()] :
	        this._monthsShort[MONTHS_IN_FORMAT.test(format) ? 'format' : 'standalone'][m.month()];
	}

	function handleStrictParse(monthName, format, strict) {
	    var i, ii, mom, llc = monthName.toLocaleLowerCase();
	    if (!this._monthsParse) {
	        // this is not used
	        this._monthsParse = [];
	        this._longMonthsParse = [];
	        this._shortMonthsParse = [];
	        for (i = 0; i < 12; ++i) {
	            mom = createUTC([2000, i]);
	            this._shortMonthsParse[i] = this.monthsShort(mom, '').toLocaleLowerCase();
	            this._longMonthsParse[i] = this.months(mom, '').toLocaleLowerCase();
	        }
	    }

	    if (strict) {
	        if (format === 'MMM') {
	            ii = indexOf.call(this._shortMonthsParse, llc);
	            return ii !== -1 ? ii : null;
	        } else {
	            ii = indexOf.call(this._longMonthsParse, llc);
	            return ii !== -1 ? ii : null;
	        }
	    } else {
	        if (format === 'MMM') {
	            ii = indexOf.call(this._shortMonthsParse, llc);
	            if (ii !== -1) {
	                return ii;
	            }
	            ii = indexOf.call(this._longMonthsParse, llc);
	            return ii !== -1 ? ii : null;
	        } else {
	            ii = indexOf.call(this._longMonthsParse, llc);
	            if (ii !== -1) {
	                return ii;
	            }
	            ii = indexOf.call(this._shortMonthsParse, llc);
	            return ii !== -1 ? ii : null;
	        }
	    }
	}

	function localeMonthsParse (monthName, format, strict) {
	    var i, mom, regex;

	    if (this._monthsParseExact) {
	        return handleStrictParse.call(this, monthName, format, strict);
	    }

	    if (!this._monthsParse) {
	        this._monthsParse = [];
	        this._longMonthsParse = [];
	        this._shortMonthsParse = [];
	    }

	    // TODO: add sorting
	    // Sorting makes sure if one month (or abbr) is a prefix of another
	    // see sorting in computeMonthsParse
	    for (i = 0; i < 12; i++) {
	        // make the regex if we don't have it already
	        mom = createUTC([2000, i]);
	        if (strict && !this._longMonthsParse[i]) {
	            this._longMonthsParse[i] = new RegExp('^' + this.months(mom, '').replace('.', '') + '$', 'i');
	            this._shortMonthsParse[i] = new RegExp('^' + this.monthsShort(mom, '').replace('.', '') + '$', 'i');
	        }
	        if (!strict && !this._monthsParse[i]) {
	            regex = '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');
	            this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');
	        }
	        // test the regex
	        if (strict && format === 'MMMM' && this._longMonthsParse[i].test(monthName)) {
	            return i;
	        } else if (strict && format === 'MMM' && this._shortMonthsParse[i].test(monthName)) {
	            return i;
	        } else if (!strict && this._monthsParse[i].test(monthName)) {
	            return i;
	        }
	    }
	}

	// MOMENTS

	function setMonth (mom, value) {
	    var dayOfMonth;

	    if (!mom.isValid()) {
	        // No op
	        return mom;
	    }

	    if (typeof value === 'string') {
	        if (/^\d+$/.test(value)) {
	            value = toInt(value);
	        } else {
	            value = mom.localeData().monthsParse(value);
	            // TODO: Another silent failure?
	            if (!isNumber(value)) {
	                return mom;
	            }
	        }
	    }

	    dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));
	    mom._d['set' + (mom._isUTC ? 'UTC' : '') + 'Month'](value, dayOfMonth);
	    return mom;
	}

	function getSetMonth (value) {
	    if (value != null) {
	        setMonth(this, value);
	        hooks.updateOffset(this, true);
	        return this;
	    } else {
	        return get(this, 'Month');
	    }
	}

	function getDaysInMonth () {
	    return daysInMonth(this.year(), this.month());
	}

	var defaultMonthsShortRegex = matchWord;
	function monthsShortRegex (isStrict) {
	    if (this._monthsParseExact) {
	        if (!hasOwnProp(this, '_monthsRegex')) {
	            computeMonthsParse.call(this);
	        }
	        if (isStrict) {
	            return this._monthsShortStrictRegex;
	        } else {
	            return this._monthsShortRegex;
	        }
	    } else {
	        if (!hasOwnProp(this, '_monthsShortRegex')) {
	            this._monthsShortRegex = defaultMonthsShortRegex;
	        }
	        return this._monthsShortStrictRegex && isStrict ?
	            this._monthsShortStrictRegex : this._monthsShortRegex;
	    }
	}

	var defaultMonthsRegex = matchWord;
	function monthsRegex (isStrict) {
	    if (this._monthsParseExact) {
	        if (!hasOwnProp(this, '_monthsRegex')) {
	            computeMonthsParse.call(this);
	        }
	        if (isStrict) {
	            return this._monthsStrictRegex;
	        } else {
	            return this._monthsRegex;
	        }
	    } else {
	        if (!hasOwnProp(this, '_monthsRegex')) {
	            this._monthsRegex = defaultMonthsRegex;
	        }
	        return this._monthsStrictRegex && isStrict ?
	            this._monthsStrictRegex : this._monthsRegex;
	    }
	}

	function computeMonthsParse () {
	    function cmpLenRev(a, b) {
	        return b.length - a.length;
	    }

	    var shortPieces = [], longPieces = [], mixedPieces = [],
	        i, mom;
	    for (i = 0; i < 12; i++) {
	        // make the regex if we don't have it already
	        mom = createUTC([2000, i]);
	        shortPieces.push(this.monthsShort(mom, ''));
	        longPieces.push(this.months(mom, ''));
	        mixedPieces.push(this.months(mom, ''));
	        mixedPieces.push(this.monthsShort(mom, ''));
	    }
	    // Sorting makes sure if one month (or abbr) is a prefix of another it
	    // will match the longer piece.
	    shortPieces.sort(cmpLenRev);
	    longPieces.sort(cmpLenRev);
	    mixedPieces.sort(cmpLenRev);
	    for (i = 0; i < 12; i++) {
	        shortPieces[i] = regexEscape(shortPieces[i]);
	        longPieces[i] = regexEscape(longPieces[i]);
	    }
	    for (i = 0; i < 24; i++) {
	        mixedPieces[i] = regexEscape(mixedPieces[i]);
	    }

	    this._monthsRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
	    this._monthsShortRegex = this._monthsRegex;
	    this._monthsStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');
	    this._monthsShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');
	}

	function createDate (y, m, d, h, M, s, ms) {
	    // can't just apply() to create a date:
	    // https://stackoverflow.com/q/181348
	    var date;
	    // the date constructor remaps years 0-99 to 1900-1999
	    if (y < 100 && y >= 0) {
	        // preserve leap years using a full 400 year cycle, then reset
	        date = new Date(y + 400, m, d, h, M, s, ms);
	        if (isFinite(date.getFullYear())) {
	            date.setFullYear(y);
	        }
	    } else {
	        date = new Date(y, m, d, h, M, s, ms);
	    }

	    return date;
	}

	function createUTCDate (y) {
	    var date;
	    // the Date.UTC function remaps years 0-99 to 1900-1999
	    if (y < 100 && y >= 0) {
	        var args = Array.prototype.slice.call(arguments);
	        // preserve leap years using a full 400 year cycle, then reset
	        args[0] = y + 400;
	        date = new Date(Date.UTC.apply(null, args));
	        if (isFinite(date.getUTCFullYear())) {
	            date.setUTCFullYear(y);
	        }
	    } else {
	        date = new Date(Date.UTC.apply(null, arguments));
	    }

	    return date;
	}

	// start-of-first-week - start-of-year
	function firstWeekOffset(year, dow, doy) {
	    var // first-week day -- which january is always in the first week (4 for iso, 1 for other)
	        fwd = 7 + dow - doy,
	        // first-week day local weekday -- which local weekday is fwd
	        fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;

	    return -fwdlw + fwd - 1;
	}

	// https://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday
	function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
	    var localWeekday = (7 + weekday - dow) % 7,
	        weekOffset = firstWeekOffset(year, dow, doy),
	        dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset,
	        resYear, resDayOfYear;

	    if (dayOfYear <= 0) {
	        resYear = year - 1;
	        resDayOfYear = daysInYear(resYear) + dayOfYear;
	    } else if (dayOfYear > daysInYear(year)) {
	        resYear = year + 1;
	        resDayOfYear = dayOfYear - daysInYear(year);
	    } else {
	        resYear = year;
	        resDayOfYear = dayOfYear;
	    }

	    return {
	        year: resYear,
	        dayOfYear: resDayOfYear
	    };
	}

	function weekOfYear(mom, dow, doy) {
	    var weekOffset = firstWeekOffset(mom.year(), dow, doy),
	        week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1,
	        resWeek, resYear;

	    if (week < 1) {
	        resYear = mom.year() - 1;
	        resWeek = week + weeksInYear(resYear, dow, doy);
	    } else if (week > weeksInYear(mom.year(), dow, doy)) {
	        resWeek = week - weeksInYear(mom.year(), dow, doy);
	        resYear = mom.year() + 1;
	    } else {
	        resYear = mom.year();
	        resWeek = week;
	    }

	    return {
	        week: resWeek,
	        year: resYear
	    };
	}

	function weeksInYear(year, dow, doy) {
	    var weekOffset = firstWeekOffset(year, dow, doy),
	        weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
	    return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
	}

	// FORMATTING

	addFormatToken('w', ['ww', 2], 'wo', 'week');
	addFormatToken('W', ['WW', 2], 'Wo', 'isoWeek');

	// ALIASES

	addUnitAlias('week', 'w');
	addUnitAlias('isoWeek', 'W');

	// PRIORITIES

	addUnitPriority('week', 5);
	addUnitPriority('isoWeek', 5);

	// PARSING

	addRegexToken('w',  match1to2);
	addRegexToken('ww', match1to2, match2);
	addRegexToken('W',  match1to2);
	addRegexToken('WW', match1to2, match2);

	addWeekParseToken(['w', 'ww', 'W', 'WW'], function (input, week, config, token) {
	    week[token.substr(0, 1)] = toInt(input);
	});

	// HELPERS

	// LOCALES

	function localeWeek (mom) {
	    return weekOfYear(mom, this._week.dow, this._week.doy).week;
	}

	var defaultLocaleWeek = {
	    dow : 0, // Sunday is the first day of the week.
	    doy : 6  // The week that contains Jan 6th is the first week of the year.
	};

	function localeFirstDayOfWeek () {
	    return this._week.dow;
	}

	function localeFirstDayOfYear () {
	    return this._week.doy;
	}

	// MOMENTS

	function getSetWeek (input) {
	    var week = this.localeData().week(this);
	    return input == null ? week : this.add((input - week) * 7, 'd');
	}

	function getSetISOWeek (input) {
	    var week = weekOfYear(this, 1, 4).week;
	    return input == null ? week : this.add((input - week) * 7, 'd');
	}

	// FORMATTING

	addFormatToken('d', 0, 'do', 'day');

	addFormatToken('dd', 0, 0, function (format) {
	    return this.localeData().weekdaysMin(this, format);
	});

	addFormatToken('ddd', 0, 0, function (format) {
	    return this.localeData().weekdaysShort(this, format);
	});

	addFormatToken('dddd', 0, 0, function (format) {
	    return this.localeData().weekdays(this, format);
	});

	addFormatToken('e', 0, 0, 'weekday');
	addFormatToken('E', 0, 0, 'isoWeekday');

	// ALIASES

	addUnitAlias('day', 'd');
	addUnitAlias('weekday', 'e');
	addUnitAlias('isoWeekday', 'E');

	// PRIORITY
	addUnitPriority('day', 11);
	addUnitPriority('weekday', 11);
	addUnitPriority('isoWeekday', 11);

	// PARSING

	addRegexToken('d',    match1to2);
	addRegexToken('e',    match1to2);
	addRegexToken('E',    match1to2);
	addRegexToken('dd',   function (isStrict, locale) {
	    return locale.weekdaysMinRegex(isStrict);
	});
	addRegexToken('ddd',   function (isStrict, locale) {
	    return locale.weekdaysShortRegex(isStrict);
	});
	addRegexToken('dddd',   function (isStrict, locale) {
	    return locale.weekdaysRegex(isStrict);
	});

	addWeekParseToken(['dd', 'ddd', 'dddd'], function (input, week, config, token) {
	    var weekday = config._locale.weekdaysParse(input, token, config._strict);
	    // if we didn't get a weekday name, mark the date as invalid
	    if (weekday != null) {
	        week.d = weekday;
	    } else {
	        getParsingFlags(config).invalidWeekday = input;
	    }
	});

	addWeekParseToken(['d', 'e', 'E'], function (input, week, config, token) {
	    week[token] = toInt(input);
	});

	// HELPERS

	function parseWeekday(input, locale) {
	    if (typeof input !== 'string') {
	        return input;
	    }

	    if (!isNaN(input)) {
	        return parseInt(input, 10);
	    }

	    input = locale.weekdaysParse(input);
	    if (typeof input === 'number') {
	        return input;
	    }

	    return null;
	}

	function parseIsoWeekday(input, locale) {
	    if (typeof input === 'string') {
	        return locale.weekdaysParse(input) % 7 || 7;
	    }
	    return isNaN(input) ? null : input;
	}

	// LOCALES
	function shiftWeekdays (ws, n) {
	    return ws.slice(n, 7).concat(ws.slice(0, n));
	}

	var defaultLocaleWeekdays = 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_');
	function localeWeekdays (m, format) {
	    var weekdays = isArray(this._weekdays) ? this._weekdays :
	        this._weekdays[(m && m !== true && this._weekdays.isFormat.test(format)) ? 'format' : 'standalone'];
	    return (m === true) ? shiftWeekdays(weekdays, this._week.dow)
	        : (m) ? weekdays[m.day()] : weekdays;
	}

	var defaultLocaleWeekdaysShort = 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_');
	function localeWeekdaysShort (m) {
	    return (m === true) ? shiftWeekdays(this._weekdaysShort, this._week.dow)
	        : (m) ? this._weekdaysShort[m.day()] : this._weekdaysShort;
	}

	var defaultLocaleWeekdaysMin = 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_');
	function localeWeekdaysMin (m) {
	    return (m === true) ? shiftWeekdays(this._weekdaysMin, this._week.dow)
	        : (m) ? this._weekdaysMin[m.day()] : this._weekdaysMin;
	}

	function handleStrictParse$1(weekdayName, format, strict) {
	    var i, ii, mom, llc = weekdayName.toLocaleLowerCase();
	    if (!this._weekdaysParse) {
	        this._weekdaysParse = [];
	        this._shortWeekdaysParse = [];
	        this._minWeekdaysParse = [];

	        for (i = 0; i < 7; ++i) {
	            mom = createUTC([2000, 1]).day(i);
	            this._minWeekdaysParse[i] = this.weekdaysMin(mom, '').toLocaleLowerCase();
	            this._shortWeekdaysParse[i] = this.weekdaysShort(mom, '').toLocaleLowerCase();
	            this._weekdaysParse[i] = this.weekdays(mom, '').toLocaleLowerCase();
	        }
	    }

	    if (strict) {
	        if (format === 'dddd') {
	            ii = indexOf.call(this._weekdaysParse, llc);
	            return ii !== -1 ? ii : null;
	        } else if (format === 'ddd') {
	            ii = indexOf.call(this._shortWeekdaysParse, llc);
	            return ii !== -1 ? ii : null;
	        } else {
	            ii = indexOf.call(this._minWeekdaysParse, llc);
	            return ii !== -1 ? ii : null;
	        }
	    } else {
	        if (format === 'dddd') {
	            ii = indexOf.call(this._weekdaysParse, llc);
	            if (ii !== -1) {
	                return ii;
	            }
	            ii = indexOf.call(this._shortWeekdaysParse, llc);
	            if (ii !== -1) {
	                return ii;
	            }
	            ii = indexOf.call(this._minWeekdaysParse, llc);
	            return ii !== -1 ? ii : null;
	        } else if (format === 'ddd') {
	            ii = indexOf.call(this._shortWeekdaysParse, llc);
	            if (ii !== -1) {
	                return ii;
	            }
	            ii = indexOf.call(this._weekdaysParse, llc);
	            if (ii !== -1) {
	                return ii;
	            }
	            ii = indexOf.call(this._minWeekdaysParse, llc);
	            return ii !== -1 ? ii : null;
	        } else {
	            ii = indexOf.call(this._minWeekdaysParse, llc);
	            if (ii !== -1) {
	                return ii;
	            }
	            ii = indexOf.call(this._weekdaysParse, llc);
	            if (ii !== -1) {
	                return ii;
	            }
	            ii = indexOf.call(this._shortWeekdaysParse, llc);
	            return ii !== -1 ? ii : null;
	        }
	    }
	}

	function localeWeekdaysParse (weekdayName, format, strict) {
	    var i, mom, regex;

	    if (this._weekdaysParseExact) {
	        return handleStrictParse$1.call(this, weekdayName, format, strict);
	    }

	    if (!this._weekdaysParse) {
	        this._weekdaysParse = [];
	        this._minWeekdaysParse = [];
	        this._shortWeekdaysParse = [];
	        this._fullWeekdaysParse = [];
	    }

	    for (i = 0; i < 7; i++) {
	        // make the regex if we don't have it already

	        mom = createUTC([2000, 1]).day(i);
	        if (strict && !this._fullWeekdaysParse[i]) {
	            this._fullWeekdaysParse[i] = new RegExp('^' + this.weekdays(mom, '').replace('.', '\\.?') + '$', 'i');
	            this._shortWeekdaysParse[i] = new RegExp('^' + this.weekdaysShort(mom, '').replace('.', '\\.?') + '$', 'i');
	            this._minWeekdaysParse[i] = new RegExp('^' + this.weekdaysMin(mom, '').replace('.', '\\.?') + '$', 'i');
	        }
	        if (!this._weekdaysParse[i]) {
	            regex = '^' + this.weekdays(mom, '') + '|^' + this.weekdaysShort(mom, '') + '|^' + this.weekdaysMin(mom, '');
	            this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');
	        }
	        // test the regex
	        if (strict && format === 'dddd' && this._fullWeekdaysParse[i].test(weekdayName)) {
	            return i;
	        } else if (strict && format === 'ddd' && this._shortWeekdaysParse[i].test(weekdayName)) {
	            return i;
	        } else if (strict && format === 'dd' && this._minWeekdaysParse[i].test(weekdayName)) {
	            return i;
	        } else if (!strict && this._weekdaysParse[i].test(weekdayName)) {
	            return i;
	        }
	    }
	}

	// MOMENTS

	function getSetDayOfWeek (input) {
	    if (!this.isValid()) {
	        return input != null ? this : NaN;
	    }
	    var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
	    if (input != null) {
	        input = parseWeekday(input, this.localeData());
	        return this.add(input - day, 'd');
	    } else {
	        return day;
	    }
	}

	function getSetLocaleDayOfWeek (input) {
	    if (!this.isValid()) {
	        return input != null ? this : NaN;
	    }
	    var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
	    return input == null ? weekday : this.add(input - weekday, 'd');
	}

	function getSetISODayOfWeek (input) {
	    if (!this.isValid()) {
	        return input != null ? this : NaN;
	    }

	    // behaves the same as moment#day except
	    // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)
	    // as a setter, sunday should belong to the previous week.

	    if (input != null) {
	        var weekday = parseIsoWeekday(input, this.localeData());
	        return this.day(this.day() % 7 ? weekday : weekday - 7);
	    } else {
	        return this.day() || 7;
	    }
	}

	var defaultWeekdaysRegex = matchWord;
	function weekdaysRegex (isStrict) {
	    if (this._weekdaysParseExact) {
	        if (!hasOwnProp(this, '_weekdaysRegex')) {
	            computeWeekdaysParse.call(this);
	        }
	        if (isStrict) {
	            return this._weekdaysStrictRegex;
	        } else {
	            return this._weekdaysRegex;
	        }
	    } else {
	        if (!hasOwnProp(this, '_weekdaysRegex')) {
	            this._weekdaysRegex = defaultWeekdaysRegex;
	        }
	        return this._weekdaysStrictRegex && isStrict ?
	            this._weekdaysStrictRegex : this._weekdaysRegex;
	    }
	}

	var defaultWeekdaysShortRegex = matchWord;
	function weekdaysShortRegex (isStrict) {
	    if (this._weekdaysParseExact) {
	        if (!hasOwnProp(this, '_weekdaysRegex')) {
	            computeWeekdaysParse.call(this);
	        }
	        if (isStrict) {
	            return this._weekdaysShortStrictRegex;
	        } else {
	            return this._weekdaysShortRegex;
	        }
	    } else {
	        if (!hasOwnProp(this, '_weekdaysShortRegex')) {
	            this._weekdaysShortRegex = defaultWeekdaysShortRegex;
	        }
	        return this._weekdaysShortStrictRegex && isStrict ?
	            this._weekdaysShortStrictRegex : this._weekdaysShortRegex;
	    }
	}

	var defaultWeekdaysMinRegex = matchWord;
	function weekdaysMinRegex (isStrict) {
	    if (this._weekdaysParseExact) {
	        if (!hasOwnProp(this, '_weekdaysRegex')) {
	            computeWeekdaysParse.call(this);
	        }
	        if (isStrict) {
	            return this._weekdaysMinStrictRegex;
	        } else {
	            return this._weekdaysMinRegex;
	        }
	    } else {
	        if (!hasOwnProp(this, '_weekdaysMinRegex')) {
	            this._weekdaysMinRegex = defaultWeekdaysMinRegex;
	        }
	        return this._weekdaysMinStrictRegex && isStrict ?
	            this._weekdaysMinStrictRegex : this._weekdaysMinRegex;
	    }
	}


	function computeWeekdaysParse () {
	    function cmpLenRev(a, b) {
	        return b.length - a.length;
	    }

	    var minPieces = [], shortPieces = [], longPieces = [], mixedPieces = [],
	        i, mom, minp, shortp, longp;
	    for (i = 0; i < 7; i++) {
	        // make the regex if we don't have it already
	        mom = createUTC([2000, 1]).day(i);
	        minp = this.weekdaysMin(mom, '');
	        shortp = this.weekdaysShort(mom, '');
	        longp = this.weekdays(mom, '');
	        minPieces.push(minp);
	        shortPieces.push(shortp);
	        longPieces.push(longp);
	        mixedPieces.push(minp);
	        mixedPieces.push(shortp);
	        mixedPieces.push(longp);
	    }
	    // Sorting makes sure if one weekday (or abbr) is a prefix of another it
	    // will match the longer piece.
	    minPieces.sort(cmpLenRev);
	    shortPieces.sort(cmpLenRev);
	    longPieces.sort(cmpLenRev);
	    mixedPieces.sort(cmpLenRev);
	    for (i = 0; i < 7; i++) {
	        shortPieces[i] = regexEscape(shortPieces[i]);
	        longPieces[i] = regexEscape(longPieces[i]);
	        mixedPieces[i] = regexEscape(mixedPieces[i]);
	    }

	    this._weekdaysRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
	    this._weekdaysShortRegex = this._weekdaysRegex;
	    this._weekdaysMinRegex = this._weekdaysRegex;

	    this._weekdaysStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');
	    this._weekdaysShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');
	    this._weekdaysMinStrictRegex = new RegExp('^(' + minPieces.join('|') + ')', 'i');
	}

	// FORMATTING

	function hFormat() {
	    return this.hours() % 12 || 12;
	}

	function kFormat() {
	    return this.hours() || 24;
	}

	addFormatToken('H', ['HH', 2], 0, 'hour');
	addFormatToken('h', ['hh', 2], 0, hFormat);
	addFormatToken('k', ['kk', 2], 0, kFormat);

	addFormatToken('hmm', 0, 0, function () {
	    return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2);
	});

	addFormatToken('hmmss', 0, 0, function () {
	    return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2) +
	        zeroFill(this.seconds(), 2);
	});

	addFormatToken('Hmm', 0, 0, function () {
	    return '' + this.hours() + zeroFill(this.minutes(), 2);
	});

	addFormatToken('Hmmss', 0, 0, function () {
	    return '' + this.hours() + zeroFill(this.minutes(), 2) +
	        zeroFill(this.seconds(), 2);
	});

	function meridiem (token, lowercase) {
	    addFormatToken(token, 0, 0, function () {
	        return this.localeData().meridiem(this.hours(), this.minutes(), lowercase);
	    });
	}

	meridiem('a', true);
	meridiem('A', false);

	// ALIASES

	addUnitAlias('hour', 'h');

	// PRIORITY
	addUnitPriority('hour', 13);

	// PARSING

	function matchMeridiem (isStrict, locale) {
	    return locale._meridiemParse;
	}

	addRegexToken('a',  matchMeridiem);
	addRegexToken('A',  matchMeridiem);
	addRegexToken('H',  match1to2);
	addRegexToken('h',  match1to2);
	addRegexToken('k',  match1to2);
	addRegexToken('HH', match1to2, match2);
	addRegexToken('hh', match1to2, match2);
	addRegexToken('kk', match1to2, match2);

	addRegexToken('hmm', match3to4);
	addRegexToken('hmmss', match5to6);
	addRegexToken('Hmm', match3to4);
	addRegexToken('Hmmss', match5to6);

	addParseToken(['H', 'HH'], HOUR);
	addParseToken(['k', 'kk'], function (input, array, config) {
	    var kInput = toInt(input);
	    array[HOUR] = kInput === 24 ? 0 : kInput;
	});
	addParseToken(['a', 'A'], function (input, array, config) {
	    config._isPm = config._locale.isPM(input);
	    config._meridiem = input;
	});
	addParseToken(['h', 'hh'], function (input, array, config) {
	    array[HOUR] = toInt(input);
	    getParsingFlags(config).bigHour = true;
	});
	addParseToken('hmm', function (input, array, config) {
	    var pos = input.length - 2;
	    array[HOUR] = toInt(input.substr(0, pos));
	    array[MINUTE] = toInt(input.substr(pos));
	    getParsingFlags(config).bigHour = true;
	});
	addParseToken('hmmss', function (input, array, config) {
	    var pos1 = input.length - 4;
	    var pos2 = input.length - 2;
	    array[HOUR] = toInt(input.substr(0, pos1));
	    array[MINUTE] = toInt(input.substr(pos1, 2));
	    array[SECOND] = toInt(input.substr(pos2));
	    getParsingFlags(config).bigHour = true;
	});
	addParseToken('Hmm', function (input, array, config) {
	    var pos = input.length - 2;
	    array[HOUR] = toInt(input.substr(0, pos));
	    array[MINUTE] = toInt(input.substr(pos));
	});
	addParseToken('Hmmss', function (input, array, config) {
	    var pos1 = input.length - 4;
	    var pos2 = input.length - 2;
	    array[HOUR] = toInt(input.substr(0, pos1));
	    array[MINUTE] = toInt(input.substr(pos1, 2));
	    array[SECOND] = toInt(input.substr(pos2));
	});

	// LOCALES

	function localeIsPM (input) {
	    // IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays
	    // Using charAt should be more compatible.
	    return ((input + '').toLowerCase().charAt(0) === 'p');
	}

	var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i;
	function localeMeridiem (hours, minutes, isLower) {
	    if (hours > 11) {
	        return isLower ? 'pm' : 'PM';
	    } else {
	        return isLower ? 'am' : 'AM';
	    }
	}


	// MOMENTS

	// Setting the hour should keep the time, because the user explicitly
	// specified which hour they want. So trying to maintain the same hour (in
	// a new timezone) makes sense. Adding/subtracting hours does not follow
	// this rule.
	var getSetHour = makeGetSet('Hours', true);

	var baseConfig = {
	    calendar: defaultCalendar,
	    longDateFormat: defaultLongDateFormat,
	    invalidDate: defaultInvalidDate,
	    ordinal: defaultOrdinal,
	    dayOfMonthOrdinalParse: defaultDayOfMonthOrdinalParse,
	    relativeTime: defaultRelativeTime,

	    months: defaultLocaleMonths,
	    monthsShort: defaultLocaleMonthsShort,

	    week: defaultLocaleWeek,

	    weekdays: defaultLocaleWeekdays,
	    weekdaysMin: defaultLocaleWeekdaysMin,
	    weekdaysShort: defaultLocaleWeekdaysShort,

	    meridiemParse: defaultLocaleMeridiemParse
	};

	// internal storage for locale config files
	var locales = {};
	var localeFamilies = {};
	var globalLocale;

	function normalizeLocale(key) {
	    return key ? key.toLowerCase().replace('_', '-') : key;
	}

	// pick the locale from the array
	// try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each
	// substring from most specific to least, but move to the next array item if it's a more specific variant than the current root
	function chooseLocale(names) {
	    var i = 0, j, next, locale, split;

	    while (i < names.length) {
	        split = normalizeLocale(names[i]).split('-');
	        j = split.length;
	        next = normalizeLocale(names[i + 1]);
	        next = next ? next.split('-') : null;
	        while (j > 0) {
	            locale = loadLocale(split.slice(0, j).join('-'));
	            if (locale) {
	                return locale;
	            }
	            if (next && next.length >= j && compareArrays(split, next, true) >= j - 1) {
	                //the next array item is better than a shallower substring of this one
	                break;
	            }
	            j--;
	        }
	        i++;
	    }
	    return globalLocale;
	}

	function loadLocale(name) {
	    var oldLocale = null;
	    // TODO: Find a better way to register and load all the locales in Node
	    if (!locales[name] && (typeof module !== 'undefined') &&
	            module && module.exports) {
	        try {
	            oldLocale = globalLocale._abbr;
	            var aliasedRequire = require;
	            aliasedRequire('./locale/' + name);
	            getSetGlobalLocale(oldLocale);
	        } catch (e) {}
	    }
	    return locales[name];
	}

	// This function will load locale and then set the global locale.  If
	// no arguments are passed in, it will simply return the current global
	// locale key.
	function getSetGlobalLocale (key, values) {
	    var data;
	    if (key) {
	        if (isUndefined(values)) {
	            data = getLocale(key);
	        }
	        else {
	            data = defineLocale(key, values);
	        }

	        if (data) {
	            // moment.duration._locale = moment._locale = data;
	            globalLocale = data;
	        }
	        else {
	            if ((typeof console !==  'undefined') && console.warn) {
	                //warn user if arguments are passed but the locale could not be set
	                console.warn('Locale ' + key +  ' not found. Did you forget to load it?');
	            }
	        }
	    }

	    return globalLocale._abbr;
	}

	function defineLocale (name, config) {
	    if (config !== null) {
	        var locale, parentConfig = baseConfig;
	        config.abbr = name;
	        if (locales[name] != null) {
	            deprecateSimple('defineLocaleOverride',
	                    'use moment.updateLocale(localeName, config) to change ' +
	                    'an existing locale. moment.defineLocale(localeName, ' +
	                    'config) should only be used for creating a new locale ' +
	                    'See http://momentjs.com/guides/#/warnings/define-locale/ for more info.');
	            parentConfig = locales[name]._config;
	        } else if (config.parentLocale != null) {
	            if (locales[config.parentLocale] != null) {
	                parentConfig = locales[config.parentLocale]._config;
	            } else {
	                locale = loadLocale(config.parentLocale);
	                if (locale != null) {
	                    parentConfig = locale._config;
	                } else {
	                    if (!localeFamilies[config.parentLocale]) {
	                        localeFamilies[config.parentLocale] = [];
	                    }
	                    localeFamilies[config.parentLocale].push({
	                        name: name,
	                        config: config
	                    });
	                    return null;
	                }
	            }
	        }
	        locales[name] = new Locale(mergeConfigs(parentConfig, config));

	        if (localeFamilies[name]) {
	            localeFamilies[name].forEach(function (x) {
	                defineLocale(x.name, x.config);
	            });
	        }

	        // backwards compat for now: also set the locale
	        // make sure we set the locale AFTER all child locales have been
	        // created, so we won't end up with the child locale set.
	        getSetGlobalLocale(name);


	        return locales[name];
	    } else {
	        // useful for testing
	        delete locales[name];
	        return null;
	    }
	}

	function updateLocale(name, config) {
	    if (config != null) {
	        var locale, tmpLocale, parentConfig = baseConfig;
	        // MERGE
	        tmpLocale = loadLocale(name);
	        if (tmpLocale != null) {
	            parentConfig = tmpLocale._config;
	        }
	        config = mergeConfigs(parentConfig, config);
	        locale = new Locale(config);
	        locale.parentLocale = locales[name];
	        locales[name] = locale;

	        // backwards compat for now: also set the locale
	        getSetGlobalLocale(name);
	    } else {
	        // pass null for config to unupdate, useful for tests
	        if (locales[name] != null) {
	            if (locales[name].parentLocale != null) {
	                locales[name] = locales[name].parentLocale;
	            } else if (locales[name] != null) {
	                delete locales[name];
	            }
	        }
	    }
	    return locales[name];
	}

	// returns locale data
	function getLocale (key) {
	    var locale;

	    if (key && key._locale && key._locale._abbr) {
	        key = key._locale._abbr;
	    }

	    if (!key) {
	        return globalLocale;
	    }

	    if (!isArray(key)) {
	        //short-circuit everything else
	        locale = loadLocale(key);
	        if (locale) {
	            return locale;
	        }
	        key = [key];
	    }

	    return chooseLocale(key);
	}

	function listLocales() {
	    return keys(locales);
	}

	function checkOverflow (m) {
	    var overflow;
	    var a = m._a;

	    if (a && getParsingFlags(m).overflow === -2) {
	        overflow =
	            a[MONTH]       < 0 || a[MONTH]       > 11  ? MONTH :
	            a[DATE]        < 1 || a[DATE]        > daysInMonth(a[YEAR], a[MONTH]) ? DATE :
	            a[HOUR]        < 0 || a[HOUR]        > 24 || (a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0)) ? HOUR :
	            a[MINUTE]      < 0 || a[MINUTE]      > 59  ? MINUTE :
	            a[SECOND]      < 0 || a[SECOND]      > 59  ? SECOND :
	            a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND :
	            -1;

	        if (getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
	            overflow = DATE;
	        }
	        if (getParsingFlags(m)._overflowWeeks && overflow === -1) {
	            overflow = WEEK;
	        }
	        if (getParsingFlags(m)._overflowWeekday && overflow === -1) {
	            overflow = WEEKDAY;
	        }

	        getParsingFlags(m).overflow = overflow;
	    }

	    return m;
	}

	// Pick the first defined of two or three arguments.
	function defaults(a, b, c) {
	    if (a != null) {
	        return a;
	    }
	    if (b != null) {
	        return b;
	    }
	    return c;
	}

	function currentDateArray(config) {
	    // hooks is actually the exported moment object
	    var nowValue = new Date(hooks.now());
	    if (config._useUTC) {
	        return [nowValue.getUTCFullYear(), nowValue.getUTCMonth(), nowValue.getUTCDate()];
	    }
	    return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];
	}

	// convert an array to a date.
	// the array should mirror the parameters below
	// note: all values past the year are optional and will default to the lowest possible value.
	// [year, month, day , hour, minute, second, millisecond]
	function configFromArray (config) {
	    var i, date, input = [], currentDate, expectedWeekday, yearToUse;

	    if (config._d) {
	        return;
	    }

	    currentDate = currentDateArray(config);

	    //compute day of the year from weeks and weekdays
	    if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
	        dayOfYearFromWeekInfo(config);
	    }

	    //if the day of the year is set, figure out what it is
	    if (config._dayOfYear != null) {
	        yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);

	        if (config._dayOfYear > daysInYear(yearToUse) || config._dayOfYear === 0) {
	            getParsingFlags(config)._overflowDayOfYear = true;
	        }

	        date = createUTCDate(yearToUse, 0, config._dayOfYear);
	        config._a[MONTH] = date.getUTCMonth();
	        config._a[DATE] = date.getUTCDate();
	    }

	    // Default to current date.
	    // * if no year, month, day of month are given, default to today
	    // * if day of month is given, default month and year
	    // * if month is given, default only year
	    // * if year is given, don't default anything
	    for (i = 0; i < 3 && config._a[i] == null; ++i) {
	        config._a[i] = input[i] = currentDate[i];
	    }

	    // Zero out whatever was not defaulted, including time
	    for (; i < 7; i++) {
	        config._a[i] = input[i] = (config._a[i] == null) ? (i === 2 ? 1 : 0) : config._a[i];
	    }

	    // Check for 24:00:00.000
	    if (config._a[HOUR] === 24 &&
	            config._a[MINUTE] === 0 &&
	            config._a[SECOND] === 0 &&
	            config._a[MILLISECOND] === 0) {
	        config._nextDay = true;
	        config._a[HOUR] = 0;
	    }

	    config._d = (config._useUTC ? createUTCDate : createDate).apply(null, input);
	    expectedWeekday = config._useUTC ? config._d.getUTCDay() : config._d.getDay();

	    // Apply timezone offset from input. The actual utcOffset can be changed
	    // with parseZone.
	    if (config._tzm != null) {
	        config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
	    }

	    if (config._nextDay) {
	        config._a[HOUR] = 24;
	    }

	    // check for mismatching day of week
	    if (config._w && typeof config._w.d !== 'undefined' && config._w.d !== expectedWeekday) {
	        getParsingFlags(config).weekdayMismatch = true;
	    }
	}

	function dayOfYearFromWeekInfo(config) {
	    var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow;

	    w = config._w;
	    if (w.GG != null || w.W != null || w.E != null) {
	        dow = 1;
	        doy = 4;

	        // TODO: We need to take the current isoWeekYear, but that depends on
	        // how we interpret now (local, utc, fixed offset). So create
	        // a now version of current config (take local/utc/offset flags, and
	        // create now).
	        weekYear = defaults(w.GG, config._a[YEAR], weekOfYear(createLocal(), 1, 4).year);
	        week = defaults(w.W, 1);
	        weekday = defaults(w.E, 1);
	        if (weekday < 1 || weekday > 7) {
	            weekdayOverflow = true;
	        }
	    } else {
	        dow = config._locale._week.dow;
	        doy = config._locale._week.doy;

	        var curWeek = weekOfYear(createLocal(), dow, doy);

	        weekYear = defaults(w.gg, config._a[YEAR], curWeek.year);

	        // Default to current week.
	        week = defaults(w.w, curWeek.week);

	        if (w.d != null) {
	            // weekday -- low day numbers are considered next week
	            weekday = w.d;
	            if (weekday < 0 || weekday > 6) {
	                weekdayOverflow = true;
	            }
	        } else if (w.e != null) {
	            // local weekday -- counting starts from beginning of week
	            weekday = w.e + dow;
	            if (w.e < 0 || w.e > 6) {
	                weekdayOverflow = true;
	            }
	        } else {
	            // default to beginning of week
	            weekday = dow;
	        }
	    }
	    if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {
	        getParsingFlags(config)._overflowWeeks = true;
	    } else if (weekdayOverflow != null) {
	        getParsingFlags(config)._overflowWeekday = true;
	    } else {
	        temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
	        config._a[YEAR] = temp.year;
	        config._dayOfYear = temp.dayOfYear;
	    }
	}

	// iso 8601 regex
	// 0000-00-00 0000-W00 or 0000-W00-0 + T + 00 or 00:00 or 00:00:00 or 00:00:00.000 + +00:00 or +0000 or +00)
	var extendedIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/;
	var basicIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/;

	var tzRegex = /Z|[+-]\d\d(?::?\d\d)?/;

	var isoDates = [
	    ['YYYYYY-MM-DD', /[+-]\d{6}-\d\d-\d\d/],
	    ['YYYY-MM-DD', /\d{4}-\d\d-\d\d/],
	    ['GGGG-[W]WW-E', /\d{4}-W\d\d-\d/],
	    ['GGGG-[W]WW', /\d{4}-W\d\d/, false],
	    ['YYYY-DDD', /\d{4}-\d{3}/],
	    ['YYYY-MM', /\d{4}-\d\d/, false],
	    ['YYYYYYMMDD', /[+-]\d{10}/],
	    ['YYYYMMDD', /\d{8}/],
	    // YYYYMM is NOT allowed by the standard
	    ['GGGG[W]WWE', /\d{4}W\d{3}/],
	    ['GGGG[W]WW', /\d{4}W\d{2}/, false],
	    ['YYYYDDD', /\d{7}/]
	];

	// iso time formats and regexes
	var isoTimes = [
	    ['HH:mm:ss.SSSS', /\d\d:\d\d:\d\d\.\d+/],
	    ['HH:mm:ss,SSSS', /\d\d:\d\d:\d\d,\d+/],
	    ['HH:mm:ss', /\d\d:\d\d:\d\d/],
	    ['HH:mm', /\d\d:\d\d/],
	    ['HHmmss.SSSS', /\d\d\d\d\d\d\.\d+/],
	    ['HHmmss,SSSS', /\d\d\d\d\d\d,\d+/],
	    ['HHmmss', /\d\d\d\d\d\d/],
	    ['HHmm', /\d\d\d\d/],
	    ['HH', /\d\d/]
	];

	var aspNetJsonRegex = /^\/?Date\((\-?\d+)/i;

	// date from iso format
	function configFromISO(config) {
	    var i, l,
	        string = config._i,
	        match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string),
	        allowTime, dateFormat, timeFormat, tzFormat;

	    if (match) {
	        getParsingFlags(config).iso = true;

	        for (i = 0, l = isoDates.length; i < l; i++) {
	            if (isoDates[i][1].exec(match[1])) {
	                dateFormat = isoDates[i][0];
	                allowTime = isoDates[i][2] !== false;
	                break;
	            }
	        }
	        if (dateFormat == null) {
	            config._isValid = false;
	            return;
	        }
	        if (match[3]) {
	            for (i = 0, l = isoTimes.length; i < l; i++) {
	                if (isoTimes[i][1].exec(match[3])) {
	                    // match[2] should be 'T' or space
	                    timeFormat = (match[2] || ' ') + isoTimes[i][0];
	                    break;
	                }
	            }
	            if (timeFormat == null) {
	                config._isValid = false;
	                return;
	            }
	        }
	        if (!allowTime && timeFormat != null) {
	            config._isValid = false;
	            return;
	        }
	        if (match[4]) {
	            if (tzRegex.exec(match[4])) {
	                tzFormat = 'Z';
	            } else {
	                config._isValid = false;
	                return;
	            }
	        }
	        config._f = dateFormat + (timeFormat || '') + (tzFormat || '');
	        configFromStringAndFormat(config);
	    } else {
	        config._isValid = false;
	    }
	}

	// RFC 2822 regex: For details see https://tools.ietf.org/html/rfc2822#section-3.3
	var rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/;

	function extractFromRFC2822Strings(yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {
	    var result = [
	        untruncateYear(yearStr),
	        defaultLocaleMonthsShort.indexOf(monthStr),
	        parseInt(dayStr, 10),
	        parseInt(hourStr, 10),
	        parseInt(minuteStr, 10)
	    ];

	    if (secondStr) {
	        result.push(parseInt(secondStr, 10));
	    }

	    return result;
	}

	function untruncateYear(yearStr) {
	    var year = parseInt(yearStr, 10);
	    if (year <= 49) {
	        return 2000 + year;
	    } else if (year <= 999) {
	        return 1900 + year;
	    }
	    return year;
	}

	function preprocessRFC2822(s) {
	    // Remove comments and folding whitespace and replace multiple-spaces with a single space
	    return s.replace(/\([^)]*\)|[\n\t]/g, ' ').replace(/(\s\s+)/g, ' ').replace(/^\s\s*/, '').replace(/\s\s*$/, '');
	}

	function checkWeekday(weekdayStr, parsedInput, config) {
	    if (weekdayStr) {
	        // TODO: Replace the vanilla JS Date object with an indepentent day-of-week check.
	        var weekdayProvided = defaultLocaleWeekdaysShort.indexOf(weekdayStr),
	            weekdayActual = new Date(parsedInput[0], parsedInput[1], parsedInput[2]).getDay();
	        if (weekdayProvided !== weekdayActual) {
	            getParsingFlags(config).weekdayMismatch = true;
	            config._isValid = false;
	            return false;
	        }
	    }
	    return true;
	}

	var obsOffsets = {
	    UT: 0,
	    GMT: 0,
	    EDT: -4 * 60,
	    EST: -5 * 60,
	    CDT: -5 * 60,
	    CST: -6 * 60,
	    MDT: -6 * 60,
	    MST: -7 * 60,
	    PDT: -7 * 60,
	    PST: -8 * 60
	};

	function calculateOffset(obsOffset, militaryOffset, numOffset) {
	    if (obsOffset) {
	        return obsOffsets[obsOffset];
	    } else if (militaryOffset) {
	        // the only allowed military tz is Z
	        return 0;
	    } else {
	        var hm = parseInt(numOffset, 10);
	        var m = hm % 100, h = (hm - m) / 100;
	        return h * 60 + m;
	    }
	}

	// date and time from ref 2822 format
	function configFromRFC2822(config) {
	    var match = rfc2822.exec(preprocessRFC2822(config._i));
	    if (match) {
	        var parsedArray = extractFromRFC2822Strings(match[4], match[3], match[2], match[5], match[6], match[7]);
	        if (!checkWeekday(match[1], parsedArray, config)) {
	            return;
	        }

	        config._a = parsedArray;
	        config._tzm = calculateOffset(match[8], match[9], match[10]);

	        config._d = createUTCDate.apply(null, config._a);
	        config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);

	        getParsingFlags(config).rfc2822 = true;
	    } else {
	        config._isValid = false;
	    }
	}

	// date from iso format or fallback
	function configFromString(config) {
	    var matched = aspNetJsonRegex.exec(config._i);

	    if (matched !== null) {
	        config._d = new Date(+matched[1]);
	        return;
	    }

	    configFromISO(config);
	    if (config._isValid === false) {
	        delete config._isValid;
	    } else {
	        return;
	    }

	    configFromRFC2822(config);
	    if (config._isValid === false) {
	        delete config._isValid;
	    } else {
	        return;
	    }

	    // Final attempt, use Input Fallback
	    hooks.createFromInputFallback(config);
	}

	hooks.createFromInputFallback = deprecate(
	    'value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), ' +
	    'which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are ' +
	    'discouraged and will be removed in an upcoming major release. Please refer to ' +
	    'http://momentjs.com/guides/#/warnings/js-date/ for more info.',
	    function (config) {
	        config._d = new Date(config._i + (config._useUTC ? ' UTC' : ''));
	    }
	);

	// constant that refers to the ISO standard
	hooks.ISO_8601 = function () {};

	// constant that refers to the RFC 2822 form
	hooks.RFC_2822 = function () {};

	// date from string and format string
	function configFromStringAndFormat(config) {
	    // TODO: Move this to another part of the creation flow to prevent circular deps
	    if (config._f === hooks.ISO_8601) {
	        configFromISO(config);
	        return;
	    }
	    if (config._f === hooks.RFC_2822) {
	        configFromRFC2822(config);
	        return;
	    }
	    config._a = [];
	    getParsingFlags(config).empty = true;

	    // This array is used to make a Date, either with `new Date` or `Date.UTC`
	    var string = '' + config._i,
	        i, parsedInput, tokens, token, skipped,
	        stringLength = string.length,
	        totalParsedInputLength = 0;

	    tokens = expandFormat(config._f, config._locale).match(formattingTokens) || [];

	    for (i = 0; i < tokens.length; i++) {
	        token = tokens[i];
	        parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0];
	        // console.log('token', token, 'parsedInput', parsedInput,
	        //         'regex', getParseRegexForToken(token, config));
	        if (parsedInput) {
	            skipped = string.substr(0, string.indexOf(parsedInput));
	            if (skipped.length > 0) {
	                getParsingFlags(config).unusedInput.push(skipped);
	            }
	            string = string.slice(string.indexOf(parsedInput) + parsedInput.length);
	            totalParsedInputLength += parsedInput.length;
	        }
	        // don't parse if it's not a known token
	        if (formatTokenFunctions[token]) {
	            if (parsedInput) {
	                getParsingFlags(config).empty = false;
	            }
	            else {
	                getParsingFlags(config).unusedTokens.push(token);
	            }
	            addTimeToArrayFromToken(token, parsedInput, config);
	        }
	        else if (config._strict && !parsedInput) {
	            getParsingFlags(config).unusedTokens.push(token);
	        }
	    }

	    // add remaining unparsed input length to the string
	    getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;
	    if (string.length > 0) {
	        getParsingFlags(config).unusedInput.push(string);
	    }

	    // clear _12h flag if hour is <= 12
	    if (config._a[HOUR] <= 12 &&
	        getParsingFlags(config).bigHour === true &&
	        config._a[HOUR] > 0) {
	        getParsingFlags(config).bigHour = undefined;
	    }

	    getParsingFlags(config).parsedDateParts = config._a.slice(0);
	    getParsingFlags(config).meridiem = config._meridiem;
	    // handle meridiem
	    config._a[HOUR] = meridiemFixWrap(config._locale, config._a[HOUR], config._meridiem);

	    configFromArray(config);
	    checkOverflow(config);
	}


	function meridiemFixWrap (locale, hour, meridiem) {
	    var isPm;

	    if (meridiem == null) {
	        // nothing to do
	        return hour;
	    }
	    if (locale.meridiemHour != null) {
	        return locale.meridiemHour(hour, meridiem);
	    } else if (locale.isPM != null) {
	        // Fallback
	        isPm = locale.isPM(meridiem);
	        if (isPm && hour < 12) {
	            hour += 12;
	        }
	        if (!isPm && hour === 12) {
	            hour = 0;
	        }
	        return hour;
	    } else {
	        // this is not supposed to happen
	        return hour;
	    }
	}

	// date from string and array of format strings
	function configFromStringAndArray(config) {
	    var tempConfig,
	        bestMoment,

	        scoreToBeat,
	        i,
	        currentScore;

	    if (config._f.length === 0) {
	        getParsingFlags(config).invalidFormat = true;
	        config._d = new Date(NaN);
	        return;
	    }

	    for (i = 0; i < config._f.length; i++) {
	        currentScore = 0;
	        tempConfig = copyConfig({}, config);
	        if (config._useUTC != null) {
	            tempConfig._useUTC = config._useUTC;
	        }
	        tempConfig._f = config._f[i];
	        configFromStringAndFormat(tempConfig);

	        if (!isValid(tempConfig)) {
	            continue;
	        }

	        // if there is any input that was not parsed add a penalty for that format
	        currentScore += getParsingFlags(tempConfig).charsLeftOver;

	        //or tokens
	        currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;

	        getParsingFlags(tempConfig).score = currentScore;

	        if (scoreToBeat == null || currentScore < scoreToBeat) {
	            scoreToBeat = currentScore;
	            bestMoment = tempConfig;
	        }
	    }

	    extend(config, bestMoment || tempConfig);
	}

	function configFromObject(config) {
	    if (config._d) {
	        return;
	    }

	    var i = normalizeObjectUnits(config._i);
	    config._a = map([i.year, i.month, i.day || i.date, i.hour, i.minute, i.second, i.millisecond], function (obj) {
	        return obj && parseInt(obj, 10);
	    });

	    configFromArray(config);
	}

	function createFromConfig (config) {
	    var res = new Moment(checkOverflow(prepareConfig(config)));
	    if (res._nextDay) {
	        // Adding is smart enough around DST
	        res.add(1, 'd');
	        res._nextDay = undefined;
	    }

	    return res;
	}

	function prepareConfig (config) {
	    var input = config._i,
	        format = config._f;

	    config._locale = config._locale || getLocale(config._l);

	    if (input === null || (format === undefined && input === '')) {
	        return createInvalid({nullInput: true});
	    }

	    if (typeof input === 'string') {
	        config._i = input = config._locale.preparse(input);
	    }

	    if (isMoment(input)) {
	        return new Moment(checkOverflow(input));
	    } else if (isDate(input)) {
	        config._d = input;
	    } else if (isArray(format)) {
	        configFromStringAndArray(config);
	    } else if (format) {
	        configFromStringAndFormat(config);
	    }  else {
	        configFromInput(config);
	    }

	    if (!isValid(config)) {
	        config._d = null;
	    }

	    return config;
	}

	function configFromInput(config) {
	    var input = config._i;
	    if (isUndefined(input)) {
	        config._d = new Date(hooks.now());
	    } else if (isDate(input)) {
	        config._d = new Date(input.valueOf());
	    } else if (typeof input === 'string') {
	        configFromString(config);
	    } else if (isArray(input)) {
	        config._a = map(input.slice(0), function (obj) {
	            return parseInt(obj, 10);
	        });
	        configFromArray(config);
	    } else if (isObject(input)) {
	        configFromObject(config);
	    } else if (isNumber(input)) {
	        // from milliseconds
	        config._d = new Date(input);
	    } else {
	        hooks.createFromInputFallback(config);
	    }
	}

	function createLocalOrUTC (input, format, locale, strict, isUTC) {
	    var c = {};

	    if (locale === true || locale === false) {
	        strict = locale;
	        locale = undefined;
	    }

	    if ((isObject(input) && isObjectEmpty(input)) ||
	            (isArray(input) && input.length === 0)) {
	        input = undefined;
	    }
	    // object construction must be done this way.
	    // https://github.com/moment/moment/issues/1423
	    c._isAMomentObject = true;
	    c._useUTC = c._isUTC = isUTC;
	    c._l = locale;
	    c._i = input;
	    c._f = format;
	    c._strict = strict;

	    return createFromConfig(c);
	}

	function createLocal (input, format, locale, strict) {
	    return createLocalOrUTC(input, format, locale, strict, false);
	}

	var prototypeMin = deprecate(
	    'moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/',
	    function () {
	        var other = createLocal.apply(null, arguments);
	        if (this.isValid() && other.isValid()) {
	            return other < this ? this : other;
	        } else {
	            return createInvalid();
	        }
	    }
	);

	var prototypeMax = deprecate(
	    'moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/',
	    function () {
	        var other = createLocal.apply(null, arguments);
	        if (this.isValid() && other.isValid()) {
	            return other > this ? this : other;
	        } else {
	            return createInvalid();
	        }
	    }
	);

	// Pick a moment m from moments so that m[fn](other) is true for all
	// other. This relies on the function fn to be transitive.
	//
	// moments should either be an array of moment objects or an array, whose
	// first element is an array of moment objects.
	function pickBy(fn, moments) {
	    var res, i;
	    if (moments.length === 1 && isArray(moments[0])) {
	        moments = moments[0];
	    }
	    if (!moments.length) {
	        return createLocal();
	    }
	    res = moments[0];
	    for (i = 1; i < moments.length; ++i) {
	        if (!moments[i].isValid() || moments[i][fn](res)) {
	            res = moments[i];
	        }
	    }
	    return res;
	}

	// TODO: Use [].sort instead?
	function min () {
	    var args = [].slice.call(arguments, 0);

	    return pickBy('isBefore', args);
	}

	function max () {
	    var args = [].slice.call(arguments, 0);

	    return pickBy('isAfter', args);
	}

	var now = function () {
	    return Date.now ? Date.now() : +(new Date());
	};

	var ordering = ['year', 'quarter', 'month', 'week', 'day', 'hour', 'minute', 'second', 'millisecond'];

	function isDurationValid(m) {
	    for (var key in m) {
	        if (!(indexOf.call(ordering, key) !== -1 && (m[key] == null || !isNaN(m[key])))) {
	            return false;
	        }
	    }

	    var unitHasDecimal = false;
	    for (var i = 0; i < ordering.length; ++i) {
	        if (m[ordering[i]]) {
	            if (unitHasDecimal) {
	                return false; // only allow non-integers for smallest unit
	            }
	            if (parseFloat(m[ordering[i]]) !== toInt(m[ordering[i]])) {
	                unitHasDecimal = true;
	            }
	        }
	    }

	    return true;
	}

	function isValid$1() {
	    return this._isValid;
	}

	function createInvalid$1() {
	    return createDuration(NaN);
	}

	function Duration (duration) {
	    var normalizedInput = normalizeObjectUnits(duration),
	        years = normalizedInput.year || 0,
	        quarters = normalizedInput.quarter || 0,
	        months = normalizedInput.month || 0,
	        weeks = normalizedInput.week || normalizedInput.isoWeek || 0,
	        days = normalizedInput.day || 0,
	        hours = normalizedInput.hour || 0,
	        minutes = normalizedInput.minute || 0,
	        seconds = normalizedInput.second || 0,
	        milliseconds = normalizedInput.millisecond || 0;

	    this._isValid = isDurationValid(normalizedInput);

	    // representation for dateAddRemove
	    this._milliseconds = +milliseconds +
	        seconds * 1e3 + // 1000
	        minutes * 6e4 + // 1000 * 60
	        hours * 1000 * 60 * 60; //using 1000 * 60 * 60 instead of 36e5 to avoid floating point rounding errors https://github.com/moment/moment/issues/2978
	    // Because of dateAddRemove treats 24 hours as different from a
	    // day when working around DST, we need to store them separately
	    this._days = +days +
	        weeks * 7;
	    // It is impossible to translate months into days without knowing
	    // which months you are are talking about, so we have to store
	    // it separately.
	    this._months = +months +
	        quarters * 3 +
	        years * 12;

	    this._data = {};

	    this._locale = getLocale();

	    this._bubble();
	}

	function isDuration (obj) {
	    return obj instanceof Duration;
	}

	function absRound (number) {
	    if (number < 0) {
	        return Math.round(-1 * number) * -1;
	    } else {
	        return Math.round(number);
	    }
	}

	// FORMATTING

	function offset (token, separator) {
	    addFormatToken(token, 0, 0, function () {
	        var offset = this.utcOffset();
	        var sign = '+';
	        if (offset < 0) {
	            offset = -offset;
	            sign = '-';
	        }
	        return sign + zeroFill(~~(offset / 60), 2) + separator + zeroFill(~~(offset) % 60, 2);
	    });
	}

	offset('Z', ':');
	offset('ZZ', '');

	// PARSING

	addRegexToken('Z',  matchShortOffset);
	addRegexToken('ZZ', matchShortOffset);
	addParseToken(['Z', 'ZZ'], function (input, array, config) {
	    config._useUTC = true;
	    config._tzm = offsetFromString(matchShortOffset, input);
	});

	// HELPERS

	// timezone chunker
	// '+10:00' > ['10',  '00']
	// '-1530'  > ['-15', '30']
	var chunkOffset = /([\+\-]|\d\d)/gi;

	function offsetFromString(matcher, string) {
	    var matches = (string || '').match(matcher);

	    if (matches === null) {
	        return null;
	    }

	    var chunk   = matches[matches.length - 1] || [];
	    var parts   = (chunk + '').match(chunkOffset) || ['-', 0, 0];
	    var minutes = +(parts[1] * 60) + toInt(parts[2]);

	    return minutes === 0 ?
	      0 :
	      parts[0] === '+' ? minutes : -minutes;
	}

	// Return a moment from input, that is local/utc/zone equivalent to model.
	function cloneWithOffset(input, model) {
	    var res, diff;
	    if (model._isUTC) {
	        res = model.clone();
	        diff = (isMoment(input) || isDate(input) ? input.valueOf() : createLocal(input).valueOf()) - res.valueOf();
	        // Use low-level api, because this fn is low-level api.
	        res._d.setTime(res._d.valueOf() + diff);
	        hooks.updateOffset(res, false);
	        return res;
	    } else {
	        return createLocal(input).local();
	    }
	}

	function getDateOffset (m) {
	    // On Firefox.24 Date#getTimezoneOffset returns a floating point.
	    // https://github.com/moment/moment/pull/1871
	    return -Math.round(m._d.getTimezoneOffset() / 15) * 15;
	}

	// HOOKS

	// This function will be called whenever a moment is mutated.
	// It is intended to keep the offset in sync with the timezone.
	hooks.updateOffset = function () {};

	// MOMENTS

	// keepLocalTime = true means only change the timezone, without
	// affecting the local hour. So 5:31:26 +0300 --[utcOffset(2, true)]-->
	// 5:31:26 +0200 It is possible that 5:31:26 doesn't exist with offset
	// +0200, so we adjust the time as needed, to be valid.
	//
	// Keeping the time actually adds/subtracts (one hour)
	// from the actual represented time. That is why we call updateOffset
	// a second time. In case it wants us to change the offset again
	// _changeInProgress == true case, then we have to adjust, because
	// there is no such time in the given timezone.
	function getSetOffset (input, keepLocalTime, keepMinutes) {
	    var offset = this._offset || 0,
	        localAdjust;
	    if (!this.isValid()) {
	        return input != null ? this : NaN;
	    }
	    if (input != null) {
	        if (typeof input === 'string') {
	            input = offsetFromString(matchShortOffset, input);
	            if (input === null) {
	                return this;
	            }
	        } else if (Math.abs(input) < 16 && !keepMinutes) {
	            input = input * 60;
	        }
	        if (!this._isUTC && keepLocalTime) {
	            localAdjust = getDateOffset(this);
	        }
	        this._offset = input;
	        this._isUTC = true;
	        if (localAdjust != null) {
	            this.add(localAdjust, 'm');
	        }
	        if (offset !== input) {
	            if (!keepLocalTime || this._changeInProgress) {
	                addSubtract(this, createDuration(input - offset, 'm'), 1, false);
	            } else if (!this._changeInProgress) {
	                this._changeInProgress = true;
	                hooks.updateOffset(this, true);
	                this._changeInProgress = null;
	            }
	        }
	        return this;
	    } else {
	        return this._isUTC ? offset : getDateOffset(this);
	    }
	}

	function getSetZone (input, keepLocalTime) {
	    if (input != null) {
	        if (typeof input !== 'string') {
	            input = -input;
	        }

	        this.utcOffset(input, keepLocalTime);

	        return this;
	    } else {
	        return -this.utcOffset();
	    }
	}

	function setOffsetToUTC (keepLocalTime) {
	    return this.utcOffset(0, keepLocalTime);
	}

	function setOffsetToLocal (keepLocalTime) {
	    if (this._isUTC) {
	        this.utcOffset(0, keepLocalTime);
	        this._isUTC = false;

	        if (keepLocalTime) {
	            this.subtract(getDateOffset(this), 'm');
	        }
	    }
	    return this;
	}

	function setOffsetToParsedOffset () {
	    if (this._tzm != null) {
	        this.utcOffset(this._tzm, false, true);
	    } else if (typeof this._i === 'string') {
	        var tZone = offsetFromString(matchOffset, this._i);
	        if (tZone != null) {
	            this.utcOffset(tZone);
	        }
	        else {
	            this.utcOffset(0, true);
	        }
	    }
	    return this;
	}

	function hasAlignedHourOffset (input) {
	    if (!this.isValid()) {
	        return false;
	    }
	    input = input ? createLocal(input).utcOffset() : 0;

	    return (this.utcOffset() - input) % 60 === 0;
	}

	function isDaylightSavingTime () {
	    return (
	        this.utcOffset() > this.clone().month(0).utcOffset() ||
	        this.utcOffset() > this.clone().month(5).utcOffset()
	    );
	}

	function isDaylightSavingTimeShifted () {
	    if (!isUndefined(this._isDSTShifted)) {
	        return this._isDSTShifted;
	    }

	    var c = {};

	    copyConfig(c, this);
	    c = prepareConfig(c);

	    if (c._a) {
	        var other = c._isUTC ? createUTC(c._a) : createLocal(c._a);
	        this._isDSTShifted = this.isValid() &&
	            compareArrays(c._a, other.toArray()) > 0;
	    } else {
	        this._isDSTShifted = false;
	    }

	    return this._isDSTShifted;
	}

	function isLocal () {
	    return this.isValid() ? !this._isUTC : false;
	}

	function isUtcOffset () {
	    return this.isValid() ? this._isUTC : false;
	}

	function isUtc () {
	    return this.isValid() ? this._isUTC && this._offset === 0 : false;
	}

	// ASP.NET json date format regex
	var aspNetRegex = /^(\-|\+)?(?:(\d*)[. ])?(\d+)\:(\d+)(?:\:(\d+)(\.\d*)?)?$/;

	// from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html
	// somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere
	// and further modified to allow for strings containing both week and day
	var isoRegex = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;

	function createDuration (input, key) {
	    var duration = input,
	        // matching against regexp is expensive, do it on demand
	        match = null,
	        sign,
	        ret,
	        diffRes;

	    if (isDuration(input)) {
	        duration = {
	            ms : input._milliseconds,
	            d  : input._days,
	            M  : input._months
	        };
	    } else if (isNumber(input)) {
	        duration = {};
	        if (key) {
	            duration[key] = input;
	        } else {
	            duration.milliseconds = input;
	        }
	    } else if (!!(match = aspNetRegex.exec(input))) {
	        sign = (match[1] === '-') ? -1 : 1;
	        duration = {
	            y  : 0,
	            d  : toInt(match[DATE])                         * sign,
	            h  : toInt(match[HOUR])                         * sign,
	            m  : toInt(match[MINUTE])                       * sign,
	            s  : toInt(match[SECOND])                       * sign,
	            ms : toInt(absRound(match[MILLISECOND] * 1000)) * sign // the millisecond decimal point is included in the match
	        };
	    } else if (!!(match = isoRegex.exec(input))) {
	        sign = (match[1] === '-') ? -1 : 1;
	        duration = {
	            y : parseIso(match[2], sign),
	            M : parseIso(match[3], sign),
	            w : parseIso(match[4], sign),
	            d : parseIso(match[5], sign),
	            h : parseIso(match[6], sign),
	            m : parseIso(match[7], sign),
	            s : parseIso(match[8], sign)
	        };
	    } else if (duration == null) {// checks for null or undefined
	        duration = {};
	    } else if (typeof duration === 'object' && ('from' in duration || 'to' in duration)) {
	        diffRes = momentsDifference(createLocal(duration.from), createLocal(duration.to));

	        duration = {};
	        duration.ms = diffRes.milliseconds;
	        duration.M = diffRes.months;
	    }

	    ret = new Duration(duration);

	    if (isDuration(input) && hasOwnProp(input, '_locale')) {
	        ret._locale = input._locale;
	    }

	    return ret;
	}

	createDuration.fn = Duration.prototype;
	createDuration.invalid = createInvalid$1;

	function parseIso (inp, sign) {
	    // We'd normally use ~~inp for this, but unfortunately it also
	    // converts floats to ints.
	    // inp may be undefined, so careful calling replace on it.
	    var res = inp && parseFloat(inp.replace(',', '.'));
	    // apply sign while we're at it
	    return (isNaN(res) ? 0 : res) * sign;
	}

	function positiveMomentsDifference(base, other) {
	    var res = {};

	    res.months = other.month() - base.month() +
	        (other.year() - base.year()) * 12;
	    if (base.clone().add(res.months, 'M').isAfter(other)) {
	        --res.months;
	    }

	    res.milliseconds = +other - +(base.clone().add(res.months, 'M'));

	    return res;
	}

	function momentsDifference(base, other) {
	    var res;
	    if (!(base.isValid() && other.isValid())) {
	        return {milliseconds: 0, months: 0};
	    }

	    other = cloneWithOffset(other, base);
	    if (base.isBefore(other)) {
	        res = positiveMomentsDifference(base, other);
	    } else {
	        res = positiveMomentsDifference(other, base);
	        res.milliseconds = -res.milliseconds;
	        res.months = -res.months;
	    }

	    return res;
	}

	// TODO: remove 'name' arg after deprecation is removed
	function createAdder(direction, name) {
	    return function (val, period) {
	        var dur, tmp;
	        //invert the arguments, but complain about it
	        if (period !== null && !isNaN(+period)) {
	            deprecateSimple(name, 'moment().' + name  + '(period, number) is deprecated. Please use moment().' + name + '(number, period). ' +
	            'See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info.');
	            tmp = val; val = period; period = tmp;
	        }

	        val = typeof val === 'string' ? +val : val;
	        dur = createDuration(val, period);
	        addSubtract(this, dur, direction);
	        return this;
	    };
	}

	function addSubtract (mom, duration, isAdding, updateOffset) {
	    var milliseconds = duration._milliseconds,
	        days = absRound(duration._days),
	        months = absRound(duration._months);

	    if (!mom.isValid()) {
	        // No op
	        return;
	    }

	    updateOffset = updateOffset == null ? true : updateOffset;

	    if (months) {
	        setMonth(mom, get(mom, 'Month') + months * isAdding);
	    }
	    if (days) {
	        set$1(mom, 'Date', get(mom, 'Date') + days * isAdding);
	    }
	    if (milliseconds) {
	        mom._d.setTime(mom._d.valueOf() + milliseconds * isAdding);
	    }
	    if (updateOffset) {
	        hooks.updateOffset(mom, days || months);
	    }
	}

	var add      = createAdder(1, 'add');
	var subtract = createAdder(-1, 'subtract');

	function getCalendarFormat(myMoment, now) {
	    var diff = myMoment.diff(now, 'days', true);
	    return diff < -6 ? 'sameElse' :
	            diff < -1 ? 'lastWeek' :
	            diff < 0 ? 'lastDay' :
	            diff < 1 ? 'sameDay' :
	            diff < 2 ? 'nextDay' :
	            diff < 7 ? 'nextWeek' : 'sameElse';
	}

	function calendar$1 (time, formats) {
	    // We want to compare the start of today, vs this.
	    // Getting start-of-today depends on whether we're local/utc/offset or not.
	    var now = time || createLocal(),
	        sod = cloneWithOffset(now, this).startOf('day'),
	        format = hooks.calendarFormat(this, sod) || 'sameElse';

	    var output = formats && (isFunction(formats[format]) ? formats[format].call(this, now) : formats[format]);

	    return this.format(output || this.localeData().calendar(format, this, createLocal(now)));
	}

	function clone () {
	    return new Moment(this);
	}

	function isAfter (input, units) {
	    var localInput = isMoment(input) ? input : createLocal(input);
	    if (!(this.isValid() && localInput.isValid())) {
	        return false;
	    }
	    units = normalizeUnits(units) || 'millisecond';
	    if (units === 'millisecond') {
	        return this.valueOf() > localInput.valueOf();
	    } else {
	        return localInput.valueOf() < this.clone().startOf(units).valueOf();
	    }
	}

	function isBefore (input, units) {
	    var localInput = isMoment(input) ? input : createLocal(input);
	    if (!(this.isValid() && localInput.isValid())) {
	        return false;
	    }
	    units = normalizeUnits(units) || 'millisecond';
	    if (units === 'millisecond') {
	        return this.valueOf() < localInput.valueOf();
	    } else {
	        return this.clone().endOf(units).valueOf() < localInput.valueOf();
	    }
	}

	function isBetween (from, to, units, inclusivity) {
	    var localFrom = isMoment(from) ? from : createLocal(from),
	        localTo = isMoment(to) ? to : createLocal(to);
	    if (!(this.isValid() && localFrom.isValid() && localTo.isValid())) {
	        return false;
	    }
	    inclusivity = inclusivity || '()';
	    return (inclusivity[0] === '(' ? this.isAfter(localFrom, units) : !this.isBefore(localFrom, units)) &&
	        (inclusivity[1] === ')' ? this.isBefore(localTo, units) : !this.isAfter(localTo, units));
	}

	function isSame (input, units) {
	    var localInput = isMoment(input) ? input : createLocal(input),
	        inputMs;
	    if (!(this.isValid() && localInput.isValid())) {
	        return false;
	    }
	    units = normalizeUnits(units) || 'millisecond';
	    if (units === 'millisecond') {
	        return this.valueOf() === localInput.valueOf();
	    } else {
	        inputMs = localInput.valueOf();
	        return this.clone().startOf(units).valueOf() <= inputMs && inputMs <= this.clone().endOf(units).valueOf();
	    }
	}

	function isSameOrAfter (input, units) {
	    return this.isSame(input, units) || this.isAfter(input, units);
	}

	function isSameOrBefore (input, units) {
	    return this.isSame(input, units) || this.isBefore(input, units);
	}

	function diff (input, units, asFloat) {
	    var that,
	        zoneDelta,
	        output;

	    if (!this.isValid()) {
	        return NaN;
	    }

	    that = cloneWithOffset(input, this);

	    if (!that.isValid()) {
	        return NaN;
	    }

	    zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;

	    units = normalizeUnits(units);

	    switch (units) {
	        case 'year': output = monthDiff(this, that) / 12; break;
	        case 'month': output = monthDiff(this, that); break;
	        case 'quarter': output = monthDiff(this, that) / 3; break;
	        case 'second': output = (this - that) / 1e3; break; // 1000
	        case 'minute': output = (this - that) / 6e4; break; // 1000 * 60
	        case 'hour': output = (this - that) / 36e5; break; // 1000 * 60 * 60
	        case 'day': output = (this - that - zoneDelta) / 864e5; break; // 1000 * 60 * 60 * 24, negate dst
	        case 'week': output = (this - that - zoneDelta) / 6048e5; break; // 1000 * 60 * 60 * 24 * 7, negate dst
	        default: output = this - that;
	    }

	    return asFloat ? output : absFloor(output);
	}

	function monthDiff (a, b) {
	    // difference in months
	    var wholeMonthDiff = ((b.year() - a.year()) * 12) + (b.month() - a.month()),
	        // b is in (anchor - 1 month, anchor + 1 month)
	        anchor = a.clone().add(wholeMonthDiff, 'months'),
	        anchor2, adjust;

	    if (b - anchor < 0) {
	        anchor2 = a.clone().add(wholeMonthDiff - 1, 'months');
	        // linear across the month
	        adjust = (b - anchor) / (anchor - anchor2);
	    } else {
	        anchor2 = a.clone().add(wholeMonthDiff + 1, 'months');
	        // linear across the month
	        adjust = (b - anchor) / (anchor2 - anchor);
	    }

	    //check for negative zero, return zero if negative zero
	    return -(wholeMonthDiff + adjust) || 0;
	}

	hooks.defaultFormat = 'YYYY-MM-DDTHH:mm:ssZ';
	hooks.defaultFormatUtc = 'YYYY-MM-DDTHH:mm:ss[Z]';

	function toString () {
	    return this.clone().locale('en').format('ddd MMM DD YYYY HH:mm:ss [GMT]ZZ');
	}

	function toISOString(keepOffset) {
	    if (!this.isValid()) {
	        return null;
	    }
	    var utc = keepOffset !== true;
	    var m = utc ? this.clone().utc() : this;
	    if (m.year() < 0 || m.year() > 9999) {
	        return formatMoment(m, utc ? 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]' : 'YYYYYY-MM-DD[T]HH:mm:ss.SSSZ');
	    }
	    if (isFunction(Date.prototype.toISOString)) {
	        // native implementation is ~50x faster, use it when we can
	        if (utc) {
	            return this.toDate().toISOString();
	        } else {
	            return new Date(this.valueOf() + this.utcOffset() * 60 * 1000).toISOString().replace('Z', formatMoment(m, 'Z'));
	        }
	    }
	    return formatMoment(m, utc ? 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]' : 'YYYY-MM-DD[T]HH:mm:ss.SSSZ');
	}

	/**
	 * Return a human readable representation of a moment that can
	 * also be evaluated to get a new moment which is the same
	 *
	 * @link https://nodejs.org/dist/latest/docs/api/util.html#util_custom_inspect_function_on_objects
	 */
	function inspect () {
	    if (!this.isValid()) {
	        return 'moment.invalid(/* ' + this._i + ' */)';
	    }
	    var func = 'moment';
	    var zone = '';
	    if (!this.isLocal()) {
	        func = this.utcOffset() === 0 ? 'moment.utc' : 'moment.parseZone';
	        zone = 'Z';
	    }
	    var prefix = '[' + func + '("]';
	    var year = (0 <= this.year() && this.year() <= 9999) ? 'YYYY' : 'YYYYYY';
	    var datetime = '-MM-DD[T]HH:mm:ss.SSS';
	    var suffix = zone + '[")]';

	    return this.format(prefix + year + datetime + suffix);
	}

	function format (inputString) {
	    if (!inputString) {
	        inputString = this.isUtc() ? hooks.defaultFormatUtc : hooks.defaultFormat;
	    }
	    var output = formatMoment(this, inputString);
	    return this.localeData().postformat(output);
	}

	function from (time, withoutSuffix) {
	    if (this.isValid() &&
	            ((isMoment(time) && time.isValid()) ||
	             createLocal(time).isValid())) {
	        return createDuration({to: this, from: time}).locale(this.locale()).humanize(!withoutSuffix);
	    } else {
	        return this.localeData().invalidDate();
	    }
	}

	function fromNow (withoutSuffix) {
	    return this.from(createLocal(), withoutSuffix);
	}

	function to (time, withoutSuffix) {
	    if (this.isValid() &&
	            ((isMoment(time) && time.isValid()) ||
	             createLocal(time).isValid())) {
	        return createDuration({from: this, to: time}).locale(this.locale()).humanize(!withoutSuffix);
	    } else {
	        return this.localeData().invalidDate();
	    }
	}

	function toNow (withoutSuffix) {
	    return this.to(createLocal(), withoutSuffix);
	}

	// If passed a locale key, it will set the locale for this
	// instance.  Otherwise, it will return the locale configuration
	// variables for this instance.
	function locale (key) {
	    var newLocaleData;

	    if (key === undefined) {
	        return this._locale._abbr;
	    } else {
	        newLocaleData = getLocale(key);
	        if (newLocaleData != null) {
	            this._locale = newLocaleData;
	        }
	        return this;
	    }
	}

	var lang$1 = deprecate(
	    'moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.',
	    function (key) {
	        if (key === undefined) {
	            return this.localeData();
	        } else {
	            return this.locale(key);
	        }
	    }
	);

	function localeData () {
	    return this._locale;
	}

	var MS_PER_SECOND = 1000;
	var MS_PER_MINUTE = 60 * MS_PER_SECOND;
	var MS_PER_HOUR = 60 * MS_PER_MINUTE;
	var MS_PER_400_YEARS = (365 * 400 + 97) * 24 * MS_PER_HOUR;

	// actual modulo - handles negative numbers (for dates before 1970):
	function mod$1(dividend, divisor) {
	    return (dividend % divisor + divisor) % divisor;
	}

	function localStartOfDate(y, m, d) {
	    // the date constructor remaps years 0-99 to 1900-1999
	    if (y < 100 && y >= 0) {
	        // preserve leap years using a full 400 year cycle, then reset
	        return new Date(y + 400, m, d) - MS_PER_400_YEARS;
	    } else {
	        return new Date(y, m, d).valueOf();
	    }
	}

	function utcStartOfDate(y, m, d) {
	    // Date.UTC remaps years 0-99 to 1900-1999
	    if (y < 100 && y >= 0) {
	        // preserve leap years using a full 400 year cycle, then reset
	        return Date.UTC(y + 400, m, d) - MS_PER_400_YEARS;
	    } else {
	        return Date.UTC(y, m, d);
	    }
	}

	function startOf (units) {
	    var time;
	    units = normalizeUnits(units);
	    if (units === undefined || units === 'millisecond' || !this.isValid()) {
	        return this;
	    }

	    var startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;

	    switch (units) {
	        case 'year':
	            time = startOfDate(this.year(), 0, 1);
	            break;
	        case 'quarter':
	            time = startOfDate(this.year(), this.month() - this.month() % 3, 1);
	            break;
	        case 'month':
	            time = startOfDate(this.year(), this.month(), 1);
	            break;
	        case 'week':
	            time = startOfDate(this.year(), this.month(), this.date() - this.weekday());
	            break;
	        case 'isoWeek':
	            time = startOfDate(this.year(), this.month(), this.date() - (this.isoWeekday() - 1));
	            break;
	        case 'day':
	        case 'date':
	            time = startOfDate(this.year(), this.month(), this.date());
	            break;
	        case 'hour':
	            time = this._d.valueOf();
	            time -= mod$1(time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE), MS_PER_HOUR);
	            break;
	        case 'minute':
	            time = this._d.valueOf();
	            time -= mod$1(time, MS_PER_MINUTE);
	            break;
	        case 'second':
	            time = this._d.valueOf();
	            time -= mod$1(time, MS_PER_SECOND);
	            break;
	    }

	    this._d.setTime(time);
	    hooks.updateOffset(this, true);
	    return this;
	}

	function endOf (units) {
	    var time;
	    units = normalizeUnits(units);
	    if (units === undefined || units === 'millisecond' || !this.isValid()) {
	        return this;
	    }

	    var startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;

	    switch (units) {
	        case 'year':
	            time = startOfDate(this.year() + 1, 0, 1) - 1;
	            break;
	        case 'quarter':
	            time = startOfDate(this.year(), this.month() - this.month() % 3 + 3, 1) - 1;
	            break;
	        case 'month':
	            time = startOfDate(this.year(), this.month() + 1, 1) - 1;
	            break;
	        case 'week':
	            time = startOfDate(this.year(), this.month(), this.date() - this.weekday() + 7) - 1;
	            break;
	        case 'isoWeek':
	            time = startOfDate(this.year(), this.month(), this.date() - (this.isoWeekday() - 1) + 7) - 1;
	            break;
	        case 'day':
	        case 'date':
	            time = startOfDate(this.year(), this.month(), this.date() + 1) - 1;
	            break;
	        case 'hour':
	            time = this._d.valueOf();
	            time += MS_PER_HOUR - mod$1(time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE), MS_PER_HOUR) - 1;
	            break;
	        case 'minute':
	            time = this._d.valueOf();
	            time += MS_PER_MINUTE - mod$1(time, MS_PER_MINUTE) - 1;
	            break;
	        case 'second':
	            time = this._d.valueOf();
	            time += MS_PER_SECOND - mod$1(time, MS_PER_SECOND) - 1;
	            break;
	    }

	    this._d.setTime(time);
	    hooks.updateOffset(this, true);
	    return this;
	}

	function valueOf () {
	    return this._d.valueOf() - ((this._offset || 0) * 60000);
	}

	function unix () {
	    return Math.floor(this.valueOf() / 1000);
	}

	function toDate () {
	    return new Date(this.valueOf());
	}

	function toArray () {
	    var m = this;
	    return [m.year(), m.month(), m.date(), m.hour(), m.minute(), m.second(), m.millisecond()];
	}

	function toObject () {
	    var m = this;
	    return {
	        years: m.year(),
	        months: m.month(),
	        date: m.date(),
	        hours: m.hours(),
	        minutes: m.minutes(),
	        seconds: m.seconds(),
	        milliseconds: m.milliseconds()
	    };
	}

	function toJSON () {
	    // new Date(NaN).toJSON() === null
	    return this.isValid() ? this.toISOString() : null;
	}

	function isValid$2 () {
	    return isValid(this);
	}

	function parsingFlags () {
	    return extend({}, getParsingFlags(this));
	}

	function invalidAt () {
	    return getParsingFlags(this).overflow;
	}

	function creationData() {
	    return {
	        input: this._i,
	        format: this._f,
	        locale: this._locale,
	        isUTC: this._isUTC,
	        strict: this._strict
	    };
	}

	// FORMATTING

	addFormatToken(0, ['gg', 2], 0, function () {
	    return this.weekYear() % 100;
	});

	addFormatToken(0, ['GG', 2], 0, function () {
	    return this.isoWeekYear() % 100;
	});

	function addWeekYearFormatToken (token, getter) {
	    addFormatToken(0, [token, token.length], 0, getter);
	}

	addWeekYearFormatToken('gggg',     'weekYear');
	addWeekYearFormatToken('ggggg',    'weekYear');
	addWeekYearFormatToken('GGGG',  'isoWeekYear');
	addWeekYearFormatToken('GGGGG', 'isoWeekYear');

	// ALIASES

	addUnitAlias('weekYear', 'gg');
	addUnitAlias('isoWeekYear', 'GG');

	// PRIORITY

	addUnitPriority('weekYear', 1);
	addUnitPriority('isoWeekYear', 1);


	// PARSING

	addRegexToken('G',      matchSigned);
	addRegexToken('g',      matchSigned);
	addRegexToken('GG',     match1to2, match2);
	addRegexToken('gg',     match1to2, match2);
	addRegexToken('GGGG',   match1to4, match4);
	addRegexToken('gggg',   match1to4, match4);
	addRegexToken('GGGGG',  match1to6, match6);
	addRegexToken('ggggg',  match1to6, match6);

	addWeekParseToken(['gggg', 'ggggg', 'GGGG', 'GGGGG'], function (input, week, config, token) {
	    week[token.substr(0, 2)] = toInt(input);
	});

	addWeekParseToken(['gg', 'GG'], function (input, week, config, token) {
	    week[token] = hooks.parseTwoDigitYear(input);
	});

	// MOMENTS

	function getSetWeekYear (input) {
	    return getSetWeekYearHelper.call(this,
	            input,
	            this.week(),
	            this.weekday(),
	            this.localeData()._week.dow,
	            this.localeData()._week.doy);
	}

	function getSetISOWeekYear (input) {
	    return getSetWeekYearHelper.call(this,
	            input, this.isoWeek(), this.isoWeekday(), 1, 4);
	}

	function getISOWeeksInYear () {
	    return weeksInYear(this.year(), 1, 4);
	}

	function getWeeksInYear () {
	    var weekInfo = this.localeData()._week;
	    return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
	}

	function getSetWeekYearHelper(input, week, weekday, dow, doy) {
	    var weeksTarget;
	    if (input == null) {
	        return weekOfYear(this, dow, doy).year;
	    } else {
	        weeksTarget = weeksInYear(input, dow, doy);
	        if (week > weeksTarget) {
	            week = weeksTarget;
	        }
	        return setWeekAll.call(this, input, week, weekday, dow, doy);
	    }
	}

	function setWeekAll(weekYear, week, weekday, dow, doy) {
	    var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy),
	        date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);

	    this.year(date.getUTCFullYear());
	    this.month(date.getUTCMonth());
	    this.date(date.getUTCDate());
	    return this;
	}

	// FORMATTING

	addFormatToken('Q', 0, 'Qo', 'quarter');

	// ALIASES

	addUnitAlias('quarter', 'Q');

	// PRIORITY

	addUnitPriority('quarter', 7);

	// PARSING

	addRegexToken('Q', match1);
	addParseToken('Q', function (input, array) {
	    array[MONTH] = (toInt(input) - 1) * 3;
	});

	// MOMENTS

	function getSetQuarter (input) {
	    return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
	}

	// FORMATTING

	addFormatToken('D', ['DD', 2], 'Do', 'date');

	// ALIASES

	addUnitAlias('date', 'D');

	// PRIORITY
	addUnitPriority('date', 9);

	// PARSING

	addRegexToken('D',  match1to2);
	addRegexToken('DD', match1to2, match2);
	addRegexToken('Do', function (isStrict, locale) {
	    // TODO: Remove "ordinalParse" fallback in next major release.
	    return isStrict ?
	      (locale._dayOfMonthOrdinalParse || locale._ordinalParse) :
	      locale._dayOfMonthOrdinalParseLenient;
	});

	addParseToken(['D', 'DD'], DATE);
	addParseToken('Do', function (input, array) {
	    array[DATE] = toInt(input.match(match1to2)[0]);
	});

	// MOMENTS

	var getSetDayOfMonth = makeGetSet('Date', true);

	// FORMATTING

	addFormatToken('DDD', ['DDDD', 3], 'DDDo', 'dayOfYear');

	// ALIASES

	addUnitAlias('dayOfYear', 'DDD');

	// PRIORITY
	addUnitPriority('dayOfYear', 4);

	// PARSING

	addRegexToken('DDD',  match1to3);
	addRegexToken('DDDD', match3);
	addParseToken(['DDD', 'DDDD'], function (input, array, config) {
	    config._dayOfYear = toInt(input);
	});

	// HELPERS

	// MOMENTS

	function getSetDayOfYear (input) {
	    var dayOfYear = Math.round((this.clone().startOf('day') - this.clone().startOf('year')) / 864e5) + 1;
	    return input == null ? dayOfYear : this.add((input - dayOfYear), 'd');
	}

	// FORMATTING

	addFormatToken('m', ['mm', 2], 0, 'minute');

	// ALIASES

	addUnitAlias('minute', 'm');

	// PRIORITY

	addUnitPriority('minute', 14);

	// PARSING

	addRegexToken('m',  match1to2);
	addRegexToken('mm', match1to2, match2);
	addParseToken(['m', 'mm'], MINUTE);

	// MOMENTS

	var getSetMinute = makeGetSet('Minutes', false);

	// FORMATTING

	addFormatToken('s', ['ss', 2], 0, 'second');

	// ALIASES

	addUnitAlias('second', 's');

	// PRIORITY

	addUnitPriority('second', 15);

	// PARSING

	addRegexToken('s',  match1to2);
	addRegexToken('ss', match1to2, match2);
	addParseToken(['s', 'ss'], SECOND);

	// MOMENTS

	var getSetSecond = makeGetSet('Seconds', false);

	// FORMATTING

	addFormatToken('S', 0, 0, function () {
	    return ~~(this.millisecond() / 100);
	});

	addFormatToken(0, ['SS', 2], 0, function () {
	    return ~~(this.millisecond() / 10);
	});

	addFormatToken(0, ['SSS', 3], 0, 'millisecond');
	addFormatToken(0, ['SSSS', 4], 0, function () {
	    return this.millisecond() * 10;
	});
	addFormatToken(0, ['SSSSS', 5], 0, function () {
	    return this.millisecond() * 100;
	});
	addFormatToken(0, ['SSSSSS', 6], 0, function () {
	    return this.millisecond() * 1000;
	});
	addFormatToken(0, ['SSSSSSS', 7], 0, function () {
	    return this.millisecond() * 10000;
	});
	addFormatToken(0, ['SSSSSSSS', 8], 0, function () {
	    return this.millisecond() * 100000;
	});
	addFormatToken(0, ['SSSSSSSSS', 9], 0, function () {
	    return this.millisecond() * 1000000;
	});


	// ALIASES

	addUnitAlias('millisecond', 'ms');

	// PRIORITY

	addUnitPriority('millisecond', 16);

	// PARSING

	addRegexToken('S',    match1to3, match1);
	addRegexToken('SS',   match1to3, match2);
	addRegexToken('SSS',  match1to3, match3);

	var token;
	for (token = 'SSSS'; token.length <= 9; token += 'S') {
	    addRegexToken(token, matchUnsigned);
	}

	function parseMs(input, array) {
	    array[MILLISECOND] = toInt(('0.' + input) * 1000);
	}

	for (token = 'S'; token.length <= 9; token += 'S') {
	    addParseToken(token, parseMs);
	}
	// MOMENTS

	var getSetMillisecond = makeGetSet('Milliseconds', false);

	// FORMATTING

	addFormatToken('z',  0, 0, 'zoneAbbr');
	addFormatToken('zz', 0, 0, 'zoneName');

	// MOMENTS

	function getZoneAbbr () {
	    return this._isUTC ? 'UTC' : '';
	}

	function getZoneName () {
	    return this._isUTC ? 'Coordinated Universal Time' : '';
	}

	var proto = Moment.prototype;

	proto.add               = add;
	proto.calendar          = calendar$1;
	proto.clone             = clone;
	proto.diff              = diff;
	proto.endOf             = endOf;
	proto.format            = format;
	proto.from              = from;
	proto.fromNow           = fromNow;
	proto.to                = to;
	proto.toNow             = toNow;
	proto.get               = stringGet;
	proto.invalidAt         = invalidAt;
	proto.isAfter           = isAfter;
	proto.isBefore          = isBefore;
	proto.isBetween         = isBetween;
	proto.isSame            = isSame;
	proto.isSameOrAfter     = isSameOrAfter;
	proto.isSameOrBefore    = isSameOrBefore;
	proto.isValid           = isValid$2;
	proto.lang              = lang$1;
	proto.locale            = locale;
	proto.localeData        = localeData;
	proto.max               = prototypeMax;
	proto.min               = prototypeMin;
	proto.parsingFlags      = parsingFlags;
	proto.set               = stringSet;
	proto.startOf           = startOf;
	proto.subtract          = subtract;
	proto.toArray           = toArray;
	proto.toObject          = toObject;
	proto.toDate            = toDate;
	proto.toISOString       = toISOString;
	proto.inspect           = inspect;
	proto.toJSON            = toJSON;
	proto.toString          = toString;
	proto.unix              = unix;
	proto.valueOf           = valueOf;
	proto.creationData      = creationData;
	proto.year       = getSetYear;
	proto.isLeapYear = getIsLeapYear;
	proto.weekYear    = getSetWeekYear;
	proto.isoWeekYear = getSetISOWeekYear;
	proto.quarter = proto.quarters = getSetQuarter;
	proto.month       = getSetMonth;
	proto.daysInMonth = getDaysInMonth;
	proto.week           = proto.weeks        = getSetWeek;
	proto.isoWeek        = proto.isoWeeks     = getSetISOWeek;
	proto.weeksInYear    = getWeeksInYear;
	proto.isoWeeksInYear = getISOWeeksInYear;
	proto.date       = getSetDayOfMonth;
	proto.day        = proto.days             = getSetDayOfWeek;
	proto.weekday    = getSetLocaleDayOfWeek;
	proto.isoWeekday = getSetISODayOfWeek;
	proto.dayOfYear  = getSetDayOfYear;
	proto.hour = proto.hours = getSetHour;
	proto.minute = proto.minutes = getSetMinute;
	proto.second = proto.seconds = getSetSecond;
	proto.millisecond = proto.milliseconds = getSetMillisecond;
	proto.utcOffset            = getSetOffset;
	proto.utc                  = setOffsetToUTC;
	proto.local                = setOffsetToLocal;
	proto.parseZone            = setOffsetToParsedOffset;
	proto.hasAlignedHourOffset = hasAlignedHourOffset;
	proto.isDST                = isDaylightSavingTime;
	proto.isLocal              = isLocal;
	proto.isUtcOffset          = isUtcOffset;
	proto.isUtc                = isUtc;
	proto.isUTC                = isUtc;
	proto.zoneAbbr = getZoneAbbr;
	proto.zoneName = getZoneName;
	proto.dates  = deprecate('dates accessor is deprecated. Use date instead.', getSetDayOfMonth);
	proto.months = deprecate('months accessor is deprecated. Use month instead', getSetMonth);
	proto.years  = deprecate('years accessor is deprecated. Use year instead', getSetYear);
	proto.zone   = deprecate('moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/', getSetZone);
	proto.isDSTShifted = deprecate('isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information', isDaylightSavingTimeShifted);

	function createUnix (input) {
	    return createLocal(input * 1000);
	}

	function createInZone () {
	    return createLocal.apply(null, arguments).parseZone();
	}

	function preParsePostFormat (string) {
	    return string;
	}

	var proto$1 = Locale.prototype;

	proto$1.calendar        = calendar;
	proto$1.longDateFormat  = longDateFormat;
	proto$1.invalidDate     = invalidDate;
	proto$1.ordinal         = ordinal;
	proto$1.preparse        = preParsePostFormat;
	proto$1.postformat      = preParsePostFormat;
	proto$1.relativeTime    = relativeTime;
	proto$1.pastFuture      = pastFuture;
	proto$1.set             = set;

	proto$1.months            =        localeMonths;
	proto$1.monthsShort       =        localeMonthsShort;
	proto$1.monthsParse       =        localeMonthsParse;
	proto$1.monthsRegex       = monthsRegex;
	proto$1.monthsShortRegex  = monthsShortRegex;
	proto$1.week = localeWeek;
	proto$1.firstDayOfYear = localeFirstDayOfYear;
	proto$1.firstDayOfWeek = localeFirstDayOfWeek;

	proto$1.weekdays       =        localeWeekdays;
	proto$1.weekdaysMin    =        localeWeekdaysMin;
	proto$1.weekdaysShort  =        localeWeekdaysShort;
	proto$1.weekdaysParse  =        localeWeekdaysParse;

	proto$1.weekdaysRegex       =        weekdaysRegex;
	proto$1.weekdaysShortRegex  =        weekdaysShortRegex;
	proto$1.weekdaysMinRegex    =        weekdaysMinRegex;

	proto$1.isPM = localeIsPM;
	proto$1.meridiem = localeMeridiem;

	function get$1 (format, index, field, setter) {
	    var locale = getLocale();
	    var utc = createUTC().set(setter, index);
	    return locale[field](utc, format);
	}

	function listMonthsImpl (format, index, field) {
	    if (isNumber(format)) {
	        index = format;
	        format = undefined;
	    }

	    format = format || '';

	    if (index != null) {
	        return get$1(format, index, field, 'month');
	    }

	    var i;
	    var out = [];
	    for (i = 0; i < 12; i++) {
	        out[i] = get$1(format, i, field, 'month');
	    }
	    return out;
	}

	// ()
	// (5)
	// (fmt, 5)
	// (fmt)
	// (true)
	// (true, 5)
	// (true, fmt, 5)
	// (true, fmt)
	function listWeekdaysImpl (localeSorted, format, index, field) {
	    if (typeof localeSorted === 'boolean') {
	        if (isNumber(format)) {
	            index = format;
	            format = undefined;
	        }

	        format = format || '';
	    } else {
	        format = localeSorted;
	        index = format;
	        localeSorted = false;

	        if (isNumber(format)) {
	            index = format;
	            format = undefined;
	        }

	        format = format || '';
	    }

	    var locale = getLocale(),
	        shift = localeSorted ? locale._week.dow : 0;

	    if (index != null) {
	        return get$1(format, (index + shift) % 7, field, 'day');
	    }

	    var i;
	    var out = [];
	    for (i = 0; i < 7; i++) {
	        out[i] = get$1(format, (i + shift) % 7, field, 'day');
	    }
	    return out;
	}

	function listMonths (format, index) {
	    return listMonthsImpl(format, index, 'months');
	}

	function listMonthsShort (format, index) {
	    return listMonthsImpl(format, index, 'monthsShort');
	}

	function listWeekdays (localeSorted, format, index) {
	    return listWeekdaysImpl(localeSorted, format, index, 'weekdays');
	}

	function listWeekdaysShort (localeSorted, format, index) {
	    return listWeekdaysImpl(localeSorted, format, index, 'weekdaysShort');
	}

	function listWeekdaysMin (localeSorted, format, index) {
	    return listWeekdaysImpl(localeSorted, format, index, 'weekdaysMin');
	}

	getSetGlobalLocale('en', {
	    dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
	    ordinal : function (number) {
	        var b = number % 10,
	            output = (toInt(number % 100 / 10) === 1) ? 'th' :
	            (b === 1) ? 'st' :
	            (b === 2) ? 'nd' :
	            (b === 3) ? 'rd' : 'th';
	        return number + output;
	    }
	});

	// Side effect imports

	hooks.lang = deprecate('moment.lang is deprecated. Use moment.locale instead.', getSetGlobalLocale);
	hooks.langData = deprecate('moment.langData is deprecated. Use moment.localeData instead.', getLocale);

	var mathAbs = Math.abs;

	function abs () {
	    var data           = this._data;

	    this._milliseconds = mathAbs(this._milliseconds);
	    this._days         = mathAbs(this._days);
	    this._months       = mathAbs(this._months);

	    data.milliseconds  = mathAbs(data.milliseconds);
	    data.seconds       = mathAbs(data.seconds);
	    data.minutes       = mathAbs(data.minutes);
	    data.hours         = mathAbs(data.hours);
	    data.months        = mathAbs(data.months);
	    data.years         = mathAbs(data.years);

	    return this;
	}

	function addSubtract$1 (duration, input, value, direction) {
	    var other = createDuration(input, value);

	    duration._milliseconds += direction * other._milliseconds;
	    duration._days         += direction * other._days;
	    duration._months       += direction * other._months;

	    return duration._bubble();
	}

	// supports only 2.0-style add(1, 's') or add(duration)
	function add$1 (input, value) {
	    return addSubtract$1(this, input, value, 1);
	}

	// supports only 2.0-style subtract(1, 's') or subtract(duration)
	function subtract$1 (input, value) {
	    return addSubtract$1(this, input, value, -1);
	}

	function absCeil (number) {
	    if (number < 0) {
	        return Math.floor(number);
	    } else {
	        return Math.ceil(number);
	    }
	}

	function bubble () {
	    var milliseconds = this._milliseconds;
	    var days         = this._days;
	    var months       = this._months;
	    var data         = this._data;
	    var seconds, minutes, hours, years, monthsFromDays;

	    // if we have a mix of positive and negative values, bubble down first
	    // check: https://github.com/moment/moment/issues/2166
	    if (!((milliseconds >= 0 && days >= 0 && months >= 0) ||
	            (milliseconds <= 0 && days <= 0 && months <= 0))) {
	        milliseconds += absCeil(monthsToDays(months) + days) * 864e5;
	        days = 0;
	        months = 0;
	    }

	    // The following code bubbles up values, see the tests for
	    // examples of what that means.
	    data.milliseconds = milliseconds % 1000;

	    seconds           = absFloor(milliseconds / 1000);
	    data.seconds      = seconds % 60;

	    minutes           = absFloor(seconds / 60);
	    data.minutes      = minutes % 60;

	    hours             = absFloor(minutes / 60);
	    data.hours        = hours % 24;

	    days += absFloor(hours / 24);

	    // convert days to months
	    monthsFromDays = absFloor(daysToMonths(days));
	    months += monthsFromDays;
	    days -= absCeil(monthsToDays(monthsFromDays));

	    // 12 months -> 1 year
	    years = absFloor(months / 12);
	    months %= 12;

	    data.days   = days;
	    data.months = months;
	    data.years  = years;

	    return this;
	}

	function daysToMonths (days) {
	    // 400 years have 146097 days (taking into account leap year rules)
	    // 400 years have 12 months === 4800
	    return days * 4800 / 146097;
	}

	function monthsToDays (months) {
	    // the reverse of daysToMonths
	    return months * 146097 / 4800;
	}

	function as (units) {
	    if (!this.isValid()) {
	        return NaN;
	    }
	    var days;
	    var months;
	    var milliseconds = this._milliseconds;

	    units = normalizeUnits(units);

	    if (units === 'month' || units === 'quarter' || units === 'year') {
	        days = this._days + milliseconds / 864e5;
	        months = this._months + daysToMonths(days);
	        switch (units) {
	            case 'month':   return months;
	            case 'quarter': return months / 3;
	            case 'year':    return months / 12;
	        }
	    } else {
	        // handle milliseconds separately because of floating point math errors (issue #1867)
	        days = this._days + Math.round(monthsToDays(this._months));
	        switch (units) {
	            case 'week'   : return days / 7     + milliseconds / 6048e5;
	            case 'day'    : return days         + milliseconds / 864e5;
	            case 'hour'   : return days * 24    + milliseconds / 36e5;
	            case 'minute' : return days * 1440  + milliseconds / 6e4;
	            case 'second' : return days * 86400 + milliseconds / 1000;
	            // Math.floor prevents floating point math errors here
	            case 'millisecond': return Math.floor(days * 864e5) + milliseconds;
	            default: throw new Error('Unknown unit ' + units);
	        }
	    }
	}

	// TODO: Use this.as('ms')?
	function valueOf$1 () {
	    if (!this.isValid()) {
	        return NaN;
	    }
	    return (
	        this._milliseconds +
	        this._days * 864e5 +
	        (this._months % 12) * 2592e6 +
	        toInt(this._months / 12) * 31536e6
	    );
	}

	function makeAs (alias) {
	    return function () {
	        return this.as(alias);
	    };
	}

	var asMilliseconds = makeAs('ms');
	var asSeconds      = makeAs('s');
	var asMinutes      = makeAs('m');
	var asHours        = makeAs('h');
	var asDays         = makeAs('d');
	var asWeeks        = makeAs('w');
	var asMonths       = makeAs('M');
	var asQuarters     = makeAs('Q');
	var asYears        = makeAs('y');

	function clone$1 () {
	    return createDuration(this);
	}

	function get$2 (units) {
	    units = normalizeUnits(units);
	    return this.isValid() ? this[units + 's']() : NaN;
	}

	function makeGetter(name) {
	    return function () {
	        return this.isValid() ? this._data[name] : NaN;
	    };
	}

	var milliseconds = makeGetter('milliseconds');
	var seconds      = makeGetter('seconds');
	var minutes      = makeGetter('minutes');
	var hours        = makeGetter('hours');
	var days         = makeGetter('days');
	var months       = makeGetter('months');
	var years        = makeGetter('years');

	function weeks () {
	    return absFloor(this.days() / 7);
	}

	var round = Math.round;
	var thresholds = {
	    ss: 44,         // a few seconds to seconds
	    s : 45,         // seconds to minute
	    m : 45,         // minutes to hour
	    h : 22,         // hours to day
	    d : 26,         // days to month
	    M : 11          // months to year
	};

	// helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize
	function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {
	    return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
	}

	function relativeTime$1 (posNegDuration, withoutSuffix, locale) {
	    var duration = createDuration(posNegDuration).abs();
	    var seconds  = round(duration.as('s'));
	    var minutes  = round(duration.as('m'));
	    var hours    = round(duration.as('h'));
	    var days     = round(duration.as('d'));
	    var months   = round(duration.as('M'));
	    var years    = round(duration.as('y'));

	    var a = seconds <= thresholds.ss && ['s', seconds]  ||
	            seconds < thresholds.s   && ['ss', seconds] ||
	            minutes <= 1             && ['m']           ||
	            minutes < thresholds.m   && ['mm', minutes] ||
	            hours   <= 1             && ['h']           ||
	            hours   < thresholds.h   && ['hh', hours]   ||
	            days    <= 1             && ['d']           ||
	            days    < thresholds.d   && ['dd', days]    ||
	            months  <= 1             && ['M']           ||
	            months  < thresholds.M   && ['MM', months]  ||
	            years   <= 1             && ['y']           || ['yy', years];

	    a[2] = withoutSuffix;
	    a[3] = +posNegDuration > 0;
	    a[4] = locale;
	    return substituteTimeAgo.apply(null, a);
	}

	// This function allows you to set the rounding function for relative time strings
	function getSetRelativeTimeRounding (roundingFunction) {
	    if (roundingFunction === undefined) {
	        return round;
	    }
	    if (typeof(roundingFunction) === 'function') {
	        round = roundingFunction;
	        return true;
	    }
	    return false;
	}

	// This function allows you to set a threshold for relative time strings
	function getSetRelativeTimeThreshold (threshold, limit) {
	    if (thresholds[threshold] === undefined) {
	        return false;
	    }
	    if (limit === undefined) {
	        return thresholds[threshold];
	    }
	    thresholds[threshold] = limit;
	    if (threshold === 's') {
	        thresholds.ss = limit - 1;
	    }
	    return true;
	}

	function humanize (withSuffix) {
	    if (!this.isValid()) {
	        return this.localeData().invalidDate();
	    }

	    var locale = this.localeData();
	    var output = relativeTime$1(this, !withSuffix, locale);

	    if (withSuffix) {
	        output = locale.pastFuture(+this, output);
	    }

	    return locale.postformat(output);
	}

	var abs$1 = Math.abs;

	function sign(x) {
	    return ((x > 0) - (x < 0)) || +x;
	}

	function toISOString$1() {
	    // for ISO strings we do not use the normal bubbling rules:
	    //  * milliseconds bubble up until they become hours
	    //  * days do not bubble at all
	    //  * months bubble up until they become years
	    // This is because there is no context-free conversion between hours and days
	    // (think of clock changes)
	    // and also not between days and months (28-31 days per month)
	    if (!this.isValid()) {
	        return this.localeData().invalidDate();
	    }

	    var seconds = abs$1(this._milliseconds) / 1000;
	    var days         = abs$1(this._days);
	    var months       = abs$1(this._months);
	    var minutes, hours, years;

	    // 3600 seconds -> 60 minutes -> 1 hour
	    minutes           = absFloor(seconds / 60);
	    hours             = absFloor(minutes / 60);
	    seconds %= 60;
	    minutes %= 60;

	    // 12 months -> 1 year
	    years  = absFloor(months / 12);
	    months %= 12;


	    // inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js
	    var Y = years;
	    var M = months;
	    var D = days;
	    var h = hours;
	    var m = minutes;
	    var s = seconds ? seconds.toFixed(3).replace(/\.?0+$/, '') : '';
	    var total = this.asSeconds();

	    if (!total) {
	        // this is the same as C#'s (Noda) and python (isodate)...
	        // but not other JS (goog.date)
	        return 'P0D';
	    }

	    var totalSign = total < 0 ? '-' : '';
	    var ymSign = sign(this._months) !== sign(total) ? '-' : '';
	    var daysSign = sign(this._days) !== sign(total) ? '-' : '';
	    var hmsSign = sign(this._milliseconds) !== sign(total) ? '-' : '';

	    return totalSign + 'P' +
	        (Y ? ymSign + Y + 'Y' : '') +
	        (M ? ymSign + M + 'M' : '') +
	        (D ? daysSign + D + 'D' : '') +
	        ((h || m || s) ? 'T' : '') +
	        (h ? hmsSign + h + 'H' : '') +
	        (m ? hmsSign + m + 'M' : '') +
	        (s ? hmsSign + s + 'S' : '');
	}

	var proto$2 = Duration.prototype;

	proto$2.isValid        = isValid$1;
	proto$2.abs            = abs;
	proto$2.add            = add$1;
	proto$2.subtract       = subtract$1;
	proto$2.as             = as;
	proto$2.asMilliseconds = asMilliseconds;
	proto$2.asSeconds      = asSeconds;
	proto$2.asMinutes      = asMinutes;
	proto$2.asHours        = asHours;
	proto$2.asDays         = asDays;
	proto$2.asWeeks        = asWeeks;
	proto$2.asMonths       = asMonths;
	proto$2.asQuarters     = asQuarters;
	proto$2.asYears        = asYears;
	proto$2.valueOf        = valueOf$1;
	proto$2._bubble        = bubble;
	proto$2.clone          = clone$1;
	proto$2.get            = get$2;
	proto$2.milliseconds   = milliseconds;
	proto$2.seconds        = seconds;
	proto$2.minutes        = minutes;
	proto$2.hours          = hours;
	proto$2.days           = days;
	proto$2.weeks          = weeks;
	proto$2.months         = months;
	proto$2.years          = years;
	proto$2.humanize       = humanize;
	proto$2.toISOString    = toISOString$1;
	proto$2.toString       = toISOString$1;
	proto$2.toJSON         = toISOString$1;
	proto$2.locale         = locale;
	proto$2.localeData     = localeData;

	proto$2.toIsoString = deprecate('toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)', toISOString$1);
	proto$2.lang = lang$1;

	// FORMATTING

	addFormatToken('X', 0, 0, 'unix');
	addFormatToken('x', 0, 0, 'valueOf');

	// PARSING

	addRegexToken('x', matchSigned);
	addRegexToken('X', matchTimestamp);
	addParseToken('X', function (input, array, config) {
	    config._d = new Date(parseFloat(input, 10) * 1000);
	});
	addParseToken('x', function (input, array, config) {
	    config._d = new Date(toInt(input));
	});

	//! moment.js

	hooks.version = '2.24.0';

	setHookCallback(createLocal);

	hooks.fn                    = proto;
	hooks.min                   = min;
	hooks.max                   = max;
	hooks.now                   = now;
	hooks.utc                   = createUTC;
	hooks.unix                  = createUnix;
	hooks.months                = listMonths;
	hooks.isDate                = isDate;
	hooks.locale                = getSetGlobalLocale;
	hooks.invalid               = createInvalid;
	hooks.duration              = createDuration;
	hooks.isMoment              = isMoment;
	hooks.weekdays              = listWeekdays;
	hooks.parseZone             = createInZone;
	hooks.localeData            = getLocale;
	hooks.isDuration            = isDuration;
	hooks.monthsShort           = listMonthsShort;
	hooks.weekdaysMin           = listWeekdaysMin;
	hooks.defineLocale          = defineLocale;
	hooks.updateLocale          = updateLocale;
	hooks.locales               = listLocales;
	hooks.weekdaysShort         = listWeekdaysShort;
	hooks.normalizeUnits        = normalizeUnits;
	hooks.relativeTimeRounding  = getSetRelativeTimeRounding;
	hooks.relativeTimeThreshold = getSetRelativeTimeThreshold;
	hooks.calendarFormat        = getCalendarFormat;
	hooks.prototype             = proto;

	// currently HTML5 input type only supports 24-hour formats
	hooks.HTML5_FMT = {
	    DATETIME_LOCAL: 'YYYY-MM-DDTHH:mm',             // <input type="datetime-local" />
	    DATETIME_LOCAL_SECONDS: 'YYYY-MM-DDTHH:mm:ss',  // <input type="datetime-local" step="1" />
	    DATETIME_LOCAL_MS: 'YYYY-MM-DDTHH:mm:ss.SSS',   // <input type="datetime-local" step="0.001" />
	    DATE: 'YYYY-MM-DD',                             // <input type="date" />
	    TIME: 'HH:mm',                                  // <input type="time" />
	    TIME_SECONDS: 'HH:mm:ss',                       // <input type="time" step="1" />
	    TIME_MS: 'HH:mm:ss.SSS',                        // <input type="time" step="0.001" />
	    WEEK: 'GGGG-[W]WW',                             // <input type="week" />
	    MONTH: 'YYYY-MM'                                // <input type="month" />
	};

	//      

	                        
	                      
	               
	                    
	  

	                                       
	                
	  

	                                   
	                
	                  
	                     
	                      
	                    
	               
	                    
	                                 
	  

	                                       
	                   
	                
	                                    
	  

	class ChatMessage {
	               
	                  
	             
	                
	                   
	                    
	                

	  static parseMany(plain                         )                     {
	    return plain.items.map(item => ChatMessage.parse(item));
	  }

	  static parse(plain                     )              {
	    return new ChatMessage({
	      uuid: plain.uuid,
	      date: hooks(plain.created_at).toDate(),
	      content: plain.content,
	      alias: plain.alias,
	      userUuid: plain.user_uuid,
	      read: true,
	      roomUuid: plain.room ? plain.room.uuid : null,
	    });
	  }

	  static newFrom(message             ) {
	    return newFrom(message, ChatMessage);
	  }

	  constructor({ uuid, date, content, userUuid, alias, roomUuid, read }         = {}) {
	    this.uuid = uuid;
	    this.date = date;
	    this.content = content;
	    this.userUuid = userUuid;
	    this.alias = alias;
	    this.roomUuid = roomUuid;

	    // @TODO: change after message read status available
	    this.read = read;
	  }

	  is(other             ) {
	    return this.uuid === other.uuid;
	  }

	  isIncoming(userUuid        ) {
	    return this.userUuid !== userUuid;
	  }

	  acknowledge() {
	    // @TODO: change after message read status available
	    this.read = true;
	    return this;
	  }
	}

	//      

	                        
	                         
	                        
	                   
	             
	                  
	                    
	  

	                 
	             
	               
	                 
	                  
	               
	                 
	                 
	                                     
	     
	  

	                           
	             
	             
	                   
	           
	                 
	                   
	    
	                    
	  

	class Voicemail {
	             
	             
	                   
	                   
	           
	                 
	                   
	    

	  static parse(plain                 )            {
	    return new Voicemail({
	      id: plain.id,
	      date: hooks(plain.timestamp * 1000).toDate(),
	      duration: plain.duration * 1000,
	      caller: {
	        name: plain.caller_id_name,
	        number: plain.caller_id_num,
	      },
	      unread: plain.folder ? plain.folder.type === 'new' : null,
	    });
	  }

	  static parseMany(plain          )                   {
	    const plainUnread = plain.folders.filter(folder => folder.type === 'new')[0].messages;
	    const plainRead = plain.folders.filter(folder => folder.type === 'old')[0].messages;

	    const unread = plainUnread.map(message => Voicemail.parse(message)).map(voicemail => voicemail.makeAsUnRead());
	    const read = plainRead.map(message => Voicemail.parse(message)).map(voicemail => voicemail.acknowledge());

	    return [...unread, ...read];
	  }

	  static newFrom(profile           ) {
	    return newFrom(profile, Voicemail);
	  }

	  constructor({ id, date, duration, caller, unread }                     = {}) {
	    this.id = id;
	    this.date = date;
	    this.duration = duration;
	    this.caller = caller;
	    this.unread = unread;
	  }

	  is(other           )          {
	    return other && this.id === other.id;
	  }

	  acknowledge() {
	    this.unread = false;

	    return this;
	  }

	  makeAsUnRead() {
	    this.unread = true;

	    return this;
	  }

	  contains(query        )          {
	    if (!query) {
	      return true;
	    }

	    return this.caller.name.toUpperCase().includes(query.toUpperCase()) || this.caller.number.includes(query);
	  }
	}

	//      

	                     
	                  
	                      
	                         
	                           
	                              
	                                
	                           
	                 
	                     
	                        
	                   
	  

	                      
	             
	                    
	                    
	                     
	                       
	                     
	                       
	                          
	                  
	                 
	                     
	  

	class Call {
	             
	                    
	                     
	                       
	                     
	                       
	                          
	                    
	                  
	                 
	                     

	  static parseMany(plain                     )              {
	    return plain.map((plainCall              ) => Call.parse(plainCall));
	  }

	  static parse(plain              )       {
	    return new Call({
	      id: plain.call_id,
	      sipCallId: plain.sip_call_id,
	      callerName: plain.caller_id_name,
	      callerNumber: plain.caller_id_number,
	      calleeName: plain.peer_caller_id_name,
	      calleeNumber: plain.peer_caller_id_number,
	      dialedExtension: plain.dialed_extension,
	      isCaller: plain.is_caller,
	      onHold: plain.on_hold,
	      status: plain.status,
	      startingTime: hooks(plain.creation_time).toDate(),
	    });
	  }

	  static newFrom(call      ) {
	    return newFrom(call, Call);
	  }

	  constructor({
	    id,
	    sipCallId,
	    callerName,
	    callerNumber,
	    calleeName,
	    calleeNumber,
	    dialedExtension,
	    isCaller,
	    onHold,
	    status,
	    startingTime,
	  }                = {}) {
	    this.id = id;
	    this.sipCallId = sipCallId;
	    this.callerName = callerName;
	    this.callerNumber = callerNumber;
	    this.calleeName = calleeName;
	    this.calleeNumber = calleeNumber;
	    this.dialedExtension = dialedExtension;
	    this.onHold = onHold;
	    this.isCaller = isCaller;
	    this.status = status;
	    this.startingTime = startingTime;
	  }

	  getElapsedTimeInSeconds()         {
	    const now = Date.now();
	    return (now - this.startingTime) / 1000;
	  }

	  separateCalleeName()                                          {
	    const names = this.calleeName.split(' ');
	    const firstName = names[0];
	    const lastName = names.slice(1).join(' ');

	    return { firstName, lastName };
	  }

	  is(other       )          {
	    return !!other && this.id === other.id;
	  }

	  hasACalleeName()          {
	    return this.calleeName.length > 0;
	  }

	  hasNumber(number        )          {
	    return this.calleeNumber === number;
	  }

	  isUp()          {
	    return this.status === 'Up';
	  }

	  isDown()          {
	    return this.status === 'Down';
	  }

	  isRinging()          {
	    return this.isRingingIncoming() || this.isRingingOutgoing();
	  }

	  isRingingIncoming()          {
	    return this.status === 'Ringing';
	  }

	  isRingingOutgoing()          {
	    return this.status === 'Ring';
	  }

	  isFromTransfer()          {
	    return this.status === 'Down' || this.status === 'Ringing';
	  }

	  isOnHold()          {
	    return this.onHold;
	  }

	  putOnHold()       {
	    this.onHold = true;
	  }

	  resume()       {
	    this.onHold = false;
	  }
	}

	/*       */

	                  
	                       
	                    
	                   
	  

	var ctidNgMethods = (client              , baseUrl        ) => ({
	  updatePresence(token       , presence        )                   {
	    return client.put(`${baseUrl}/users/me/presences`, { presence }, token, ApiRequester.successResponseParser);
	  },

	  listMessages(token       , participantUuid       , limit         )                              {
	    const query         = {};

	    if (participantUuid) {
	      query.participant_user_uuid = participantUuid;
	    }

	    if (limit) {
	      query.limit = limit;
	    }

	    return client.get(`${baseUrl}/users/me/chats`, query, token).then(response => ChatMessage.parseMany(response));
	  },

	  sendMessage(token       , alias        , msg        , toUserId        ) {
	    const body = { alias, msg, to: toUserId };

	    return client.post(`${baseUrl}/users/me/chats`, body, token, ApiRequester.successResponseParser);
	  },

	  makeCall(token       , extension        , fromMobile         , lineId         ) {
	    const query            = {
	      from_mobile: fromMobile,
	      extension,
	    };

	    if (lineId) {
	      query.line_id = lineId;
	    }
	    return client.post(`${baseUrl}/users/me/calls`, query, token);
	  },

	  cancelCall(token       , callId        )                   {
	    return client.delete(`${baseUrl}/users/me/calls/${callId}`, null, token);
	  },

	  listCalls(token       )                       {
	    return client.get(`${baseUrl}/users/me/calls`, null, token).then(response => Call.parseMany(response.items));
	  },

	  relocateCall(token       , callId        , destination        , lineId         , contact          ) {
	    const body         = {
	      completions: ['answer'],
	      destination,
	      initiator_call: callId,
	    };

	    if (lineId || contact) {
	      body.location = {};
	    }

	    if (lineId) {
	      body.location.line_id = lineId;
	    }

	    if (contact) {
	      body.location.contact = contact;
	    }

	    return client.post(`${baseUrl}/users/me/relocates`, body, token);
	  },

	  listVoicemails(token       )                                           {
	    return client.get(`${baseUrl}/users/me/voicemails`, null, token).then(response => Voicemail.parseMany(response));
	  },

	  deleteVoicemail(token       , voicemailId        )                   {
	    return client.delete(`${baseUrl}/users/me/voicemails/messages/${voicemailId}`, null, token);
	  },

	  getPresence(token       , contactUuid      )                                                                      {
	    return client.get(`${baseUrl}/users/${contactUuid}/presences`, null, token);
	  },

	  getStatus(token       , lineUuid      ) {
	    return client.get(`${baseUrl}/lines/${lineUuid}/presences`, null, token);
	  },

	  fetchSwitchboardHeldCalls(token       , switchboardUuid      ) {
	    return client.get(`${baseUrl}/switchboards/${switchboardUuid}/calls/held`, null, token);
	  },

	  holdSwitchboardCall(token       , switchboardUuid      , callId        ) {
	    return client.put(`${baseUrl}/switchboards/${switchboardUuid}/calls/held/${callId}`, null, token);
	  },

	  answerSwitchboardHeldCall(token       , switchboardUuid      , callId        ) {
	    return client.put(`${baseUrl}/switchboards/${switchboardUuid}/calls/held/${callId}/answer`, null, token);
	  },

	  fetchSwitchboardQueuedCalls(token       , switchboardUuid      ) {
	    return client.get(`${baseUrl}/switchboards/${switchboardUuid}/calls/queued`, null, token);
	  },

	  answerSwitchboardQueuedCall(token       , switchboardUuid      , callId        ) {
	    return client.put(`${baseUrl}/switchboards/${switchboardUuid}/calls/queued/${callId}/answer`, null, token);
	  },

	  sendFax(token       , extension        , fax        , callerId          = null) {
	    const headers = {
	      'Content-type': 'application/pdf',
	      'X-Auth-Token': token,
	    };
	    const params = ApiRequester.getQueryString({ extension, caller_id: callerId });

	    return client.post(`${baseUrl}/users/me/faxes?${params}`, fax, headers);
	  },
	});

	/*       */
	                                                    
	                                                                                   
	                                        

	const getContactPayload = (contact                      ) => ({
	  email: contact.email,
	  firstname: contact.firstName ? contact.firstName : '',
	  lastname: contact.lastName ? contact.lastName : '',
	  number: contact.phoneNumber ? contact.phoneNumber : '',
	  entreprise: contact.entreprise ? contact.entreprise : '',
	  birthday: contact.birthday ? contact.birthday : '',
	  address: contact.address ? contact.address : '',
	  note: contact.note ? contact.note : '',
	});

	                                 
	                 
	                             
	                 
	                  
	                  
	         

	var dirdMethods = (client              , baseUrl        ) => ({
	  search(token       , context        , term        )                          {
	    return client
	      .get(`${baseUrl}/directories/lookup/${context}`, { term }, token)
	      .then(response => Contact.parseMany(response));
	  },

	  listPersonalContacts(token       , queryParams                           = null)                          {
	    return client
	      .get(`${baseUrl}/personal`, queryParams, token)
	      .then(response => Contact.parseManyPersonal(response.items));
	  },

	  addContact(token       , contact            )                   {
	    return client
	      .post(`${baseUrl}/personal`, getContactPayload(contact), token)
	      .then(response => Contact.parsePersonal(response));
	  },

	  editContact(token       , contact         )                   {
	    return client
	      .put(`${baseUrl}/personal/${contact.sourceId || contact.id || ''}`, getContactPayload(contact), token)
	      .then(response => Contact.parsePersonal(response));
	  },

	  deleteContact(token       , contactUuid      ) {
	    return client.delete(`${baseUrl}/personal/${contactUuid}`, null, token);
	  },

	  listFavorites(token       , context        )                          {
	    return client
	      .get(`${baseUrl}/directories/favorites/${context}`, null, token)
	      .then(response => Contact.parseMany(response));
	  },

	  markAsFavorite(token       , source        , sourceId        )                   {
	    const url = `${baseUrl}/directories/favorites/${source}/${sourceId}`;

	    return client.put(url, null, token, ApiRequester.successResponseParser);
	  },

	  removeFavorite(token       , source        , sourceId        ) {
	    return client.delete(`${baseUrl}/directories/favorites/${source}/${sourceId}`, null, token);
	  },

	  fetchOffice365Source(token       , context        )                            {
	    return client
	      .get(`${baseUrl}/directories/${context}/sources`, { backend: 'office365' }, token)
	      .then(response => response);
	  },

	  fetchOffice365Contacts(
	    token       ,
	    source                 ,
	    queryParams                           = null,
	  )                     {
	    return client
	      .get(`${baseUrl}/backends/office365/sources/${source.uuid}/contacts`, queryParams, token)
	      .then(response => Contact.parseManyOffice365(response.items, source));
	  },

	  fetchWazoSource(token       , context        )                   {
	    return client
	      .get(`${baseUrl}/directories/${context}/sources`, { backend: 'wazo' }, token)
	      .then(response => response);
	  },

	  fetchWazoContacts(
	    token       ,
	    source                 ,
	    queryParams                           = null,
	  )                     {
	    return client
	      .get(`${baseUrl}/backends/wazo/sources/${source.uuid}/contacts`, queryParams, token)
	      .then(response => Contact.parseManyWazo(response.items, source));
	  },

	  fetchGoogleSource(token       , context        )                   {
	    return client
	      .get(`${baseUrl}/directories/${context}/sources`, { backend: 'google' }, token)
	      .then(response => response);
	  },

	  fetchGoogleContacts(
	    token       ,
	    source                 ,
	    queryParams                           = null,
	  )                     {
	    return client
	      .get(`${baseUrl}/backends/google/sources/${source.uuid}/contacts`, queryParams, token)
	      .then(response => Contact.parseManyGoogle(response.items, source));
	  },

	  fetchConferenceSource(token       , context        )                   {
	    return client
	      .get(`${baseUrl}/directories/${context}/sources`, { backend: 'conference' }, token)
	      .then(response => response);
	  },

	  fetchConferenceContacts(token       , source                 )                     {
	    return client
	      .get(`${baseUrl}/backends/conference/sources/${source.uuid}/contacts`, null, token)
	      .then(response => Contact.parseManyConference(response.items, source));
	  },
	});

	//      

	                        
	                 
	                    
	                         
	                                
	                            
	                   
	              
	             
	                           
	                      
	                
	  

	                 
	                   
	                                
	                
	  

	                         
	               
	                    
	                          
	                        
	                
	                      
	                 
	    
	           
	                      
	                 
	    
	             
	                   
	              
	            
	  

	class CallLog {
	               
	                    
	                         
	                        
	                
	                      
	                 
	    

	           
	                      
	                 
	    

	             
	                   
	              
	            

	  static merge(current                , toMerge                )                  {
	    const onlyUnique = (value, index, self) => self.indexOf(value) === index;

	    const allLogs                 = current.concat(toMerge);
	    const onlyUniqueIds                = allLogs.map(c => c.id).filter(onlyUnique);

	    return onlyUniqueIds.map(id => allLogs.find(log => log.id === id));
	  }

	  static parseMany(plain          )                 {
	    return plain.items.map(item => CallLog.parse(item));
	  }

	  static parse(plain                 )          {
	    return new CallLog({
	      answer: hooks(plain.answer).toDate(),
	      answered: plain.answered,
	      callDirection: plain.call_direction,
	      destination: {
	        extension: plain.destination_extension,
	        name: plain.destination_name || '',
	      },
	      source: {
	        extension: plain.source_extension,
	        name: plain.source_name,
	      },
	      id: plain.id,
	      duration: (plain.duration || 0) * 1000, // duration is in seconds
	      start: hooks(plain.start).toDate(),
	      end: hooks(plain.end).toDate(),
	    });
	  }

	  static parseNew(plain                 , session         )          {
	    return new CallLog({
	      answer: hooks(plain.answer).toDate(),
	      answered: plain.answered,
	      callDirection: plain.call_direction,
	      destination: {
	        extension: plain.destination_extension,
	        name: plain.destination_name || '',
	      },
	      source: {
	        extension: plain.source_extension,
	        name: plain.source_name,
	      },
	      id: plain.id,
	      duration: (plain.duration || 0) * 1000, // duration is in seconds
	      start: hooks(plain.start).toDate(),
	      end: hooks(plain.end).toDate(),
	      // @TODO: FIXME add verification declined vs missed call
	      newMissedCall: session.hasExtension(plain.destination_extension) && !plain.answered,
	    });
	  }

	  static newFrom(profile         ) {
	    return newFrom(profile, CallLog);
	  }

	  constructor({
	    answer,
	    answered,
	    callDirection,
	    destination,
	    source,
	    id,
	    duration,
	    start,
	    end,
	  }                   = {}) {
	    this.answer = answer;
	    this.answered = answered;
	    this.callDirection = callDirection;
	    this.destination = destination;
	    this.source = source;
	    this.id = id;
	    this.duration = duration;
	    this.start = start;
	    this.end = end;
	  }

	  isFromSameParty(other         , session         )          {
	    return this.theOtherParty(session).extension === other.theOtherParty(session).extension;
	  }

	  theOtherParty(session         )                                      {
	    if (session.hasExtension(this.source.extension)) {
	      return this.destination;
	    }
	    return this.source;
	  }

	  isNewMissedCall()          {
	    return this.newMissedCall;
	  }

	  acknowledgeCall()          {
	    this.newMissedCall = false;

	    return this;
	  }

	  isAcknowledged()          {
	    return this.newMissedCall;
	  }

	  isAnswered()          {
	    return this.answered;
	  }

	  isOutgoing(session         )          {
	    if (this.callDirection === 'internal') {
	      return session.hasExtension(this.source.extension);
	    }

	    return this.callDirection === 'outbound';
	  }

	  isIncoming(session         )          {
	    if (this.callDirection === 'internal') {
	      return session.hasExtension(this.destination.extension);
	    }

	    return this.callDirection === 'inbound';
	  }

	  isAnOutgoingCall(session         )          {
	    console.warn(`@wazo/sdk 
      CallLog.isAnOutgoingcall(session) method is obsolete.
      Please use CallLog.isOutgoing(session).
    `);

	    return session.hasExtension(this.source.extension) && this.answered;
	  }

	  isAMissedOutgoingCall(session         )          {
	    return session.hasExtension(this.source.extension) && !this.answered;
	  }

	  isAnIncomingCall(session         )          {
	    console.warn(`@wazo/sdk
      CallLog.isAnIncomingCall(session) method is obsolete.
      Please use CallLog.isIncoming(session).
    `);

	    return session.hasExtension(this.destination.extension) && this.answered;
	  }

	  isADeclinedCall(session         )          {
	    return !this.answered && session.hasExtension(this.destination.extension);
	  }
	}

	/*       */

	var callLogdMethods = (client              , baseUrl        ) => ({
	  search(token       , search        , limit         = 5)                          {
	    return client
	      .get(`${baseUrl}/users/me/cdr`, { search, limit }, token)
	      .then(response => CallLog.parseMany(response));
	  },

	  listCallLogs(token       , offset        , limit         = 5)                          {
	    return client
	      .get(`${baseUrl}/users/me/cdr`, { offset, limit }, token)
	      .then(response => CallLog.parseMany(response));
	  },

	  listCallLogsFromDate(token       , from      , number        )                          {
	    return client
	      .get(`${baseUrl}/users/me/cdr`, { from: from.toISOString(), number }, token)
	      .then(response => CallLog.parseMany(response));
	  },
	});

	//      

	                            
	               
	               
	                         
	  

	                                
	                   
	                
	                             
	  

	class ChatRoom {
	               
	               
	                         

	  static parseMany(plain                  )                  {
	    return plain.items.map(item => ChatRoom.parse(item));
	  }

	  static parse(plain              )           {
	    return new ChatRoom({
	      uuid: plain.uuid,
	      name: plain.name,
	      users: plain.users,
	    });
	  }

	  static newFrom(room          ) {
	    return newFrom(room, ChatRoom);
	  }

	  constructor({ uuid, name, users }         = {}) {
	    this.uuid = uuid;
	    this.name = name;
	    this.users = users;
	  }
	}

	/*       */

	                                
	                                              
	                                                     
	                
	                 
	                    
	  

	                             
	                   
	                
	                                 
	  

	                           
	                     
	                 
	                 
	                  
	                 
	  

	var chatdMethods = (client              , baseUrl        ) => ({
	  updatePresence: (token       , contactUuid      , state        )                   =>
	    client.put(`${baseUrl}/users/${contactUuid}/presences`, { state }, token, ApiRequester.successResponseParser),

	  updateStatus: (token       , contactUuid      , state        , status        )                   => {
	    const body = { state, status };

	    return client.put(`${baseUrl}/users/${contactUuid}/presences`, body, token, ApiRequester.successResponseParser);
	  },

	  getPresence: async (token       , contactUuid      )                  =>
	    client
	      .get(`${baseUrl}/users/${contactUuid}/presences`, null, token)
	      .then((response                  ) => response.state),

	  getContactStatusInfo: async (token       , contactUuid      )                            =>
	    client.get(`${baseUrl}/users/${contactUuid}/presences`, null, token).then((response                  ) => response),

	  getLineState: async (token       , contactUuid      )                  =>
	    client
	      .get(`${baseUrl}/users/${contactUuid}/presences`, null, token)
	      .then((response                  ) => Profile.getLinesState(response.lines)),

	  getMultipleLineState: async (token       , contactUuids             )                  =>
	    client
	      .get(`${baseUrl}/users/presences`, { user_uuid: contactUuids.join(',') }, token)
	      .then((response                      ) => response.items),

	  getUserRooms: async (token       )                           =>
	    client.get(`${baseUrl}/users/me/rooms`, null, token).then(ChatRoom.parseMany),

	  createRoom: async (token       , name        , users                 )                    =>
	    client.post(`${baseUrl}/users/me/rooms`, { name, users }, token).then(ChatRoom.parse),

	  getRoomMessages: async (token       , roomUuid        )                              =>
	    client
	      .get(`${baseUrl}/users/me/rooms/${roomUuid}/messages`, null, token)
	      .then((response                         ) => ChatMessage.parseMany(response)),

	  sendRoomMessage: async (token       , roomUuid        , message             )                       =>
	    client.post(`${baseUrl}/users/me/rooms/${roomUuid}/messages`, message, token).then(ChatMessage.parse),

	  getMessages: async (token       , options                    )                       =>
	    client.get(`${baseUrl}/users/me/rooms/messages`, options, token),
	});

	/*       */
	                                             

	                                     
	                 
	                  
	                         
	                           
	             
	                    
	                   
	                 
	                    
	  

	                               
	                                      
	                
	  
	var calldMethods = (client              , baseUrl        ) => ({
	  getConferenceParticipantsAsUser: async (token       , conferenceId        )                                  =>
	    client.get(`${baseUrl}/users/me/conferences/${conferenceId}/participants`, null, token),
	});

	/*       */

	const AUTH_VERSION = '0.1';
	const APPLICATION_VERSION = '1.0';
	const CONFD_VERSION = '1.1';
	const ACCESSD_VERSION = '1.0';
	const CTIDNG_VERSION = '1.0';
	const DIRD_VERSION = '0.1';
	const CALL_LOGD_VERSION = '1.0';
	const CHATD_VERSION = '1.0';
	const CALLD_VERSION = '1.0';

	class ApiClient {
	                       
	               
	                      
	                
	                  
	                 
	               
	                   
	                
	                

	  // @see https://github.com/facebook/flow/issues/183#issuecomment-358607052
	  constructor({ server, agent = null }                                               ) {
	    this.updatePatemers({ server, agent });
	  }

	  initializeEndpoints()       {
	    this.auth = authMethods(this.client, `auth/${AUTH_VERSION}`);
	    this.application = applicationMethods(this.client, `ctid-ng/${APPLICATION_VERSION}/applications`);
	    this.confd = confdMethods(this.client, `confd/${CONFD_VERSION}`);
	    this.accessd = accessdMethods(this.client, `accessd/${ACCESSD_VERSION}`);
	    this.ctidNg = ctidNgMethods(this.client, `ctid-ng/${CTIDNG_VERSION}`);
	    this.dird = dirdMethods(this.client, `dird/${DIRD_VERSION}`);
	    this.callLogd = callLogdMethods(this.client, `call-logd/${CALL_LOGD_VERSION}`);
	    this.chatd = chatdMethods(this.client, `chatd/${CHATD_VERSION}`);
	    this.calld = calldMethods(this.client, `calld/${CALLD_VERSION}`);
	  }

	  updatePatemers({ server, agent }                                    ) {
	    this.client = new ApiRequester({ server, agent });

	    this.initializeEndpoints();
	  }
	}

	/* eslint-disable */

	/* SessionDescriptionHandler
	 * @class PeerConnection helper Class.
	 * @param {SIP.Session} session
	 * @param {Object} [options]
	 */
	var MobileSessionDescriptionHandler = SIPMethods =>
	  class MobileSessionDescriptionHandler extends events {
	    /**
	     * @param {SIP.Session} session
	     * @param {Object} [options]
	     */
	    static defaultFactory(session, options) {
	      const logger = session.ua.getLogger('sip.invitecontext.sessionDescriptionHandler', session.id);
	      const observer = new SessionDescriptionHandlerObserver_2(session, options);

	      return new MobileSessionDescriptionHandler(logger, observer, options);
	    }

	    constructor(logger, observer, options) {
	      super();

	      // TODO: Validate the options
	      this.options = options || {};

	      this.logger = logger;
	      this.observer = observer;
	      this.dtmfSender = null;

	      this.shouldAcquireMedia = true;

	      this.CONTENT_TYPE = 'application/sdp';

	      this.C = {};
	      this.C.DIRECTION = {
	        NULL: null,
	        SENDRECV: 'sendrecv',
	        SENDONLY: 'sendonly',
	        RECVONLY: 'recvonly',
	        INACTIVE: 'inactive',
	      };

	      this.logger.log('SessionDescriptionHandlerOptions: ' + JSON.stringify(this.options));

	      this.direction = this.C.DIRECTION.NULL;

	      this.modifiers = this.options.modifiers || [];
	      if (!Array.isArray(this.modifiers)) {
	        this.modifiers = [this.modifiers];
	      }

	      var environment = global.window || global;
	      this.WebRTC = {
	        MediaStream: environment.MediaStream,
	        getUserMedia: environment.navigator.mediaDevices.getUserMedia.bind(environment.navigator.mediaDevices),
	        RTCPeerConnection: environment.RTCPeerConnection,
	        RTCSessionDescription: environment.RTCSessionDescription,
	      };

	      this.iceGatheringDeferred = null;
	      this.iceGatheringTimeout = false;
	      this.iceGatheringTimer = null;

	      this.initPeerConnection(this.options.peerConnectionOptions);

	      this.constraints = this.checkAndDefaultConstraints(this.options.constraints);
	    }

	    /**
	     * Destructor
	     */
	    close() {
	      this.logger.log('closing PeerConnection');
	      // have to check signalingState since this.close() gets called multiple times
	      if (this.peerConnection && this.peerConnection.signalingState !== 'closed') {
	        if (this.peerConnection.getSenders) {
	          this.peerConnection.getSenders().forEach(function(sender) {
	            if (sender.track) {
	              sender.track.stop();
	            }
	          });
	        } else {
	          this.logger.warn('Using getLocalStreams which is deprecated');
	          this.peerConnection.getLocalStreams().forEach(function(stream) {
	            stream.getTracks().forEach(function(track) {
	              track.stop();
	            });
	          });
	        }
	        if (this.peerConnection.getReceivers) {
	          this.peerConnection.getReceivers().forEach(function(receiver) {
	            if (receiver.track) {
	              receiver.track.stop();
	            }
	          });
	        } else {
	          this.logger.warn('Using getRemoteStreams which is deprecated');
	          this.peerConnection.getRemoteStreams().forEach(function(stream) {
	            stream.getTracks().forEach(function(track) {
	              track.stop();
	            });
	          });
	        }
	        this.resetIceGatheringComplete();
	        this.peerConnection.close();
	      }
	    }

	    /**
	     * Gets the local description from the underlying media implementation
	     * @param {Object} [options] Options object to be used by getDescription
	     * @param {MediaStreamConstraints} [options.constraints] MediaStreamConstraints https://developer.mozilla.org/en-US/docs/Web/API/MediaStreamConstraints
	     * @param {Object} [options.peerConnectionOptions] If this is set it will recreate the peer connection with the new options
	     * @param {Array} [modifiers] Array with one time use description modifiers
	     * @returns {Promise} Promise that resolves with the local description to be used for the session
	     */
	    getDescription(options, modifiers) {
	      options = options || {};
	      if (options.peerConnectionOptions) {
	        this.initPeerConnection(options.peerConnectionOptions);
	      }

	      this.shouldAcquireMedia = true;

	      modifiers = modifiers || [];
	      if (!Array.isArray(modifiers)) {
	        modifiers = [modifiers];
	      }
	      modifiers = modifiers.concat(this.modifiers);

	      return Promise.resolve()
	        .then(
	          function() {
	            if (this.shouldAcquireMedia) {
	              return this.acquire(JSON.parse(JSON.stringify(this.constraints))).then(
	                function() {
	                  this.shouldAcquireMedia = false;
	                }.bind(this)
	              );
	            }
	          }.bind(this)
	        )
	        .then(
	          function() {
	            return this.createOfferOrAnswer(options.RTCOfferOptions, modifiers);
	          }.bind(this)
	        )
	        .then(
	          function(description) {
	            this.emit('getDescription', description);
	            return {
	              body: description.sdp,
	              contentType: this.CONTENT_TYPE,
	            };
	          }.bind(this)
	        );
	    }

	    /**
	     * Check if the Session Description Handler can handle the Content-Type described by a SIP Message
	     * @param {String} contentType The content type that is in the SIP Message
	     * @returns {boolean}
	     */
	    hasDescription(contentType) {
	      return contentType === this.CONTENT_TYPE;
	    }

	    /**
	     * The modifier that should be used when the session would like to place the call on hold
	     * @param {String} [sdp] The description that will be modified
	     * @returns {Promise} Promise that resolves with modified SDP
	     */
	    holdModifier(description) {
	      if (!/a=(sendrecv|sendonly|recvonly|inactive)/.test(description.sdp)) {
	        description.sdp = description.sdp.replace(/(m=[^\r]*\r\n)/g, '$1a=sendonly\r\n');
	      } else {
	        description.sdp = description.sdp.replace(/a=sendrecv\r\n/g, 'a=sendonly\r\n');
	        description.sdp = description.sdp.replace(/a=recvonly\r\n/g, 'a=inactive\r\n');
	      }
	      return Promise.resolve(description);
	    }

	    /**
	     * Set the remote description to the underlying media implementation
	     * @param {String} sessionDescription The description provided by a SIP message to be set on the media implementation
	     * @param {Object} [options] Options object to be used by getDescription
	     * @param {MediaStreamConstraints} [options.constraints] MediaStreamConstraints https://developer.mozilla.org/en-US/docs/Web/API/MediaStreamConstraints
	     * @param {Object} [options.peerConnectionOptions] If this is set it will recreate the peer connection with the new options
	     * @param {Array} [modifiers] Array with one time use description modifiers
	     * @returns {Promise} Promise that resolves once the description is set
	     */
	    setDescription(sessionDescription, options, modifiers) {
	      var self = this;

	      options = options || {};
	      if (options.peerConnectionOptions) {
	        this.initPeerConnection(options.peerConnectionOptions);
	      }

	      modifiers = modifiers || [];
	      if (!Array.isArray(modifiers)) {
	        modifiers = [modifiers];
	      }
	      modifiers = modifiers.concat(this.modifiers);

	      var description = {
	        type: this.hasOffer('local') ? 'answer' : 'offer',
	        sdp: sessionDescription,
	      };

	      if (options.disableVideo) {
	        modifiers = [SIPMethods.Web.Modifiers.stripVideo].concat(modifiers);
	      }

	      return Promise.resolve()
	        .then(
	          function() {
	            // Media should be acquired in getDescription unless we need to do it sooner for some reason (FF61+)
	            if (this.shouldAcquireMedia && this.options.alwaysAcquireMediaFirst) {
	              return this.acquire(this.constraints).then(
	                function() {
	                  this.shouldAcquireMedia = false;
	                }.bind(this)
	              );
	            }
	          }.bind(this)
	        )
	        .then(function() {
	          return SIPMethods.Utils.reducePromises(modifiers, description);
	        })
	        .catch(e => {
	          if (e instanceof SIPMethods.Exceptions.SessionDescriptionHandlerError) {
	            throw e;
	          }
	          const error = new SIPMethods.Exceptions.SessionDescriptionHandlerError(
	            'setDescription',
	            e,
	            'The modifiers did not resolve successfully'
	          );
	          this.logger.error(error.message);
	          self.emit('peerConnection-setRemoteDescriptionFailed', error);
	          throw error;
	        })
	        .then(function(modifiedDescription) {
	          self.emit('setDescription', modifiedDescription);

	          return self.peerConnection.setRemoteDescription(new self.WebRTC.RTCSessionDescription(modifiedDescription));
	        })
	        .catch(e => {
	          if (e instanceof SIPMethods.Exceptions.SessionDescriptionHandlerError) {
	            throw e;
	          }
	          // Check the original SDP for video, and ensure that we have want to do audio fallback
	          if (/^m=video.+$/gm.test(sessionDescription) && !options.disableAudioFallback) {
	            // Do not try to audio fallback again
	            options.disableAudioFallback = true;
	            // Remove video first, then do the other modifiers
	            return this.setDescription(
	              sessionDescription,
	              options,
	              [SIPMethods.Web.Modifiers.stripVideo].concat(modifiers)
	            );
	          }
	          const error = new SIPMethods.Exceptions.SessionDescriptionHandlerError('setDescription', e);
	          this.logger.error(error.error);
	          this.emit('peerConnection-setRemoteDescriptionFailed', error);
	          throw error;
	        })
	        .then(function setRemoteDescriptionSuccess() {
	          if (self.peerConnection.getReceivers) {
	            self.emit('setRemoteDescription', self.peerConnection.getReceivers());
	          } else {
	            self.emit('setRemoteDescription', self.peerConnection.getRemoteStreams());
	          }
	          self.emit('confirmed', self);
	        });
	    }

	    /**
	     * Send DTMF via RTP (RFC 4733)
	     * @param {String} tones A string containing DTMF digits
	     * @param {Object} [options] Options object to be used by sendDtmf
	     * @returns {boolean} true if DTMF send is successful, false otherwise
	     */
	    sendDtmf(tones, options) {
	      if (!this.dtmfSender && this.hasBrowserGetSenderSupport()) {
	        var senders = this.peerConnection.getSenders();
	        if (senders.length > 0) {
	          this.dtmfSender = senders[0].dtmf;
	        }
	      }
	      if (!this.dtmfSender && this.hasBrowserTrackSupport()) {
	        var streams = this.peerConnection.getLocalStreams();
	        if (streams.length > 0) {
	          var audioTracks = streams[0].getAudioTracks();
	          if (audioTracks.length > 0) {
	            this.dtmfSender = this.peerConnection.createDTMFSender(audioTracks[0]);
	          }
	        }
	      }
	      if (!this.dtmfSender) {
	        return false;
	      }
	      try {
	        this.dtmfSender.insertDTMF(tones, options.duration, options.interToneGap);
	      } catch (e) {
	        if (e.type === 'InvalidStateError' || e.type === 'InvalidCharacterError') {
	          this.logger.error(e);
	          return false;
	        } else {
	          throw e;
	        }
	      }
	      this.logger.log('DTMF sent via RTP: ' + tones.toString());
	      return true;
	    }

	    getDirection() {
	      return this.direction;
	    }

	    // Internal functions
	    createOfferOrAnswer(RTCOfferOptions, modifiers) {
	      var self = this;
	      var methodName;
	      var pc = this.peerConnection;

	      RTCOfferOptions = RTCOfferOptions || {};

	      methodName = self.hasOffer('remote') ? 'createAnswer' : 'createOffer';

	      return pc[methodName](RTCOfferOptions)
	        .catch(e => {
	          if (e instanceof SIPMethods.Exceptions.SessionDescriptionHandlerError) {
	            throw e;
	          }
	          const error = new SIPMethods.Exceptions.SessionDescriptionHandlerError(
	            'createOfferOrAnswer',
	            e,
	            'peerConnection-' + methodName + 'Failed'
	          );
	          this.emit('peerConnection-' + methodName + 'Failed', error);
	          throw error;
	        })
	        .then(function(sdp) {
	          return SIPMethods.Utils.reducePromises(modifiers, self.createRTCSessionDescriptionInit(sdp));
	        })
	        .then(function(sdp) {
	          self.resetIceGatheringComplete();
	          return pc.setLocalDescription(new self.WebRTC.RTCSessionDescription(sdp));
	        })
	        .catch(e => {
	          if (e instanceof SIPMethods.Exceptions.SessionDescriptionHandlerError) {
	            throw e;
	          }
	          const error = new SIPMethods.Exceptions.SessionDescriptionHandlerError(
	            'createOfferOrAnswer',
	            e,
	            'peerConnection-SetLocalDescriptionFailed'
	          );
	          this.emit('peerConnection-SetLocalDescriptionFailed', error);
	          throw error;
	        })
	        .then(function onSetLocalDescriptionSuccess() {
	          return self.waitForIceGatheringComplete();
	        })
	        .then(function readySuccess() {
	          var localDescription = self.createRTCSessionDescriptionInit(self.peerConnection.localDescription);
	          return SIPMethods.Utils.reducePromises(modifiers, localDescription);
	        })
	        .then(function(localDescription) {
	          self.setDirection(localDescription.sdp);
	          return localDescription;
	        })
	        .then(localDescription =>
	          // @see https://github.com/oney/react-native-webrtc/issues/242#issuecomment-290452014
	          // @see https://github.com/oney/RCTWebRTCDemo/blob/master/main.js#L103
	          methodName === 'createOffer' && !modifiers.length ? pc[methodName](RTCOfferOptions) : localDescription
	        )
	        .catch(e => {
	          if (e instanceof SIPMethods.Exceptions.SessionDescriptionHandlerError) {
	            throw e;
	          }
	          const error = new SIPMethods.Exceptions.SessionDescriptionHandlerError('createOfferOrAnswer', e);
	          this.logger.error(error);
	          throw error;
	        });
	    }

	    // Creates an RTCSessionDescriptionInit from an RTCSessionDescription
	    createRTCSessionDescriptionInit(RTCSessionDescription) {
	      return {
	        type: RTCSessionDescription.type,
	        sdp: RTCSessionDescription.sdp,
	      };
	    }

	    addDefaultIceCheckingTimeout(peerConnectionOptions) {
	      if (peerConnectionOptions.iceCheckingTimeout === undefined) {
	        peerConnectionOptions.iceCheckingTimeout = 5000;
	      }

	      return peerConnectionOptions;
	    }

	    addDefaultIceServers(rtcConfiguration) {
	      if (!rtcConfiguration.iceServers) {
	        rtcConfiguration.iceServers = [{ urls: 'stun:stun.l.google.com:19302' }];
	      }
	      return rtcConfiguration;
	    }

	    checkAndDefaultConstraints(constraints) {
	      let defaultConstraints = { audio: true, video: constraints.video };

	      constraints = constraints || defaultConstraints;
	      // Empty object check
	      if (Object.keys(constraints).length === 0 && constraints.constructor === Object) {
	        return defaultConstraints;
	      }

	      return constraints;
	    }

	    hasBrowserTrackSupport() {
	      return Boolean(this.peerConnection.addTrack);
	    }

	    hasBrowserGetSenderSupport() {
	      return Boolean(this.peerConnection.getSenders);
	    }

	    initPeerConnection(options) {
	      var self = this;
	      options = options || {};
	      options = this.addDefaultIceCheckingTimeout(options);
	      options.rtcConfiguration = options.rtcConfiguration || {};
	      options.rtcConfiguration = this.addDefaultIceServers(options.rtcConfiguration);

	      this.logger.log('initPeerConnection');

	      if (this.peerConnection) {
	        this.logger.log('Already have a peer connection for this session. Tearing down.');
	        this.resetIceGatheringComplete();
	        this.peerConnection.close();
	      }

	      this.peerConnection = new this.WebRTC.RTCPeerConnection(options.rtcConfiguration);

	      this.logger.log('New peer connection created');

	      if ('ontrack' in this.peerConnection) {
	        this.peerConnection.addEventListener('track', function(e) {
	          self.logger.log('track added');
	          self.observer.trackAdded();
	          self.emit('addTrack', e);
	        });
	      } else {
	        this.logger.warn('Using onaddstream which is deprecated');
	        this.peerConnection.onaddstream = function(e) {
	          self.logger.log('stream added');
	          self.emit('addStream', e);
	        };
	      }

	      this.peerConnection.onicecandidate = function(e) {
	        self.emit('iceCandidate', e);
	        if (e.candidate) {
	          self.logger.log(
	            'ICE candidate received: ' + (e.candidate.candidate === null ? null : e.candidate.candidate.trim())
	          );
	        } else if (e.candidate === null) {
	          // indicates the end of candidate gathering
	          self.logger.log('ICE candidate gathering complete');
	          self.triggerIceGatheringComplete();
	        }
	      };

	      this.peerConnection.onicegatheringstatechange = function() {
	        self.logger.log('RTCIceGatheringState changed: ' + this.iceGatheringState);
	        switch (this.iceGatheringState) {
	          case 'gathering':
	            self.emit('iceGathering', this);
	            if (!self.iceGatheringTimer && options.iceCheckingTimeout) {
	              self.iceGatheringTimeout = false;
	              self.iceGatheringTimer = setTimeout(function() {
	                self.logger.log(
	                  'RTCIceChecking Timeout Triggered after ' + options.iceCheckingTimeout + ' milliseconds'
	                );
	                self.iceGatheringTimeout = true;
	                self.triggerIceGatheringComplete();
	              }, options.iceCheckingTimeout);
	            }
	            break;
	          case 'complete':
	            self.triggerIceGatheringComplete();
	            break;
	        }
	      };

	      this.peerConnection.oniceconnectionstatechange = function() {
	        //need e for commented out case
	        var stateEvent;

	        switch (this.iceConnectionState) {
	          case 'new':
	            stateEvent = 'iceConnection';
	            break;
	          case 'checking':
	            stateEvent = 'iceConnectionChecking';
	            break;
	          case 'connected':
	            stateEvent = 'iceConnectionConnected';
	            break;
	          case 'completed':
	            stateEvent = 'iceConnectionCompleted';
	            break;
	          case 'failed':
	            stateEvent = 'iceConnectionFailed';
	            break;
	          case 'disconnected':
	            stateEvent = 'iceConnectionDisconnected';
	            break;
	          case 'closed':
	            stateEvent = 'iceConnectionClosed';
	            break;
	          default:
	            self.logger.warn('Unknown iceConnection state:', this.iceConnectionState);
	            return;
	        }
	        self.emit(stateEvent, this);
	      };
	    }

	    acquire(constraints) {
	      // Default audio & video to true
	      constraints = this.checkAndDefaultConstraints(constraints);

	      return new Promise(
	        function(resolve, reject) {
	          /*
	           * Make the call asynchronous, so that ICCs have a chance
	           * to define callbacks to `userMediaRequest`
	           */
	          this.logger.log('acquiring local media');
	          this.emit('userMediaRequest', constraints);

	          if (constraints.audio || constraints.video) {
	            // Avoid exception on immutable object, can't use destructuring because android crashes
	            this.WebRTC.getUserMedia(JSON.parse(JSON.stringify(constraints)))
	              .then(
	                function(streams) {
	                  this.observer.trackAdded();
	                  this.emit('userMedia', streams);
	                  resolve(streams);
	                }.bind(this)
	              )
	              .catch(
	                function(e) {
	                  this.emit('userMediaFailed', e);
	                  reject(e);
	                }.bind(this)
	              );
	          } else {
	            // Local streams were explicitly excluded.
	            resolve([]);
	          }
	        }.bind(this)
	      )
	        .catch(e => {
	          // TODO: This propogates downwards
	          if (e instanceof SIPMethods.Exceptions.SessionDescriptionHandlerError) {
	            throw e;
	          }
	          const error = new SIPMethods.Exceptions.SessionDescriptionHandlerError(
	            'acquire',
	            e,
	            'unable to acquire streams'
	          );
	          this.logger.error(error.message);
	          this.logger.error(error.error);
	          throw error;
	        })
	        .then(
	          function acquireSucceeded(streams) {
	            this.logger.log('acquired local media streams');
	            try {
	              // Remove old tracks
	              if (this.peerConnection.removeTrack) {
	                this.peerConnection.getSenders().forEach(function(sender) {
	                  this.peerConnection.removeTrack(sender);
	                }, this);
	              }
	              return streams;
	            } catch (e) {
	              return Promise.reject(e);
	            }
	          }.bind(this)
	        )
	        .catch(e => {
	          if (e instanceof SIPMethods.Exceptions.SessionDescriptionHandlerError) {
	            throw e;
	          }
	          const error = new SIPMethods.Exceptions.SessionDescriptionHandlerError(
	            'acquire',
	            e,
	            'error removing streams'
	          );
	          this.logger.error(error.message);
	          this.logger.error(error.error);
	          throw error;
	        })
	        .then(
	          function addStreams(streams) {
	            try {
	              streams = [].concat(streams);
	              streams.forEach(function(stream) {
	                if (this.peerConnection.addTrack) {
	                  stream.getTracks().forEach(function(track) {
	                    this.peerConnection.addTrack(track, stream);
	                  }, this);
	                } else {
	                  // Chrome 59 does not support addTrack
	                  this.peerConnection.addStream(stream);
	                }
	              }, this);
	            } catch (e) {
	              return Promise.reject(e);
	            }
	            return Promise.resolve();
	          }.bind(this)
	        )
	        .catch(e => {
	          if (e instanceof SIPMethods.Exceptions.SessionDescriptionHandlerError) {
	            throw e;
	          }
	          const error = new SIPMethods.Exceptions.SessionDescriptionHandlerError('acquire', e, 'error adding stream');
	          this.logger.error(error.message);
	          this.logger.error(error.error);
	          throw error;
	        });
	    }

	    hasOffer(where) {
	      var offerState = 'have-' + where + '-offer';

	      return this.peerConnection.signalingState === offerState;
	    }

	    // ICE gathering state handling
	    isIceGatheringComplete() {
	      return this.peerConnection.iceGatheringState === 'complete' || this.iceGatheringTimeout;
	    }

	    resetIceGatheringComplete() {
	      this.iceGatheringTimeout = false;

	      if (this.iceGatheringTimer) {
	        clearTimeout(this.iceGatheringTimer);
	        this.iceGatheringTimer = null;
	      }

	      if (this.iceGatheringDeferred) {
	        this.iceGatheringDeferred.reject();
	        this.iceGatheringDeferred = null;
	      }
	    }

	    setDirection(sdp) {
	      var match = sdp.match(/a=(sendrecv|sendonly|recvonly|inactive)/);
	      if (match === null) {
	        this.direction = this.C.DIRECTION.NULL;
	        this.observer.directionChanged();
	        return;
	      }
	      var direction = match[1];
	      switch (direction) {
	        case this.C.DIRECTION.SENDRECV:
	        case this.C.DIRECTION.SENDONLY:
	        case this.C.DIRECTION.RECVONLY:
	        case this.C.DIRECTION.INACTIVE:
	          this.direction = direction;
	          break;
	        default:
	          this.direction = this.C.DIRECTION.NULL;
	          break;
	      }
	      this.observer.directionChanged();
	    }

	    triggerIceGatheringComplete() {
	      if (this.isIceGatheringComplete()) {
	        this.emit('iceGatheringComplete', this);

	        if (this.iceGatheringTimer) {
	          clearTimeout(this.iceGatheringTimer);
	          this.iceGatheringTimer = null;
	        }

	        if (this.iceGatheringDeferred) {
	          this.iceGatheringDeferred.resolve();
	          this.iceGatheringDeferred = null;
	        }
	      }
	    }

	    waitForIceGatheringComplete() {
	      if (this.isIceGatheringComplete()) {
	        return Promise.resolve();
	      } else if (!this.isIceGatheringDeferred) {
	        this.iceGatheringDeferred = SIPMethods.Utils.defer();
	      }
	      return this.iceGatheringDeferred.promise;
	    }
	  };

	//      

	const SIPMethods = { Web: { Modifiers: Web_1 }, Utils: Utils_2, Exceptions: Exceptions_3 };

	const MAX_REGISTER_TRY = 10;

	const states = ['STATUS_NULL', 'STATUS_NEW', 'STATUS_CONNECTING', 'STATUS_CONNECTED', 'STATUS_COMPLETED'];
	const events$1 = [
	  'registered',
	  'unregistered',
	  'registrationFailed',
	  'invite',
	  'inviteSent',
	  'transportCreated',
	  'newTransaction',
	  'transactionDestroyed',
	  'notify',
	  'outOfDialogReferRequested',
	  'message',
	];
	const transportEvents = [
	  'connected',
	  'disconnected',
	  'transportError',
	  'message',
	  'closed',
	  'keepAliveDebounceTimeout',
	];
	const MAX_MERGE_SESSIONS = 4;

	                    
	                          
	                          
	                                
	  

	                     
	                      
	               
	             
	                
	                             
	                    
	              
	                     
	                           
	                              
	               
	                               
	  

	// @see https://github.com/onsip/SIP.js/blob/master/src/Web/Simple.js
	class WebRTCClient extends Emitter {
	                       
	                
	                    
	                          
	                                                
	                          
	                        
	                                 
	                              
	                       
	                                                     
	                               
	                        
	                        
	                      
	                              

	  static isAPrivateIp(ip        )          {
	    const regex = /^(?:10|127|172\.(?:1[6-9]|2[0-9]|3[01])|192\.168)\..*/;
	    return regex.exec(ip) == null;
	  }

	  static getIceServers(ip        )                                 {
	    if (WebRTCClient.isAPrivateIp(ip)) {
	      return [
	        {
	          urls: ['stun:stun.l.google.com:19302', 'stun:stun4.l.google.com:19302'],
	        },
	      ];
	    }
	    return [];
	  }

	  constructor(config              , session          ) {
	    super();
	    this._buildConfig(config, session).then((newConfig              ) => {
	      this.config = newConfig;
	      this.userAgent = this.createUserAgent();
	    });

	    this.audioOutputDeviceId = config.audioOutputDeviceId;

	    this.configureMedia(config.media);

	    this.videoSessions = {};
	    this.registerTries = 0;
	    this.registered = false;
	    this.registerTimeout = null;
	  }

	  configureMedia(media             ) {
	    this.hasAudio = !!media.audio;
	    this.video = media.video;
	    this.audio = media.audio;
	    this.localVideo = media.localVideo;
	    this.audioContext = this._isWeb() ? new (window.AudioContext || window.webkitAudioContext)() : null;
	    this.audioStreams = {};
	    this.audioElements = {};
	  }

	  createUserAgent()     {
	    const webRTCConfiguration = this._createWebRTCConfiguration();
	    const userAgent = new UA_2(webRTCConfiguration);

	    events$1
	      .filter(eventName => eventName !== 'invite' && eventName !== 'new')
	      .forEach(eventName => userAgent.on(eventName, event => this.eventEmitter.emit(eventName, event)));

	    // Particular case for `invite` event
	    userAgent.on('invite', (session                               ) => {
	      this._setupSession(session);
	      this._fixLocalDescription(session, 'answer');
	      const shouldAutoAnswer = !!session.request.getHeader('alert-info');

	      this.eventEmitter.emit('invite', session, this.sessionWantsToDoVideo(session), shouldAutoAnswer);
	    });

	    transportEvents.forEach(eventName => {
	      userAgent.transport.on(eventName, event => {
	        this.eventEmitter.emit(eventName, event);
	      });
	    });

	    this._bindRegistrationEvents(userAgent);

	    return userAgent;
	  }

	  isRegistered()          {
	    return this.userAgent && this.userAgent.isRegistered();
	  }

	  register() {
	    if (!this.userAgent) {
	      return;
	    }

	    this.userAgent.register();
	  }

	  unregister() {
	    if (!this.userAgent) {
	      return;
	    }

	    this.userAgent.unregister();
	  }

	  // eslint-disable-next-line no-unused-vars
	  sessionWantsToDoVideo(session                               ) {
	    const sdp = session.request.body;
	    const sessionHasVideo = /\r\nm=video /.test(sdp);

	    return sessionHasVideo;
	  }

	  call(number        , enableVideo          )                          {
	    this.changeVideo(enableVideo || false);
	    const context = this.userAgent.invite(number, this._getMediaConfiguration(enableVideo || false));

	    this._setupSession(context);

	    return context;
	  }

	  answer(session                               , enableVideo          ) {
	    this.changeVideo(enableVideo || false);
	    return session.accept(this._getMediaConfiguration(enableVideo || false));
	  }

	  hangup(session                               ) {
	    if ('stop' in session) {
	      session.stop();
	    }

	    if (session.id in this.audioStreams) {
	      this.removeFromMerge(session);
	    }

	    if (session.hasAnswer && session.bye) {
	      return session.bye();
	    }

	    if (!session.hasAnswer && session.cancel) {
	      return session.cancel();
	    }

	    if (session.reject) {
	      return session.reject();
	    }

	    this._cleanupMedia(session);

	    return null;
	  }

	  reject(session                               ) {
	    return session.reject();
	  }

	  getNumber(session                               )          {
	    if (!session) {
	      return null;
	    }

	    // eslint-disable-next-line
	    return session.remoteIdentity.uri._normal.user;
	  }

	  mute(session                               ) {
	    this._toggleAudio(session, true);
	  }

	  unmute(session                               ) {
	    this._toggleAudio(session, false);
	  }

	  toggleCameraOn(session                               ) {
	    this._toggleVideo(session, false);
	  }

	  toggleCameraOff(session                               ) {
	    this._toggleVideo(session, true);
	  }

	  hold(session                               ) {
	    this.mute(session);

	    return session.hold(this._getMediaConfiguration(this.videoEnabled));
	  }

	  unhold(session                               ) {
	    this.unmute(session);

	    return session.unhold(this._getMediaConfiguration(this.videoEnabled));
	  }

	  sendDTMF(session                               , tone        ) {
	    return session.dtmf(tone);
	  }

	  message(destination        , message        ) {
	    return this.userAgent.message(destination, message);
	  }

	  transfer(session                               , target        ) {
	    this.hold(session);

	    setTimeout(() => {
	      session.refer(target);
	      this.hangup(session);
	    }, 50);
	  }

	  // check https://sipjs.com/api/0.12.0/refer/referClientContext/
	  atxfer(session                               ) {
	    this.hold(session);

	    return {
	      init: (target        ) => this.call(target),
	      complete: (newSession                               ) => {
	        this.unhold(session);

	        setTimeout(() => {
	          newSession.refer(session);
	          this.hangup(session);
	        }, 50);
	      },
	      cancel: (newSession                               ) => {
	        this.hangup(newSession);
	        this.unhold(session);
	      },
	    };
	  }

	  merge(sessions                                )                          {
	    this._checkMaxMergeSessions(sessions.length);
	    if (this.audioContext) {
	      this.mergeDestination = this.audioContext.createMediaStreamDestination();
	    }

	    if (this.audioContext && this.audioContext.state === 'suspended') {
	      this.audioContext.resume();
	    }

	    return sessions.map(this.addToMerge.bind(this));
	  }

	  addToMerge(session                         )                   {
	    this._checkMaxMergeSessions(Object.keys(this.audioStreams).length + 1);

	    const isFirefox = this._isWeb() && navigator.userAgent.toLowerCase().indexOf('firefox') > -1;
	    const sdh = session.sessionDescriptionHandler;
	    const pc = sdh.peerConnection;

	    const bindStreams = remoteStream => {
	      const localStream = pc.getLocalStreams()[0];
	      const localAudioSource = this._addAudioStream(localStream);
	      const remoteAudioSource = this._addAudioStream(remoteStream);

	      pc.removeStream(remoteStream);
	      pc.removeStream(localStream);
	      if (this.mergeDestination) {
	        pc.addStream(this.mergeDestination.stream);
	      }

	      return pc.createOffer(this._getRtcOptions(false)).then(offer => {
	        this.audioStreams[session.id] = { localAudioSource, remoteAudioSource };

	        pc.setLocalDescription(offer);
	      });
	    };

	    if (session.local_hold && !isFirefox) {
	      this.unhold(session);

	      // When call is hold we lost the current track. Wait for another one.
	      return sdh.once('addTrack', e => bindStreams(e.streams[0]));
	    }

	    return bindStreams(pc.getRemoteStreams()[0]);
	  }

	  removeFromMerge(session                         , shouldHold          = true) {
	    const sdh = session.sessionDescriptionHandler;
	    const pc = sdh.peerConnection;
	    const { localAudioSource, remoteAudioSource } = this.audioStreams[session.id];

	    remoteAudioSource.disconnect(this.mergeDestination);
	    localAudioSource.disconnect(this.mergeDestination);

	    if (this.audioContext) {
	      const newDestination = this.audioContext.createMediaStreamDestination();
	      localAudioSource.connect(newDestination);
	      remoteAudioSource.connect(newDestination);

	      if (pc.signalingState === 'closed' || pc.iceConnectionState === 'closed') {
	        return null;
	      }

	      if (this.mergeDestination) {
	        pc.removeStream(this.mergeDestination.stream);
	      }
	      pc.addStream(newDestination.stream);
	    }

	    delete this.audioStreams[session.id];

	    return pc.createOffer(this._getRtcOptions(false)).then(offer => {
	      const result = pc.setLocalDescription(offer);

	      if (shouldHold) {
	        this.hold(session);
	      }

	      return result;
	    });
	  }

	  unmerge(sessions                                )                   {
	    const nbSessions = sessions.length;

	    const promises = sessions.map((session, i) => this.removeFromMerge(session, i < nbSessions - 1));

	    return new Promise((resolve, reject) => {
	      Promise.all(promises)
	        .then(() => {
	          this.mergeDestination = null;
	          resolve(true);
	        })
	        .catch(reject);
	    });
	  }

	  getState() {
	    return states[this.userAgent.state];
	  }

	  getContactIdentifier() {
	    return this.userAgent ? `${this.userAgent.configuration.contactName}/${this.userAgent.contact.uri}` : null;
	  }

	  close() {
	    this._cleanupMedia();

	    (Object.values(this.audioElements)     ).forEach((audioElement                  ) => {
	      // eslint-disable-next-line
	      audioElement.srcObject = null;
	      audioElement.pause();
	    });

	    this.audioElements = {};

	    this.userAgent.transport.disconnect();

	    return this.userAgent.stop();
	  }

	  changeAudioOutputDevice(id        ) {
	    Object.values(this.audioElements).forEach(audioElement => {
	      // `setSinkId` method is not included in any flow type definitions for HTMLAudioElements but is a valid method
	      // audioElement is an array of HTMLAudioElements, and HTMLAudioElement inherits the method from HTMLMediaElement
	      // https://developer.mozilla.org/en-US/docs/Web/API/HTMLAudioElement
	      // https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/setSinkId

	      // $FlowFixMe
	      if (audioElement.setSinkId) {
	        audioElement.setSinkId(id);
	      }
	    });
	  }

	  changeAudioInputDevice(id        ) {
	    this.audio = id ? { deviceId: { exact: id } } : true;
	    if (this.userAgent) {
	      this.userAgent.transport.disconnect();
	      this.userAgent.stop();
	    }
	    this.userAgent = this.createUserAgent();
	  }

	  changeVideoInputDevice(id        ) {
	    this.video = id ? { deviceId: { exact: id } } : true;
	    if (this.userAgent) {
	      this.userAgent.transport.disconnect();
	      this.userAgent.stop();
	    }
	    this.userAgent = this.createUserAgent();
	  }

	  changeVideo(enabled         ) {
	    this.videoEnabled = enabled;
	  }

	  _checkMaxMergeSessions(nbSessions        ) {
	    if (nbSessions < MAX_MERGE_SESSIONS) {
	      return;
	    }

	    console.warn(
	      `Merging more than ${MAX_MERGE_SESSIONS} session is not recommended, it will consume too many resources.`,
	    );
	  }

	  _fixLocalDescription(context                         , direction        ) {
	    const eventName = direction === 'answer' ? 'iceGatheringComplete' : 'iceCandidate';
	    context.on(
	      'SessionDescriptionHandler-created',
	      once(sdh => {
	        sdh.on(
	          eventName,
	          once(() => {
	            const pc = sdh.peerConnection;
	            const constraints = this._getRtcOptions(this._hasVideo());
	            pc.createOffer(constraints).then(offer => pc.setLocalDescription(offer));
	          }),
	        );
	      }),
	    );
	  }

	  _isWeb() {
	    return typeof window === 'object' && typeof document === 'object';
	  }

	  _hasAudio() {
	    return this.hasAudio;
	  }

	  _getAudioConstraints() {
	    return this.audio && this.audio.deviceId && this.audio.deviceId.exact ? this.audio : true;
	  }

	  _getVideoConstraints() {
	    if (!this.videoEnabled) {
	      return false;
	    }
	    return this.video && this.video.deviceId && this.video.deviceId.exact ? this.video : true;
	  }

	  _hasVideo() {
	    return this.videoEnabled;
	  }

	  sessionHasLocalVideo(sessionId        )          {
	    const streams = this.videoSessions[sessionId];
	    if (!streams || !streams.local) {
	      return false;
	    }
	    return !!streams.local.getVideoTracks().length;
	  }

	  sessionHasRemoteVideo(sessionId        )          {
	    const streams = this.videoSessions[sessionId];
	    if (!streams || !streams.remotes) {
	      return false;
	    }
	    return streams.remotes.some(remote => !!remote.getVideoTracks().length);
	  }

	  sessionHasVideo(sessionId        ) {
	    return this.sessionHasLocalVideo(sessionId) || this.sessionHasRemoteVideo(sessionId);
	  }

	  sessionHasAudio(session                               ) {
	    const pc = session.sessionDescriptionHandler.peerConnection;

	    if (pc.getSenders) {
	      const senders = pc.getSenders();

	      return senders.some(sender => sender.track && sender.track.kind === 'audio' && sender.track.enabled);
	    }

	    const localStreams = pc.getLocalStreams();

	    return localStreams.some(stream => {
	      const audioTracks = stream.getAudioTracks();
	      return audioTracks.some(track => track.kind === 'audio' && track.enabled);
	    });
	  }

	  getRemoteVideoStreamsForSession(sessionId        ) {
	    const streams = this.videoSessions[sessionId];
	    if (!streams || !streams.remotes) {
	      return [];
	    }
	    return streams.remotes;
	  }

	  reinit(cb           = () => {}) {
	    this.userAgent = this.createUserAgent();
	    this.registered = false;

	    this._tryToRegister(cb);
	  }

	  _initializeVideoSession(sessionId        ) {
	    if (!this.videoSessions[sessionId]) {
	      this.videoSessions[sessionId] = {
	        local: null,
	        remotes: [],
	      };
	    }
	  }

	  _buildConfig(config              , session          )                        {
	    // If no session provided, return the configuration directly
	    if (!session) {
	      return new Promise(resolve => resolve(config));
	    }

	    const client = new ApiClient({ server: config.host });

	    return client.confd.getUserLineSipFromToken(session.token, session.uuid).then(sipLine => ({
	      authorizationUser: sipLine.username,
	      password: sipLine.secret,
	      uri: `${sipLine.username}@${config.host}`,
	      ...config,
	    }));
	  }

	  _addLocalToVideoSession(sessionId        , stream     ) {
	    this._initializeVideoSession(sessionId);

	    this.videoSessions[sessionId].local = stream;
	  }

	  _addRemoteToVideoSession(sessionId        , stream     ) {
	    this._initializeVideoSession(sessionId);

	    this.videoSessions[sessionId].remotes.push(stream);
	  }

	  _hasLocalVideo() {
	    return !!this.localVideo;
	  }

	  _createWebRTCConfiguration() {
	    const config         = {
	      authorizationUser: this.config.authorizationUser,
	      displayName: this.config.displayName,
	      hackIpInContact: true,
	      hackWssInTransport: true,
	      log: this.config.log || { builtinEnabled: false },
	      password: this.config.password,
	      uri: `${this.config.authorizationUser || ''}@${this.config.host}`,
	      transportOptions: {
	        traceSip: false,
	        wsServers: `wss://${this.config.host}:${this.config.port || 443}/api/asterisk/ws`,
	      },
	      sessionDescriptionHandlerFactoryOptions: {
	        constraints: {
	          audio: this._getAudioConstraints(),
	          video: this._getVideoConstraints(),
	        },
	        peerConnectionOptions: {
	          iceCheckingTimeout: this.config.iceCheckingTimeout || 5000,
	          rtcConfiguration: {
	            rtcpMuxPolicy: 'require',
	            bundlePolicy: 'max-compat',
	            iceServers: WebRTCClient.getIceServers(this.config.host),
	            ...this._getRtcOptions(this.videoEnabled),
	          },
	        },
	      },
	    };

	    // Use custom SessionDescription handler for mobile
	    if (!this._isWeb()) {
	      config.sessionDescriptionHandlerFactory = MobileSessionDescriptionHandler(SIPMethods).defaultFactory;
	      config.registerOptions = {
	        extraContactHeaderParams: ['mobility=mobile'],
	      };
	    }

	    return config;
	  }

	  // eslint-disable-next-line no-unused-vars
	  _getRtcOptions(enableVideo         ) {
	    return {
	      mandatory: {
	        OfferToReceiveAudio: this._hasAudio(),
	        OfferToReceiveVideo: enableVideo,
	      },
	    };
	  }

	  _getMediaConfiguration(enableVideo         ) {
	    return {
	      sessionDescriptionHandlerOptions: {
	        constraints: {
	          audio: this._getAudioConstraints(),
	          video: this._getVideoConstraints(),
	        },
	        disableVideo: !enableVideo,
	        RTCOfferOptions: {
	          OfferToReceiveAudio: this._hasAudio(),
	          OfferToReceiveVideo: enableVideo,
	          mandatory: {
	            OfferToReceiveAudio: this._hasAudio(),
	            OfferToReceiveVideo: enableVideo,
	          },
	        },
	      },
	    };
	  }

	  _setupSession(session                               ) {
	    session.on('accepted', () => this._onAccepted(session));

	    session.on('terminated', () => {
	      if ('stop' in session) {
	        session.stop();
	      }

	      if (session.id in this.audioStreams) {
	        this.removeFromMerge(session);
	      }
	    });

	    session.on('SessionDescriptionHandler-created', sdh => {
	      sdh.on('userMedia', stream => {
	        // eslint-disable-next-line
	        session.stop = () => {
	          stream.getAudioTracks().forEach(track => {
	            track.stop();
	          });
	        };
	      });
	    });
	  }

	  _onAccepted(session                               ) {
	    this._setupLocalMedia(session);
	    this._setupRemoteMedia(session);

	    session.sessionDescriptionHandler.on('addTrack', () => {
	      this._setupRemoteMedia(session);
	    });

	    session.sessionDescriptionHandler.on('addStream', () => {
	      this._setupRemoteMedia(session);
	    });

	    this.eventEmitter.emit('accepted', session);
	  }

	  _setupRemoteMedia(session                               ) {
	    // If there is a video track, it will attach the video and audio to the same element
	    const pc = session.sessionDescriptionHandler.peerConnection;
	    let remoteStream;

	    if (pc.getReceivers) {
	      remoteStream = typeof global !== 'undefined' ? new global.window.MediaStream() : new window.MediaStream();
	      pc.getReceivers().forEach(receiver => {
	        const { track } = receiver;
	        if (track) {
	          remoteStream.addTrack(track);
	        }
	      });
	    } else {
	      [remoteStream] = pc.getRemoteStreams();
	    }

	    if (this._hasVideo() && this._isWeb()) {
	      this._addRemoteToVideoSession(session.id, remoteStream);
	    } else if (this._hasAudio() && this._isWeb()) {
	      const audio = this.audioElements[session.id];
	      audio.srcObject = remoteStream;
	      audio.play();
	    }
	  }

	  _addAudioStream(mediaStream             ) {
	    if (!this.audioContext) {
	      return null;
	    }
	    const audioSource = this.audioContext.createMediaStreamSource(mediaStream);
	    if (this.mergeDestination) {
	      audioSource.connect(this.mergeDestination);
	    }

	    return audioSource;
	  }

	  _setupLocalMedia(session                               ) {
	    // Safari hack, because you cannot call .play() from a non user action
	    if (this._hasAudio() && this._isWeb()) {
	      const audio      = document.createElement('audio');

	      if (audio.setSinkId && this.audioOutputDeviceId) {
	        audio.setSinkId(this.audioOutputDeviceId);
	      }

	      if (document.body) {
	        document.body.appendChild(audio);
	      }
	      this.audioElements[session.id] = audio;
	    }

	    if (!this._hasVideo()) {
	      return;
	    }

	    const pc = session.sessionDescriptionHandler.peerConnection;
	    let localStream;

	    if (pc.getSenders) {
	      localStream = typeof global !== 'undefined' ? new global.window.MediaStream() : new window.MediaStream();
	      pc.getSenders().forEach(sender => {
	        const { track } = sender;
	        if (track && track.kind === 'video') {
	          localStream.addTrack(track);
	        }
	      });
	    } else {
	      [localStream] = pc.getLocalStreams();
	    }

	    if (this._isWeb() && this._hasVideo()) {
	      this._addLocalToVideoSession(session.id, localStream);
	    }
	  }

	  _cleanupMedia(session                                ) {
	    if (session && session.id in this.videoSessions) {
	      delete this.videoSessions[session.id];
	    }

	    const cleanAudio = id => {
	      const element = this.audioElements[id];

	      element.pause();
	      if (element.parentNode) {
	        element.parentNode.removeChild(element);
	      }
	      element.srcObject = null;

	      delete this.audioElements[id];
	    };

	    if (this._hasAudio() && this._isWeb()) {
	      if (session) {
	        cleanAudio(session.id);
	      } else {
	        Object.keys(this.audioElements).forEach(sessionId => cleanAudio(sessionId));
	      }
	    }
	  }

	  _toggleAudio(session                               , muteAudio         ) {
	    const pc = session.sessionDescriptionHandler.peerConnection;

	    if (pc.getSenders) {
	      pc.getSenders().forEach(sender => {
	        if (sender.track && sender.track.kind === 'audio') {
	          // eslint-disable-next-line
	          sender.track.enabled = !muteAudio;
	        }
	      });
	    } else {
	      pc.getLocalStreams().forEach(stream => {
	        stream.getAudioTracks().forEach(track => {
	          // eslint-disable-next-line
	          track.enabled = !muteAudio;
	        });
	      });
	    }
	  }

	  _toggleVideo(session                               , muteCamera         ) {
	    const pc = session.sessionDescriptionHandler.peerConnection;

	    if (pc.getSenders) {
	      pc.getSenders().forEach(sender => {
	        if (sender.track && sender.track.kind === 'video') {
	          // eslint-disable-next-line
	          sender.track.enabled = !muteCamera;
	        }
	      });
	    } else {
	      pc.getLocalStreams().forEach(stream => {
	        stream.getVideoTracks().forEach(track => {
	          // eslint-disable-next-line
	          track.enabled = !muteCamera;
	        });
	      });
	    }
	  }

	  _bindRegistrationEvents(userAgent    ) {
	    const onDisconnected = () => {
	      this.registered = false;
	      this.registerTries = 0;
	      this._tryToRegister();
	    };

	    userAgent.on('registered', () => {
	      this.registered = true;
	    });

	    userAgent.transport.on('disconnected', onDisconnected);
	    userAgent.on('unregistered', onDisconnected);
	  }

	  _tryToRegister(cb           = () => {}) {
	    if (this.registered || this.registerTries >= MAX_REGISTER_TRY) {
	      if (this.registerTimeout) {
	        clearTimeout(this.registerTimeout);
	      }
	      cb(this.registerTries >= MAX_REGISTER_TRY);
	      return;
	    }

	    this.registerTimeout = setTimeout(() => {
	      this.register();
	      this.registerTries++;
	      this._tryToRegister(cb);
	    }, 500 * this.registerTries);
	  }
	}

	//      
	// import WebSocketClient, { SOCKET_EVENTS } from './websocket-client';
	// import Emitter from './utils/Emitter';
	//
	// // Domain
	// import BadResponse from './domain/BadResponse';
	// import ServerError from './domain/ServerError';
	// import Call from './domain/Call';
	// import CallLog from './domain/CallLog';
	// import ChatMessage from './domain/ChatMessage';
	// import ChatRoom from './domain/ChatRoom';
	// import Contact from './domain/Contact';
	// import COUNTRIES from './domain/Country';
	// import ForwardOption, { FORWARD_KEYS } from './domain/ForwardOption';
	// import Line from './domain/Line';
	// import NotificationOptions from './domain/NotificationOptions';
	// import Profile, { PRESENCE, STATE as PROFILE_STATE, LINE_STATE } from './domain/Profile';
	// import Session from './domain/Session';
	// import Voicemail from './domain/Voicemail';
	// import type {
	//   NewContact as NewContactType,
	//   ContactResponse as ContactResponseType,
	//   ContactsResponse as ContactsResponseType,
	//   ContactPersonalResponse as ContactPersonalResponseType,
	//   ContactMobileResponse as ContactMobileResponseType,
	// } from './domain/Contact';
	// import type { Phone as PhoneType, PhoneEventCallbacks as PhoneEventCallbacksType } from './domain/Phone/Phone';
	// import type { ChatUser as ChatUserType } from './domain/ChatMessage';
	// import DebugPhone from './domain/Phone/DebugPhone';
	// import type { Device as DeviceType } from './domain/Device/Device';
	// import DebugDevice from './domain/Device/DebugDevice';
	// import {
	//   PhoneNumberUtil,
	//   PhoneNumberFormat,
	//   AsYouTypeFormatter,
	//   getDisplayableNumber,
	//   getCallableNumber,
	// } from './utils/PhoneNumberUtil';
	// import type {
	//   DirectorySource as DirectorySourceType,
	//   DirectorySources as DirectorySourcesType,
	// } from './domain/DirectorySource';
	// import type { ConferenceParticipant as ConferenceParticipantType } from './api/calld';

	// export type NewContact = NewContactType;
	// export type ContactResponse = ContactResponseType;
	// export type ContactsResponse = ContactsResponseType;
	// export type ContactPersonalResponse = ContactPersonalResponseType;
	// export type ContactMobileResponse = ContactMobileResponseType;
	// export type Phone = PhoneType;
	// export type PhoneEventCallbacks = PhoneEventCallbacksType;
	// export type Device = DeviceType;
	// export type ChatUser = ChatUserType;
	// export type Source = DirectorySourceType;
	// export type Sources = DirectorySourcesType;
	// export type ConferenceParticipant = ConferenceParticipantType;

	var index = {
	  // Emitter,
	  // PhoneNumberUtil,
	  // PhoneNumberFormat,
	  // AsYouTypeFormatter,
	  // getDisplayableNumber,
	  // getCallableNumber,
	  // SIP,
	  // WazoApiClient: ApiClient,
	  WazoWebRTCClient: WebRTCClient,
	  // WazoWebSocketClient: WebSocketClient,
	  // BadResponse,
	  // ServerError,
	  // Call,
	  // CallLog,
	  // ChatMessage,
	  // ChatRoom,
	  // Contact,
	  // COUNTRIES,
	  // ForwardOption,
	  // Line,
	  // NotificationOptions,
	  // Profile,
	  // Session,
	  // Voicemail,
	  // DebugPhone,
	  // DebugDevice,
	  // PRESENCE,
	  // PROFILE_STATE,
	  // FORWARD_KEYS,
	  // LINE_STATE,
	  // SOCKET_EVENTS,
	};

	return index;

}));
//# sourceMappingURL=wazo-sdk.js.map
