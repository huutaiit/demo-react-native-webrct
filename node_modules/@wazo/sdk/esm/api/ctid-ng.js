import { Base64 } from 'js-base64';
import moment from 'moment';

/*       */

class BadResponse extends Error {
  static fromResponse(error        , status        ) {
    return new BadResponse(error.message, status, error.timestamp, error.error_id, error.details);
  }

  static fromText(response        , status        ) {
    return new BadResponse(response, status);
  }

                  
                 
                     
                   
                   

  constructor(
    message        ,
    status        ,
    timestamp          = null,
    errorId          = null,
    details          = null,
  ) {
    super(message);

    this.timestamp = timestamp;
    this.status = status;
    this.errorId = errorId;
    this.details = details;
  }
}

/*       */

class ServerError extends BadResponse {
  static fromResponse(error        , status        ) {
    return new ServerError(error.message, status, error.timestamp, error.error_id, error.details);
  }

  static fromText(response        , status        ) {
    return new ServerError(response, status);
  }
}

/*       */

class Logger {
  static hasDebug() {
    return typeof process !== 'undefined' && (+process.env.DEBUG === 1 || process.env.DEBUG === 'true');
  }

  static logRequest(url        , { method, body, headers }        , response        ) {
    if (!Logger.hasDebug()) {
      return;
    }

    const { status } = response;

    let curl = `${status} - curl ${method !== 'get' ? `-X ${method.toUpperCase()}` : ''}`;
    Object.keys(headers).forEach(headerName => {
      curl += ` -H '${headerName}: ${headers[headerName]}'`;
    });

    curl += ` ${url}`;

    if (body) {
      curl += ` -d '${body}'`;
    }

    console.info(curl);
  }
}

/*       */
/* global navigator */
const isMobile = () => typeof navigator !== 'undefined' && navigator.product === 'ReactNative';

/*       */
                                             

                          
                 
                 
                    
                                 
  

const methods = ['head', 'get', 'post', 'put', 'delete'];

// Use a function here to be able to mock it in tests
const realFetch = () => {
  if (typeof document !== 'undefined') {
    // Browser
    return window.fetch;
  }

  if (isMobile()) {
    // React native
    return fetch;
  }

  // nodejs
  // this package is disable for react-native in package.json because it requires nodejs modules
  return require('node-fetch/lib/index');
};

class ApiRequester {
                 
                 
                    
                
                  
                                 

                 
                
                 
                
                   

  // eslint-disable-next-line
  static successResponseParser(response        , isJson         ) {
    return response.status === 204;
  }

  static defaultParser(response        ) {
    return response.json().then((data        ) => data);
  }

  static getQueryString(obj        )         {
    return Object.keys(obj)
      .filter(key => obj[key])
      .map(key => `${key}=${encodeURIComponent(obj[key])}`)
      .join('&');
  }

  static base64Encode(str        )         {
    return typeof btoa !== 'undefined' ? btoa(str) : Base64.encode(str);
  }

  // @see https://github.com/facebook/flow/issues/183#issuecomment-358607052
  constructor({ server, refreshTokenCallback, clientId, agent = null }                   ) {
    this.server = server;
    this.agent = agent;
    this.clientId = clientId;
    this.refreshTokenCallback = refreshTokenCallback;

    methods.forEach(method => {
      // $FlowFixMe
      ApiRequester.prototype[method] = function sugar(...args) {
        // Add method in arguments passed to `call`
        args.splice(1, 0, method);

        return this.call.call(this, ...args);
      };
    });
  }

  setTenant(tenant         ) {
    this.tenant = tenant;
  }

  call(
    path        ,
    method         = 'get',
    body          = null,
    headers                    = null,
    parse           = ApiRequester.defaultParser,
    firstCall          = true,
  )               {
    const url = this.computeUrl(method, path, body);
    const newHeaders = this.getHeaders(headers);
    let newBody = method === 'get' ? null : body;
    if (newBody && newHeaders['Content-Type'] === 'application/json') {
      newBody = JSON.stringify(newBody);
    }
    const isHead = method === 'head';
    const hasEmptyResponse = method === 'delete' || isHead;
    const newParse = hasEmptyResponse ? ApiRequester.successResponseParser : parse;
    const options = {
      method,
      body: newBody,
      headers: this.getHeaders(headers),
      agent: this.agent,
    };

    return realFetch()(url, options).then(response => {
      const contentType = response.headers.get('content-type') || '';
      const isJson = contentType.indexOf('application/json') !== -1;

      Logger.logRequest(url, options, response);

      // Throw an error only if status >= 400
      if ((isHead && response.status >= 500) || (!isHead && response.status >= 400)) {
        const promise = isJson ? response.json() : response.text();
        const exceptionClass = response.status >= 500 ? ServerError : BadResponse;

        return promise.then(async err => {
          // Check if the token is still valid
          if (firstCall && this._checkTokenExpired(response, err)) {
            // Replay the call after refreshing the token
            return this._replayWithNewToken(err, path, method, body, headers, parse);
          }

          throw typeof err === 'string'
            ? exceptionClass.fromText(err, response.status)
            : exceptionClass.fromResponse(err, response.status);
        });
      }

      return newParse(response, isJson);
    });
  }

  _checkTokenExpired(response        , err        ) {
    // Special case when authenticating form a token: we got a 404
    const isTokenNotFound = response.status === 404 && this._isTokenNotFound(err);

    return response.status === 401 || isTokenNotFound;
  }

  _isTokenNotFound(err        ) {
    return err.reason && err.reason[0] === 'No such token';
  }

  _replayWithNewToken(
    err        ,
    path        ,
    method        ,
    body          = null,
    headers                    = null,
    parse          ,
  ) {
    const isTokenNotFound = this._isTokenNotFound(err);
    let newPath = path;

    return this.refreshTokenCallback().then(() => {
      if (isTokenNotFound) {
        const pathParts = path.split('/');
        pathParts.pop();
        pathParts.push(this.token);
        newPath = pathParts.join('/');
      }

      return this.call(newPath, method, body, headers, parse, false);
    });
  }

  getHeaders(header                  )         {
    if (header instanceof Object) {
      return header;
    }

    return {
      'X-Auth-Token': this.token,
      ...(this.tenant ? { 'Wazo-Tenant': this.tenant } : null),
      Accept: 'application/json',
      'Content-Type': 'application/json',
    };
  }

  computeUrl(method        , path        , body         )         {
    const url = `${this.baseUrl}/${path}`;

    return method === 'get' && body && Object.keys(body).length ? `${url}?${ApiRequester.getQueryString(body)}` : url;
  }

  get baseUrl()         {
    return `https://${this.server}/api`;
  }
}

//      

                                  
                             
                    
                         
                         
                         
                  
  

                            
                         
                          
                          
  

class Relocation {
                                             

                        

                        

                        

  static parse(response                    ) {
    return new Relocation({
      initiatorCall: response.initiator_call,
      recipientCall: response.recipient_call,
      relocatedCall: response.relocated_call,
    });
  }

  constructor({ relocatedCall, initiatorCall, recipientCall }                     ) {
    this.initiatorCall = initiatorCall || '';
    this.relocatedCall = relocatedCall || '';
    this.recipientCall = recipientCall || '';
  }
}

Relocation.MIN_ENGINE_VERSION_REQUIRED = '19.09';

//      

var newFrom = (instance     , ToClass     ) => {
  const args = {};
  Object.getOwnPropertyNames(instance).forEach(prop => {
    args[prop] = instance[prop];
  });

  return new ToClass(args);
};

//      

                        
                      
               
                    
  

                                       
                
  

                                   
                
                  
                     
                      
                    
               
                    
                                 
  

                                       
                   
                
                                    
  

class ChatMessage {
               

               
                  
             
                
                   
                    
                

  static parseMany(plain                         )                     {
    return plain.items.map(item => ChatMessage.parse(item));
  }

  static parse(plain                     )              {
    return new ChatMessage({
      uuid: plain.uuid,
      date: moment(plain.created_at).toDate(),
      content: plain.content,
      alias: plain.alias,
      userUuid: plain.user_uuid,
      read: true,
      roomUuid: plain.room ? plain.room.uuid : null,
    });
  }

  static newFrom(message             ) {
    return newFrom(message, ChatMessage);
  }

  constructor({ uuid, date, content, userUuid, alias, roomUuid, read }         = {}) {
    this.uuid = uuid;
    this.date = date;
    this.content = content;
    this.userUuid = userUuid;
    this.alias = alias;
    this.roomUuid = roomUuid;

    // @TODO: change after message read status available
    this.read = read;

    // Useful to compare instead of instanceof with minified code
    this.type = 'ChatMessage';
  }

  is(other             ) {
    return this.uuid === other.uuid;
  }

  isIncoming(userUuid        ) {
    return this.userUuid !== userUuid;
  }

  acknowledge() {
    // @TODO: change after message read status available
    this.read = true;
    return this;
  }
}

//      

                        
                         
                        
                   
             
                  
                    
  

                 
             
               
                 
                  
               
                 
                 
                                     
     
  

                           
             
             
                   
           
                 
                   
    
                    
  

class Voicemail {
               

             
             
                   
                   
           
                 
                   
    

  static parse(plain                 )            {
    return new Voicemail({
      id: plain.id,
      date: moment(plain.timestamp * 1000).toDate(),
      duration: plain.duration * 1000,
      caller: {
        name: plain.caller_id_name,
        number: plain.caller_id_num,
      },
      unread: plain.folder ? plain.folder.type === 'new' : null,
    });
  }

  static parseMany(plain          )                   {
    const plainUnread = plain.folders.filter(folder => folder.type === 'new')[0].messages;
    const plainRead = plain.folders.filter(folder => folder.type === 'old')[0].messages;

    const unread = plainUnread.map(message => Voicemail.parse(message)).map(voicemail => voicemail.makeAsUnRead());
    const read = plainRead.map(message => Voicemail.parse(message)).map(voicemail => voicemail.acknowledge());

    return [...unread, ...read];
  }

  static newFrom(profile           ) {
    return newFrom(profile, Voicemail);
  }

  constructor({ id, date, duration, caller, unread }                     = {}) {
    this.id = id;
    this.date = date;
    this.duration = duration;
    this.caller = caller;
    this.unread = unread;

    // Useful to compare instead of instanceof with minified code
    this.type = 'Voicemail';
  }

  is(other           )          {
    return other && this.id === other.id;
  }

  acknowledge() {
    this.unread = false;

    return this;
  }

  makeAsUnRead() {
    this.unread = true;

    return this;
  }

  contains(query        )          {
    if (!query) {
      return true;
    }

    return this.caller.name.toUpperCase().includes(query.toUpperCase()) || this.caller.number.includes(query);
  }
}

//      

                     
                  
                      
                         
                           
                              
                                
                           
                 
                     
                        
                   
  

                      
             
                    
                    
                     
                       
                     
                       
                          
                  
                 
                     
  

class Call {
               

             
                    
                     
                       
                     
                       
                          
                    
                  
                 
                     

  static parseMany(plain                     )              {
    return plain.map((plainCall              ) => Call.parse(plainCall));
  }

  static parse(plain              )       {
    return new Call({
      id: plain.call_id,
      sipCallId: plain.sip_call_id,
      callerName: plain.caller_id_name,
      callerNumber: plain.caller_id_number,
      calleeName: plain.peer_caller_id_name,
      calleeNumber: plain.peer_caller_id_number,
      dialedExtension: plain.dialed_extension,
      isCaller: plain.is_caller,
      onHold: plain.on_hold,
      status: plain.status,
      startingTime: moment(plain.creation_time).toDate(),
    });
  }

  static newFrom(call      ) {
    return newFrom(call, Call);
  }

  constructor({
    id,
    sipCallId,
    callerName,
    callerNumber,
    calleeName,
    calleeNumber,
    dialedExtension,
    isCaller,
    onHold,
    status,
    startingTime,
  }                = {}) {
    this.id = id;
    this.sipCallId = sipCallId;
    this.callerName = callerName;
    this.callerNumber = callerNumber;
    this.calleeName = calleeName;
    this.calleeNumber = calleeNumber;
    this.dialedExtension = dialedExtension;
    this.onHold = onHold;
    this.isCaller = isCaller;
    this.status = status;
    this.startingTime = startingTime;

    // Useful to compare instead of instanceof with minified code
    this.type = 'Call';
  }

  getElapsedTimeInSeconds()         {
    const now = Date.now();
    return (now - this.startingTime) / 1000;
  }

  separateCalleeName()                                          {
    const names = this.calleeName.split(' ');
    const firstName = names[0];
    const lastName = names.slice(1).join(' ');

    return { firstName, lastName };
  }

  is(other       )          {
    return !!other && this.id === other.id;
  }

  hasACalleeName()          {
    return this.calleeName.length > 0;
  }

  hasNumber(number        )          {
    return this.calleeNumber === number;
  }

  isUp()          {
    return this.status === 'Up';
  }

  isDown()          {
    return this.status === 'Down';
  }

  isRinging()          {
    return this.isRingingIncoming() || this.isRingingOutgoing();
  }

  isRingingIncoming()          {
    return this.status === 'Ringing';
  }

  isRingingOutgoing()          {
    return this.status === 'Ring';
  }

  isFromTransfer()          {
    return this.status === 'Down' || this.status === 'Ringing';
  }

  isOnHold()          {
    return this.onHold;
  }

  putOnHold()       {
    this.onHold = true;
  }

  resume()       {
    this.onHold = false;
  }
}

/*       */

                  
                       
                    
                   
  

var ctidNg = (client              , baseUrl        ) => ({
  updatePresence: (presence        )                   =>
    client.put(`${baseUrl}/users/me/presences`, { presence }, null, ApiRequester.successResponseParser),

  listMessages: (participantUuid       , limit         )                              => {
    const query         = {};

    if (participantUuid) {
      query.participant_user_uuid = participantUuid;
    }

    if (limit) {
      query.limit = limit;
    }

    return client.get(`${baseUrl}/users/me/chats`, query).then(ChatMessage.parseMany);
  },

  sendMessage: (alias        , msg        , toUserId        ) => {
    const body = { alias, msg, to: toUserId };

    return client.post(`${baseUrl}/users/me/chats`, body, null, ApiRequester.successResponseParser);
  },

  makeCall: (extension        , fromMobile         , lineId         ) => {
    const query            = {
      from_mobile: fromMobile,
      extension,
    };

    if (lineId) {
      query.line_id = lineId;
    }
    return client.post(`${baseUrl}/users/me/calls`, query);
  },

  cancelCall: (callId        )                   => client.delete(`${baseUrl}/users/me/calls/${callId}`),

  listCalls: ()                       =>
    client.get(`${baseUrl}/users/me/calls`).then(response => Call.parseMany(response.items)),

  relocateCall(callId        , destination        , lineId         , contact          )                      {
    const body         = {
      completions: ['answer'],
      destination,
      initiator_call: callId,
    };

    if (lineId || contact) {
      body.location = {};
    }

    if (lineId) {
      body.location.line_id = lineId;
    }

    if (contact) {
      body.location.contact = contact;
    }

    return client.post(`${baseUrl}/users/me/relocates`, body).then(response => Relocation.parse(response));
  },

  listVoicemails: ()                                           =>
    client.get(`${baseUrl}/users/me/voicemails`, null).then(response => Voicemail.parseMany(response)),

  deleteVoicemail: (voicemailId        )                   =>
    client.delete(`${baseUrl}/users/me/voicemails/messages/${voicemailId}`, null),

  getPresence: (contactUuid      )                                                                      =>
    client.get(`${baseUrl}/users/${contactUuid}/presences`, null),

  getStatus: (lineUuid      ) => client.get(`${baseUrl}/lines/${lineUuid}/presences`, null),

  fetchSwitchboardHeldCalls: (switchboardUuid      ) =>
    client.get(`${baseUrl}/switchboards/${switchboardUuid}/calls/held`, null),

  holdSwitchboardCall: (switchboardUuid      , callId        ) =>
    client.put(
      `${baseUrl}/switchboards/${switchboardUuid}/calls/held/${callId}`,
      null,
      null,
      ApiRequester.successResponseParser,
    ),

  answerSwitchboardHeldCall: (switchboardUuid      , callId        ) =>
    client.put(`${baseUrl}/switchboards/${switchboardUuid}/calls/held/${callId}/answer`, null),

  fetchSwitchboardQueuedCalls: (switchboardUuid      ) =>
    client.get(`${baseUrl}/switchboards/${switchboardUuid}/calls/queued`, null),

  answerSwitchboardQueuedCall: (switchboardUuid      , callId        ) =>
    client.put(`${baseUrl}/switchboards/${switchboardUuid}/calls/queued/${callId}/answer`, null),

  sendFax: (extension        , fax        , callerId          = null) => {
    const headers = {
      'Content-type': 'application/pdf',
      'X-Auth-Token': client.token,
    };
    const params = ApiRequester.getQueryString({ extension, caller_id: callerId });

    return client.post(`${baseUrl}/users/me/faxes?${params}`, fax, headers);
  },
});

export default ctidNg;
