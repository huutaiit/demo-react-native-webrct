import SIP from 'sip.js';
import { Base64 } from 'js-base64';
import { jws, b64utoutf8, KEYUTIL } from 'jsrsasign';
import moment from 'moment';
import 'webrtc-adapter';
import { SessionStatus } from 'sip.js/lib/Enums';
import { UA } from 'sip.js/lib/UA';
import { Utils } from 'sip.js/lib/Utils';
import { Exceptions } from 'sip.js/lib/Exceptions';
import { Modifiers } from 'sip.js/lib/Web';
import EventEmitter from 'events';
import { SessionDescriptionHandlerObserver } from 'sip.js/lib/Web/SessionDescriptionHandlerObserver';
import ReconnectingWebSocket from 'reconnecting-websocket';
import LibPhoneNumber from 'google-libphonenumber';

/*       */

class BadResponse extends Error {
  static fromResponse(error        , status        ) {
    return new BadResponse(error.message, status, error.timestamp, error.error_id, error.details);
  }

  static fromText(response        , status        ) {
    return new BadResponse(response, status);
  }

                  
                 
                     
                   
                   

  constructor(
    message        ,
    status        ,
    timestamp          = null,
    errorId          = null,
    details          = null,
  ) {
    super(message);

    this.timestamp = timestamp;
    this.status = status;
    this.errorId = errorId;
    this.details = details;
  }
}

/*       */

class ServerError extends BadResponse {
  static fromResponse(error        , status        ) {
    return new ServerError(error.message, status, error.timestamp, error.error_id, error.details);
  }

  static fromText(response        , status        ) {
    return new ServerError(response, status);
  }
}

/*       */

class Logger {
  static hasDebug() {
    return typeof process !== 'undefined' && (+process.env.DEBUG === 1 || process.env.DEBUG === 'true');
  }

  static logRequest(url        , { method, body, headers }        , response        ) {
    if (!Logger.hasDebug()) {
      return;
    }

    const { status } = response;

    let curl = `${status} - curl ${method !== 'get' ? `-X ${method.toUpperCase()}` : ''}`;
    Object.keys(headers).forEach(headerName => {
      curl += ` -H '${headerName}: ${headers[headerName]}'`;
    });

    curl += ` ${url}`;

    if (body) {
      curl += ` -d '${body}'`;
    }

    console.info(curl);
  }
}

/*       */
/* global navigator */
const isMobile = () => typeof navigator !== 'undefined' && navigator.product === 'ReactNative';

/*       */
                                             

                          
                 
                 
                    
                                 
  

const methods = ['head', 'get', 'post', 'put', 'delete'];

// Use a function here to be able to mock it in tests
const realFetch = () => {
  if (typeof document !== 'undefined') {
    // Browser
    return window.fetch;
  }

  if (isMobile()) {
    // React native
    return fetch;
  }

  // nodejs
  // this package is disable for react-native in package.json because it requires nodejs modules
  return require('node-fetch/lib/index');
};

class ApiRequester {
                 
                 
                    
                
                  
                                 

                 
                
                 
                
                   

  // eslint-disable-next-line
  static successResponseParser(response        , isJson         ) {
    return response.status === 204;
  }

  static defaultParser(response        ) {
    return response.json().then((data        ) => data);
  }

  static getQueryString(obj        )         {
    return Object.keys(obj)
      .filter(key => obj[key])
      .map(key => `${key}=${encodeURIComponent(obj[key])}`)
      .join('&');
  }

  static base64Encode(str        )         {
    return typeof btoa !== 'undefined' ? btoa(str) : Base64.encode(str);
  }

  // @see https://github.com/facebook/flow/issues/183#issuecomment-358607052
  constructor({ server, refreshTokenCallback, clientId, agent = null }                   ) {
    this.server = server;
    this.agent = agent;
    this.clientId = clientId;
    this.refreshTokenCallback = refreshTokenCallback;

    methods.forEach(method => {
      // $FlowFixMe
      ApiRequester.prototype[method] = function sugar(...args) {
        // Add method in arguments passed to `call`
        args.splice(1, 0, method);

        return this.call.call(this, ...args);
      };
    });
  }

  setTenant(tenant         ) {
    this.tenant = tenant;
  }

  call(
    path        ,
    method         = 'get',
    body          = null,
    headers                    = null,
    parse           = ApiRequester.defaultParser,
    firstCall          = true,
  )               {
    const url = this.computeUrl(method, path, body);
    const newHeaders = this.getHeaders(headers);
    let newBody = method === 'get' ? null : body;
    if (newBody && newHeaders['Content-Type'] === 'application/json') {
      newBody = JSON.stringify(newBody);
    }
    const isHead = method === 'head';
    const hasEmptyResponse = method === 'delete' || isHead;
    const newParse = hasEmptyResponse ? ApiRequester.successResponseParser : parse;
    const options = {
      method,
      body: newBody,
      headers: this.getHeaders(headers),
      agent: this.agent,
    };

    return realFetch()(url, options).then(response => {
      const contentType = response.headers.get('content-type') || '';
      const isJson = contentType.indexOf('application/json') !== -1;

      Logger.logRequest(url, options, response);

      // Throw an error only if status >= 400
      if ((isHead && response.status >= 500) || (!isHead && response.status >= 400)) {
        const promise = isJson ? response.json() : response.text();
        const exceptionClass = response.status >= 500 ? ServerError : BadResponse;

        return promise.then(async err => {
          // Check if the token is still valid
          if (firstCall && this._checkTokenExpired(response, err)) {
            // Replay the call after refreshing the token
            return this._replayWithNewToken(err, path, method, body, headers, parse);
          }

          throw typeof err === 'string'
            ? exceptionClass.fromText(err, response.status)
            : exceptionClass.fromResponse(err, response.status);
        });
      }

      return newParse(response, isJson);
    });
  }

  _checkTokenExpired(response        , err        ) {
    // Special case when authenticating form a token: we got a 404
    const isTokenNotFound = response.status === 404 && this._isTokenNotFound(err);

    return response.status === 401 || isTokenNotFound;
  }

  _isTokenNotFound(err        ) {
    return err.reason && err.reason[0] === 'No such token';
  }

  _replayWithNewToken(
    err        ,
    path        ,
    method        ,
    body          = null,
    headers                    = null,
    parse          ,
  ) {
    const isTokenNotFound = this._isTokenNotFound(err);
    let newPath = path;

    return this.refreshTokenCallback().then(() => {
      if (isTokenNotFound) {
        const pathParts = path.split('/');
        pathParts.pop();
        pathParts.push(this.token);
        newPath = pathParts.join('/');
      }

      return this.call(newPath, method, body, headers, parse, false);
    });
  }

  getHeaders(header                  )         {
    if (header instanceof Object) {
      return header;
    }

    return {
      'X-Auth-Token': this.token,
      ...(this.tenant ? { 'Wazo-Tenant': this.tenant } : null),
      Accept: 'application/json',
      'Content-Type': 'application/json',
    };
  }

  computeUrl(method        , path        , body         )         {
    const url = `${this.baseUrl}/${path}`;

    return method === 'get' && body && Object.keys(body).length ? `${url}?${ApiRequester.getQueryString(body)}` : url;
  }

  get baseUrl()         {
    return `https://${this.server}/api`;
  }
}

//      

const swarmPublicKey  = `-----BEGIN PUBLIC KEY-----
MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAmkXOuNfY8u5xoTiIhkb8
djnbIwG/Wrz3vpo8BZir8L5e1a1nSy740qBjP7ZINBQoALDhFfmdOfJnCyEGiHuz
ZW6jbG6C3PryE3Bu6GKwqSmD6k3q4Zk27fpwYAnNl+rWhYYM563rJZBda/INyHNN
pK7M1mixWi7gNdjjXwoEXSSBx+VpYMkY6LiAB2mvHXTY9M1qI14dvgGoQISZQoKi
NMTRCg5UP2ic0Dd9nSz/XpcOxGfa+0fwIl1F7RC1tJXOqvkGGPTOV4LLfg/Yta3h
nUPX9EZZDIX6vO/0IBV1LzjSl2A1bYFYAjJfowv3i1CpvONBOClHjSY5t9Y8MH6p
BwIDAQAB
-----END PUBLIC KEY-----`;

//      

var newFrom = (instance     , ToClass     ) => {
  const args = {};
  Object.getOwnPropertyNames(instance).forEach(prop => {
    args[prop] = instance[prop];
  });

  return new ToClass(args);
};

//      

                  
                  
                
             
                                               
  

                        
             
                                              
                    
  

                     
                             
                           
                          
                               
             
  

                      
             
                               
                                   
                                 
                                
  

class Line {
               

             
                               
                                  
                                
                               

  static parse(plain              )       {
    return new Line({
      id: plain.id,
      extensions: plain.extensions,
      endpointCustom: plain.endpoint_custom || null,
      endpointSccp: plain.endpoint_sccp || null,
      endpointSip: plain.endpoint_sip || null,
    });
  }

  static newFrom(profile      ) {
    return newFrom(profile, Line);
  }

  is(line      ) {
    return this.id === line.id;
  }

  hasExtension(extension        ) {
    return this.extensions.some(ext => ext.exten === extension);
  }

  constructor({ id, extensions, endpointCustom, endpointSccp, endpointSip }                = {}) {
    this.id = id;
    this.extensions = extensions;
    this.endpointCustom = endpointCustom || null;
    this.endpointSccp = endpointSccp || null;
    this.endpointSip = endpointSip || null;

    // Useful to compare instead of instanceof with minified code
    this.type = 'Line';
  }
}

//      

                 
                      
                   
  

const FORWARD_KEYS = {
  BUSY: 'busy',
  NO_ANSWER: 'noanswer',
  UNCONDITIONAL: 'unconditional',
};

                               
                      
                   
              
  

class ForwardOption {
                      
                   
              

  static parse(plain          , key        )                {
    return new ForwardOption({
      destination: plain.destination || '',
      enabled: plain.enabled,
      key,
    });
  }

  static newFrom(profile               ) {
    return newFrom(profile, ForwardOption);
  }

  constructor({ destination, enabled, key }                         = {}) {
    this.destination = destination;
    this.enabled = enabled;
    this.key = key;
  }

  setDestination(number        )                {
    this.destination = number;

    return this;
  }

  setEnabled(enabled         )                {
    this.enabled = enabled;

    return this;
  }

  is(other               ) {
    return this.key === other.key;
  }
}

//      
                                       

                        
             
                      
                   
                 
               
               
                                
                       
                 
                 
  

                         
             
                     
                   
                 
               
               
                                
                       
                 
                 
  

class SipLine {
               

             
                     
                   
                 
               
               
                                
                       
                 
                 

  static parse(plain                 )          {
    return new SipLine({
      id: plain.id,
      tenantUuid: plain.tenant_uuid,
      username: plain.username,
      secret: plain.secret,
      type: plain.type,
      host: plain.host,
      options: plain.options,
      links: plain.links,
      trunk: plain.trunk,
      line: plain.line,
    });
  }

  static newFrom(sipLine         ) {
    return newFrom(sipLine, SipLine);
  }

  is(line         ) {
    return this.id === line.id;
  }

  isWebRtc() {
    return this.options.some(option => option[0] === 'webrtc' && option[1] === 'yes');
  }

  constructor({ id, tenantUuid, username, secret, type, host, options, links, trunk, line }                   = {}) {
    this.id = id;
    this.tenantUuid = tenantUuid;
    this.username = username;
    this.secret = secret;
    this.type = type;
    this.host = host;
    this.options = options;
    this.links = links;
    this.trunk = trunk;
    this.line = line;

    // Useful to compare instead of instanceof with minified code
    this.type = 'SipLine';
  }
}

//      

const STATE = {
  AVAILABLE: 'available',
  UNAVAILABLE: 'unavailable',
  INVISIBLE: 'invisible',
  DISCONNECTED: 'disconnected',
  AWAY: 'away',
};

const LINE_STATE = {
  AVAILABLE: 'available',
  HOLDING: 'holding',
  RINGING: 'ringing',
  TALKING: 'talking',
  UNAVAILABLE: 'unavailable',
};

                        
                                              
                    
                     
                   
                    
               
                
               
                                                                                                                    
                                      
                                    
                                   
     
             
                   
                    
                   
                
             
           
                          
                       
      
               
                          
                       
      
                    
                          
                       
      
    
                               
                             
             
          
                       
      
    
                           
               
               
                 
    
  

                         
             
                    
                   
                
                     
                            
                   
                       
                                 
                         
                 
                 
                            
               
               
                 
    
                           
  

class Profile {
             
                    
                   
                
                     
                           
                   
                       
                                 
                         
                 
                                           
                 
                            
                           

  static parse(plain                 )          {
    return new Profile({
      id: plain.uuid,
      firstName: plain.firstName || plain.firstname || '',
      lastName: plain.lastName || plain.lastname || '',
      email: plain.email,
      lines: plain.lines.map(line => Line.parse(line)),
      username: plain.username,
      mobileNumber: plain.mobile_phone_number || '',
      forwards: [
        ForwardOption.parse(plain.forwards.unconditional, FORWARD_KEYS.UNCONDITIONAL),
        ForwardOption.parse(plain.forwards.noanswer, FORWARD_KEYS.NO_ANSWER),
        ForwardOption.parse(plain.forwards.busy, FORWARD_KEYS.BUSY),
      ],
      doNotDisturb: plain.services.dnd.enabled,
      subscriptionType: plain.subscription_type,
      voicemail: plain.voicemail,
      switchboards: plain.switchboards || [],
      status: '',
    });
  }

  static newFrom(profile         ) {
    return newFrom(profile, Profile);
  }

  constructor({
    id,
    firstName,
    lastName,
    email,
    lines,
    username,
    mobileNumber,
    forwards,
    doNotDisturb,
    state,
    subscriptionType,
    voicemail,
    switchboards,
    status,
    sipLines,
  }                           = {}) {
    this.id = id;
    this.firstName = firstName;
    this.lastName = lastName;
    this.email = email;
    this.lines = lines;
    this.username = username;
    this.mobileNumber = mobileNumber;
    this.forwards = forwards;
    this.doNotDisturb = doNotDisturb;
    this.state = state;
    this.voicemail = voicemail;
    this.subscriptionType = subscriptionType;
    this.switchboards = switchboards;
    this.status = status;

    this.sipLines = sipLines || [];
  }

  static getLinesState(lines               ) {
    let result = LINE_STATE.UNAVAILABLE;

    // eslint-disable-next-line
    for (const line of lines) {
      if (line.state === LINE_STATE.RINGING) {
        result = LINE_STATE.RINGING;
        break;
      }

      if (line.state === LINE_STATE.TALKING) {
        result = LINE_STATE.TALKING;
        break;
      }

      if (line.state === LINE_STATE.AVAILABLE) {
        result = LINE_STATE.AVAILABLE;
      }
    }

    return result;
  }

  hasId(id        ) {
    return id === this.id;
  }

  setMobileNumber(number        ) {
    this.mobileNumber = number;

    return this;
  }

  setForwardOption(forwardOption               ) {
    const updatedForwardOptions = this.forwards.slice();
    const index = updatedForwardOptions.findIndex(forward => forward.is(forwardOption));
    updatedForwardOptions.splice(index, 1, forwardOption);

    this.forwards = updatedForwardOptions;

    return this;
  }

  setDoNotDisturb(enabled         ) {
    this.doNotDisturb = enabled;

    return this;
  }

  setState(state        ) {
    this.state = state;

    return this;
  }
}

//      
                                                         

const BACKEND = {
  OFFICE365: 'office365',
  PERSONAL: 'personal',
  GOOGLE: 'google',
  WAZO: 'wazo',
};

                          
                    
                   
                      
                 
                   
                      
                    
                
  

                               
                 
                  
                            
              
                    
                    
                      
                        
                      
                            
    
  

                                
                               
               
                                
                                  
  

                                       
             
                     
                    
                  
                                                     
                 
                      
                    
                   
                
                    
                     
                    
                   
                     
  

// @see: https://github.com/rt2zz/react-native-contacts#example-contact-record
                                     
                   
                  
                         
                  
                  
     
                    
                     
                     
                   
               
                       
                  
                
     
                       
                  
                   
     
                        
                        
                          
                   
                 
                  
                   
                     
                    
                  
     
             
                 
                  
                
    
  

                         
              
                
                
                  
                                                     
                      
                 
                                                   
                      
                    
                   
                
                      
                     
                 
                  
                    
                     
                   
                  
                   
                          
  

                          
                     
                
                       
                        
                             
                         
                    
                       
                   
                          
                  
                      
                                                           
                 
                  
                 
                   
                       
             
                   
                
                
                               
               
                  
                      
                
                      
                    
                         
                        
                  
                  
                  
             
                       
                     
                   
  

                     
                
                
                    
                   
                           
               
             
                        
  
                           
                  
               
             
                                                        
                                                     
  

                       
                   
             
               
                    
                        
  

const SOURCE_MOBILE = 'mobile';

class Contact {
               

              
                
                
                  
                                                     
                      
                 
                                                   
                      
                    
                   
                
                      
                     
                 
                     
                   
                  
                   
                  
                   
                         

  static merge(oldContacts                , newContacts                )                 {
    return newContacts.map(current => {
      const old = oldContacts.find(contact => contact.is(current));

      return typeof old !== 'undefined' ? current.merge(old) : current;
    });
  }

  static sortContacts(a         , b         ) {
    const aNames = a.separateName();
    const bNames = b.separateName();
    const aLastName = aNames.lastName;
    const bLastName = bNames.lastName;

    // last Name can be empty
    if (aLastName === bLastName) {
      return aNames.firstName.localeCompare(bNames.firstName);
    }

    return aLastName.localeCompare(bLastName);
  }

  static parseMany(response                  )                 {
    return response.results.map(r => Contact.parse(r, response.column_types));
  }

  static fetchNumbers(plain                 , columns                )                {
    const numberColumns = columns
      .map((e, index) => ({ index, columnName: e }))
      .filter(e => e.columnName === 'number' || e.columnName === 'callable')
      .map(e => e.index);

    return plain.column_values.filter((e, index) => numberColumns.some(i => i === index) && e !== null);
  }

  static parse(plain                 , columns                )          {
    const numbers = Contact.fetchNumbers(plain, columns);
    const email = plain.column_values[columns.indexOf('email')];

    return new Contact({
      name: plain.column_values[columns.indexOf('name')],
      number: numbers.length ? numbers[0] : '',
      numbers: numbers.map((number, i) => ({ label: i === 0 ? 'primary' : 'secondary', number })),
      favorited: plain.column_values[columns.indexOf('favorite')],
      email: email || '',
      emails: email ? [{ label: 'primary', email }] : [],
      entreprise: plain.column_values[columns.indexOf('entreprise')] || '',
      birthday: plain.column_values[columns.indexOf('birthday')] || '',
      address: plain.column_values[columns.indexOf('address')] || '',
      note: plain.column_values[columns.indexOf('note')] || '',
      endpointId: plain.relations.endpoint_id,
      personal: plain.column_values[columns.indexOf('personal')],
      source: plain.source,
      sourceId: plain.relations.source_entry_id,
      uuid: plain.relations.user_uuid,
      backend: plain.backend || '',
    });
  }

  static parseManyPersonal(results                                )                  {
    return results.map(r => Contact.parsePersonal(r));
  }

  static parsePersonal(plain                         )          {
    return new Contact({
      name: `${plain.firstName || plain.firstname || ''} ${plain.lastName || plain.lastname || ''}`,
      number: plain.number || '',
      numbers: plain.number ? [{ label: 'primary', number: plain.number }] : [],
      email: plain.email || '',
      emails: plain.email ? [{ label: 'primary', email: plain.email }] : [],
      source: 'personal',
      sourceId: plain.id,
      entreprise: plain.entreprise || '',
      birthday: plain.birthday || '',
      address: plain.address || '',
      note: plain.note || '',
      favorited: plain.favorited,
      personal: true,
      backend: plain.backend || BACKEND.PERSONAL,
    });
  }

  static parseMobile(plain                       )          {
    let address = '';
    if (plain.postalAddresses.length) {
      const postalAddress = plain.postalAddresses[0];

      address = `${postalAddress.street} ${postalAddress.city} ${postalAddress.postCode} ${postalAddress.country}`;
    }

    return new Contact({
      name: `${plain.givenName || ''} ${plain.familyName || ''}`,
      number: plain.phoneNumbers.length ? plain.phoneNumbers[0].number : '',
      numbers: plain.phoneNumbers.length ? [{ label: 'primary', number: plain.phoneNumbers[0].number }] : [],
      email: plain.emailAddresses.length ? plain.emailAddresses[0].email : '',
      emails: plain.emailAddresses.length ? [{ label: 'primary', email: plain.emailAddresses[0].email }] : [],
      source: SOURCE_MOBILE,
      sourceId: plain.recordID,
      birthday: plain.birthday ? `${plain.birthday.year}-${plain.birthday.month}-${plain.birthday.day}` : '',
      address,
      note: plain.note || '',
      favorited: false,
      personal: true,
    });
  }

  static parseManyOffice365(response                     , source                 )                 {
    return response.map(r => Contact.parseOffice365(r, source));
  }

  static parseOffice365(single                   , source                 )          {
    const emails = [];
    const numbers = [];

    if (single.emailAddresses) {
      const formattedEmails = single.emailAddresses.map(email => ({ label: 'email', email: email.address }));
      emails.push(...formattedEmails);
    }

    if (single.homePhones) {
      const formattedPhones = single.homePhones.map(phone => ({ label: 'home', number: phone }));
      numbers.push(...formattedPhones);
    }

    if (single.mobilePhone) {
      numbers.push({ label: 'mobile', number: single.mobilePhone });
    }

    return new Contact({
      sourceId: single.id,
      name: single.displayName,
      numbers,
      emails,
      source: source.name,
      backend: BACKEND.OFFICE365,
    });
  }

  static parseManyGoogle(response                  , source                 )                 {
    return response.map(r => Contact.parseGoogle(r, source));
  }

  static parseGoogle(single                , source                 )          {
    const emails = [];
    const numbers = [];

    if (single.emails) {
      const formattedEmails = single.emails.map(email => ({ label: 'email', email }));
      emails.push(...formattedEmails);
    }

    if (single.numbers) {
      const formattedPhones = single.numbers.map(phone => ({ label: 'mobile', number: phone }));
      numbers.push(...formattedPhones);
    }

    return new Contact({
      sourceId: single.id,
      name: single.name,
      numbers,
      emails,
      source: source.name,
      backend: BACKEND.GOOGLE,
    });
  }

  static parseManyWazo(response                , source                 )                 {
    return response.map(r => Contact.parseWazo(r, source));
  }

  static parseWazo(single              , source                 )          {
    const emails = [];
    const numbers = [];

    if (single.email) {
      emails.push({ label: 'email', email: single.email });
    }

    if (single.exten) {
      numbers.push({ label: 'exten', number: single.exten });
    }

    if (single.mobile_phone_number) {
      numbers.push({ label: 'mobile', number: single.mobile_phone_number });
    }

    return new Contact({
      uuid: single.uuid,
      sourceId: String(single.id),
      name: `${single.firstname} ${single.lastname}`,
      numbers,
      emails,
      source: source.name,
      backend: BACKEND.WAZO,
    });
  }

  static parseManyConference(response                      , source                 )                 {
    return response.map(r => Contact.parseConference(r, source));
  }

  static parseConference(single                    , source                 )          {
    const numbers = [];
    let firstNumber = '';

    if (single.extensions.length > 0 && single.extensions[0].exten) {
      firstNumber = single.extensions[0].exten;
      numbers.push({ label: 'exten', number: firstNumber });
    }

    return new Contact({
      sourceId: String(single.id),
      name: single.name,
      number: firstNumber,
      numbers,
      source: source.name,
      backend: 'conference',
    });
  }

  static newFrom(profile         ) {
    return newFrom(profile, Contact);
  }

  constructor({
    id,
    uuid,
    name,
    number,
    numbers,
    email,
    emails,
    source,
    sourceId,
    entreprise,
    birthday,
    address,
    note,
    state,
    lineState,
    mobile,
    status,
    endpointId,
    personal,
    favorited,
    backend,
    personalStatus,
  }                   = {}) {
    this.id = id;
    this.uuid = uuid;
    this.name = name;
    this.number = number;
    this.numbers = numbers;
    this.email = email;
    this.emails = emails;
    this.source = source;
    this.sourceId = sourceId || '';
    this.entreprise = entreprise;
    this.birthday = birthday;
    this.address = address;
    this.note = note;
    this.state = state;
    this.lineState = lineState;
    this.mobile = mobile;
    this.status = status;
    this.endpointId = endpointId;
    this.personal = personal;
    this.favorited = favorited;
    this.backend = backend;
    this.personalStatus = personalStatus || '';

    // Useful to compare instead of instanceof with minified code
    this.type = 'Contact';
  }

  setFavorite(value         ) {
    this.favorited = value;

    return this;
  }

  is(other         )          {
    const sameSourceId = !!this.sourceId && !!other.sourceId && this.sourceId === other.sourceId;
    const sameUuid = !!this.uuid && !!other.uuid && this.uuid === other.uuid;

    const hasSameId = sameSourceId || sameUuid;
    const hasSameBackend = !!this.backend && !!other.backend && this.backend === other.backend;
    const hasSameSource = !!this.source && !!other.source && this.source === other.source;

    return !!other && hasSameId && hasSameBackend && hasSameSource;
  }

  hasId(id        )          {
    return this.uuid === id;
  }

  hasNumber(number        )          {
    return this.number === number;
  }

  hasEndpointId(endpointId        )          {
    return this.endpointId === endpointId;
  }

  isAvailable()          {
    return this.state === STATE.AVAILABLE;
  }

  isAway()          {
    return this.state === STATE.AWAY;
  }

  isUnavailable()          {
    return this.state === STATE.UNAVAILABLE;
  }

  isInvisible()          {
    return this.state === STATE.INVISIBLE;
  }

  isInCall()          {
    return this.lineState === LINE_STATE.TALKING || this.lineState === LINE_STATE.HOLDING;
  }

  isRinging()          {
    return this.lineState === LINE_STATE.RINGING;
  }

  isInUseOrRinging()          {
    return this.lineState === LINE_STATE.TALKING || this.lineState === LINE_STATE.RINGING;
  }

  merge(old         )          {
    this.state = old.state;
    this.status = old.status;
    this.mobile = old.mobile;
    if (old.lineState && !this.lineState) {
      this.lineState = old.lineState;
    }

    return this;
  }

  isIntern()          {
    return !!this.uuid;
  }

  isCallable(session         )          {
    return !!this.number && !!session && !session.is(this);
  }

  isFromMobile() {
    return this.source === SOURCE_MOBILE;
  }

  isFavorite() {
    return this.favorited;
  }

  separateName()                                          {
    if (!this.name) {
      return {
        firstName: '',
        lastName: '',
      };
    }
    const names = this.name.split(/\s+/);
    const firstName = names[0];
    const lastName = names.slice(1).join(' ');

    return {
      firstName,
      lastName,
    };
  }
}

// Can't use `semver` package as Wazo version aren't in semver format

const compareVersions = (a, b) => {
  let i;
  let diff;
  const regExStrip0 = /(\.0+)+$/;
  const segmentsA = a.replace(regExStrip0, '').split('.');
  const segmentsB = b.replace(regExStrip0, '').split('.');
  const l = Math.min(segmentsA.length, segmentsB.length);

  for (i = 0; i < l; i++) {
    diff = parseInt(segmentsA[i], 10) - parseInt(segmentsB[i], 10);
    if (diff) {
      return diff;
    }
  }
  return segmentsA.length - segmentsB.length;
};

//      

const swarmKey = KEYUTIL.getKey(swarmPublicKey);
const MINIMUM_WAZO_ENGINE_VERSION_FOR_DEFAULT_CONTEXT = '19.08';

                 
         
                 
                          
                       
                        
                           
                      
                      
                    
                       
                            
                
                   
                        
                 
                         
                            
                             
                       
                                      
                     
      
    
  

                      
               
                                                  
                   
  

                         
                
                         
                        
                 
                       
                     
                  
                                        
                          
  

class Session {
                
                        
                
                      
                       
                         
                    
                  
                                       

  static parse(plain          )           {
    const token = plain.data.metadata ? plain.data.metadata.jwt : null;
    let authorizations = [];

    // Add authorizations from JWT
    if (token) {
      const isValid = jws.JWS.verifyJWT(token, swarmKey, { alg: ['RS256'], verifyAt: new Date() });
      if (isValid) {
        const decodedToken = jws.JWS.readSafeJSONString(b64utoutf8(token.split('.')[1]));
        authorizations = decodedToken ? decodedToken.authorizations : [];
      }
    }

    return new Session({
      token: plain.data.token,
      refreshToken: plain.data.refresh_token || null,
      uuid: plain.data.metadata ? plain.data.metadata.uuid : null,
      sessionUuid: plain.data.session_uuid,
      authorizations,
      tenantUuid: plain.data.metadata ? plain.data.metadata.tenant_uuid : undefined,
      expiresAt: new Date(`${plain.data.utc_expires_at}z`),
    });
  }

  static newFrom(profile         ) {
    return newFrom(profile, Session);
  }

  constructor({
    token,
    uuid,
    tenantUuid,
    profile,
    expiresAt,
    authorizations,
    engineVersion,
    refreshToken,
    sessionUuid,
  }                   = {}) {
    this.token = token;
    this.uuid = uuid;
    this.tenantUuid = tenantUuid || null;
    this.profile = profile;
    this.expiresAt = expiresAt;
    this.authorizations = authorizations || [];
    this.engineVersion = engineVersion;
    this.refreshToken = refreshToken;
    this.sessionUuid = sessionUuid;
  }

  hasExpired(date       = new Date())          {
    return date >= this.expiresAt;
  }

  is(contact         )          {
    return Boolean(contact) && this.uuid === contact.uuid;
  }

  using(profile         )          {
    this.profile = profile;

    return this;
  }

  hasAuthorizations() {
    return this.authorizations && !!this.authorizations.length;
  }

  displayName()         {
    return this.profile ? `${this.profile.firstName} ${this.profile.lastName}` : '';
  }

  hasAccessToVoicemail()          {
    if (!this.profile) {
      return false;
    }
    return !!this.profile.voicemail;
  }

  primaryLine()        {
    return this.profile && this.profile.lines.length > 0 ? this.profile.lines[0] : null;
  }

  primarySipLine()           {
    return this.profile && this.profile.sipLines.length > 0 ? this.profile.sipLines[0] : null;
  }

  primaryWebRtcLine()           {
    return this.profile && this.profile.sipLines.find(sipLine => sipLine.isWebRtc());
  }

  primaryCtiLine()           {
    return this.profile && this.profile.sipLines.find(sipLine => !sipLine.isWebRtc());
  }

  primaryContext()         {
    if (this.engineVersion) {
      if (this.hasEngineVersionGte(MINIMUM_WAZO_ENGINE_VERSION_FOR_DEFAULT_CONTEXT)) {
        return 'default';
      }
    }

    const line = this.primaryLine();

    return line && line.extensions.length > 0 ? line.extensions[0].context : 'default';
  }

  hasEngineVersionGte(version        ) {
    return this.engineVersion && compareVersions(String(this.engineVersion), String(version)) >= 0;
  }

  primaryNumber()          {
    const line = this.primaryLine();

    return line ? line.extensions[0].exten : null;
  }

  allLines()         {
    return this.profile ? this.profile.lines || [] : [];
  }

  allNumbers()           {
    const extensions = this.allLines().map(line => line.extensions.map(extension => extension.exten));
    if (!extensions.length) {
      return [];
    }

    return extensions.reduce((a, b) => a.concat(b));
  }

  hasExtension(extension        )          {
    return this.allNumbers().some(number => number === extension);
  }
}

/*       */

const DEFAULT_BACKEND_USER = 'wazo_user';
const DETAULT_EXPIRATION = 3600;

var authMethods = (client              , baseUrl        ) => ({
  checkToken: (token       )                   => client.head(`${baseUrl}/token/${token}`, null, {}),

  authenticate: (token       )                    =>
    client.get(`${baseUrl}/token/${token}`, null, {}).then(response => Session.parse(response)),

  logIn(params   
                     
                     
                    
                       
                     
   )                    {
    const body         = {
      backend: params.backend || DEFAULT_BACKEND_USER,
      expiration: params.expiration || DETAULT_EXPIRATION,
    };
    const headers         = {
      Authorization: `Basic ${ApiRequester.base64Encode(`${params.username}:${params.password}`)}`,
      'Content-Type': 'application/json',
    };

    if (client.clientId) {
      body.access_type = 'offline';
      body.client_id = client.clientId;
    }

    if (params.mobile) {
      headers['Wazo-Session-Type'] = 'mobile';
    }

    return client.post(`${baseUrl}/token`, body, headers).then(response => Session.parse(response));
  },

  logOut: (token       )                          =>
    client.delete(`${baseUrl}/token/${token}`, null, {}, ApiRequester.successResponseParser),

  refreshToken: (refreshToken        , backend        , expiration        )                    => {
    const body         = {
      backend: backend || DEFAULT_BACKEND_USER,
      expiration: expiration || DETAULT_EXPIRATION,
      refresh_token: refreshToken,
      client_id: client.clientId,
    };

    const headers         = {
      'Content-Type': 'application/json',
    };

    return client.post(`${baseUrl}/token`, body, headers, ApiRequester.defaultParser, false).then(Session.parse);
  },

  updatePassword: (userUuid      , oldPassword        , newPassword        )                   => {
    const body = {
      new_password: newPassword,
      old_password: oldPassword,
    };

    return client.put(`${baseUrl}/users/${userUuid}/password`, body, null, ApiRequester.successResponseParser);
  },

  sendDeviceToken: (userUuid      , deviceToken        , apnsToken         ) => {
    const body         = {
      token: deviceToken,
    };

    if (apnsToken) {
      body.apns_token = apnsToken;
    }

    return client.post(`${baseUrl}/users/${userUuid}/external/mobile`, body);
  },

  getPushNotificationSenderId: (userUuid      ) =>
    client.get(`${baseUrl}/users/${userUuid}/external/mobile/sender_id`, null).then(response => response.sender_id),

  /**
   * `username` or `email` should be set.
   */
  sendResetPasswordEmail: ({ username, email }                                       ) => {
    const body = {};
    if (username) {
      body.username = username;
    }
    if (email) {
      body.email = email;
    }

    return client.get(`${baseUrl}/users/password/reset`, body, {}, ApiRequester.successResponseParser);
  },

  resetPassword: (userUuid        , password        ) => {
    const body = {
      password,
    };

    return client.post(
      `${baseUrl}/users/password/reset?user_uuid=${userUuid}`,
      body,
      null,
      ApiRequester.successResponseParser,
    );
  },

  removeDeviceToken: (userUuid      ) => client.delete(`${baseUrl}/users/${userUuid}/external/mobile`),

  createUser: (
    username        ,
    password        ,
    firstname        ,
    lastname        ,
  )                               => {
    const body = {
      username,
      password,
      firstname,
      lastname,
    };

    return client.post(`${baseUrl}/users`, body);
  },

  addUserEmail: (userUuid      , email        , main          ) => {
    const body = {
      emails: [
        {
          address: email,
          main,
        },
      ],
    };

    return client.put(`${baseUrl}/users/${userUuid}/emails`, body);
  },

  addUserPolicy: (userUuid      , policyUuid      ) =>
    client.put(`${baseUrl}/users/${userUuid}/policies/${policyUuid}`),

  deleteUserPolicy: (userUuid      , policyUuid      ) =>
    client.delete(`${baseUrl}/users/${userUuid}/policies/${policyUuid}`),

  addUserGroup: (userUuid      , groupUuid      ) => client.put(`${baseUrl}/groups/${groupUuid}/users/${userUuid}`),

  listUsersGroup: (groupUuid      ) => client.get(`${baseUrl}/groups/${groupUuid}/users`),

  deleteUserGroup: (userUuid      , groupUuid      ) =>
    client.delete(`${baseUrl}/groups/${groupUuid}/users/${userUuid}`),

  getUser: (userUuid      )                           => client.get(`${baseUrl}/users/${userUuid}`),

  getUserSession: (userUuid      ) => client.get(`${baseUrl}/users/${userUuid}/sessions`),

  deleteUserSession: (userUuid      , sessionUuids      ) =>
    client.delete(`${baseUrl}/users/${userUuid}/sessions/${sessionUuids}`),

  listUsers: ()                             => client.get(`${baseUrl}/users`),

  deleteUser: (userUuid      )                                  => client.delete(`${baseUrl}/users/${userUuid}`),

  listTenants: ()                               => client.get(`${baseUrl}/tenants`),

  getTenant: (tenantUuid      )                             => client.get(`${baseUrl}/tenants/${tenantUuid}`),

  createTenant: (name        )                                 => client.post(`${baseUrl}/tenants`, { name }),

  updateTenant: (
    uuid      ,
    name        ,
    contact        ,
    phone        ,
    address               ,
  )                                 => {
    const body = {
      name,
      contact,
      phone,
      address,
    };

    return client.put(`${baseUrl}/tenants/${uuid}`, body);
  },

  deleteTenant: (uuid      )                                  => client.delete(`${baseUrl}/tenants/${uuid}`),

  createGroup: (name        ) => client.post(`${baseUrl}/groups`, { name }),

  listGroups: ()                              => client.get(`${baseUrl}/groups`),

  deleteGroup: (uuid      )                                  => client.delete(`${baseUrl}/groups/${uuid}`),

  createPolicy: (name        , description        , aclTemplates               ) => {
    const body = {
      name,
      description,
      acl_templates: aclTemplates,
    };

    client.post(`${baseUrl}/policies`, body);
  },

  listPolicies: ()                                => client.get(`${baseUrl}/policies`),

  deletePolicy: (policyUuid      )                                  =>
    client.delete(`${baseUrl}/policies/${policyUuid}`),

  getProviders: (userUuid      ) => client.get(`${baseUrl}/users/${userUuid}/external`),

  getProviderToken: (userUuid      , provider        ) =>
    client.get(`${baseUrl}/users/${userUuid}/external/${provider}`),

  getProviderAuthUrl: (userUuid      , provider        ) =>
    client.post(`${baseUrl}/users/${userUuid}/external/${provider}`, {}),

  deleteProviderToken: (userUuid      , provider        ) =>
    client.delete(`${baseUrl}/users/${userUuid}/external/${provider}`),
});

/*       */
                                                                                

var applicationMethods = (client              , baseUrl        ) => ({
  bridgeCall(
    applicationUuid        ,
    callId        ,
    context        ,
    exten        ,
    autoanswer        ,
    displayed_caller_id_number         ,
  ) {
    const url = `${baseUrl}/${applicationUuid}/nodes`;
    const body = { calls: [{ id: callId }] };

    return client
      .post(url, body, null, res => res.json().then(response => response.uuid))
      .then(nodeUuid =>
        client
          .post(`${url}/${nodeUuid}/calls`, { context, exten, autoanswer, displayed_caller_id_number })
          .then(data => ({
            nodeUuid,
            data,
          })));
  },

  answerCall: (applicationUuid        , callId        ) =>
    client.put(`${baseUrl}/${applicationUuid}/calls/${callId}/answer`, {}, null, ApiRequester.successResponseParser),

  calls: (applicationUuid        ) => client.get(`${baseUrl}/${applicationUuid}/calls`),

  hangupCall: (applicationUuid        , callId        ) =>
    client.delete(`${baseUrl}/${applicationUuid}/calls/${callId}`),

  startPlaybackCall: (applicationUuid        , callId        , language        , uri        ) =>
    client.post(`${baseUrl}/${applicationUuid}/calls/${callId}/playbacks`, { language, uri }),

  stopPlaybackCall: (applicationUuid        , playbackUuid        ) =>
    client.delete(`${baseUrl}/${applicationUuid}/playbacks/${playbackUuid}`),

  startProgressCall: (applicationUuid        , callId        ) =>
    client.put(
      `${baseUrl}/${applicationUuid}/calls/${callId}/progress/start`,
      {},
      null,
      ApiRequester.successResponseParser,
    ),

  stopProgressCall: (applicationUuid        , callId        ) =>
    client.put(
      `${baseUrl}/${applicationUuid}/calls/${callId}/progress/stop`,
      {},
      null,
      ApiRequester.successResponseParser,
    ),

  startMohCall: (applicationUuid        , callId        ) =>
    client.put(`${baseUrl}/${applicationUuid}/calls/${callId}/moh/start`, {}, null, ApiRequester.successResponseParser),

  stopMohCall: (applicationUuid        , callId        ) =>
    client.put(`${baseUrl}/${applicationUuid}/calls/${callId}/moh/stop`, {}, null, ApiRequester.successResponseParser),

  startMuteCall: (applicationUuid        , callId        ) =>
    client.put(
      `${baseUrl}/${applicationUuid}/calls/${callId}/mute/start`,
      {},
      null,
      ApiRequester.successResponseParser,
    ),

  stopMuteCall: (applicationUuid        , callId        ) =>
    client.put(`${baseUrl}/${applicationUuid}/calls/${callId}/mute/stop`, {}, null, ApiRequester.successResponseParser),

  addCallNodes: (applicationUuid        , nodeUuid        , callId        )                   =>
    client.put(
      `${baseUrl}/${applicationUuid}/nodes/${nodeUuid}/calls/${callId}`,
      {},
      null,
      ApiRequester.successResponseParser,
    ),

  addNewCallNodes: (applicationUuid        , nodeUuid        , context        , exten        , autoanswer        ) =>
    client.post(`${baseUrl}/${applicationUuid}/nodes/${nodeUuid}/calls`, { context, exten, autoanswer }),

  listCallsNodes: (applicationUuid        , nodeUuid        )                                 =>
    client.get(`${baseUrl}/${applicationUuid}/nodes/${nodeUuid}`),

  listNodes: (applicationUuid        )                             => client.get(`${baseUrl}/${applicationUuid}/nodes`),

  removeNode: (applicationUuid        , nodeUuid        ) =>
    client.delete(`${baseUrl}/${applicationUuid}/nodes/${nodeUuid}`),

  removeCallNodes: (applicationUuid        , nodeUuid        , callId        ) =>
    client.delete(`${baseUrl}/${applicationUuid}/nodes/${nodeUuid}/calls/${callId}`),
});

/*       */

var confdMethods = (client              , baseUrl        ) => ({
  listUsers: ()                                  => client.get(`${baseUrl}/users`, null),

  getUser: (userUuid        )                   => client.get(`${baseUrl}/users/${userUuid}`, null).then(Profile.parse),

  updateUser: (userUuid        , profile         )                   => {
    const body = {
      firstname: profile.firstName,
      lastname: profile.lastName,
      email: profile.email,
      mobile_phone_number: profile.mobileNumber,
    };

    return client.put(`${baseUrl}/users/${userUuid}`, body, null, ApiRequester.successResponseParser);
  },

  updateForwardOption: (userUuid        , key        , destination        , enabled         )                   => {
    const url = `${baseUrl}/users/${userUuid}/forwards/${key}`;
    return client.put(url, { destination, enabled }, null, ApiRequester.successResponseParser);
  },

  updateDoNotDisturb: (userUuid      , enabled         )                   =>
    client.put(`${baseUrl}/users/${userUuid}/services/dnd`, { enabled }, null, ApiRequester.successResponseParser),

  getUserLineSip: (userUuid        , lineId        )                   =>
    client.get(`${baseUrl}/users/${userUuid}/lines/${lineId}/associated/endpoints/sip`).then(SipLine.parse),

  getUserLinesSip(userUuid        , lineIds          )                     {
    // $FlowFixMe
    return Promise.all(lineIds.map(lineId => this.getUserLineSip(userUuid, lineId)));
  },

  getUserLineSipFromToken(userUuid        ) {
    return this.getUser(userUuid).then(user => {
      if (!user.lines.length) {
        console.warn(`No sip line for user: ${userUuid}`);
        return null;
      }
      const line = user.lines[0];

      return this.getUserLineSip(userUuid, line.id);
    });
  },

  listApplications: ()                                    => client.get(`${baseUrl}/applications?recurse=true`, null),

  getInfos: ()                                                  => client.get(`${baseUrl}/infos`, null),
});

/*       */

var accessdMethods = (client              , baseUrl        ) => ({
  listSubscriptions: () => client.get(`${baseUrl}/subscriptions`),

  createSubscription: ({ productSku, name, startDate, contractDate, autoRenew, term }        ) => {
    const body = {
      product_sku: productSku,
      name,
      start_date: startDate,
      contract_date: contractDate,
      auto_renew: autoRenew,
      term,
    };

    return client.post(`${baseUrl}/subscriptions`, body);
  },

  getSubscription: (uuid        ) => client.get(`${baseUrl}/subscriptions/${uuid}`),

  deleteSubscription: (uuid        ) => client.delete(`${baseUrl}/subscriptions/${uuid}`),

  createSubscriptionToken: () => client.post(`${baseUrl}/subscriptions/token`),

  listAuthorizations: (subscriptionUuid        ) =>
    client.get(`${baseUrl}/subscriptions/${subscriptionUuid}/authorizations`),

  getAuthorization: (subscriptionUuid        , uuid        ) =>
    client.get(`${baseUrl}/subscriptions/${subscriptionUuid}/authorizations/${uuid}`),

  deleteAuthorization: (subscriptionUuid        , uuid        ) =>
    client.delete(`${baseUrl}/subscriptions/${subscriptionUuid}/authorizations/${uuid}`),

  createAuthorization: (subscriptionUuid        , { startDate, term, service, rules, autoRenew }        ) => {
    const url = `${baseUrl}/subscriptions/${subscriptionUuid}/authorizations`;
    const body = {
      start_date: startDate,
      term,
      service,
      rules,
      auto_renew: autoRenew,
    };

    return client.post(url, body);
  },
});

//      

                                  
                             
                    
                         
                         
                         
                  
  

                            
                         
                          
                          
  

class Relocation {
                                             

                        

                        

                        

  static parse(response                    ) {
    return new Relocation({
      initiatorCall: response.initiator_call,
      recipientCall: response.recipient_call,
      relocatedCall: response.relocated_call,
    });
  }

  constructor({ relocatedCall, initiatorCall, recipientCall }                     ) {
    this.initiatorCall = initiatorCall || '';
    this.relocatedCall = relocatedCall || '';
    this.recipientCall = recipientCall || '';
  }
}

Relocation.MIN_ENGINE_VERSION_REQUIRED = '19.09';

//      

                        
                      
               
                    
  

                                       
                
  

                                   
                
                  
                     
                      
                    
               
                    
                                 
  

                                       
                   
                
                                    
  

class ChatMessage {
               

               
                  
             
                
                   
                    
                

  static parseMany(plain                         )                     {
    return plain.items.map(item => ChatMessage.parse(item));
  }

  static parse(plain                     )              {
    return new ChatMessage({
      uuid: plain.uuid,
      date: moment(plain.created_at).toDate(),
      content: plain.content,
      alias: plain.alias,
      userUuid: plain.user_uuid,
      read: true,
      roomUuid: plain.room ? plain.room.uuid : null,
    });
  }

  static newFrom(message             ) {
    return newFrom(message, ChatMessage);
  }

  constructor({ uuid, date, content, userUuid, alias, roomUuid, read }         = {}) {
    this.uuid = uuid;
    this.date = date;
    this.content = content;
    this.userUuid = userUuid;
    this.alias = alias;
    this.roomUuid = roomUuid;

    // @TODO: change after message read status available
    this.read = read;

    // Useful to compare instead of instanceof with minified code
    this.type = 'ChatMessage';
  }

  is(other             ) {
    return this.uuid === other.uuid;
  }

  isIncoming(userUuid        ) {
    return this.userUuid !== userUuid;
  }

  acknowledge() {
    // @TODO: change after message read status available
    this.read = true;
    return this;
  }
}

//      

                        
                         
                        
                   
             
                  
                    
  

                 
             
               
                 
                  
               
                 
                 
                                     
     
  

                           
             
             
                   
           
                 
                   
    
                    
  

class Voicemail {
               

             
             
                   
                   
           
                 
                   
    

  static parse(plain                 )            {
    return new Voicemail({
      id: plain.id,
      date: moment(plain.timestamp * 1000).toDate(),
      duration: plain.duration * 1000,
      caller: {
        name: plain.caller_id_name,
        number: plain.caller_id_num,
      },
      unread: plain.folder ? plain.folder.type === 'new' : null,
    });
  }

  static parseMany(plain          )                   {
    const plainUnread = plain.folders.filter(folder => folder.type === 'new')[0].messages;
    const plainRead = plain.folders.filter(folder => folder.type === 'old')[0].messages;

    const unread = plainUnread.map(message => Voicemail.parse(message)).map(voicemail => voicemail.makeAsUnRead());
    const read = plainRead.map(message => Voicemail.parse(message)).map(voicemail => voicemail.acknowledge());

    return [...unread, ...read];
  }

  static newFrom(profile           ) {
    return newFrom(profile, Voicemail);
  }

  constructor({ id, date, duration, caller, unread }                     = {}) {
    this.id = id;
    this.date = date;
    this.duration = duration;
    this.caller = caller;
    this.unread = unread;

    // Useful to compare instead of instanceof with minified code
    this.type = 'Voicemail';
  }

  is(other           )          {
    return other && this.id === other.id;
  }

  acknowledge() {
    this.unread = false;

    return this;
  }

  makeAsUnRead() {
    this.unread = true;

    return this;
  }

  contains(query        )          {
    if (!query) {
      return true;
    }

    return this.caller.name.toUpperCase().includes(query.toUpperCase()) || this.caller.number.includes(query);
  }
}

//      

                     
                  
                      
                         
                           
                              
                                
                           
                 
                     
                        
                   
  

                      
             
                    
                    
                     
                       
                     
                       
                          
                  
                 
                     
  

class Call {
               

             
                    
                     
                       
                     
                       
                          
                    
                  
                 
                     

  static parseMany(plain                     )              {
    return plain.map((plainCall              ) => Call.parse(plainCall));
  }

  static parse(plain              )       {
    return new Call({
      id: plain.call_id,
      sipCallId: plain.sip_call_id,
      callerName: plain.caller_id_name,
      callerNumber: plain.caller_id_number,
      calleeName: plain.peer_caller_id_name,
      calleeNumber: plain.peer_caller_id_number,
      dialedExtension: plain.dialed_extension,
      isCaller: plain.is_caller,
      onHold: plain.on_hold,
      status: plain.status,
      startingTime: moment(plain.creation_time).toDate(),
    });
  }

  static newFrom(call      ) {
    return newFrom(call, Call);
  }

  constructor({
    id,
    sipCallId,
    callerName,
    callerNumber,
    calleeName,
    calleeNumber,
    dialedExtension,
    isCaller,
    onHold,
    status,
    startingTime,
  }                = {}) {
    this.id = id;
    this.sipCallId = sipCallId;
    this.callerName = callerName;
    this.callerNumber = callerNumber;
    this.calleeName = calleeName;
    this.calleeNumber = calleeNumber;
    this.dialedExtension = dialedExtension;
    this.onHold = onHold;
    this.isCaller = isCaller;
    this.status = status;
    this.startingTime = startingTime;

    // Useful to compare instead of instanceof with minified code
    this.type = 'Call';
  }

  getElapsedTimeInSeconds()         {
    const now = Date.now();
    return (now - this.startingTime) / 1000;
  }

  separateCalleeName()                                          {
    const names = this.calleeName.split(' ');
    const firstName = names[0];
    const lastName = names.slice(1).join(' ');

    return { firstName, lastName };
  }

  is(other       )          {
    return !!other && this.id === other.id;
  }

  hasACalleeName()          {
    return this.calleeName.length > 0;
  }

  hasNumber(number        )          {
    return this.calleeNumber === number;
  }

  isUp()          {
    return this.status === 'Up';
  }

  isDown()          {
    return this.status === 'Down';
  }

  isRinging()          {
    return this.isRingingIncoming() || this.isRingingOutgoing();
  }

  isRingingIncoming()          {
    return this.status === 'Ringing';
  }

  isRingingOutgoing()          {
    return this.status === 'Ring';
  }

  isFromTransfer()          {
    return this.status === 'Down' || this.status === 'Ringing';
  }

  isOnHold()          {
    return this.onHold;
  }

  putOnHold()       {
    this.onHold = true;
  }

  resume()       {
    this.onHold = false;
  }
}

/*       */

                  
                       
                    
                   
  

var ctidNgMethods = (client              , baseUrl        ) => ({
  updatePresence: (presence        )                   =>
    client.put(`${baseUrl}/users/me/presences`, { presence }, null, ApiRequester.successResponseParser),

  listMessages: (participantUuid       , limit         )                              => {
    const query         = {};

    if (participantUuid) {
      query.participant_user_uuid = participantUuid;
    }

    if (limit) {
      query.limit = limit;
    }

    return client.get(`${baseUrl}/users/me/chats`, query).then(ChatMessage.parseMany);
  },

  sendMessage: (alias        , msg        , toUserId        ) => {
    const body = { alias, msg, to: toUserId };

    return client.post(`${baseUrl}/users/me/chats`, body, null, ApiRequester.successResponseParser);
  },

  makeCall: (extension        , fromMobile         , lineId         ) => {
    const query            = {
      from_mobile: fromMobile,
      extension,
    };

    if (lineId) {
      query.line_id = lineId;
    }
    return client.post(`${baseUrl}/users/me/calls`, query);
  },

  cancelCall: (callId        )                   => client.delete(`${baseUrl}/users/me/calls/${callId}`),

  listCalls: ()                       =>
    client.get(`${baseUrl}/users/me/calls`).then(response => Call.parseMany(response.items)),

  relocateCall(callId        , destination        , lineId         , contact          )                      {
    const body         = {
      completions: ['answer'],
      destination,
      initiator_call: callId,
    };

    if (lineId || contact) {
      body.location = {};
    }

    if (lineId) {
      body.location.line_id = lineId;
    }

    if (contact) {
      body.location.contact = contact;
    }

    return client.post(`${baseUrl}/users/me/relocates`, body).then(response => Relocation.parse(response));
  },

  listVoicemails: ()                                           =>
    client.get(`${baseUrl}/users/me/voicemails`, null).then(response => Voicemail.parseMany(response)),

  deleteVoicemail: (voicemailId        )                   =>
    client.delete(`${baseUrl}/users/me/voicemails/messages/${voicemailId}`, null),

  getPresence: (contactUuid      )                                                                      =>
    client.get(`${baseUrl}/users/${contactUuid}/presences`, null),

  getStatus: (lineUuid      ) => client.get(`${baseUrl}/lines/${lineUuid}/presences`, null),

  fetchSwitchboardHeldCalls: (switchboardUuid      ) =>
    client.get(`${baseUrl}/switchboards/${switchboardUuid}/calls/held`, null),

  holdSwitchboardCall: (switchboardUuid      , callId        ) =>
    client.put(
      `${baseUrl}/switchboards/${switchboardUuid}/calls/held/${callId}`,
      null,
      null,
      ApiRequester.successResponseParser,
    ),

  answerSwitchboardHeldCall: (switchboardUuid      , callId        ) =>
    client.put(`${baseUrl}/switchboards/${switchboardUuid}/calls/held/${callId}/answer`, null),

  fetchSwitchboardQueuedCalls: (switchboardUuid      ) =>
    client.get(`${baseUrl}/switchboards/${switchboardUuid}/calls/queued`, null),

  answerSwitchboardQueuedCall: (switchboardUuid      , callId        ) =>
    client.put(`${baseUrl}/switchboards/${switchboardUuid}/calls/queued/${callId}/answer`, null),

  sendFax: (extension        , fax        , callerId          = null) => {
    const headers = {
      'Content-type': 'application/pdf',
      'X-Auth-Token': client.token,
    };
    const params = ApiRequester.getQueryString({ extension, caller_id: callerId });

    return client.post(`${baseUrl}/users/me/faxes?${params}`, fax, headers);
  },
});

/*       */
                                                    
                                                                                   
                                        

const getContactPayload = (contact                      ) => ({
  email: contact.email,
  firstname: contact.firstName ? contact.firstName : '',
  lastname: contact.lastName ? contact.lastName : '',
  number: contact.phoneNumber ? contact.phoneNumber : '',
  entreprise: contact.entreprise ? contact.entreprise : '',
  birthday: contact.birthday ? contact.birthday : '',
  address: contact.address ? contact.address : '',
  note: contact.note ? contact.note : '',
});

                                 
                 
                             
                 
                  
                  
                
         

var dirdMethods = (client              , baseUrl        ) => ({
  search: (context        , term        )                          =>
    client.get(`${baseUrl}/directories/lookup/${context}`, { term }).then(Contact.parseMany),

  listPersonalContacts: (queryParams                           = null)                          =>
    client.get(`${baseUrl}/personal`, queryParams).then(response => Contact.parseManyPersonal(response.items)),

  addContact: (contact            )                   =>
    client.post(`${baseUrl}/personal`, getContactPayload(contact)).then(Contact.parsePersonal),

  editContact: (contact         )                   =>
    client
      .put(`${baseUrl}/personal/${contact.sourceId || contact.id || ''}`, getContactPayload(contact))
      .then(Contact.parsePersonal),

  deleteContact: (contactUuid      ) => client.delete(`${baseUrl}/personal/${contactUuid}`),

  listFavorites: (context        )                          =>
    client.get(`${baseUrl}/directories/favorites/${context}`).then(Contact.parseMany),

  markAsFavorite: (source        , sourceId        )                   => {
    const url = `${baseUrl}/directories/favorites/${source}/${sourceId}`;

    return client.put(url, null, null, ApiRequester.successResponseParser);
  },

  removeFavorite: (source        , sourceId        ) =>
    client.delete(`${baseUrl}/directories/favorites/${source}/${sourceId}`),

  fetchOffice365Source: (context        )                            =>
    client.get(`${baseUrl}/directories/${context}/sources`, { backend: 'office365' }),

  fetchOffice365Contacts: (source                 , queryParams                           = null)                     =>
    client
      .get(`${baseUrl}/backends/office365/sources/${source.uuid}/contacts`, queryParams)
      .then(response => Contact.parseManyOffice365(response.items, source)),

  fetchWazoSource: (context        )                   =>
    client.get(`${baseUrl}/directories/${context}/sources`, { backend: 'wazo' }),

  // Can be used with `queryParams = { uuid: uuid1, uuid2 }` to fetch multiple contacts
  fetchWazoContacts: (source                 , queryParams                           = null)                     =>
    client
      .get(`${baseUrl}/backends/wazo/sources/${source.uuid}/contacts`, queryParams)
      .then(response => Contact.parseManyWazo(response.items, source)),

  fetchGoogleSource: (context        )                   =>
    client.get(`${baseUrl}/directories/${context}/sources`, { backend: 'google' }),

  fetchGoogleContacts: (source                 , queryParams                           = null)                     =>
    client
      .get(`${baseUrl}/backends/google/sources/${source.uuid}/contacts`, queryParams)
      .then(response => Contact.parseManyGoogle(response.items, source)),

  fetchConferenceSource: (context        )                   =>
    client.get(`${baseUrl}/directories/${context}/sources`, { backend: 'conference' }),

  fetchConferenceContacts: (source                 )                     =>
    client
      .get(`${baseUrl}/backends/conference/sources/${source.uuid}/contacts`)
      .then(response => Contact.parseManyConference(response.items, source)),
});

//      

                        
                 
                    
                         
                                
                            
                   
              
             
                           
                      
                              
                
  

                 
                   
                                
                
  

                         
               
                    
                          
                        
                
                      
                 
    
           
                      
                 
    
             
                   
              
            
  

class CallLog {
               

               
                    
                         
                        
                
                      
                 
    

           
                      
                 
    

             
                   
              
            

  static merge(current                , toMerge                )                  {
    const onlyUnique = (value, index, self) => self.indexOf(value) === index;

    const allLogs                 = current.concat(toMerge);
    const onlyUniqueIds                = allLogs.map(c => c.id).filter(onlyUnique);

    return onlyUniqueIds.map(id => allLogs.find(log => log.id === id));
  }

  static parseMany(plain          )                 {
    return plain.items.map(item => CallLog.parse(item));
  }

  static parse(plain                 )          {
    return new CallLog({
      answer: moment(plain.answer).toDate(),
      answered: plain.answered,
      callDirection: plain.call_direction,
      destination: {
        extension: plain.destination_extension || plain.requested_extension,
        name: plain.destination_name || '',
      },
      source: {
        extension: plain.source_extension,
        name: plain.source_name,
      },
      id: plain.id,
      duration: (plain.duration || 0) * 1000, // duration is in seconds
      start: moment(plain.start).toDate(),
      end: moment(plain.end).toDate(),
    });
  }

  static parseNew(plain                 , session         )          {
    return new CallLog({
      answer: moment(plain.answer).toDate(),
      answered: plain.answered,
      callDirection: plain.call_direction,
      destination: {
        extension: plain.destination_extension || plain.requested_extension,
        name: plain.destination_name || '',
      },
      source: {
        extension: plain.source_extension,
        name: plain.source_name,
      },
      id: plain.id,
      duration: (plain.duration || 0) * 1000, // duration is in seconds
      start: moment(plain.start).toDate(),
      end: moment(plain.end).toDate(),
      // @TODO: FIXME add verification declined vs missed call
      newMissedCall: session && session.hasExtension(plain.destination_extension) && !plain.answered,
    });
  }

  static newFrom(profile         ) {
    return newFrom(profile, CallLog);
  }

  constructor({
    answer,
    answered,
    callDirection,
    destination,
    source,
    id,
    duration,
    start,
    end,
  }                   = {}) {
    this.answer = answer;
    this.answered = answered;
    this.callDirection = callDirection;
    this.destination = destination;
    this.source = source;
    this.id = id;
    this.duration = duration;
    this.start = start;
    this.end = end;

    // Useful to compare instead of instanceof with minified code
    this.type = 'CallLog';
  }

  isFromSameParty(other         , session         )          {
    return this.theOtherParty(session).extension === other.theOtherParty(session).extension;
  }

  theOtherParty(session         )                                      {
    if (this.callDirection === 'inbound') {
      return this.source;
    }

    if (this.callDirection === 'outbound') {
      return this.destination;
    }

    return session.hasExtension(this.source.extension) ? this.destination : this.source;
  }

  isNewMissedCall()          {
    return this.newMissedCall;
  }

  acknowledgeCall()          {
    this.newMissedCall = false;

    return this;
  }

  isAcknowledged()          {
    return this.newMissedCall;
  }

  isAnswered()          {
    return this.answered;
  }

  isOutgoing(session         )          {
    if (this.callDirection === 'internal') {
      return session.hasExtension(this.source.extension);
    }

    return this.callDirection === 'outbound';
  }

  isIncoming(session         )          {
    if (this.callDirection === 'internal') {
      return session.hasExtension(this.destination.extension);
    }

    return this.callDirection === 'inbound';
  }

  isAnOutgoingCall(session         )          {
    console.warn(`@wazo/sdk 
      CallLog.isAnOutgoingcall(session) method is obsolete.
      Please use CallLog.isOutgoing(session).
    `);

    return session.hasExtension(this.source.extension) && this.answered;
  }

  isAMissedOutgoingCall(session         )          {
    return session.hasExtension(this.source.extension) && !this.answered;
  }

  isAnIncomingCall(session         )          {
    console.warn(`@wazo/sdk
      CallLog.isAnIncomingCall(session) method is obsolete.
      Please use CallLog.isIncoming(session).
    `);

    return session.hasExtension(this.destination.extension) && this.answered;
  }

  isADeclinedCall(session         )          {
    return !this.answered && session.hasExtension(this.destination.extension);
  }
}

/*       */

var callLogdMethods = (client              , baseUrl        ) => ({
  search: (search        , limit         = 5)                          =>
    client.get(`${baseUrl}/users/me/cdr`, { search, limit }).then(CallLog.parseMany),

  listCallLogs: (offset        , limit         = 5)                          =>
    client.get(`${baseUrl}/users/me/cdr`, { offset, limit }).then(CallLog.parseMany),

  listDistinctCallLogs: (offset        , limit         = 5, distinct        )                          =>
    client.get(`${baseUrl}/users/me/cdr`, { offset, limit, distinct }).then(CallLog.parseMany),

  listCallLogsFromDate: (from      , number        )                          =>
    client.get(`${baseUrl}/users/me/cdr`, { from: from.toISOString(), number }).then(CallLog.parseMany),
});

//      

                            
               
               
                         
  

                                
                   
                
                             
  

class ChatRoom {
               

               
               
                         

  static parseMany(plain                  )                  {
    return plain.items.map(item => ChatRoom.parse(item));
  }

  static parse(plain              )           {
    return new ChatRoom({
      uuid: plain.uuid,
      name: plain.name,
      users: plain.users,
    });
  }

  static newFrom(room          ) {
    return newFrom(room, ChatRoom);
  }

  constructor({ uuid, name, users }         = {}) {
    this.uuid = uuid;
    this.name = name;
    this.users = users;

    // Useful to compare instead of instanceof with minified code
    this.type = 'ChatRoom';
  }
}

/*       */

                                
                                              
                                                     
                
                 
                    
  

                             
                   
                
                                 
  

                           
                     
                 
                 
                  
                 
                   
  

var chatdMethods = (client              , baseUrl        ) => ({
  updateState: (contactUuid      , state        )                   =>
    client.put(`${baseUrl}/users/${contactUuid}/presences`, { state }, null, ApiRequester.successResponseParser),

  updateStatus: (contactUuid      , state        , status        )                   => {
    const body = { state, status };

    return client.put(`${baseUrl}/users/${contactUuid}/presences`, body, null, ApiRequester.successResponseParser);
  },

  getState: async (contactUuid      )                  =>
    client.get(`${baseUrl}/users/${contactUuid}/presences`).then((response                  ) => response.state),

  getContactStatusInfo: async (contactUuid      )                            =>
    client.get(`${baseUrl}/users/${contactUuid}/presences`).then((response                  ) => response),

  getLineState: async (contactUuid      )                  =>
    client
      .get(`${baseUrl}/users/${contactUuid}/presences`)
      .then((response                  ) => Profile.getLinesState(response.lines)),

  getMultipleLineState: async (contactUuids             )                  =>
    client
      .get(`${baseUrl}/users/presences`, { user_uuid: contactUuids.join(',') })
      .then((response                      ) => response.items),

  getUserRooms: async ()                           => client.get(`${baseUrl}/users/me/rooms`).then(ChatRoom.parseMany),

  createRoom: async (name        , users                 )                    =>
    client.post(`${baseUrl}/users/me/rooms`, { name, users }).then(ChatRoom.parse),

  getRoomMessages: async (roomUuid        )                              =>
    client
      .get(`${baseUrl}/users/me/rooms/${roomUuid}/messages`)
      .then((response                         ) => ChatMessage.parseMany(response)),

  sendRoomMessage: async (roomUuid        , message             )                       =>
    client.post(`${baseUrl}/users/me/rooms/${roomUuid}/messages`, message).then(ChatMessage.parse),

  getMessages: async (options                    )                       =>
    client.get(`${baseUrl}/users/me/rooms/messages`, options),
});

/*       */

                  
                       
                    
                   
  

var calldMethods = (client              , baseUrl        ) => ({
  updatePresence: (presence        )                   =>
    client.put(`${baseUrl}/users/me/presences`, { presence }, null, ApiRequester.successResponseParser),

  listMessages: (participantUuid       , limit         )                              => {
    const query         = {};

    if (participantUuid) {
      query.participant_user_uuid = participantUuid;
    }

    if (limit) {
      query.limit = limit;
    }

    return client.get(`${baseUrl}/users/me/chats`, query).then(response => ChatMessage.parseMany(response));
  },

  sendMessage: (alias        , msg        , toUserId        ) => {
    const body = { alias, msg, to: toUserId };

    return client.post(`${baseUrl}/users/me/chats`, body, null, ApiRequester.successResponseParser);
  },

  makeCall: (extension        , fromMobile         , lineId         ) => {
    const query            = {
      from_mobile: fromMobile,
      extension,
    };

    if (lineId) {
      query.line_id = lineId;
    }

    return client.post(`${baseUrl}/users/me/calls`, query);
  },

  cancelCall: (callId        )                   => client.delete(`${baseUrl}/users/me/calls/${callId}`, null),

  listCalls: ()                       =>
    client.get(`${baseUrl}/users/me/calls`, null).then(response => Call.parseMany(response.items)),

  relocateCall(callId        , destination        , lineId         , contact          )                      {
    const body         = {
      completions: ['answer'],
      destination,
      initiator_call: callId,
    };

    if (lineId || contact) {
      body.location = {};
    }

    if (lineId) {
      body.location.line_id = lineId;
    }

    if (contact) {
      body.location.contact = contact;
    }

    return client.post(`${baseUrl}/users/me/relocates`, body).then(response => Relocation.parse(response));
  },

  listVoicemails: ()                                           =>
    client.get(`${baseUrl}/users/me/voicemails`).then(response => Voicemail.parseMany(response)),

  deleteVoicemail: (voicemailId        )                   =>
    client.delete(`${baseUrl}/users/me/voicemails/messages/${voicemailId}`),

  fetchSwitchboardHeldCalls: (switchboardUuid      ) =>
    client.get(`${baseUrl}/switchboards/${switchboardUuid}/calls/held`),

  holdSwitchboardCall: (switchboardUuid      , callId        ) =>
    client.put(
      `${baseUrl}/switchboards/${switchboardUuid}/calls/held/${callId}`,
      null,
      null,
      ApiRequester.successResponseParser,
    ),

  answerSwitchboardHeldCall: (switchboardUuid      , callId        ) =>
    client.put(`${baseUrl}/switchboards/${switchboardUuid}/calls/held/${callId}/answer`),

  fetchSwitchboardQueuedCalls: (switchboardUuid      ) =>
    client.get(`${baseUrl}/switchboards/${switchboardUuid}/calls/queued`),

  answerSwitchboardQueuedCall: (switchboardUuid      , callId        ) =>
    client.put(`${baseUrl}/switchboards/${switchboardUuid}/calls/queued/${callId}/answer`),

  sendFax: (extension        , fax        , callerId          = null) => {
    const headers = {
      'Content-type': 'application/pdf',
      'X-Auth-Token': client.token,
    };
    const params = ApiRequester.getQueryString({ extension, caller_id: callerId });

    return client.post(`${baseUrl}/users/me/faxes?${params}`, fax, headers);
  },

  getConferenceParticipantsAsUser: async (conferenceId        )                                  =>
    client.get(`${baseUrl}/users/me/conferences/${conferenceId}/participants`),
});

/*       */

                          
                 
                  
                    
                         
  

const AUTH_VERSION = '0.1';
const APPLICATION_VERSION = '1.0';
const CONFD_VERSION = '1.1';
const ACCESSD_VERSION = '1.0';
const CTIDNG_VERSION = '1.0';
const DIRD_VERSION = '0.1';
const CALL_LOGD_VERSION = '1.0';
const CHATD_VERSION = '1.0';
const CALLD_VERSION = '1.0';

class ApiClient {
                       
               
                      
                
                  
                 
               
                   
                
                

                        
                            
                             
                          

  // @see https://github.com/facebook/flow/issues/183#issuecomment-358607052
  constructor({ server, agent = null, refreshToken, clientId }                   ) {
    this.updateParameters({ server, agent, clientId });
    this.refreshToken = refreshToken;
  }

  initializeEndpoints()       {
    this.auth = authMethods(this.client, `auth/${AUTH_VERSION}`);
    this.application = applicationMethods(this.client, `ctid-ng/${APPLICATION_VERSION}/applications`);
    this.confd = confdMethods(this.client, `confd/${CONFD_VERSION}`);
    this.accessd = accessdMethods(this.client, `accessd/${ACCESSD_VERSION}`);
    this.ctidNg = ctidNgMethods(this.client, `ctid-ng/${CTIDNG_VERSION}`);
    this.dird = dirdMethods(this.client, `dird/${DIRD_VERSION}`);
    this.callLogd = callLogdMethods(this.client, `call-logd/${CALL_LOGD_VERSION}`);
    this.chatd = chatdMethods(this.client, `chatd/${CHATD_VERSION}`);
    this.calld = calldMethods(this.client, `calld/${CALLD_VERSION}`);
  }

  updateParameters({ server, agent, clientId }                                                       ) {
    const refreshTokenCallback = this.refreshTokenCallback.bind(this);
    this.client = new ApiRequester({ server, agent, refreshTokenCallback, clientId });

    this.initializeEndpoints();
  }

  async forceRefreshToken() {
    return this.refreshTokenCallback();
  }

  async refreshTokenCallback() {
    if (!this.refreshToken) {
      return null;
    }

    const session = await this.auth.refreshToken(this.refreshToken, this.refreshBackend, this.refreshExpiration, true);

    if (this.onRefreshToken) {
      this.onRefreshToken(session.token, session);
    }

    this.setToken(session.token);

    return session.token;
  }

  setToken(token        ) {
    this.client.token = token;
  }

  setTenant(tenant        ) {
    this.client.setTenant(tenant);
  }

  setRefreshToken(refreshToken         ) {
    this.refreshToken = refreshToken;
  }

  setClientId(clientId         ) {
    this.client.clientId = clientId;
  }

  setOnRefreshToken(onRefreshToken          ) {
    this.onRefreshToken = onRefreshToken;
  }

  setRefreshExpiration(refreshExpiration        ) {
    this.refreshExpiration = refreshExpiration;
  }

  setRefreshBackend(refreshBackend        ) {
    this.refreshBackend = refreshBackend;
  }
}

//      

class Emitter {
                             

  constructor() {
    this.eventEmitter = new EventEmitter();
  }

  on(event        , callback          ) {
    this.eventEmitter.on(event, callback);
  }

  once(event        , callback          ) {
    this.eventEmitter.once(event, callback);
  }

  off(event        , callback          ) {
    this.eventEmitter.removeListener(event, callback);
  }

  unbind() {
    this.eventEmitter.removeAllListeners();
  }
}

//      
/* eslint-disable */
// Can't use arrow function here due to `apply`
function once(func           ) {
  let ran = false;
  let memo;
  return function() {
    if (ran) return memo;
    ran = true;
    memo = func && func.apply(this, arguments);
    func = null;
    return memo;
  };
}

/* global window */
//      

global.wazoIssueReporterLogs = [];

class IssueReporter {
               
              
               
                

                           
                            
                   

  constructor() {
    this.INFO = 'info';
    this.LOG = 'log';
    this.WARN = 'warn';
    this.ERROR = 'error';

    this.consoleMethods = [this.INFO, this.LOG, this.WARN, this.ERROR];
    this.oldConsoleMethods = {};
    this.enabled = false;
  }

  init() {
    this._catchConsole();
  }

  enable() {
    this.enabled = true;
  }

  disable() {
    this.enabled = false;
  }

  log(level        , ...args     ) {
    if (!this.enabled) {
      return;
    }
    global.wazoIssueReporterLogs.push({
      level,
      date: new Date(),
      message: args.join(', '),
    });
  }

  getReport() {
    return global.wazoIssueReporterLogs
      .map(log => `${log.date.toString().substr(0, 24)} - ${log.level} - ${log.message}`)
      .join('\r\n');
  }

  getLogs() {
    return global.wazoIssueReporterLogs;
  }

  _catchConsole() {
    this.consoleMethods.forEach((methodName        ) => {
      // eslint-disable-next-line
      this.oldConsoleMethods[methodName] = console[methodName];
      window.console[methodName] = (...args) => {
        // Store message
        this.log(methodName, args.join(' '));
        // Use old console method to log it normally
        this.oldConsoleMethods[methodName].apply(null, args);
      };
    });
  }
}

var IssueReporter$1 = new IssueReporter();

/* eslint-disable */

// Avoid issue with sip.js :
// `window.addEventListener` is not a function. (In 'window.addEventListener("unload",this.unloadListener)')`
if (!window.addEventListener) {
  window.addEventListener = () => {};
  window.removeEventListener = () => {};
}

/* SessionDescriptionHandler
 * @class PeerConnection helper Class.
 * @param {SIP.Session} session
 * @param {Object} [options]
 */
var MobileSessionDescriptionHandler = SIPMethods =>
  class MobileSessionDescriptionHandler extends EventEmitter {
    /**
     * @param {SIP.Session} session
     * @param {Object} [options]
     */
    static defaultFactory(session, options) {
      const logger = session.ua.getLogger('sip.invitecontext.sessionDescriptionHandler', session.id);
      const observer = new SessionDescriptionHandlerObserver(session, options);

      return new MobileSessionDescriptionHandler(logger, observer, options);
    }

    constructor(logger, observer, options) {
      super();

      // TODO: Validate the options
      this.options = options || {};

      this.logger = logger;
      this.observer = observer;
      this.dtmfSender = null;

      this.shouldAcquireMedia = true;

      this.CONTENT_TYPE = 'application/sdp';

      this.C = {};
      this.C.DIRECTION = {
        NULL: null,
        SENDRECV: 'sendrecv',
        SENDONLY: 'sendonly',
        RECVONLY: 'recvonly',
        INACTIVE: 'inactive',
      };

      this.logger.log('SessionDescriptionHandlerOptions: ' + JSON.stringify(this.options));

      this.direction = this.C.DIRECTION.NULL;

      this.modifiers = this.options.modifiers || [];
      if (!Array.isArray(this.modifiers)) {
        this.modifiers = [this.modifiers];
      }

      var environment = global.window || global;
      this.WebRTC = {
        MediaStream: environment.MediaStream,
        getUserMedia: environment.navigator.mediaDevices.getUserMedia.bind(environment.navigator.mediaDevices),
        RTCPeerConnection: environment.RTCPeerConnection,
        RTCSessionDescription: environment.RTCSessionDescription,
      };

      this.iceGatheringDeferred = null;
      this.iceGatheringTimeout = false;
      this.iceGatheringTimer = null;

      this.initPeerConnection(this.options.peerConnectionOptions);

      this.constraints = this.checkAndDefaultConstraints(this.options.constraints);
    }

    /**
     * Destructor
     */
    close() {
      this.logger.log('closing PeerConnection');
      // have to check signalingState since this.close() gets called multiple times
      if (this.peerConnection && this.peerConnection.signalingState !== 'closed') {
        if (this.peerConnection.getSenders) {
          this.peerConnection.getSenders().forEach(function(sender) {
            if (sender.track) {
              sender.track.stop();
            }
          });
        } else {
          this.logger.warn('Using getLocalStreams which is deprecated');
          this.peerConnection.getLocalStreams().forEach(function(stream) {
            stream.getTracks().forEach(function(track) {
              track.stop();
            });
          });
        }
        if (this.peerConnection.getReceivers) {
          this.peerConnection.getReceivers().forEach(function(receiver) {
            if (receiver.track) {
              receiver.track.stop();
            }
          });
        } else {
          this.logger.warn('Using getRemoteStreams which is deprecated');
          this.peerConnection.getRemoteStreams().forEach(function(stream) {
            stream.getTracks().forEach(function(track) {
              track.stop();
            });
          });
        }
        this.resetIceGatheringComplete();
        this.peerConnection.close();
      }
    }

    /**
     * Gets the local description from the underlying media implementation
     * @param {Object} [options] Options object to be used by getDescription
     * @param {MediaStreamConstraints} [options.constraints] MediaStreamConstraints https://developer.mozilla.org/en-US/docs/Web/API/MediaStreamConstraints
     * @param {Object} [options.peerConnectionOptions] If this is set it will recreate the peer connection with the new options
     * @param {Array} [modifiers] Array with one time use description modifiers
     * @returns {Promise} Promise that resolves with the local description to be used for the session
     */
    getDescription(options, modifiers) {
      options = options || {};
      if (options.peerConnectionOptions) {
        this.initPeerConnection(options.peerConnectionOptions);
      }

      this.shouldAcquireMedia = true;

      modifiers = modifiers || [];
      if (!Array.isArray(modifiers)) {
        modifiers = [modifiers];
      }
      modifiers = modifiers.concat(this.modifiers);

      return Promise.resolve()
        .then(
          function() {
            if (this.shouldAcquireMedia) {
              return this.acquire(JSON.parse(JSON.stringify(this.constraints))).then(
                function() {
                  this.shouldAcquireMedia = false;
                }.bind(this)
              );
            }
          }.bind(this)
        )
        .then(
          function() {
            return this.createOfferOrAnswer(options.RTCOfferOptions, modifiers);
          }.bind(this)
        )
        .then(
          function(description) {
            this.emit('getDescription', description);
            return {
              body: description.sdp,
              contentType: this.CONTENT_TYPE,
            };
          }.bind(this)
        );
    }

    /**
     * Check if the Session Description Handler can handle the Content-Type described by a SIP Message
     * @param {String} contentType The content type that is in the SIP Message
     * @returns {boolean}
     */
    hasDescription(contentType) {
      return contentType === this.CONTENT_TYPE;
    }

    /**
     * The modifier that should be used when the session would like to place the call on hold
     * @param {String} [sdp] The description that will be modified
     * @returns {Promise} Promise that resolves with modified SDP
     */
    holdModifier(description) {
      if (!/a=(sendrecv|sendonly|recvonly|inactive)/.test(description.sdp)) {
        description.sdp = description.sdp.replace(/(m=[^\r]*\r\n)/g, '$1a=sendonly\r\n');
      } else {
        description.sdp = description.sdp.replace(/a=sendrecv\r\n/g, 'a=sendonly\r\n');
        description.sdp = description.sdp.replace(/a=recvonly\r\n/g, 'a=inactive\r\n');
      }
      return Promise.resolve(description);
    }

    /**
     * Set the remote description to the underlying media implementation
     * @param {String} sessionDescription The description provided by a SIP message to be set on the media implementation
     * @param {Object} [options] Options object to be used by getDescription
     * @param {MediaStreamConstraints} [options.constraints] MediaStreamConstraints https://developer.mozilla.org/en-US/docs/Web/API/MediaStreamConstraints
     * @param {Object} [options.peerConnectionOptions] If this is set it will recreate the peer connection with the new options
     * @param {Array} [modifiers] Array with one time use description modifiers
     * @returns {Promise} Promise that resolves once the description is set
     */
    setDescription(sessionDescription, options, modifiers) {
      var self = this;

      options = options || {};
      if (options.peerConnectionOptions) {
        this.initPeerConnection(options.peerConnectionOptions);
      }

      modifiers = modifiers || [];
      if (!Array.isArray(modifiers)) {
        modifiers = [modifiers];
      }
      modifiers = modifiers.concat(this.modifiers);

      var description = {
        type: this.hasOffer('local') ? 'answer' : 'offer',
        sdp: sessionDescription,
      };

      return Promise.resolve()
        .then(
          function() {
            // Media should be acquired in getDescription unless we need to do it sooner for some reason (FF61+)
            if (this.shouldAcquireMedia && this.options.alwaysAcquireMediaFirst) {
              return this.acquire(this.constraints).then(
                function() {
                  this.shouldAcquireMedia = false;
                }.bind(this)
              );
            }
          }.bind(this)
        )
        .then(function() {
          return SIPMethods.Utils.reducePromises(modifiers, description);
        })
        .catch(e => {
          if (e instanceof SIPMethods.Exceptions.SessionDescriptionHandlerError) {
            throw e;
          }
          const error = new SIPMethods.Exceptions.SessionDescriptionHandlerError(
            'setDescription',
            e,
            'The modifiers did not resolve successfully'
          );
          this.logger.error(error.message);
          self.emit('peerConnection-setRemoteDescriptionFailed', error);
          throw error;
        })
        .then(function(modifiedDescription) {
          self.emit('setDescription', modifiedDescription);

          return self.peerConnection.setRemoteDescription(new self.WebRTC.RTCSessionDescription(modifiedDescription));
        })
        .catch(e => {
          if (e instanceof SIPMethods.Exceptions.SessionDescriptionHandlerError) {
            throw e;
          }
          // Check the original SDP for video, and ensure that we have want to do audio fallback
          if (/^m=video.+$/gm.test(sessionDescription) && !options.disableAudioFallback) {
            // Do not try to audio fallback again
            options.disableAudioFallback = true;
            // Remove video first, then do the other modifiers
            return this.setDescription(
              sessionDescription,
              options,
              [SIPMethods.Web.Modifiers.stripVideo].concat(modifiers)
            );
          }
          const error = new SIPMethods.Exceptions.SessionDescriptionHandlerError('setDescription', e);
          this.logger.error(error.error);
          this.emit('peerConnection-setRemoteDescriptionFailed', error);
          throw error;
        })
        .then(function setRemoteDescriptionSuccess() {
          if (self.peerConnection.getReceivers) {
            self.emit('setRemoteDescription', self.peerConnection.getReceivers());
          } else {
            self.emit('setRemoteDescription', self.peerConnection.getRemoteStreams());
          }
          self.emit('confirmed', self);
        });
    }

    /**
     * Send DTMF via RTP (RFC 4733)
     * @param {String} tones A string containing DTMF digits
     * @param {Object} [options] Options object to be used by sendDtmf
     * @returns {boolean} true if DTMF send is successful, false otherwise
     */
    sendDtmf(tones, options) {
      if (!this.dtmfSender && this.hasBrowserGetSenderSupport()) {
        var senders = this.peerConnection.getSenders();
        if (senders.length > 0) {
          this.dtmfSender = senders[0].dtmf;
        }
      }
      if (!this.dtmfSender && this.hasBrowserTrackSupport()) {
        var streams = this.peerConnection.getLocalStreams();
        if (streams.length > 0) {
          var audioTracks = streams[0].getAudioTracks();
          if (audioTracks.length > 0) {
            this.dtmfSender = this.peerConnection.createDTMFSender(audioTracks[0]);
          }
        }
      }
      if (!this.dtmfSender) {
        return false;
      }
      try {
        this.dtmfSender.insertDTMF(tones, options.duration, options.interToneGap);
      } catch (e) {
        if (e.type === 'InvalidStateError' || e.type === 'InvalidCharacterError') {
          this.logger.error(e);
          return false;
        } else {
          throw e;
        }
      }
      this.logger.log('DTMF sent via RTP: ' + tones.toString());
      return true;
    }

    getDirection() {
      return this.direction;
    }

    // Internal functions
    createOfferOrAnswer(RTCOfferOptions, modifiers) {
      var self = this;
      var methodName;
      var pc = this.peerConnection;

      RTCOfferOptions = RTCOfferOptions || {};

      methodName = self.hasOffer('remote') ? 'createAnswer' : 'createOffer';

      return pc[methodName](RTCOfferOptions)
        .catch(e => {
          if (e instanceof SIPMethods.Exceptions.SessionDescriptionHandlerError) {
            throw e;
          }
          const error = new SIPMethods.Exceptions.SessionDescriptionHandlerError(
            'createOfferOrAnswer',
            e,
            'peerConnection-' + methodName + 'Failed'
          );
          this.emit('peerConnection-' + methodName + 'Failed', error);
          throw error;
        })
        .then(function(sdp) {
          return SIPMethods.Utils.reducePromises(modifiers, self.createRTCSessionDescriptionInit(sdp));
        })
        .then(function(sdp) {
          self.resetIceGatheringComplete();
          return pc.setLocalDescription(new self.WebRTC.RTCSessionDescription(sdp));
        })
        .catch(e => {
          if (e instanceof SIPMethods.Exceptions.SessionDescriptionHandlerError) {
            throw e;
          }
          const error = new SIPMethods.Exceptions.SessionDescriptionHandlerError(
            'createOfferOrAnswer',
            e,
            'peerConnection-SetLocalDescriptionFailed'
          );
          this.emit('peerConnection-SetLocalDescriptionFailed', error);
          throw error;
        })
        .then(function onSetLocalDescriptionSuccess() {
          return self.waitForIceGatheringComplete();
        })
        .then(function readySuccess() {
          var localDescription = self.createRTCSessionDescriptionInit(self.peerConnection.localDescription);
          return SIPMethods.Utils.reducePromises(modifiers, localDescription);
        })
        .then(function(localDescription) {
          self.setDirection(localDescription.sdp);
          return localDescription;
        })
        .then(localDescription =>
          // @see https://github.com/oney/react-native-webrtc/issues/242#issuecomment-290452014
          // @see https://github.com/oney/RCTWebRTCDemo/blob/master/main.js#L103
          methodName === 'createOffer' && !modifiers.length ? pc[methodName](RTCOfferOptions) : localDescription
        )
        .catch(e => {
          if (e instanceof SIPMethods.Exceptions.SessionDescriptionHandlerError) {
            throw e;
          }
          const error = new SIPMethods.Exceptions.SessionDescriptionHandlerError('createOfferOrAnswer', e);
          this.logger.error(error);
          throw error;
        });
    }

    // Creates an RTCSessionDescriptionInit from an RTCSessionDescription
    createRTCSessionDescriptionInit(RTCSessionDescription) {
      return {
        type: RTCSessionDescription.type,
        sdp: RTCSessionDescription.sdp,
      };
    }

    addDefaultIceCheckingTimeout(peerConnectionOptions) {
      if (peerConnectionOptions.iceCheckingTimeout === undefined) {
        peerConnectionOptions.iceCheckingTimeout = 5000;
      }

      return peerConnectionOptions;
    }

    addDefaultIceServers(rtcConfiguration) {
      if (!rtcConfiguration.iceServers) {
        rtcConfiguration.iceServers = [{ urls: 'stun:stun.l.google.com:19302' }];
      }
      return rtcConfiguration;
    }

    checkAndDefaultConstraints(constraints) {
      let defaultConstraints = { audio: true, video: constraints.video };

      constraints = constraints || defaultConstraints;
      // Empty object check
      if (Object.keys(constraints).length === 0 && constraints.constructor === Object) {
        return defaultConstraints;
      }

      return constraints;
    }

    hasBrowserTrackSupport() {
      return Boolean(this.peerConnection.addTrack);
    }

    hasBrowserGetSenderSupport() {
      return Boolean(this.peerConnection.getSenders);
    }

    initPeerConnection(options) {
      var self = this;
      options = options || {};
      options = this.addDefaultIceCheckingTimeout(options);
      options.rtcConfiguration = options.rtcConfiguration || {};
      options.rtcConfiguration = this.addDefaultIceServers(options.rtcConfiguration);

      this.logger.log('initPeerConnection');

      if (this.peerConnection) {
        this.logger.log('Already have a peer connection for this session. Tearing down.');
        this.resetIceGatheringComplete();
        this.peerConnection.close();
      }

      this.peerConnection = new this.WebRTC.RTCPeerConnection(options.rtcConfiguration);

      this.logger.log('New peer connection created');

      if ('ontrack' in this.peerConnection) {
        this.peerConnection.addEventListener('track', function(e) {
          self.logger.log('track added');
          self.observer.trackAdded();
          self.emit('addTrack', e);
        });
      } else {
        this.logger.warn('Using onaddstream which is deprecated');
        this.peerConnection.onaddstream = function(e) {
          self.logger.log('stream added');
          self.emit('addStream', e);
        };
      }

      this.peerConnection.onicecandidate = function(e) {
        self.emit('iceCandidate', e);
        if (e.candidate) {
          self.logger.log(
            'ICE candidate received: ' + (e.candidate.candidate === null ? null : e.candidate.candidate.trim())
          );
        } else if (e.candidate === null) {
          // indicates the end of candidate gathering
          self.logger.log('ICE candidate gathering complete');
          self.triggerIceGatheringComplete();
        }
      };

      this.peerConnection.onicegatheringstatechange = function() {
        self.logger.log('RTCIceGatheringState changed: ' + this.iceGatheringState);
        switch (this.iceGatheringState) {
          case 'gathering':
            self.emit('iceGathering', this);
            if (!self.iceGatheringTimer && options.iceCheckingTimeout) {
              self.iceGatheringTimeout = false;
              self.iceGatheringTimer = setTimeout(function() {
                self.logger.log(
                  'RTCIceChecking Timeout Triggered after ' + options.iceCheckingTimeout + ' milliseconds'
                );
                self.iceGatheringTimeout = true;
                self.triggerIceGatheringComplete();
              }, options.iceCheckingTimeout);
            }
            break;
          case 'complete':
            self.triggerIceGatheringComplete();
            break;
        }
      };

      this.peerConnection.oniceconnectionstatechange = function() {
        //need e for commented out case
        var stateEvent;

        switch (this.iceConnectionState) {
          case 'new':
            stateEvent = 'iceConnection';
            break;
          case 'checking':
            stateEvent = 'iceConnectionChecking';
            break;
          case 'connected':
            stateEvent = 'iceConnectionConnected';
            break;
          case 'completed':
            stateEvent = 'iceConnectionCompleted';
            break;
          case 'failed':
            stateEvent = 'iceConnectionFailed';
            break;
          case 'disconnected':
            stateEvent = 'iceConnectionDisconnected';
            break;
          case 'closed':
            stateEvent = 'iceConnectionClosed';
            break;
          default:
            self.logger.warn('Unknown iceConnection state:', this.iceConnectionState);
            return;
        }
        self.emit(stateEvent, this);
      };
    }

    acquire(constraints) {
      // Default audio & video to true
      constraints = this.checkAndDefaultConstraints(constraints);

      return new Promise(
        function(resolve, reject) {
          /*
           * Make the call asynchronous, so that ICCs have a chance
           * to define callbacks to `userMediaRequest`
           */
          this.logger.log('acquiring local media');
          this.emit('userMediaRequest', constraints);

          if (constraints.audio || constraints.video) {
            // Avoid exception on immutable object, can't use destructuring because android crashes
            this.WebRTC.getUserMedia(JSON.parse(JSON.stringify(constraints)))
              .then(
                function(streams) {
                  this.observer.trackAdded();
                  this.emit('userMedia', streams);
                  resolve(streams);
                }.bind(this)
              )
              .catch(
                function(e) {
                  this.emit('userMediaFailed', e);
                  reject(e);
                }.bind(this)
              );
          } else {
            // Local streams were explicitly excluded.
            resolve([]);
          }
        }.bind(this)
      )
        .catch(e => {
          // TODO: This propogates downwards
          if (e instanceof SIPMethods.Exceptions.SessionDescriptionHandlerError) {
            throw e;
          }
          const error = new SIPMethods.Exceptions.SessionDescriptionHandlerError(
            'acquire',
            e,
            'unable to acquire streams'
          );
          this.logger.error(error.message);
          this.logger.error(error.error);
          throw error;
        })
        .then(
          function acquireSucceeded(streams) {
            this.logger.log('acquired local media streams');
            try {
              // Remove old tracks
              if (this.peerConnection.removeTrack) {
                this.peerConnection.getSenders().forEach(function(sender) {
                  this.peerConnection.removeTrack(sender);
                }, this);
              }
              return streams;
            } catch (e) {
              return Promise.reject(e);
            }
          }.bind(this)
        )
        .catch(e => {
          if (e instanceof SIPMethods.Exceptions.SessionDescriptionHandlerError) {
            throw e;
          }
          const error = new SIPMethods.Exceptions.SessionDescriptionHandlerError(
            'acquire',
            e,
            'error removing streams'
          );
          this.logger.error(error.message);
          this.logger.error(error.error);
          throw error;
        })
        .then(
          function addStreams(streams) {
            try {
              streams = [].concat(streams);
              streams.forEach(function(stream) {
                if (this.peerConnection.addTrack) {
                  stream.getTracks().forEach(function(track) {
                    this.peerConnection.addTrack(track, stream);
                  }, this);
                } else {
                  // Chrome 59 does not support addTrack
                  this.peerConnection.addStream(stream);
                }
              }, this);
            } catch (e) {
              return Promise.reject(e);
            }
            return Promise.resolve();
          }.bind(this)
        )
        .catch(e => {
          if (e instanceof SIPMethods.Exceptions.SessionDescriptionHandlerError) {
            throw e;
          }
          const error = new SIPMethods.Exceptions.SessionDescriptionHandlerError('acquire', e, 'error adding stream');
          this.logger.error(error.message);
          this.logger.error(error.error);
          throw error;
        });
    }

    hasOffer(where) {
      var offerState = 'have-' + where + '-offer';

      return this.peerConnection.signalingState === offerState;
    }

    // ICE gathering state handling
    isIceGatheringComplete() {
      return this.peerConnection.iceGatheringState === 'complete' || this.iceGatheringTimeout;
    }

    resetIceGatheringComplete() {
      this.iceGatheringTimeout = false;

      if (this.iceGatheringTimer) {
        clearTimeout(this.iceGatheringTimer);
        this.iceGatheringTimer = null;
      }

      if (this.iceGatheringDeferred) {
        this.iceGatheringDeferred.reject();
        this.iceGatheringDeferred = null;
      }
    }

    setDirection(sdp) {
      var match = sdp.match(/a=(sendrecv|sendonly|recvonly|inactive)/);
      if (match === null) {
        this.direction = this.C.DIRECTION.NULL;
        this.observer.directionChanged();
        return;
      }
      var direction = match[1];
      switch (direction) {
        case this.C.DIRECTION.SENDRECV:
        case this.C.DIRECTION.SENDONLY:
        case this.C.DIRECTION.RECVONLY:
        case this.C.DIRECTION.INACTIVE:
          this.direction = direction;
          break;
        default:
          this.direction = this.C.DIRECTION.NULL;
          break;
      }
      this.observer.directionChanged();
    }

    triggerIceGatheringComplete() {
      if (this.isIceGatheringComplete()) {
        this.emit('iceGatheringComplete', this);

        if (this.iceGatheringTimer) {
          clearTimeout(this.iceGatheringTimer);
          this.iceGatheringTimer = null;
        }

        if (this.iceGatheringDeferred) {
          this.iceGatheringDeferred.resolve();
          this.iceGatheringDeferred = null;
        }
      }
    }

    waitForIceGatheringComplete() {
      if (this.isIceGatheringComplete()) {
        return Promise.resolve();
      } else if (!this.isIceGatheringDeferred) {
        this.iceGatheringDeferred = SIPMethods.Utils.defer();
      }
      return this.iceGatheringDeferred.promise;
    }
  };

//      

const SIPMethods = { Web: { Modifiers }, Utils, Exceptions };

const states = ['STATUS_NULL', 'STATUS_NEW', 'STATUS_CONNECTING', 'STATUS_CONNECTED', 'STATUS_COMPLETED'];
const events = [
  'registered',
  'unregistered',
  'registrationFailed',
  'invite',
  'inviteSent',
  'transportCreated',
  'newTransaction',
  'transactionDestroyed',
  'notify',
  'outOfDialogReferRequested',
  'message',
];
const transportEvents = [
  'connected',
  'disconnected',
  'transportError',
  'message',
  'closed',
  'keepAliveDebounceTimeout',
];
const MAX_MERGE_SESSIONS = 4;

                    
                          
                          
                                
  

                     
                      
               
             
                
                             
                    
              
                     
                           
                              
               
                               
                           
  

// @see https://github.com/onsip/SIP.js/blob/master/src/Web/Simple.js
class WebRTCClient extends Emitter {
                       
                
                    
                          
                                                
                          
                        
                                 
                              
                       
                                                     
                               
                        
                                    

  static isAPrivateIp(ip        )          {
    const regex = /^(?:10|127|172\.(?:1[6-9]|2[0-9]|3[01])|192\.168)\..*/;
    return regex.exec(ip) == null;
  }

  static getIceServers(ip        )                                 {
    if (WebRTCClient.isAPrivateIp(ip)) {
      return [
        {
          urls: ['stun:stun.l.google.com:19302', 'stun:stun4.l.google.com:19302'],
        },
      ];
    }
    return [];
  }

  constructor(config              , session          ) {
    super();
    this._buildConfig(config, session).then((newConfig              ) => {
      this.config = newConfig;
      this.userAgent = this.createUserAgent();
    });

    this.audioOutputDeviceId = config.audioOutputDeviceId;

    this.configureMedia(config.media);

    this.videoSessions = {};
    this.connectionPromise = null;
  }

  configureMedia(media             ) {
    this.hasAudio = !!media.audio;
    this.video = media.video;
    this.audio = media.audio;
    this.localVideo = media.localVideo;
    this.audioContext = this._isWeb() ? new (window.AudioContext || window.webkitAudioContext)() : null;
    this.audioStreams = {};
    this.audioElements = {};
  }

  createUserAgent()     {
    const webRTCConfiguration = this._createWebRTCConfiguration();
    const userAgent = new UA(webRTCConfiguration);

    events
      .filter(eventName => eventName !== 'invite' && eventName !== 'new')
      .forEach(eventName => userAgent.on(eventName, event => this.eventEmitter.emit(eventName, event)));

    // Particular case for `invite` event
    userAgent.on('invite', (session                               ) => {
      this._setupSession(session);
      // This causes trouble with the desktop version on some engines, restrict its use to mobile
      if (isMobile()) {
        this._fixLocalDescription(session, 'answer');
      }
      const shouldAutoAnswer = !!session.request.getHeader('alert-info');

      this.eventEmitter.emit('invite', session, this.sessionWantsToDoVideo(session), shouldAutoAnswer);
    });

    transportEvents.forEach(eventName => {
      userAgent.transport.on(eventName, event => {
        this.eventEmitter.emit(eventName, event);
      });
    });

    return userAgent;
  }

  isRegistered()          {
    return this.userAgent && this.userAgent.transport.isConnected() && this.userAgent.isRegistered();
  }

  register() {
    IssueReporter$1.log(IssueReporter$1.INFO, '[WebRtcClient] register', !!this.userAgent, this.isRegistered());
    if (!this.userAgent || this.isRegistered()) {
      return;
    }

    this._connectIfNeeded().then(this.userAgent.register.bind(this.userAgent));
  }

  unregister() {
    IssueReporter$1.log(IssueReporter$1.INFO, '[WebRtcClient] unregister', !!this.userAgent);
    if (!this.userAgent) {
      return;
    }

    this.userAgent.unregister();
  }

  stop() {
    IssueReporter$1.log(IssueReporter$1.INFO, '[WebRtcClient] stop', !!this.userAgent);
    if (!this.userAgent) {
      return;
    }

    this.userAgent.stop();
  }

  // eslint-disable-next-line no-unused-vars
  sessionWantsToDoVideo(session                               ) {
    const sdp = session.request.body;
    const sessionHasVideo = /\r\nm=video /.test(sdp);

    return sessionHasVideo;
  }

  call(number        , enableVideo          )                          {
    this.changeVideo(enableVideo || false);
    const context = this.userAgent.invite(number, this._getMediaConfiguration(enableVideo || false));

    this._setupSession(context);

    return context;
  }

  answer(session                               , enableVideo          ) {
    this.changeVideo(enableVideo || false);
    return session.accept(this._getMediaConfiguration(enableVideo || false));
  }

  hangup(session                                                         ) {
    try {
      this._cleanupMedia(session);
      const { status } = session;

      if (this.getSipSessionId(session) in this.audioStreams) {
        this.removeFromMerge(session);
      }

      this._cleanupMedia(session);

      // Check if sessionDescriptionHandler or InviteServerContext (ISC = outgoing call)
      const isISC = typeof session.cancel !== 'undefined';

      const cancel = () => {
        if (!session.isCanceled) {
          session.cancel();
        }
      };

      const reject = () => {
        // eslint-disable-next-line
        if (!session._canceled) {
          session.reject();
        }
      };

      const bye = () => session.bye && session.bye();

      const actions = {
        // Status 2 (STATUS_1XX_RECEIVED) : cancel
        [SessionStatus.STATUS_1XX_RECEIVED]: isISC ? cancel : reject,
        // Status 4 (STATUS_WAITING_FOR_ANSWER) : cancel
        [SessionStatus.STATUS_WAITING_FOR_ANSWER]: isISC ? cancel : reject,
        // Status 8 (STATUS_CANCELED) : nothing to do
        [SessionStatus.STATUS_CANCELED]: null,
        // Status 9 (STATUS_TERMINATED): nothing to do
        [SessionStatus.STATUS_TERMINATED]: null,
        // Status 10 (STATUS_ANSWERED_WAITING_FOR_PRACK): bye
        [SessionStatus.STATUS_ANSWERED_WAITING_FOR_PRACK]: bye, // bye is the same for sdh ou isc
        // Status 12 (STATUS_CONFIRMED): bye
        [SessionStatus.STATUS_CONFIRMED]: bye, // bye is the same for sdh ou isc
      };

      // Handle different session status
      if (actions[status]) {
        return actions[status]();
      }

      // For InviteServerContext
      if (isISC) {
        if (session.hasAnswer && session.bye) {
          return session.bye();
        }

        // For InviteServerContext
        if (!session.hasAnswer) {
          return cancel();
        }
      }

      if ('stop' in session) {
        session.stop();
      }

      return bye();
    } catch (error) {
      console.warn('WebRtcClient.hangup error', error);
    }

    return null;
  }

  reject(session                               ) {
    return session.reject ? session.reject() : session.cancel();
  }

  getNumber(session                               )          {
    if (!session) {
      return null;
    }

    // eslint-disable-next-line
    return session.remoteIdentity.uri._normal.user;
  }

  mute(session                               ) {
    this._toggleAudio(session, true);
  }

  unmute(session                               ) {
    this._toggleAudio(session, false);
  }

  toggleCameraOn(session                               ) {
    this._toggleVideo(session, false);
  }

  toggleCameraOff(session                               ) {
    this._toggleVideo(session, true);
  }

  hold(session                               ) {
    this.mute(session);

    return session.hold(this._getMediaConfiguration(this.videoEnabled));
  }

  unhold(session                               ) {
    this.unmute(session);

    return session.unhold(this._getMediaConfiguration(this.videoEnabled));
  }

  sendDTMF(session                               , tone        ) {
    return session.dtmf(tone);
  }

  message(destination        , message        ) {
    return this.userAgent.message(destination, message);
  }

  transfer(session                               , target        ) {
    this.hold(session);

    setTimeout(() => {
      session.refer(target);
      this.hangup(session);
    }, 50);
  }

  // check https://sipjs.com/api/0.12.0/refer/referClientContext/
  atxfer(session                               ) {
    this.hold(session);

    return {
      init: (target        ) => this.call(target),
      complete: (newSession                               ) => {
        this.unhold(session);

        setTimeout(() => {
          newSession.refer(session);
          this.hangup(session);
        }, 50);
      },
      cancel: (newSession                               ) => {
        this.hangup(newSession);
        this.unhold(session);
      },
    };
  }

  merge(sessions                                )                          {
    this._checkMaxMergeSessions(sessions.length);
    if (this.audioContext) {
      this.mergeDestination = this.audioContext.createMediaStreamDestination();
    }

    if (this.audioContext && this.audioContext.state === 'suspended') {
      this.audioContext.resume();
    }

    return sessions.map(this.addToMerge.bind(this));
  }

  isFirefox()          {
    return this._isWeb() && navigator.userAgent.toLowerCase().indexOf('firefox') > -1;
  }

  addToMerge(session                         )                   {
    this._checkMaxMergeSessions(Object.keys(this.audioStreams).length + 1);

    const sdh = session.sessionDescriptionHandler;
    const pc = sdh.peerConnection;

    const bindStreams = remoteStream => {
      const localStream = this._getLocalStream(pc);
      const localAudioSource = this._addAudioStream(localStream);
      const remoteAudioSource = this._addAudioStream(remoteStream);

      if (remoteStream) {
        pc.removeStream(remoteStream);
      }
      pc.removeStream(localStream);

      if (this.mergeDestination) {
        pc.addStream(this.mergeDestination.stream);
      }

      return pc.createOffer(this._getRtcOptions(false)).then(offer => {
        this.audioStreams[this.getSipSessionId(session)] = { localAudioSource, remoteAudioSource };

        pc.setLocalDescription(offer);
      });
    };

    if (session.localHold && !this.isFirefox()) {
      this.unhold(session);

      // When call is hold we lost the current track. Wait for another one.
      return sdh.once('addTrack', e => bindStreams(e.streams[0]));
    }

    return bindStreams(this._getRemoteStream(pc));
  }

  removeFromMerge(session                         , shouldHold          = true) {
    const sdh = session.sessionDescriptionHandler;
    const pc = sdh.peerConnection;
    const { localAudioSource, remoteAudioSource } = this.audioStreams[this.getSipSessionId(session)];

    if (remoteAudioSource) {
      remoteAudioSource.disconnect(this.mergeDestination);
    }
    localAudioSource.disconnect(this.mergeDestination);

    if (this.audioContext) {
      const newDestination = this.audioContext.createMediaStreamDestination();
      localAudioSource.connect(newDestination);
      if (remoteAudioSource) {
        remoteAudioSource.connect(newDestination);
      }

      if (pc.signalingState === 'closed' || pc.iceConnectionState === 'closed') {
        return null;
      }

      if (this.mergeDestination && this.mergeDestination.stream) {
        pc.removeStream(this.mergeDestination.stream);
      }
      pc.addStream(newDestination.stream);
    }

    delete this.audioStreams[this.getSipSessionId(session)];

    return pc.createOffer(this._getRtcOptions(false)).then(offer => {
      const result = pc.setLocalDescription(offer);

      if (shouldHold) {
        this.hold(session);
      }

      return result;
    });
  }

  unmerge(sessions                                )                   {
    const nbSessions = sessions.length;

    const promises = sessions.map((session, i) => this.removeFromMerge(session, i < nbSessions - 1));

    return new Promise((resolve, reject) => {
      Promise.all(promises)
        .then(() => {
          this.mergeDestination = null;
          resolve(true);
        })
        .catch(reject);
    });
  }

  getState() {
    return states[this.userAgent.state];
  }

  getContactIdentifier() {
    return this.userAgent ? `${this.userAgent.configuration.contactName}/${this.userAgent.contact.uri}` : null;
  }

  close() {
    IssueReporter$1.log(IssueReporter$1.INFO, '[WebRtcClient] close', !!this.userAgent);
    this._cleanupMedia();

    (Object.values(this.audioElements)     ).forEach((audioElement                  ) => {
      // eslint-disable-next-line
      audioElement.srcObject = null;
      audioElement.pause();
    });

    this.audioElements = {};
    if (!this.userAgent) {
      return null;
    }

    if (this.userAgent.transport) {
      this.userAgent.transport.disconnect();
    }

    this.userAgent.removeAllListeners();

    return this.userAgent.stop();
  }

  changeAudioOutputDevice(id        ) {
    Object.values(this.audioElements).forEach(audioElement => {
      // `setSinkId` method is not included in any flow type definitions for HTMLAudioElements but is a valid method
      // audioElement is an array of HTMLAudioElements, and HTMLAudioElement inherits the method from HTMLMediaElement
      // https://developer.mozilla.org/en-US/docs/Web/API/HTMLAudioElement
      // https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/setSinkId

      // $FlowFixMe
      if (audioElement.setSinkId) {
        audioElement.setSinkId(id);
      }
    });
  }

  changeAudioInputDevice(id        , session                          ) {
    const currentId = this.getAudioDeviceId();
    if (id === currentId) {
      return;
    }

    if (session) {
      const sdh = session.sessionDescriptionHandler;
      const pc = sdh.peerConnection;

      // $FlowFixMe
      navigator.mediaDevices.getUserMedia({ audio: { deviceId: { exact: id } } }).then(async stream => {
        const audioTrack = stream.getAudioTracks()[0];
        const sender = pc.getSenders().find(s => s.track.kind === audioTrack.kind);

        sender.replaceTrack(audioTrack);
      });
    }
  }

  changeVideoInputDevice(id        , session                          ) {
    const currentId = this.getVideoDeviceId();
    if (id === currentId) {
      return;
    }

    if (session) {
      const sdh = session.sessionDescriptionHandler;
      const pc = sdh.peerConnection;

      // $FlowFixMe
      navigator.mediaDevices.getUserMedia({ video: { deviceId: { exact: id } } }).then(async stream => {
        const videoTrack = stream.getVideoTracks()[0];
        const sender = pc.getSenders().find(s => s.track.kind === videoTrack.kind);

        sender.replaceTrack(videoTrack);
      });
    }
  }

  getAudioDeviceId()          {
    // $FlowFixMe
    return this.audio && 'deviceId' in this.audio ? this.audio.deviceId.exact : null;
  }

  getVideoDeviceId()          {
    // $FlowFixMe
    return this.video && 'deviceId' in this.video ? this.video.deviceId.exact : null;
  }

  changeVideo(enabled         ) {
    this.videoEnabled = enabled;
  }

  _checkMaxMergeSessions(nbSessions        ) {
    if (nbSessions < MAX_MERGE_SESSIONS) {
      return;
    }

    console.warn(
      `Merging more than ${MAX_MERGE_SESSIONS} session is not recommended, it will consume too many resources.`,
    );
  }

  _fixLocalDescription(context                         , direction        ) {
    const eventName = direction === 'answer' ? 'iceGatheringComplete' : 'iceCandidate';
    context.on(
      'SessionDescriptionHandler-created',
      once(sdh => {
        sdh.on(
          eventName,
          once(() => {
            const pc = sdh.peerConnection;
            const constraints = this._getRtcOptions(this._hasVideo());
            pc.createOffer(constraints).then(offer => pc.setLocalDescription(offer));
          }),
        );
      }),
    );
  }

  _isWeb() {
    return typeof window === 'object' && typeof document === 'object';
  }

  _hasAudio() {
    return this.hasAudio;
  }

  _getAudioConstraints() {
    return this.audio && this.audio.deviceId && this.audio.deviceId.exact ? this.audio : true;
  }

  _getVideoConstraints() {
    if (!this.videoEnabled) {
      return false;
    }
    return this.video && this.video.deviceId && this.video.deviceId.exact ? this.video : true;
  }

  _hasVideo() {
    return this.videoEnabled;
  }

  sessionHasLocalVideo(sessionId        )          {
    const streams = this.videoSessions[sessionId];
    if (!streams || !streams.local) {
      return false;
    }
    return !!streams.local.getVideoTracks().length;
  }

  sessionHasRemoteVideo(sessionId        )          {
    const streams = this.videoSessions[sessionId];
    if (!streams || !streams.remotes) {
      return false;
    }
    return streams.remotes.some(remote => !!remote.getVideoTracks().length);
  }

  sessionHasVideo(sessionId        ) {
    return this.sessionHasLocalVideo(sessionId) || this.sessionHasRemoteVideo(sessionId);
  }

  sessionHasAudio(session                               ) {
    const pc = session.sessionDescriptionHandler.peerConnection;

    if (pc.getSenders) {
      const senders = pc.getSenders();

      return senders.some(sender => sender.track && sender.track.kind === 'audio' && sender.track.enabled);
    }

    const localStreams = this._getLocalStream(pc);

    return localStreams.some(stream => {
      const audioTracks = stream.getAudioTracks();
      return audioTracks.some(track => track.kind === 'audio' && track.enabled);
    });
  }

  getRemoteVideoStreamsForSession(sessionId        ) {
    const streams = this.videoSessions[sessionId];
    if (!streams || !streams.remotes) {
      return [];
    }
    return streams.remotes;
  }

  getSipSessionId(sipSession                                )         {
    return (sipSession && sipSession.request && sipSession.request.callId) || (sipSession && sipSession.id) || '';
  }

  _connectIfNeeded()                {
    return new Promise(resolve => {
      IssueReporter$1.log(IssueReporter$1.INFO, '[WebRtcClient][_connectIfNeeded]', this.userAgent.transport.isConnected());
      if (!this.userAgent.transport.isConnected()) {
        if (this.connectionPromise) {
          return this.connectionPromise;
        }

        IssueReporter$1.log(IssueReporter$1.INFO, '[WebRtcClient][_connectIfNeeded] connecting');
        this.connectionPromise = this.userAgent.transport
          .connectPromise()
          .then(resolve)
          .catch(error => {
            this.connectionPromise = null;
            console.warn('[WebRtcClient][_connectIfNeeded] error', error.message);
          });

        return this.connectionPromise;
      }

      return resolve();
    });
  }

  _initializeVideoSession(sessionId        ) {
    if (!this.videoSessions[sessionId]) {
      this.videoSessions[sessionId] = {
        local: null,
        remotes: [],
      };
    }
  }

  _buildConfig(config              , session          )                        {
    // If no session provided, return the configuration directly
    if (!session) {
      return new Promise(resolve => resolve(config));
    }

    const client = new ApiClient({ server: config.host });
    client.setToken(session.token);
    client.setRefreshToken(session.refreshToken);

    return client.confd.getUserLineSipFromToken(session.uuid).then(sipLine => ({
      authorizationUser: sipLine.username,
      password: sipLine.secret,
      uri: `${sipLine.username}@${config.host}`,
      ...config,
    }));
  }

  _addLocalToVideoSession(sessionId        , stream     ) {
    this._initializeVideoSession(sessionId);

    this.videoSessions[sessionId].local = stream;
  }

  _addRemoteToVideoSession(sessionId        , stream     ) {
    this._initializeVideoSession(sessionId);

    this.videoSessions[sessionId].remotes.push(stream);
  }

  _hasLocalVideo() {
    return !!this.localVideo;
  }

  _createWebRTCConfiguration() {
    const config         = {
      authorizationUser: this.config.authorizationUser,
      displayName: this.config.displayName,
      hackIpInContact: true,
      hackWssInTransport: true,
      log: this.config.log || { builtinEnabled: false },
      password: this.config.password,
      uri: `${this.config.authorizationUser || ''}@${this.config.host}`,
      userAgentString: this.config.userAgentString || 'wazo-sdk',
      transportOptions: {
        maxReconnectionAttempts: 100000,
        reconnectionTimeout: 2,
        traceSip: false,
        wsServers: `wss://${this.config.host}:${this.config.port || 443}/api/asterisk/ws`,
      },
      sessionDescriptionHandlerFactoryOptions: {
        alwaysAcquireMediaFirst: this.isFirefox(),
        constraints: {
          audio: this._getAudioConstraints(),
          video: this._getVideoConstraints(),
        },
        peerConnectionOptions: {
          iceCheckingTimeout: this.config.iceCheckingTimeout || 1000,
          rtcConfiguration: {
            rtcpMuxPolicy: 'require',
            bundlePolicy: 'max-compat',
            iceServers: WebRTCClient.getIceServers(this.config.host),
            ...this._getRtcOptions(this.videoEnabled),
          },
        },
      },
    };

    // Use custom SessionDescription handler for mobile
    if (!this._isWeb()) {
      config.sessionDescriptionHandlerFactory = MobileSessionDescriptionHandler(SIPMethods).defaultFactory;
      config.registerOptions = {
        extraContactHeaderParams: ['mobility=mobile'],
      };
    }

    return config;
  }

  // eslint-disable-next-line no-unused-vars
  _getRtcOptions(enableVideo         ) {
    return {
      mandatory: {
        OfferToReceiveAudio: this._hasAudio(),
        OfferToReceiveVideo: enableVideo,
      },
    };
  }

  _getMediaConfiguration(enableVideo         ) {
    return {
      sessionDescriptionHandlerOptions: {
        constraints: {
          audio: this._getAudioConstraints(),
          video: this._getVideoConstraints(),
        },
        disableVideo: !enableVideo,
        RTCOfferOptions: {
          OfferToReceiveAudio: this._hasAudio(),
          OfferToReceiveVideo: enableVideo,
          mandatory: {
            OfferToReceiveAudio: this._hasAudio(),
            OfferToReceiveVideo: enableVideo,
          },
        },
      },
    };
  }

  _setupSession(session                               ) {
    session.on('accepted', () => this._onAccepted(session));

    session.on('terminated', () => {
      if ('stop' in session) {
        session.stop();
      }

      if (this.getSipSessionId(session) in this.audioStreams) {
        this.removeFromMerge(session);
      }
    });

    session.on('SessionDescriptionHandler-created', sdh => {
      sdh.on('userMedia', stream => {
        // eslint-disable-next-line
        session.stop = () => {
          stream.getAudioTracks().forEach(track => {
            track.stop();
          });
        };
      });
    });
  }

  _onAccepted(session                               ) {
    this._setupLocalMedia(session);
    this._setupRemoteMedia(session);

    session.sessionDescriptionHandler.on('addTrack', () => {
      this._setupRemoteMedia(session);
    });

    session.sessionDescriptionHandler.on('addStream', () => {
      this._setupRemoteMedia(session);
    });

    this.eventEmitter.emit('accepted', session);
  }

  _setupRemoteMedia(session                               ) {
    // If there is a video track, it will attach the video and audio to the same element
    const pc = session.sessionDescriptionHandler.peerConnection;
    const remoteStream = this._getRemoteStream(pc);

    if (this._hasVideo() && this._isWeb()) {
      this._addRemoteToVideoSession(this.getSipSessionId(session), remoteStream);
    } else if (this._hasAudio() && this._isWeb()) {
      const audio = this.audioElements[this.getSipSessionId(session)];
      audio.srcObject = remoteStream;
      audio.play();
    }
  }

  _addAudioStream(mediaStream             ) {
    if (!this.audioContext || !mediaStream) {
      return null;
    }
    const audioSource = this.audioContext.createMediaStreamSource(mediaStream);
    if (this.mergeDestination) {
      audioSource.connect(this.mergeDestination);
    }

    return audioSource;
  }

  _setupLocalMedia(session                               ) {
    // Safari hack, because you cannot call .play() from a non user action
    if (this._hasAudio() && this._isWeb()) {
      const audio      = document.createElement('audio');

      if (audio.setSinkId && this.audioOutputDeviceId) {
        audio.setSinkId(this.audioOutputDeviceId);
      }

      if (document.body) {
        document.body.appendChild(audio);
      }
      this.audioElements[this.getSipSessionId(session)] = audio;
    }

    if (!this._hasVideo()) {
      return;
    }

    const pc = session.sessionDescriptionHandler.peerConnection;
    const localStream = this._getLocalStream(pc);

    if (this._isWeb() && this._hasVideo()) {
      this._addLocalToVideoSession(this.getSipSessionId(session), localStream);
    }
  }

  _cleanupMedia(session                                ) {
    const sessionId = this.getSipSessionId(session);
    if (session && sessionId in this.videoSessions) {
      delete this.videoSessions[this.getSipSessionId(session)];
    }

    const cleanAudio = id => {
      const element = this.audioElements[id];
      if (!element) {
        return;
      }

      element.pause();
      if (element.parentNode) {
        element.parentNode.removeChild(element);
      }
      element.srcObject = null;

      delete this.audioElements[id];
    };

    if (this._hasAudio() && this._isWeb()) {
      if (session) {
        cleanAudio(this.getSipSessionId(session));
      } else {
        Object.keys(this.audioElements).forEach(id => cleanAudio(id));
      }
    }
  }

  _toggleAudio(session                               , muteAudio         ) {
    const pc = session.sessionDescriptionHandler ? session.sessionDescriptionHandler.peerConnection : null;
    if (!pc) {
      return;
    }

    if (pc.getSenders) {
      pc.getSenders().forEach(sender => {
        if (sender.track && sender.track.kind === 'audio') {
          // eslint-disable-next-line
          sender.track.enabled = !muteAudio;
        }
      });
    } else {
      pc.getLocalStreams().forEach(stream => {
        stream.getAudioTracks().forEach(track => {
          // eslint-disable-next-line
          track.enabled = !muteAudio;
        });
      });
    }
  }

  _toggleVideo(session                               , muteCamera         ) {
    const pc = session.sessionDescriptionHandler.peerConnection;

    if (pc.getSenders) {
      pc.getSenders().forEach(sender => {
        if (sender.track && sender.track.kind === 'video') {
          // eslint-disable-next-line
          sender.track.enabled = !muteCamera;
        }
      });
    } else {
      pc.getLocalStreams().forEach(stream => {
        stream.getVideoTracks().forEach(track => {
          // eslint-disable-next-line
          track.enabled = !muteCamera;
        });
      });
    }
  }

  /**
   * @param pc RTCPeerConnection
   */
  _getRemoteStream(pc     ) {
    let remoteStream;

    if (pc.getReceivers) {
      remoteStream = typeof global !== 'undefined' ? new global.window.MediaStream() : new window.MediaStream();
      pc.getReceivers().forEach(receiver => {
        const { track } = receiver;
        if (track) {
          remoteStream.addTrack(track);
        }
      });
    } else {
      [remoteStream] = pc.getRemoteStreams();
    }

    return remoteStream;
  }

  /**
   * @param pc RTCPeerConnection
   */
  _getLocalStream(pc     ) {
    let localStream;

    if (pc.getSenders) {
      localStream = typeof global !== 'undefined' ? new global.window.MediaStream() : new window.MediaStream();
      pc.getSenders().forEach(sender => {
        const { track } = sender;
        if (track) {
          localStream.addTrack(track);
        }
      });
    } else {
      [localStream] = pc.getLocalStreams();
    }

    return localStream;
  }
}

//      

const SOCKET_EVENTS = {
  ON_OPEN: 'onopen',
  ON_ERROR: 'onerror',
  ON_CLOSE: 'onclose',
  INITIALIZED: 'initialized',
};

                                 
               
                
                        
                   
  

const AUTH_SESSION_EXPIRE_SOON = 'auth_session_expire_soon';
const FAVORITE_ADDED = 'favorite_added';
const FAVORITE_DELETED = 'favorite_deleted';
const USER_STATUS_UPDATE = 'user_status_update';
const CHAT_MESSAGE_SENT = 'chat_message_sent';
const CHAT_MESSAGE_RECEIVED = 'chat_message_received';
const ENDPOINT_STATUS_UPDATE = 'endpoint_status_update';
const USERS_FORWARDS_BUSY_UPDATED = 'users_forwards_busy_updated';
const USERS_FORWARDS_NOANSWER_UPDATED = 'users_forwards_noanswer_updated';
const USERS_FORWARDS_UNCONDITIONAL_UPDATED = 'users_forwards_unconditional_updated';
const USERS_SERVICES_DND_UPDATED = 'users_services_dnd_updated';
const USER_VOICEMAIL_MESSAGE_CREATED = 'user_voicemail_message_created';
const USER_VOICEMAIL_MESSAGE_DELETED = 'user_voicemail_message_deleted';
const CALL_LOG_USER_CREATED = 'call_log_user_created';
const CALL_CREATED = 'call_created';
const CALL_ENDED = 'call_ended';
const CALL_UPDATED = 'call_updated';
const CALL_HELD = 'call_held';
const CALL_RESUMED = 'call_resumed';
const AUTH_USER_EXTERNAL_AUTH_ADDED = 'auth_user_external_auth_added';
const AUTH_USER_EXTERNAL_AUTH_DELETED = 'auth_user_external_auth_deleted';
const CHATD_PRESENCE_UPDATED = 'chatd_presence_updated';
const CHATD_USER_ROOM_MESSAGE_CREATED = 'chatd_user_room_message_created';
const CHATD_USER_ROOM_CREATED = 'chatd_user_room_created';
const CONFERENCE_USER_PARTICIPANT_JOINED = 'conference_user_participant_joined';
const CONFERENCE_USER_PARTICIPANT_LEFT = 'conference_user_participant_left';
const SWITCHBOARD_QUEUED_CALLS_UPDATED = 'switchboard_queued_calls_updated';
const SWITCHBOARD_QUEUED_CALL_ANSWERED = 'switchboard_queued_call_answered';
const SWITCHBOARD_HELD_CALLS_UPDATED = 'switchboard_held_calls_updated';
const SWITCHBOARD_HELD_CALL_ANSWERED = 'switchboard_held_call_answered';
const FAX_OUTBOUND_USER_CREATED = 'fax_outbound_user_created';
const FAX_OUTBOUND_USER_SUCCEEDED = 'fax_outbound_user_succeeded';
const FAX_OUTBOUND_USER_FAILED = 'fax_outbound_user_failed';
const APPLICATION_CALL_DTMF_RECEIVED = 'application_call_dtmf_received';
const APPLICATION_CALL_ENTERED = 'application_call_entered';
const APPLICATION_CALL_INITIATED = 'application_call_initiated';
const APPLICATION_CALL_DELETED = 'application_call_deleted';
const APPLICATION_CALL_UPDATED = 'application_call_updated';
const APPLICATION_CALL_ANSWERED = 'application_call_answered';
const APPLICATION_PROGRESS_STARTED = 'application_progress_started';
const APPLICATION_PROGRESS_STOPPED = 'application_progress_stopped';
const APPLICATION_DESTINATION_NODE_CREATED = 'application_destination_node_created';
const APPLICATION_NODE_CREATED = 'application_node_created';
const APPLICATION_NODE_DELETED = 'application_node_deleted';
const APPLICATION_NODE_UPDATED = 'application_node_updated';
const APPLICATION_PLAYBACK_CREATED = 'application_playback_created';
const APPLICATION_PLAYBACK_DELETED = 'application_playback_deleted';
const APPLICATION_SNOOP_CREATED = 'application_snoop_created';
const APPLICATION_SNOOP_DELETED = 'application_snoop_deleted';
const APPLICATION_SNOOP_UPDATED = 'application_snoop_updated';
const APPLICATION_USER_OUTGOING_CALL_CREATED = 'application_user_outgoing_call_created';

const BLACKLIST_EVENTS = [
  CHAT_MESSAGE_SENT,
  CHAT_MESSAGE_RECEIVED,
  CHATD_USER_ROOM_MESSAGE_CREATED,
  CHATD_USER_ROOM_CREATED,
];

class WebSocketClient extends Emitter {
                       
               
                  
                
                        
                  
                                 

                                   

  /**
   *
   * @param host
   * @param token
   * @param events
   * @param version
   * @param options @see https://github.com/pladaria/reconnecting-websocket#available-options
   */
  constructor({ host, token, version = 1, events = [] }                          , options         = {}) {
    super();
    this.initialized = false;

    this.socket = null;
    this.host = host;
    this.token = token;
    this.events = events;
    this.options = options;
    this.version = version;
  }

  connect() {
    IssueReporter$1.log(IssueReporter$1.INFO, '[WebSocketClient][connect]');
    this.socket = new ReconnectingWebSocket(this._getUrl(), [], this.options);
    if (this.options.binaryType) {
      this.socket.binaryType = this.options.binaryType;
    }

    this.socket.onopen = () => {
      IssueReporter$1.log(IssueReporter$1.INFO, '[WebSocketClient][connect] onopen');
      this.eventEmitter.emit(SOCKET_EVENTS.ON_OPEN);
    };

    this.socket.onerror = error => {
      IssueReporter$1.log(IssueReporter$1.ERROR, '[WebSocketClient] onerror', JSON.stringify(error));
      this.eventEmitter.emit(SOCKET_EVENTS.ON_ERROR);
    };

    this.socket.onmessage = (event              ) => {
      const message = JSON.parse(typeof event.data === 'string' ? event.data : '{}');
      let { name } = message;
      if (message.data && message.data.name) {
        // eslint-disable-next-line
        name = message.data.name;
      }

      if (BLACKLIST_EVENTS.indexOf(name) === -1) {
        IssueReporter$1.log(IssueReporter$1.INFO, '[WebSocketClient] onmessage', event.data);
      }

      if (!this.initialized) {
        this._handleInitMessage(message, this.socket);
      } else {
        this._handleMessage(message);
      }
    };

    this.socket.onclose = e => {
      IssueReporter$1.log(IssueReporter$1.INFO, '[WebSocketClient] onclose', JSON.stringify(e));
      this.initialized = false;
      this.eventEmitter.emit(SOCKET_EVENTS.ON_CLOSE);

      switch (e.code) {
        case 4002:
          break;
        case 4003:
          break;
        default:
      }
    };
  }

  close()       {
    if (!this.socket) {
      return;
    }

    this.socket.close();
  }

  updateToken(token        ) {
    this.token = token;
    IssueReporter$1.log(IssueReporter$1.INFO, '[WebSocketClient] updateToken', !!this.socket);

    if (this.socket) {
      // If still connected, send the token to the WS
      if (this.socket.readyState === this.socket.OPEN && this.version >= 2) {
        this.socket.send(JSON.stringify({ op: 'token', data: { token } }));
        return;
      }
      // $FlowFixMe
      this.socket._url = this._getUrl();
    }
  }

  _handleInitMessage(message                  , sock                       ) {
    switch (message.op) {
      case 'init':
        this.events.forEach(event => {
          const op = {
            op: 'subscribe',
            data: { event_name: event },
          };

          sock.send(JSON.stringify(op));
        });

        sock.send(JSON.stringify({ op: 'start' }));
        break;
      case 'subscribe':
        break;
      case 'start':
        this.initialized = true;
        this.eventEmitter.emit(SOCKET_EVENTS.INITIALIZED);
        break;
      default:
        this.eventEmitter.emit('message', message);
    }
  }

  _handleMessage(message        ) {
    if (this.version === 1) {
      this.eventEmitter.emit(message.name, message);
      return;
    }

    if (this.version >= 2 && message.op === 'event') {
      this.eventEmitter.emit(message.data.name, message.data);
    }
  }

  _getUrl() {
    return `wss://${this.host}/api/websocketd/?token=${this.token}&version=${this.version}`;
  }
}

// Can't use static
WebSocketClient.eventLists = [
  AUTH_SESSION_EXPIRE_SOON,
  FAVORITE_ADDED,
  FAVORITE_DELETED,
  USER_STATUS_UPDATE,
  CHAT_MESSAGE_SENT,
  CHAT_MESSAGE_RECEIVED,
  ENDPOINT_STATUS_UPDATE,
  USERS_FORWARDS_BUSY_UPDATED,
  USERS_FORWARDS_NOANSWER_UPDATED,
  USERS_FORWARDS_UNCONDITIONAL_UPDATED,
  USERS_SERVICES_DND_UPDATED,
  USER_VOICEMAIL_MESSAGE_CREATED,
  USER_VOICEMAIL_MESSAGE_DELETED,
  CALL_LOG_USER_CREATED,
  CALL_CREATED,
  CALL_ENDED,
  CALL_UPDATED,
  CALL_HELD,
  CALL_RESUMED,
  AUTH_USER_EXTERNAL_AUTH_ADDED,
  AUTH_USER_EXTERNAL_AUTH_DELETED,
  CHATD_PRESENCE_UPDATED,
  CHATD_USER_ROOM_MESSAGE_CREATED,
  CHATD_USER_ROOM_CREATED,
  CONFERENCE_USER_PARTICIPANT_JOINED,
  CONFERENCE_USER_PARTICIPANT_LEFT,
  SWITCHBOARD_QUEUED_CALLS_UPDATED,
  SWITCHBOARD_QUEUED_CALL_ANSWERED,
  SWITCHBOARD_HELD_CALLS_UPDATED,
  SWITCHBOARD_HELD_CALL_ANSWERED,
  FAX_OUTBOUND_USER_CREATED,
  FAX_OUTBOUND_USER_SUCCEEDED,
  FAX_OUTBOUND_USER_FAILED,
  APPLICATION_CALL_DTMF_RECEIVED,
  APPLICATION_CALL_ENTERED,
  APPLICATION_CALL_INITIATED,
  APPLICATION_CALL_DELETED,
  APPLICATION_CALL_UPDATED,
  APPLICATION_CALL_ANSWERED,
  APPLICATION_PROGRESS_STARTED,
  APPLICATION_PROGRESS_STOPPED,
  APPLICATION_DESTINATION_NODE_CREATED,
  APPLICATION_NODE_CREATED,
  APPLICATION_NODE_DELETED,
  APPLICATION_NODE_UPDATED,
  APPLICATION_PLAYBACK_CREATED,
  APPLICATION_PLAYBACK_DELETED,
  APPLICATION_SNOOP_CREATED,
  APPLICATION_SNOOP_DELETED,
  APPLICATION_SNOOP_UPDATED,
  APPLICATION_USER_OUTGOING_CALL_CREATED,
];

var COUNTRIES = {
  BELGIUM: 'BE',
  CANADA: 'CA',
  FRANCE: 'FR',
  GERMANY: 'DE',
  ITALY: 'IT',
  PORTUGAL: 'PT',
  SPAIN: 'ES',
  SWITZERLAND: 'CH',
  UNITED_KINGDOM: 'GB',
  UNITED_STATES: 'US',
};

//      

                                   
                 
                     
  

                                     
                 
                     
  

class NotificationOptions {
                 
                     

  static parse(plain                            )                      {
    if (!plain) {
      return new NotificationOptions({ sound: true, vibration: true });
    }

    return new NotificationOptions({
      sound: plain.sound,
      vibration: plain.vibration,
    });
  }

  static newFrom(profile                     ) {
    return newFrom(profile, NotificationOptions);
  }

  constructor({ sound = true, vibration = true }                               = {}) {
    this.sound = sound;
    this.vibration = vibration;
  }

  setSound(sound         )                      {
    this.sound = sound;

    return this;
  }

  setVibration(vibration         )                      {
    this.vibration = vibration;

    return this;
  }

  enable() {
    this.vibration = true;
    this.sound = true;

    return this;
  }

  disable() {
    this.vibration = false;
    this.sound = false;

    return this;
  }

  isEnabled() {
    return this.sound || this.vibration;
  }
}

//      
/* eslint-disable no-param-reassign */

var updateFrom = (instance     , from     ) => {
  Object.keys(from).forEach(key => {
    // $FlowFixMe
    if (
      (!instance[key] && from[key])
      || (typeof instance[key] !== 'undefined' && typeof from[key] !== 'undefined' && instance[key] !== from[key])
    ) {
      // $FlowFixMe
      instance[key] = from[key];
    }
  });
};

//      

                             
                    
              
                 
                       
                         
                                  
                      
                    
                 
                 
                  
                   
                    
                 
                     
                    
  

class CallSession {
              

                 

                      

                 

                       

                    

                    

                    

                          

                   

  // Should be computed ?
                  

                    

                     

                 

                         

               

  constructor({
    answered,
    isCaller,
    displayName,
    callId,
    muted,
    number,
    paused,
    ringing,
    startTime,
    cameraEnabled,
    dialedExtension,
    sipCallId,
    sipStatus,
    callerNumber,
    call,
  }                      ) {
    this.callId = callId;
    this.sipCallId = sipCallId;
    this.displayName = displayName;
    this.number = number;
    this.startTime = startTime;
    this.isCaller = isCaller;
    this.answered = answered;
    this.ringing = ringing;
    this.paused = paused;
    this.muted = muted;
    this.callerNumber = callerNumber;
    this.cameraEnabled = cameraEnabled;
    this.dialedExtension = dialedExtension || '';
    this.call = call;
    this.sipStatus = sipStatus;

    // Useful to compare instead of instanceof with minified code
    this.type = 'CallSession';
  }

  resume() {
    this.paused = false;
  }

  hold() {
    this.paused = true;
  }

  mute() {
    this.muted = true;
  }

  unmute() {
    this.muted = false;
  }

  answer() {
    this.answered = true;
  }

  enableCamera() {
    this.cameraEnabled = true;
  }

  isIncoming()          {
    return !this.isCaller && !this.answered;
  }

  isOutgoing()          {
    return this.isCaller && !this.answered;
  }

  isActive()          {
    return this.answered || this.isOutgoing();
  }

  isAnswered()          {
    return this.answered;
  }

  isRinging()          {
    return this.ringing;
  }

  isOnHold()          {
    return this.paused;
  }

  isMuted()          {
    return this.muted;
  }

  isCameraEnabled()          {
    return this.cameraEnabled;
  }

  hasAnInitialInterceptionNumber()          {
    return this.number.startsWith('*8');
  }

  isAnInterception()          {
    return this.dialedExtension.startsWith('*8');
  }

  getElapsedTimeInSeconds() {
    if (!this.startTime) {
      return 0;
    }
    return (Date.now() - this.startTime) / 1000;
  }

  getId() {
    return this.sipCallId || this.callId;
  }

  is(callSession             ) {
    return this.isId(callSession.getId());
  }

  isId(id        )          {
    return (
      this.getId() === id || (this.sipCallId && this.sipCallId === id) || (Boolean(this.callId) && this.callId === id)
    );
  }

  updateFrom(session             ) {
    updateFrom(this, session);
  }

  separateDisplayName()                                          {
    const names = this.displayName.split(' ');
    const firstName = names[0];
    const lastName = names.slice(1).join(' ');

    return { firstName, lastName };
  }

  static newFrom(callSession             ) {
    return newFrom(callSession, CallSession);
  }

  static parseCall(session         , call      )              {
    return new CallSession({
      callId: call.id,
      sipCallId: call.sipCallId,
      displayName: call.calleeName || call.calleeNumber,
      number: call.calleeNumber,
      callerNumber: call.callerNumber,
      startTime: +call.startingTime,
      paused: call.isOnHold(),
      isCaller: call.isCaller,
      muted: false,
      ringing: call.isRinging(),
      answered: call.isUp(),
      cameraEnabled: false,
      dialedExtension: call.dialedExtension,
      call,
    });
  }
}

//      
                                           

                                     
                 
                  
                         
                           
             
                    
                   
                 
                    
  

                                      
                                      
                
  

                                   
                     
                              
               
                    
                    
  

class Conference {
                    

                              

                   

                    

               

  constructor({ startTime, participants, phone, started, finished }                     ) {
    this.phone = phone;
    this.startTime = startTime;
    this.participants = participants || [];
    this.started = started || false;
    this.finished = finished || false;

    if (!started) {
      this.phone.startConference(participants);
      this.phone.resumeConference(participants);
      this.started = true;
    }
  }

  getParticipants() {
    return this.participants;
  }

  async addParticipants(newParticipants               )                      {
    await this.phone.addToConference(newParticipants);
    this.phone.resumeConference([...this.participants, ...newParticipants]);

    if (this.participants.some(participant => !participant.isMuted())) {
      this.phone.unmuteConference(newParticipants);
    } else {
      this.phone.muteConference(newParticipants);
    }

    return new Conference({
      ...this,
      participants: [...this.participants, ...newParticipants],
    });
  }

  participantHasLeft(leaver             )             {
    return new Conference({
      ...this,
      participants: this.participants.filter(participant => !participant.is(leaver)),
    });
  }

  hasParticipants() {
    return this.participants.length > 0;
  }

  mute()             {
    this.phone.muteConference(this.participants);
    return new Conference({
      ...this,
    });
  }

  unmute()             {
    this.phone.unmuteConference(this.participants);
    return new Conference({
      ...this,
    });
  }

  hold()             {
    this.phone.holdConference(this.participants);
    return new Conference({
      ...this,
    });
  }

  resume()             {
    this.phone.resumeConference(this.participants);
    return new Conference({
      ...this,
    });
  }

  hangup()             {
    this.phone.hangupConference(this.participants);
    return new Conference({
      ...this,
      finished: true,
    });
  }

  hangupParticipant(participantToHangup             ) {
    this.phone.hangupConference([participantToHangup]);
    return new Conference({
      ...this,
      participants: this.participants.filter(participant => !participant.is(participantToHangup)),
    });
  }

  removeParticipant(participantToRemove             ) {
    this.phone.removeFromConference([participantToRemove]);
    return new Conference({
      ...this,
      participants: this.participants.filter(participant => !participant.is(participantToRemove)),
    });
  }

  isOnHold() {
    return this.participants.every(participant => participant.isOnHold());
  }

  isMuted() {
    return this.participants.every(participant => participant.isMuted());
  }
}

//      

                             
                                           
             
                
                                                           
  

// Represents a conference room, like `9000`.
class Room {
             

                                  

                                           

                                                           

  constructor({ id, connectedCallSession, participants, name }               ) {
    this.id = id;
    this.connectedCallSession = connectedCallSession;
    this.participants = participants;
    this.name = name;
  }

  getExtension()                {
    return this.connectedCallSession ? this.connectedCallSession.number : null;
  }

  connect(callSession             )       {
    return new Room({ ...this, connectedCallSession: callSession });
  }

  has(callSession             )          {
    return !!this.connectedCallSession && this.connectedCallSession.is(callSession);
  }

  addParticipant(uuid        , extension        ) {
    if (!this.participants.some(participant => participant.uuid === uuid || participant.extension === extension)) {
      return new Room({ ...this, participants: [...this.participants, { uuid, extension }] });
    }

    return this;
  }

  hasCallWithId(id        )          {
    return !!this.connectedCallSession && this.connectedCallSession.getId() === id;
  }

  disconnect()       {
    return new Room({ ...this, connectedCallSession: null });
  }

  removeParticipantWithUUID(uuid        ) {
    return new Room({
      ...this,
      participants: this.participants.filter(participant => participant.uuid !== uuid),
    });
  }

  removeParticipantWithExtension(extension        ) {
    return new Room({
      ...this,
      participants: this.participants.filter(participant => participant.extension !== extension),
    });
  }

  updateFrom(room      ) {
    updateFrom(this, room);
  }

  static newFrom(room      ) {
    return newFrom(room, Room);
  }
}

//      

                                         
                        
                   
  

class IndirectTransfer {
                   

                        

  constructor({ sourceId, destinationId }                           ) {
    this.sourceId = sourceId;
    this.destinationId = destinationId;
  }

  static parseFromCallSession(source             , destination             ) {
    return new IndirectTransfer({
      sourceId: source.getId(),
      destinationId: destination.getId(),
    });
  }

  destinationIs(callSession             )          {
    return callSession.isId(this.destinationId);
  }

  sourceIs(callSession             )          {
    return callSession.isId(this.sourceId);
  }

  updateFrom(indirectTransfer                  ) {
    updateFrom(this, indirectTransfer);
  }

  static newFrom(indirectTransfer                  ) {
    return newFrom(indirectTransfer, IndirectTransfer);
  }
}

//      

                                                                                                   

                                    
                                    
                           
  

                                             
                           
                         
                           
  

                                           
                       
                           
                           
  

                                 
             
                            
                        
                          
                   
                         
                
                          
                          
  

                                       
                            
                          
                            
             
                         
                   
                
                          
                          
  

class SwitchboardCall {
                       

             
                            
                        
                          
                   
                         
                
                          
                          
               

  static parse(plain                         )                  {
    return new SwitchboardCall({
      id: plain.id,
      callSession: plain.callSession || null,
      callerIdName: plain.caller_id_name || null,
      callerIdNumber: plain.caller_id_number || null,
      participantId: plain.participantId || null,
      startTime: plain.startTime,
      state: plain.state,
      switchboardName: plain.switchboardName,
      switchboardUuid: plain.switchboardUuid,
    });
  }

  constructor({
    id,
    callSession,
    callerIdName,
    callerIdNumber,
    participantId,
    startTime,
    state,
    switchboardName,
    switchboardUuid,
  }                           = {}) {
    this.id = id;
    this.callSession = callSession;
    this.callerIdName = callerIdName;
    this.callerIdNumber = callerIdNumber;
    this.participantId = participantId;
    this.startTime = startTime;
    this.state = state;
    this.switchboardName = switchboardName;
    this.switchboardUuid = switchboardUuid;

    // Useful to compare instead of instanceof with minified code
    this.type = 'SwitchboardCall';
  }

  updateFrom(switchboardCall                 ) {
    updateFrom(this, switchboardCall);
  }

  static newFrom(switchboardCall                 ) {
    return newFrom(switchboardCall, SwitchboardCall);
  }
}

SwitchboardCall.STATE = {
  INCOMING: 'incoming',
  ONGOING: 'ongoing',
  HELD: 'held',
};

//      
/* eslint-disable */

                                       

class DebugDevice                   {
  connectToCall() {
    console.info('DebugDevice - Connected to call');
  }

  disconnectFromCall() {
    console.info('DebugDevice - Disconnected from call');
  }

  ringback() {
    console.info('DebugDevice - Ringback');
  }

  stopRingback() {
    console.info('DebugDevice - Stop ringback');
  }

  playRingtone() {
    console.info('DebugDevice - Play ringtone');
  }

  stopRingtone() {
    console.info('DebugDevice - Stop ringtone');
  }

  mute() {
    console.info('DebugDevice - Mute');
  }

  unmute() {
    console.info('DebugDevice - Unmute');
  }

  putOnSpeaker() {
    console.info('DebugDevice - Put on speaker');
  }

  putOffSpeaker() {
    console.info('DebugDevice - Put off speaker');
  }
}

//      

const PhoneNumberUtil = LibPhoneNumber.PhoneNumberUtil.getInstance();
const { PhoneNumberFormat, AsYouTypeFormatter } = LibPhoneNumber;

// eslint-disable-next-line
const EXTRA_CHAR_REGEXP = /[^+*\d]/g;

const shouldBeFormatted = (number         ) => {
  if (!number || number.length <= 5) {
    return false;
  }

  return !number.includes('#') && !number.includes('*');
};

const getDisplayableNumber = (number        , country        , asYouType          = false)         => {
  if (!shouldBeFormatted(number)) {
    return number;
  }

  let displayValue = '';

  if (asYouType) {
    const formatter = new AsYouTypeFormatter(country);
    number.split('').forEach(char => {
      displayValue = formatter.inputDigit(char);
    });
  } else {
    const parsedNumber = PhoneNumberUtil.parseAndKeepRawInput(number, country);

    displayValue = PhoneNumberUtil.format(parsedNumber, PhoneNumberFormat.NATIONAL);
  }

  return displayValue;
};

const parsePhoneNumber = (phoneNumber        )         => phoneNumber.replace(EXTRA_CHAR_REGEXP, '');

const getCallableNumber = (number        , country         )          => {
  try {
    if (country) {
      return getDisplayableNumber(number, country).replace(EXTRA_CHAR_REGEXP, '');
    }
    return parsePhoneNumber(number);
  } catch (_) {
    return null;
  }
};

//      
             
                                         
                                           
                                  
             
                                                                     
                                                                 
                                                 
                                                   
                                  
                                                                                              

                                        
                                                  
                                                    
                                                                  
                                                              
                              
                                                          
                                
                                    
                                         
                                           
                                                              
                                                                              
                                                                          
                                                          
                                                            
                                                    

var index = {
  Emitter,
  PhoneNumberUtil,
  PhoneNumberFormat,
  AsYouTypeFormatter,
  getDisplayableNumber,
  getCallableNumber,
  SIP,
  WazoApiClient: ApiClient,
  WazoWebRTCClient: WebRTCClient,
  WazoWebSocketClient: WebSocketClient,
  BadResponse,
  ServerError,
  Call,
  Conference,
  CallSession,
  IndirectTransfer,
  SwitchboardCall,
  CallLog,
  ChatMessage,
  ChatRoom,
  Contact,
  COUNTRIES,
  ForwardOption,
  Line,
  NotificationOptions,
  Profile,
  Session,
  Voicemail,
  Relocation,
  Room,
  DebugDevice,
  PROFILE_STATE: STATE,
  FORWARD_KEYS,
  LINE_STATE,
  SOCKET_EVENTS,
};

export default index;
