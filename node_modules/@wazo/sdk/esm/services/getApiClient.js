import { Base64 } from 'js-base64';
import { jws, b64utoutf8, KEYUTIL } from 'jsrsasign';
import moment from 'moment';

/*       */

class BadResponse extends Error {
  static fromResponse(error        , status        ) {
    return new BadResponse(error.message, status, error.timestamp, error.error_id, error.details);
  }

  static fromText(response        , status        ) {
    return new BadResponse(response, status);
  }

                  
                 
                     
                   
                   

  constructor(
    message        ,
    status        ,
    timestamp          = null,
    errorId          = null,
    details          = null,
  ) {
    super(message);

    this.timestamp = timestamp;
    this.status = status;
    this.errorId = errorId;
    this.details = details;
  }
}

/*       */

class ServerError extends BadResponse {
  static fromResponse(error        , status        ) {
    return new ServerError(error.message, status, error.timestamp, error.error_id, error.details);
  }

  static fromText(response        , status        ) {
    return new ServerError(response, status);
  }
}

/*       */

class Logger {
  static hasDebug() {
    return typeof process !== 'undefined' && (+process.env.DEBUG === 1 || process.env.DEBUG === 'true');
  }

  static logRequest(url        , { method, body, headers }        , response        ) {
    if (!Logger.hasDebug()) {
      return;
    }

    const { status } = response;

    let curl = `${status} - curl ${method !== 'get' ? `-X ${method.toUpperCase()}` : ''}`;
    Object.keys(headers).forEach(headerName => {
      curl += ` -H '${headerName}: ${headers[headerName]}'`;
    });

    curl += ` ${url}`;

    if (body) {
      curl += ` -d '${body}'`;
    }

    console.info(curl);
  }
}

/*       */
                                             

const methods = ['head', 'get', 'post', 'put', 'delete'];

// Use a function here to be able to mock it in tests
const realFetch = () => {
  if (typeof document !== 'undefined') {
    // Browser
    return window.fetch;
  }

  if (typeof navigator !== 'undefined' && navigator.product === 'ReactNative') {
    // React native
    return fetch;
  }

  // nodejs
  // this package is disable for react-native in package.json because it requires nodejs modules
  return require('node-fetch/lib/index');
};

class ApiRequester {
                 
                 

                 
                
                 
                
                   

  // eslint-disable-next-line
  static successResponseParser(response        , isJson         ) {
    return response.status === 204;
  }

  static defaultParser(response        ) {
    return response.json().then((data        ) => data);
  }

  static getHeaders(header                  )         {
    if (header instanceof Object) {
      return header;
    }

    return {
      'X-Auth-Token': header,
      Accept: 'application/json',
      'Content-Type': 'application/json',
    };
  }

  static getQueryString(obj        )         {
    return Object.keys(obj)
      .filter(key => obj[key])
      .map(key => `${key}=${encodeURIComponent(obj[key])}`)
      .join('&');
  }

  static base64Encode(str        )         {
    return typeof btoa !== 'undefined' ? btoa(str) : Base64.encode(str);
  }

  // @see https://github.com/facebook/flow/issues/183#issuecomment-358607052
  constructor({ server, agent = null }                                              ) {
    this.server = server;
    this.agent = agent;

    methods.forEach(method => {
      // $FlowFixMe
      ApiRequester.prototype[method] = function sugar(...args) {
        // Add method in arguments passed to `call`
        args.splice(1, 0, method);

        return this.call.call(this, ...args);
      };
    });
  }

  call(
    path        ,
    method         = 'get',
    body          = null,
    headers                    = null,
    parse           = ApiRequester.defaultParser,
  )               {
    const url = this.computeUrl(method, path, body);
    const newHeaders = headers ? ApiRequester.getHeaders(headers) : {};
    let newBody = method === 'get' ? null : body;
    if (newBody && newHeaders['Content-Type'] === 'application/json') {
      newBody = JSON.stringify(newBody);
    }
    const isHead = method === 'head';
    const hasEmptyResponse = method === 'delete' || isHead;
    const newParse = hasEmptyResponse ? ApiRequester.successResponseParser : parse;
    const options = {
      method,
      body: newBody,
      headers: headers ? ApiRequester.getHeaders(headers) : {},
      agent: this.agent,
    };

    return realFetch()(url, options).then(response => {
      const contentType = response.headers.get('content-type') || '';
      const isJson = contentType.indexOf('application/json') !== -1;

      Logger.logRequest(url, options, response);

      // Throw an error only if status >= 500
      if ((isHead && response.status >= 500) || (!isHead && response.status >= 400)) {
        const promise = isJson ? response.json() : response.text();
        const exceptionClass = response.status >= 500 ? ServerError : BadResponse;

        return promise.then(err => {
          throw typeof err === 'string'
            ? exceptionClass.fromText(err, response.status)
            : exceptionClass.fromResponse(err, response.status);
        });
      }

      return newParse(response, isJson);
    });
  }

  computeUrl(method        , path        , body         )         {
    const url = `${this.baseUrl}/${path}`;

    return method === 'get' && body && Object.keys(body).length ? `${url}?${ApiRequester.getQueryString(body)}` : url;
  }

  get baseUrl()         {
    return `https://${this.server}/api`;
  }
}

//      

const swarmPublicKey  = `-----BEGIN PUBLIC KEY-----
MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAmkXOuNfY8u5xoTiIhkb8
djnbIwG/Wrz3vpo8BZir8L5e1a1nSy740qBjP7ZINBQoALDhFfmdOfJnCyEGiHuz
ZW6jbG6C3PryE3Bu6GKwqSmD6k3q4Zk27fpwYAnNl+rWhYYM563rJZBda/INyHNN
pK7M1mixWi7gNdjjXwoEXSSBx+VpYMkY6LiAB2mvHXTY9M1qI14dvgGoQISZQoKi
NMTRCg5UP2ic0Dd9nSz/XpcOxGfa+0fwIl1F7RC1tJXOqvkGGPTOV4LLfg/Yta3h
nUPX9EZZDIX6vO/0IBV1LzjSl2A1bYFYAjJfowv3i1CpvONBOClHjSY5t9Y8MH6p
BwIDAQAB
-----END PUBLIC KEY-----`;

//      

var newFrom = (instance     , ToClass     ) => {
  const args = {};
  Object.getOwnPropertyNames(instance).forEach(prop => {
    args[prop] = instance[prop];
  });

  return new ToClass(args);
};

//      

                  
                  
                
             
                                               
  

                        
             
                                              
                    
  

                     
                             
                           
                          
                               
             
  

                      
             
                               
                                   
                                 
                                
  

class Line {
               

             
                               
                                  
                                
                               

  static parse(plain              )       {
    return new Line({
      id: plain.id,
      extensions: plain.extensions,
      endpointCustom: plain.endpoint_custom || null,
      endpointSccp: plain.endpoint_sccp || null,
      endpointSip: plain.endpoint_sip || null,
    });
  }

  static newFrom(profile      ) {
    return newFrom(profile, Line);
  }

  is(line      ) {
    return this.id === line.id;
  }

  hasExtension(extension        ) {
    return this.extensions.some(ext => ext.exten === extension);
  }

  constructor({ id, extensions, endpointCustom, endpointSccp, endpointSip }                = {}) {
    this.id = id;
    this.extensions = extensions;
    this.endpointCustom = endpointCustom || null;
    this.endpointSccp = endpointSccp || null;
    this.endpointSip = endpointSip || null;

    // Useful to compare instead of instanceof with minified code
    this.type = 'Line';
  }
}

//      

                 
                      
                   
  

const FORWARD_KEYS = {
  BUSY: 'busy',
  NO_ANSWER: 'noanswer',
  UNCONDITIONAL: 'unconditional',
};

                               
                      
                   
              
  

class ForwardOption {
                      
                   
              

  static parse(plain          , key        )                {
    return new ForwardOption({
      destination: plain.destination || '',
      enabled: plain.enabled,
      key,
    });
  }

  static newFrom(profile               ) {
    return newFrom(profile, ForwardOption);
  }

  constructor({ destination, enabled, key }                         = {}) {
    this.destination = destination;
    this.enabled = enabled;
    this.key = key;
  }

  setDestination(number        )                {
    this.destination = number;

    return this;
  }

  setEnabled(enabled         )                {
    this.enabled = enabled;

    return this;
  }

  is(other               ) {
    return this.key === other.key;
  }
}

//      
                                       

const PRESENCE = {
  AVAILABLE: 'available',
  DO_NOT_DISTURB: 'donotdisturb',
  DISCONNECTED: 'disconnected',
};

const STATE = {
  AVAILABLE: 'available',
  UNAVAILABLE: 'unavailable',
  INVISIBLE: 'invisible',
  AWAY: 'away',
};

const LINE_STATE = {
  AVAILABLE: 'available',
  HOLDING: 'holding',
  RINGING: 'ringing',
  TALKING: 'talking',
  UNAVAILABLE: 'unavailable',
};

                        
                                              
                    
                     
                   
                    
               
                
               
                                                                                                                    
                                      
                                    
                                   
     
             
                   
                    
                   
                
             
           
                          
                       
      
               
                          
                       
      
                    
                          
                       
      
    
                               
                             
             
          
                       
      
    
                           
               
               
                 
    
  

                         
             
                    
                   
                
                     
                   
                       
                                 
                         
                    
                 
                            
               
               
                 
    
                           
  

class Profile {
             
                    
                   
                
                     
                   
                       
                                 
                         
                    
                                           
                 
                            
                           

  static parse(plain                 )          {
    return new Profile({
      id: plain.uuid,
      firstName: plain.firstName || plain.firstname || '',
      lastName: plain.lastName || plain.lastname || '',
      email: plain.email,
      lines: plain.lines.map(line => Line.parse(line)),
      username: plain.username,
      mobileNumber: plain.mobile_phone_number || '',
      forwards: [
        ForwardOption.parse(plain.forwards.unconditional, FORWARD_KEYS.UNCONDITIONAL),
        ForwardOption.parse(plain.forwards.noanswer, FORWARD_KEYS.NO_ANSWER),
        ForwardOption.parse(plain.forwards.busy, FORWARD_KEYS.BUSY),
      ],
      doNotDisturb: plain.services.dnd.enabled,
      subscriptionType: plain.subscription_type,
      voicemail: plain.voicemail,
      switchboards: plain.switchboards || [],
      status: '',
    });
  }

  static newFrom(profile         ) {
    return newFrom(profile, Profile);
  }

  constructor({
    id,
    firstName,
    lastName,
    email,
    lines,
    username,
    mobileNumber,
    forwards,
    doNotDisturb,
    presence,
    subscriptionType,
    voicemail,
    switchboards,
    status,
  }                           = {}) {
    this.id = id;
    this.firstName = firstName;
    this.lastName = lastName;
    this.email = email;
    this.lines = lines;
    this.username = username;
    this.mobileNumber = mobileNumber;
    this.forwards = forwards;
    this.doNotDisturb = doNotDisturb;
    this.presence = presence;
    this.voicemail = voicemail;
    this.subscriptionType = subscriptionType;
    this.switchboards = switchboards;
    this.status = status;
  }

  static getLinesState(lines               ) {
    let result = LINE_STATE.UNAVAILABLE;

    // eslint-disable-next-line
    for (const line of lines) {
      if (line.state === LINE_STATE.RINGING) {
        result = LINE_STATE.RINGING;
        break;
      }

      if (line.state === LINE_STATE.TALKING) {
        result = LINE_STATE.TALKING;
        break;
      }

      if (line.state === LINE_STATE.AVAILABLE) {
        result = LINE_STATE.AVAILABLE;
      }
    }

    return result;
  }

  hasId(id        ) {
    return id === this.id;
  }

  setMobileNumber(number        ) {
    this.mobileNumber = number;

    return this;
  }

  setForwardOption(forwardOption               ) {
    const updatedForwardOptions = this.forwards.slice();
    const index = updatedForwardOptions.findIndex(forward => forward.is(forwardOption));
    updatedForwardOptions.splice(index, 1, forwardOption);

    this.forwards = updatedForwardOptions;

    return this;
  }

  setDoNotDisturb(enabled         ) {
    this.doNotDisturb = enabled;

    return this;
  }

  setPresence(presence        ) {
    this.presence = presence;

    return this;
  }
}

//      
                                                         

const BACKEND = {
  OFFICE365: 'office365',
  PERSONAL: 'personal',
  GOOGLE: 'google',
  WAZO: 'wazo',
};

                          
                    
                   
                      
                 
                   
                      
                    
                
  

                               
                 
                  
                            
              
                    
                    
                      
                        
                      
                            
    
  

                                
                               
               
                                
                                  
  

                                       
             
                     
                    
                  
                                                     
                 
                                                    
                      
                    
                   
                
                    
                     
                    
                   
  

// @see: https://github.com/rt2zz/react-native-contacts#example-contact-record
                                     
                   
                  
                         
                  
                  
     
                    
                     
                     
                   
               
                       
                  
                
     
                       
                  
                   
     
                        
                        
                          
                   
                 
                  
                   
                     
                    
                  
     
             
                 
                  
                
    
  

                         
              
                
                
                  
                                                     
                      
                 
                                                   
                      
                    
                   
                
                      
                     
                    
                  
                    
                  
                      
                
                   
                          
  

                          
                     
                
                       
                        
                             
                         
                    
                       
                   
                          
                  
                      
                                                           
                 
                  
                 
                   
                       
             
                   
                
                
                               
               
                  
                      
                
                      
                    
                         
                        
                  
                  
                  
             
                       
                     
                   
  

                     
                
                
                    
                   
                           
               
             
                        
  
                           
                  
               
             
                                                        
                                                     
  

                       
                   
             
               
                    
                        
  

const SOURCE_MOBILE = 'mobile';

class Contact {
               

              
                
                
                  
                                                     
                      
                 
                                                   
                      
                    
                   
                
                      
                     
                    
                  
                   
                  
                   
                         

  static merge(oldContacts                , newContacts                )                 {
    return newContacts.map(current => {
      const old = oldContacts.find(contact => contact.is(current));

      return typeof old !== 'undefined' ? current.merge(old) : current;
    });
  }

  static sortContacts(a         , b         ) {
    const aNames = a.separateName();
    const bNames = b.separateName();
    const aLastName = aNames.lastName;
    const bLastName = bNames.lastName;

    // last Name can be empty
    if (aLastName === bLastName) {
      return aNames.firstName.localeCompare(bNames.firstName);
    }

    return aLastName.localeCompare(bLastName);
  }

  static parseMany(response                  )                 {
    return response.results.map(r => Contact.parse(r, response.column_types));
  }

  static parseMultipleNumber(plain                 , columns                ) {
    const numberColumns = columns
      .map((e, index) => ({ index, columnName: e }))
      .filter(e => e.columnName === 'number')
      .map(e => e.index);

    const number = plain.column_values.find((e, index) => numberColumns.some(i => i === index) && e !== null);

    return number || '';
  }

  static parse(plain                 , columns                )          {
    const number = Contact.parseMultipleNumber(plain, columns);
    const email = plain.column_values[columns.indexOf('email')];

    return new Contact({
      name: plain.column_values[columns.indexOf('name')],
      number: number || '',
      numbers: number ? [{ label: 'primary', number }] : [],
      favorited: plain.column_values[columns.indexOf('favorite')],
      email: email || '',
      emails: email ? [{ label: 'primary', email }] : [],
      entreprise: plain.column_values[columns.indexOf('entreprise')] || '',
      birthday: plain.column_values[columns.indexOf('birthday')] || '',
      address: plain.column_values[columns.indexOf('address')] || '',
      note: plain.column_values[columns.indexOf('note')] || '',
      endpointId: plain.relations.endpoint_id,
      personal: plain.column_values[columns.indexOf('personal')],
      source: plain.source,
      sourceId: plain.relations.source_entry_id,
      uuid: plain.relations.user_uuid,
      backend: plain.backend || '',
    });
  }

  static parseManyPersonal(results                                )                  {
    return results.map(r => Contact.parsePersonal(r));
  }

  static parsePersonal(plain                         )          {
    return new Contact({
      name: `${plain.firstName || plain.firstname || ''} ${plain.lastName || plain.lastname || ''}`,
      number: plain.number || '',
      numbers: plain.number ? [{ label: 'primary', number: plain.number }] : [],
      email: plain.email || '',
      emails: plain.email ? [{ label: 'primary', email: plain.email }] : [],
      source: 'personal',
      sourceId: plain.id,
      entreprise: plain.entreprise || '',
      birthday: plain.birthday || '',
      address: plain.address || '',
      note: plain.note || '',
      favorited: false,
      personal: true,
      backend: plain.backend || BACKEND.PERSONAL,
    });
  }

  static parseMobile(plain                       )          {
    let address = '';
    if (plain.postalAddresses.length) {
      const postalAddress = plain.postalAddresses[0];

      address = `${postalAddress.street} ${postalAddress.city} ${postalAddress.postCode} ${postalAddress.country}`;
    }

    return new Contact({
      name: `${plain.givenName || ''} ${plain.familyName || ''}`,
      number: plain.phoneNumbers.length ? plain.phoneNumbers[0].number : '',
      numbers: plain.phoneNumbers.length ? [{ label: 'primary', number: plain.phoneNumbers[0].number }] : [],
      email: plain.emailAddresses.length ? plain.emailAddresses[0].email : '',
      emails: plain.emailAddresses.length ? [{ label: 'primary', email: plain.emailAddresses[0].email }] : [],
      source: SOURCE_MOBILE,
      sourceId: plain.recordID,
      birthday: plain.birthday ? `${plain.birthday.year}-${plain.birthday.month}-${plain.birthday.day}` : '',
      address,
      note: plain.note || '',
      favorited: false,
      personal: true,
    });
  }

  static parseManyOffice365(response                     , source                 )                 {
    return response.map(r => Contact.parseOffice365(r, source));
  }

  static parseOffice365(single                   , source                 )          {
    const emails = [];
    const numbers = [];

    if (single.emailAddresses) {
      const formattedEmails = single.emailAddresses.map(email => ({ label: 'email', email: email.address }));
      emails.push(...formattedEmails);
    }

    if (single.homePhones) {
      const formattedPhones = single.homePhones.map(phone => ({ label: 'home', number: phone }));
      numbers.push(...formattedPhones);
    }

    if (single.mobilePhone) {
      numbers.push({ label: 'mobile', number: single.mobilePhone });
    }

    return new Contact({
      sourceId: single.id,
      name: single.displayName,
      numbers,
      emails,
      source: source.name,
      backend: BACKEND.OFFICE365,
    });
  }

  static parseManyGoogle(response                  , source                 )                 {
    return response.map(r => Contact.parseGoogle(r, source));
  }

  static parseGoogle(single                , source                 )          {
    const emails = [];
    const numbers = [];

    if (single.emails) {
      const formattedEmails = single.emails.map(email => ({ label: 'email', email }));
      emails.push(...formattedEmails);
    }

    if (single.numbers) {
      const formattedPhones = single.numbers.map(phone => ({ label: 'mobile', number: phone }));
      numbers.push(...formattedPhones);
    }

    return new Contact({
      sourceId: single.id,
      name: single.name,
      numbers,
      emails,
      source: source.name,
      backend: BACKEND.GOOGLE,
    });
  }

  static parseManyWazo(response                , source                 )                 {
    return response.map(r => Contact.parseWazo(r, source));
  }

  static parseWazo(single              , source                 )          {
    const emails = [];
    const numbers = [];

    if (single.email) {
      emails.push({ label: 'email', email: single.email });
    }

    if (single.exten) {
      numbers.push({ label: 'exten', number: single.exten });
    }

    if (single.mobile_phone_number) {
      numbers.push({ label: 'mobile', number: single.mobile_phone_number });
    }

    return new Contact({
      uuid: single.uuid,
      sourceId: String(single.id),
      name: `${single.firstname} ${single.lastname}`,
      numbers,
      emails,
      source: source.name,
      backend: BACKEND.WAZO,
    });
  }

  static parseManyConference(response                      , source                 )                 {
    return response.map(r => Contact.parseConference(r, source));
  }

  static parseConference(single                    , source                 )          {
    const numbers = [];
    let firstNumber = '';

    if (single.extensions.length > 0 && single.extensions[0].exten) {
      firstNumber = single.extensions[0].exten;
      numbers.push({ label: 'exten', number: firstNumber });
    }

    return new Contact({
      sourceId: String(single.id),
      name: single.name,
      number: firstNumber,
      numbers,
      source: source.name,
      backend: 'conference',
    });
  }

  static newFrom(profile         ) {
    return newFrom(profile, Contact);
  }

  constructor({
    id,
    uuid,
    name,
    number,
    numbers,
    email,
    emails,
    source,
    sourceId,
    entreprise,
    birthday,
    address,
    note,
    presence,
    status,
    endpointId,
    personal,
    favorited,
    backend,
    personalStatus,
  }                   = {}) {
    this.id = id;
    this.uuid = uuid;
    this.name = name;
    this.number = number;
    this.numbers = numbers;
    this.email = email;
    this.emails = emails;
    this.source = source;
    this.sourceId = sourceId || '';
    this.entreprise = entreprise;
    this.birthday = birthday;
    this.address = address;
    this.note = note;
    this.presence = presence;
    this.status = status;
    this.endpointId = endpointId;
    this.personal = personal;
    this.favorited = favorited;
    this.backend = backend;
    this.personalStatus = personalStatus || '';

    // Useful to compare instead of instanceof with minified code
    this.type = 'Contact';
  }

  setFavorite(value         ) {
    this.favorited = value;

    return this;
  }

  is(other         )          {
    const sameSourceId = !!this.sourceId && !!other.sourceId && this.sourceId === other.sourceId;
    const sameUuid = !!this.uuid && !!other.uuid && this.uuid === other.uuid;

    const hasSameId = sameSourceId || sameUuid;
    const hasSameBackend = !!this.backend && !!other.backend && this.backend === other.backend;
    const hasSameSource = !!this.source && !!other.source && this.source === other.source;

    return !!other && hasSameId && hasSameBackend && hasSameSource;
  }

  hasId(id        )          {
    return this.uuid === id;
  }

  hasNumber(number        )          {
    return this.number === number;
  }

  hasEndpointId(endpointId        )          {
    return this.endpointId === endpointId;
  }

  isAvailable()          {
    return this.presence === STATE.AVAILABLE;
  }

  isAway()          {
    return this.presence === STATE.AWAY;
  }

  isUnavailable()          {
    return this.presence === STATE.UNAVAILABLE;
  }

  isInvisible()          {
    return this.presence === STATE.INVISIBLE;
  }

  isDoNotDisturb()          {
    return this.presence === PRESENCE.DO_NOT_DISTURB;
  }

  isDisconnected()          {
    return this.presence === PRESENCE.DISCONNECTED;
  }

  isInCall()          {
    return this.status === LINE_STATE.TALKING || this.status === LINE_STATE.HOLDING;
  }

  isRinging()          {
    return this.status === LINE_STATE.RINGING;
  }

  isInUseOrRinging()          {
    return this.status === LINE_STATE.TALKING || this.status === LINE_STATE.RINGING;
  }

  merge(old         )          {
    this.presence = old.presence;
    this.status = old.status;

    return this;
  }

  isIntern()          {
    return !!this.uuid;
  }

  isCallable(session         )          {
    return !!this.number && !!session && !session.is(this);
  }

  isFromMobile() {
    return this.source === SOURCE_MOBILE;
  }

  isFavorite() {
    return this.favorited;
  }

  separateName()                                          {
    if (!this.name) {
      return {
        firstName: '',
        lastName: '',
      };
    }
    const names = this.name.split(/\s+/);
    const firstName = names[0];
    const lastName = names.slice(1).join(' ');

    return {
      firstName,
      lastName,
    };
  }
}

// Can't use `semver` package as Wazo version aren't in semver format

const compareVersions = (a, b) => {
  let i;
  let diff;
  const regExStrip0 = /(\.0+)+$/;
  const segmentsA = a.replace(regExStrip0, '').split('.');
  const segmentsB = b.replace(regExStrip0, '').split('.');
  const l = Math.min(segmentsA.length, segmentsB.length);

  for (i = 0; i < l; i++) {
    diff = parseInt(segmentsA[i], 10) - parseInt(segmentsB[i], 10);
    if (diff) {
      return diff;
    }
  }
  return segmentsA.length - segmentsB.length;
};

//      

const swarmKey = KEYUTIL.getKey(swarmPublicKey);
const MINIMUM_WAZO_ENGINE_VERSION_FOR_DEFAULT_CONTEXT = '19.08';

                 
         
                 
                        
                           
                      
                      
                    
                       
                            
                
                   
                        
                 
                         
                            
                             
                       
                                      
                     
      
    
  

                      
               
                                                  
                   
  

                         
                
                 
                       
                     
                  
                                        
                          
  

class Session {
                
                
                      
                         
                    
                  
                                       

  static parse(plain          )           {
    const token = plain.data.metadata ? plain.data.metadata.jwt : null;
    let authorizations = [];

    // Add authorizations from JWT
    if (token) {
      const isValid = jws.JWS.verifyJWT(token, swarmKey, { alg: ['RS256'], verifyAt: new Date() });
      if (isValid) {
        const decodedToken = jws.JWS.readSafeJSONString(b64utoutf8(token.split('.')[1]));
        authorizations = decodedToken ? decodedToken.authorizations : [];
      }
    }

    return new Session({
      token: plain.data.token,
      uuid: plain.data.metadata ? plain.data.metadata.uuid : null,
      authorizations,
      tenantUuid: plain.data.metadata ? plain.data.metadata.tenant_uuid : undefined,
      expiresAt: new Date(`${plain.data.utc_expires_at}z`),
    });
  }

  static newFrom(profile         ) {
    return newFrom(profile, Session);
  }

  constructor({ token, uuid, tenantUuid, profile, expiresAt, authorizations, engineVersion }                   = {}) {
    this.token = token;
    this.uuid = uuid;
    this.tenantUuid = tenantUuid || null;
    this.profile = profile;
    this.expiresAt = expiresAt;
    this.authorizations = authorizations || [];
    this.engineVersion = engineVersion;
  }

  hasExpired(date       = new Date())          {
    return date >= this.expiresAt;
  }

  is(contact         )          {
    return Boolean(contact) && this.uuid === contact.uuid;
  }

  using(profile         )          {
    this.profile = profile;

    return this;
  }

  hasAuthorizations() {
    return this.authorizations && !!this.authorizations.length;
  }

  displayName()         {
    return this.profile ? `${this.profile.firstName} ${this.profile.lastName}` : '';
  }

  hasAccessToVoicemail()          {
    if (!this.profile) {
      return false;
    }
    return !!this.profile.voicemail;
  }

  primaryLine()        {
    return this.profile && this.profile.lines.length > 0 ? this.profile.lines[0] : null;
  }

  primaryContext()         {
    if (this.engineVersion) {
      if (this.hasEngineVersionGte(MINIMUM_WAZO_ENGINE_VERSION_FOR_DEFAULT_CONTEXT)) {
        return 'default';
      }
    }

    const line = this.primaryLine();

    return line && line.extensions.length > 0 ? line.extensions[0].context : 'default';
  }

  hasEngineVersionGte(version        ) {
    return this.engineVersion && compareVersions(String(this.engineVersion), String(version)) >= 0;
  }

  primaryNumber()          {
    const line = this.primaryLine();

    return line ? line.extensions[0].exten : null;
  }

  allLines()         {
    return this.profile ? this.profile.lines || [] : [];
  }

  allNumbers()           {
    const extensions = this.allLines().map(line => line.extensions.map(extension => extension.exten));
    if (!extensions.length) {
      return [];
    }

    return extensions.reduce((a, b) => a.concat(b));
  }

  hasExtension(extension        )          {
    return this.allNumbers().some(number => number === extension);
  }
}

/*       */

const DEFAULT_BACKEND_USER = 'wazo_user';
const DETAULT_EXPIRATION = 3600;

var authMethods = (client              , baseUrl        ) => ({
  checkToken(token       )                   {
    return client.head(`${baseUrl}/token/${token}`, null, {});
  },

  authenticate(token       )                    {
    return client.get(`${baseUrl}/token/${token}`, null, {}).then(response => Session.parse(response));
  },

  logIn(params   
                     
                     
                    
                       
                     
   )                    {
    const body = {
      backend: params.backend || DEFAULT_BACKEND_USER,
      expiration: params.expiration || DETAULT_EXPIRATION,
    };
    const headers         = {
      Authorization: `Basic ${ApiRequester.base64Encode(`${params.username}:${params.password}`)}`,
      'Content-Type': 'application/json',
    };

    if (params.mobile) {
      headers['Wazo-Session-Type'] = 'mobile';
    }

    return client.post(`${baseUrl}/token`, body, headers).then(response => Session.parse(response));
  },

  logOut(token       )                          {
    return client.delete(`${baseUrl}/token/${token}`, null, {}, ApiRequester.successResponseParser);
  },

  updatePassword(token       , userUuid      , oldPassword        , newPassword        )                   {
    const body = {
      new_password: newPassword,
      old_password: oldPassword,
    };

    return client.put(`${baseUrl}/users/${userUuid}/password`, body, token, ApiRequester.successResponseParser);
  },

  sendDeviceToken(token       , userUuid      , deviceToken        , apnsToken         ) {
    const body         = {
      token: deviceToken,
    };

    if (apnsToken) {
      body.apns_token = apnsToken;
    }

    return client.post(`${baseUrl}/users/${userUuid}/external/mobile`, body, token);
  },

  getPushNotificationSenderId(token       , userUuid      ) {
    return client
      .get(`${baseUrl}/users/${userUuid}/external/mobile/sender_id`, null, token)
      .then(response => response.sender_id);
  },

  /**
   * `username` or `email` should be set.
   */
  sendResetPasswordEmail({ username, email }                                       ) {
    const body = {};
    if (username) {
      body.username = username;
    }
    if (email) {
      body.email = email;
    }

    return client.get(`${baseUrl}/users/password/reset`, body, {}, ApiRequester.successResponseParser);
  },

  resetPassword(token        , userUuid        , password        ) {
    const body = {
      password,
    };

    return client.post(
      `${baseUrl}/users/password/reset?user_uuid=${userUuid}`,
      body,
      token,
      ApiRequester.successResponseParser,
    );
  },

  removeDeviceToken(token       , userUuid      ) {
    return client.delete(`${baseUrl}/users/${userUuid}/external/mobile`, null, token);
  },

  createUser(
    token       ,
    username        ,
    password        ,
    firstname        ,
    lastname        ,
  )                               {
    const body = {
      username,
      password,
      firstname,
      lastname,
    };

    return client.post(`${baseUrl}/users`, body, token);
  },

  addUserEmail(token       , userUuid      , email        , main          ) {
    const body = {
      emails: [
        {
          address: email,
          main,
        },
      ],
    };

    return client.put(`${baseUrl}/users/${userUuid}/emails`, body, token);
  },

  addUserPolicy(token       , userUuid      , policyUuid      ) {
    return client.put(`${baseUrl}/users/${userUuid}/policies/${policyUuid}`, null, token);
  },

  deleteUserPolicy(token       , userUuid      , policyUuid      ) {
    return client.delete(`${baseUrl}/users/${userUuid}/policies/${policyUuid}`, null, token);
  },

  addUserGroup(token       , userUuid      , groupUuid      ) {
    return client.put(`${baseUrl}/groups/${groupUuid}/users/${userUuid}`, null, token);
  },

  listUsersGroup(token       , groupUuid      ) {
    return client.get(`${baseUrl}/groups/${groupUuid}/users`, null, token);
  },

  deleteUserGroup(token       , userUuid      , groupUuid      ) {
    return client.delete(`${baseUrl}/groups/${groupUuid}/users/${userUuid}`, null, token);
  },

  getUser(token       , userUuid      )                           {
    return client.get(`${baseUrl}/users/${userUuid}`, null, token);
  },

  getUserSession(token       , userUuid      ) {
    return client.get(`${baseUrl}/users/${userUuid}/sessions`, null, token);
  },

  listUsers(token       )                             {
    return client.get(`${baseUrl}/users`, null, token);
  },

  deleteUser(token       , userUuid      )                                  {
    return client.delete(`${baseUrl}/users/${userUuid}`, null, token);
  },

  listTenants(token       )                               {
    return client.get(`${baseUrl}/tenants`, null, token);
  },

  getTenant(token       , tenantUuid      )                             {
    return client.get(`${baseUrl}/tenants/${tenantUuid}`, null, token);
  },

  createTenant(token       , name        )                                 {
    return client.post(`${baseUrl}/tenants`, { name }, token);
  },

  updateTenant(
    token       ,
    uuid      ,
    name        ,
    contact        ,
    phone        ,
    address               ,
  )                                 {
    const body = {
      name,
      contact,
      phone,
      address,
    };

    return client.put(`${baseUrl}/tenants/${uuid}`, body, token);
  },

  deleteTenant(token       , uuid      )                                  {
    return client.delete(`${baseUrl}/tenants/${uuid}`, null, token);
  },

  createGroup(token       , name        ) {
    return client.post(`${baseUrl}/groups`, { name }, token);
  },

  listGroups(token       )                              {
    return client.get(`${baseUrl}/groups`, null, token);
  },

  deleteGroup(token       , uuid      )                                  {
    return client.delete(`${baseUrl}/groups/${uuid}`, null, token);
  },

  createPolicy(token       , name        , description        , aclTemplates               ) {
    const body = {
      name,
      description,
      acl_templates: aclTemplates,
    };

    return client.post(`${baseUrl}/policies`, body, token);
  },

  listPolicies(token       )                                {
    return client.get(`${baseUrl}/policies`, null, token);
  },

  deletePolicy(token       , policyUuid      )                                  {
    return client.delete(`${baseUrl}/policies/${policyUuid}`, null, token);
  },

  getProviders(token       , userUuid      ) {
    return client.get(`${baseUrl}/users/${userUuid}/external`, null, token);
  },

  getProviderToken(token       , userUuid      , provider        ) {
    return client.get(`${baseUrl}/users/${userUuid}/external/${provider}`, null, token);
  },

  getProviderAuthUrl(token       , userUuid      , provider        ) {
    return client.post(`${baseUrl}/users/${userUuid}/external/${provider}`, {}, token);
  },

  deleteProviderToken(token       , userUuid      , provider        ) {
    return client.delete(`${baseUrl}/users/${userUuid}/external/${provider}`, null, token);
  },
});

/*       */
                                                                                       

var applicationMethods = (client              , baseUrl        ) => ({
  answerCall(
    token        ,
    applicationUuid        ,
    callId        ,
    context        ,
    exten        ,
    autoanswer        ,
    displayed_caller_id_number         ,
  ) {
    const url = `${baseUrl}/${applicationUuid}/nodes`;
    const body = { calls: [{ id: callId }] };

    return client
      .post(url, body, token, res => res.json().then(response => response.uuid))
      .then(nodeUuid =>
        client
          .post(`${url}/${nodeUuid}/calls`, { context, exten, autoanswer, displayed_caller_id_number }, token)
          .then(data => ({
            nodeUuid,
            data,
          })));
  },

  calls(token       , applicationUuid        ) {
    return client.get(`${baseUrl}/${applicationUuid}/calls`, null, token);
  },

  hangupCall(token       , applicationUuid        , callId        ) {
    const url = `${baseUrl}/${applicationUuid}/calls/${callId}`;

    return client.delete(url, null, token);
  },

  playCall(token       , applicationUuid        , callId        , language        , uri        ) {
    return client.post(`${baseUrl}/${applicationUuid}/calls/${callId}/playbacks`, { language, uri }, token);
  },

  addCallNodes(token       , applicationUuid        , nodeUuid        , callId        )                   {
    return client.put(`${baseUrl}/${applicationUuid}/nodes/${nodeUuid}/calls/${callId}`, null, token);
  },

  addNewCallNodes(
    token       ,
    applicationUuid        ,
    nodeUuid        ,
    context        ,
    exten        ,
    autoanswer        ,
  ) {
    const data = { context, exten, autoanswer };

    return client.post(`${baseUrl}/${applicationUuid}/nodes/${nodeUuid}/calls`, data, token);
  },

  listCallsNodes(token       , applicationUuid        , nodeUuid        )                                 {
    return client.get(`${baseUrl}/${applicationUuid}/nodes/${nodeUuid}`, null, token);
  },

  listNodes(token       , applicationUuid        )                             {
    return client.get(`${baseUrl}/${applicationUuid}/nodes`, null, token);
  },

  removeNode(token       , applicationUuid        , nodeUuid        ) {
    return client.delete(`${baseUrl}/${applicationUuid}/nodes/${nodeUuid}`, null, token);
  },

  removeCallNodes(token       , applicationUuid        , nodeUuid        , callId        ) {
    return client.delete(`${baseUrl}/${applicationUuid}/nodes/${nodeUuid}/calls/${callId}`, null, token);
  },
});

/*       */

var confdMethods = (client              , baseUrl        ) => ({
  listUsers(token       )                                  {
    return client.get(`${baseUrl}/users`, null, token);
  },

  getUser(token       , userUuid        )                   {
    return client.get(`${baseUrl}/users/${userUuid}`, null, token).then(response => Profile.parse(response));
  },

  updateUser(token       , userUuid        , profile         )                   {
    const body = {
      firstname: profile.firstName,
      lastname: profile.lastName,
      email: profile.email,
      mobile_phone_number: profile.mobileNumber,
    };

    return client.put(`${baseUrl}/users/${userUuid}`, body, token, ApiRequester.successResponseParser);
  },

  updateForwardOption(
    token       ,
    userUuid        ,
    key        ,
    destination        ,
    enabled         ,
  )                   {
    const url = `${baseUrl}/users/${userUuid}/forwards/${key}`;
    return client.put(url, { destination, enabled }, token, ApiRequester.successResponseParser);
  },

  updateDoNotDisturb(token       , userUuid      , enabled         )                   {
    const url = `${baseUrl}/users/${userUuid}/services/dnd`;

    return client.put(url, { enabled }, token, ApiRequester.successResponseParser);
  },

  // @TODO: type response
  getUserLineSip(token       , userUuid        , lineId        ) {
    return client.get(`${baseUrl}/users/${userUuid}/lines/${lineId}/associated/endpoints/sip`, null, token);
  },

  getUserLineSipFromToken(token       , userUuid        ) {
    return this.getUser(token, userUuid).then(user => {
      if (!user.lines.length) {
        console.warn(`No sip line for user: ${userUuid}`);
        return null;
      }
      const line = user.lines[0];

      return this.getUserLineSip(token, userUuid, line.id);
    });
  },

  listApplications(token       )                                    {
    const url = `${baseUrl}/applications?recurse=true`;

    return client.get(url, null, token);
  },

  getSIP(token       , userUuid      , lineId        )                        {
    return client.get(`${baseUrl}/users/${userUuid}/lines/${lineId}/associated/endpoints/sip`, null, token);
  },

  getInfos(token       )                                                  {
    return client.get(`${baseUrl}/infos`, null, token);
  },
});

/*       */

var accessdMethods = (client              , baseUrl        ) => ({
  listSubscriptions(token        ) {
    return client.get(`${baseUrl}/subscriptions?recurse=true`, null, token);
  },
  createSubscription(token        , { productSku, name, startDate, contractDate, autoRenew, term }        ) {
    const body = {
      product_sku: productSku,
      name,
      start_date: startDate,
      contract_date: contractDate,
      auto_renew: autoRenew,
      term,
    };

    return client.post(`${baseUrl}/subscriptions`, body, token);
  },
  getSubscription(token        , uuid        ) {
    return client.get(`${baseUrl}/subscriptions/${uuid}`, null, token);
  },
  deleteSubscription(token        , uuid        ) {
    return client.delete(`${baseUrl}/subscriptions/${uuid}`, null, token);
  },
  createSubscriptionToken(token        ) {
    return client.post(`${baseUrl}/subscriptions/token`, null, token);
  },
  listAuthorizations(token        , subscriptionUuid        ) {
    return client.get(`${baseUrl}/subscriptions/${subscriptionUuid}/authorizations`, null, token);
  },
  getAuthorization(token        , subscriptionUuid        , uuid        ) {
    return client.get(`${baseUrl}/subscriptions/${subscriptionUuid}/authorizations/${uuid}`, null, token);
  },
  deleteAuthorization(token        , subscriptionUuid        , uuid        ) {
    return client.delete(`${baseUrl}/subscriptions/${subscriptionUuid}/authorizations/${uuid}`, null, token);
  },
  createAuthorization(token        , subscriptionUuid        , { startDate, term, service, rules, autoRenew }        ) {
    const url = `${baseUrl}/subscriptions/${subscriptionUuid}/authorizations`;
    const body = {
      start_date: startDate,
      term,
      service,
      rules,
      auto_renew: autoRenew,
    };

    return client.post(url, body, token);
  },
});

//      

                                  
                             
                    
                         
                         
                         
                  
  

                            
                         
                          
                          
  

class Relocation {
                                             

                        

                        

                        

  static parse(response                    ) {
    return new Relocation({
      initiatorCall: response.initiator_call,
      recipientCall: response.recipient_call,
      relocatedCall: response.relocated_call,
    });
  }

  constructor({ relocatedCall, initiatorCall, recipientCall }                     ) {
    this.initiatorCall = initiatorCall || '';
    this.relocatedCall = relocatedCall || '';
    this.recipientCall = recipientCall || '';
  }
}

Relocation.MIN_ENGINE_VERSION_REQUIRED = '19.09';

//      

                        
                      
               
                    
  

                                       
                
  

                                   
                
                  
                     
                      
                    
               
                    
                                 
  

                                       
                   
                
                                    
  

class ChatMessage {
               

               
                  
             
                
                   
                    
                

  static parseMany(plain                         )                     {
    return plain.items.map(item => ChatMessage.parse(item));
  }

  static parse(plain                     )              {
    return new ChatMessage({
      uuid: plain.uuid,
      date: moment(plain.created_at).toDate(),
      content: plain.content,
      alias: plain.alias,
      userUuid: plain.user_uuid,
      read: true,
      roomUuid: plain.room ? plain.room.uuid : null,
    });
  }

  static newFrom(message             ) {
    return newFrom(message, ChatMessage);
  }

  constructor({ uuid, date, content, userUuid, alias, roomUuid, read }         = {}) {
    this.uuid = uuid;
    this.date = date;
    this.content = content;
    this.userUuid = userUuid;
    this.alias = alias;
    this.roomUuid = roomUuid;

    // @TODO: change after message read status available
    this.read = read;

    // Useful to compare instead of instanceof with minified code
    this.type = 'ChatMessage';
  }

  is(other             ) {
    return this.uuid === other.uuid;
  }

  isIncoming(userUuid        ) {
    return this.userUuid !== userUuid;
  }

  acknowledge() {
    // @TODO: change after message read status available
    this.read = true;
    return this;
  }
}

//      

                        
                         
                        
                   
             
                  
                    
  

                 
             
               
                 
                  
               
                 
                 
                                     
     
  

                           
             
             
                   
           
                 
                   
    
                    
  

class Voicemail {
               

             
             
                   
                   
           
                 
                   
    

  static parse(plain                 )            {
    return new Voicemail({
      id: plain.id,
      date: moment(plain.timestamp * 1000).toDate(),
      duration: plain.duration * 1000,
      caller: {
        name: plain.caller_id_name,
        number: plain.caller_id_num,
      },
      unread: plain.folder ? plain.folder.type === 'new' : null,
    });
  }

  static parseMany(plain          )                   {
    const plainUnread = plain.folders.filter(folder => folder.type === 'new')[0].messages;
    const plainRead = plain.folders.filter(folder => folder.type === 'old')[0].messages;

    const unread = plainUnread.map(message => Voicemail.parse(message)).map(voicemail => voicemail.makeAsUnRead());
    const read = plainRead.map(message => Voicemail.parse(message)).map(voicemail => voicemail.acknowledge());

    return [...unread, ...read];
  }

  static newFrom(profile           ) {
    return newFrom(profile, Voicemail);
  }

  constructor({ id, date, duration, caller, unread }                     = {}) {
    this.id = id;
    this.date = date;
    this.duration = duration;
    this.caller = caller;
    this.unread = unread;

    // Useful to compare instead of instanceof with minified code
    this.type = 'Voicemail';
  }

  is(other           )          {
    return other && this.id === other.id;
  }

  acknowledge() {
    this.unread = false;

    return this;
  }

  makeAsUnRead() {
    this.unread = true;

    return this;
  }

  contains(query        )          {
    if (!query) {
      return true;
    }

    return this.caller.name.toUpperCase().includes(query.toUpperCase()) || this.caller.number.includes(query);
  }
}

//      

                     
                  
                      
                         
                           
                              
                                
                           
                 
                     
                        
                   
  

                      
             
                    
                    
                     
                       
                     
                       
                          
                  
                 
                     
  

class Call {
               

             
                    
                     
                       
                     
                       
                          
                    
                  
                 
                     

  static parseMany(plain                     )              {
    return plain.map((plainCall              ) => Call.parse(plainCall));
  }

  static parse(plain              )       {
    return new Call({
      id: plain.call_id,
      sipCallId: plain.sip_call_id,
      callerName: plain.caller_id_name,
      callerNumber: plain.caller_id_number,
      calleeName: plain.peer_caller_id_name,
      calleeNumber: plain.peer_caller_id_number,
      dialedExtension: plain.dialed_extension,
      isCaller: plain.is_caller,
      onHold: plain.on_hold,
      status: plain.status,
      startingTime: moment(plain.creation_time).toDate(),
    });
  }

  static newFrom(call      ) {
    return newFrom(call, Call);
  }

  constructor({
    id,
    sipCallId,
    callerName,
    callerNumber,
    calleeName,
    calleeNumber,
    dialedExtension,
    isCaller,
    onHold,
    status,
    startingTime,
  }                = {}) {
    this.id = id;
    this.sipCallId = sipCallId;
    this.callerName = callerName;
    this.callerNumber = callerNumber;
    this.calleeName = calleeName;
    this.calleeNumber = calleeNumber;
    this.dialedExtension = dialedExtension;
    this.onHold = onHold;
    this.isCaller = isCaller;
    this.status = status;
    this.startingTime = startingTime;

    // Useful to compare instead of instanceof with minified code
    this.type = 'Call';
  }

  getElapsedTimeInSeconds()         {
    const now = Date.now();
    return (now - this.startingTime) / 1000;
  }

  separateCalleeName()                                          {
    const names = this.calleeName.split(' ');
    const firstName = names[0];
    const lastName = names.slice(1).join(' ');

    return { firstName, lastName };
  }

  is(other       )          {
    return !!other && this.id === other.id;
  }

  hasACalleeName()          {
    return this.calleeName.length > 0;
  }

  hasNumber(number        )          {
    return this.calleeNumber === number;
  }

  isUp()          {
    return this.status === 'Up';
  }

  isDown()          {
    return this.status === 'Down';
  }

  isRinging()          {
    return this.isRingingIncoming() || this.isRingingOutgoing();
  }

  isRingingIncoming()          {
    return this.status === 'Ringing';
  }

  isRingingOutgoing()          {
    return this.status === 'Ring';
  }

  isFromTransfer()          {
    return this.status === 'Down' || this.status === 'Ringing';
  }

  isOnHold()          {
    return this.onHold;
  }

  putOnHold()       {
    this.onHold = true;
  }

  resume()       {
    this.onHold = false;
  }
}

/*       */

                  
                       
                    
                   
  

var ctidNgMethods = (client              , baseUrl        ) => ({
  updatePresence(token       , presence        )                   {
    return client.put(`${baseUrl}/users/me/presences`, { presence }, token, ApiRequester.successResponseParser);
  },

  listMessages(token       , participantUuid       , limit         )                              {
    const query         = {};

    if (participantUuid) {
      query.participant_user_uuid = participantUuid;
    }

    if (limit) {
      query.limit = limit;
    }

    return client.get(`${baseUrl}/users/me/chats`, query, token).then(response => ChatMessage.parseMany(response));
  },

  sendMessage(token       , alias        , msg        , toUserId        ) {
    const body = { alias, msg, to: toUserId };

    return client.post(`${baseUrl}/users/me/chats`, body, token, ApiRequester.successResponseParser);
  },

  makeCall(token       , extension        , fromMobile         , lineId         ) {
    const query            = {
      from_mobile: fromMobile,
      extension,
    };

    if (lineId) {
      query.line_id = lineId;
    }
    return client.post(`${baseUrl}/users/me/calls`, query, token);
  },

  cancelCall(token       , callId        )                   {
    return client.delete(`${baseUrl}/users/me/calls/${callId}`, null, token);
  },

  listCalls(token       )                       {
    return client.get(`${baseUrl}/users/me/calls`, null, token).then(response => Call.parseMany(response.items));
  },

  relocateCall(
    token       ,
    callId        ,
    destination        ,
    lineId         ,
    contact          ,
  )                      {
    const body         = {
      completions: ['answer'],
      destination,
      initiator_call: callId,
    };

    if (lineId || contact) {
      body.location = {};
    }

    if (lineId) {
      body.location.line_id = lineId;
    }

    if (contact) {
      body.location.contact = contact;
    }

    return client.post(`${baseUrl}/users/me/relocates`, body, token).then(response => Relocation.parse(response));
  },

  listVoicemails(token       )                                           {
    return client.get(`${baseUrl}/users/me/voicemails`, null, token).then(response => Voicemail.parseMany(response));
  },

  deleteVoicemail(token       , voicemailId        )                   {
    return client.delete(`${baseUrl}/users/me/voicemails/messages/${voicemailId}`, null, token);
  },

  getPresence(token       , contactUuid      )                                                                      {
    return client.get(`${baseUrl}/users/${contactUuid}/presences`, null, token);
  },

  getStatus(token       , lineUuid      ) {
    return client.get(`${baseUrl}/lines/${lineUuid}/presences`, null, token);
  },

  fetchSwitchboardHeldCalls(token       , switchboardUuid      ) {
    return client.get(`${baseUrl}/switchboards/${switchboardUuid}/calls/held`, null, token);
  },

  holdSwitchboardCall(token       , switchboardUuid      , callId        ) {
    return client.put(
      `${baseUrl}/switchboards/${switchboardUuid}/calls/held/${callId}`,
      null,
      token,
      ApiRequester.successResponseParser,
    );
  },

  answerSwitchboardHeldCall(token       , switchboardUuid      , callId        ) {
    return client.put(`${baseUrl}/switchboards/${switchboardUuid}/calls/held/${callId}/answer`, null, token);
  },

  fetchSwitchboardQueuedCalls(token       , switchboardUuid      ) {
    return client.get(`${baseUrl}/switchboards/${switchboardUuid}/calls/queued`, null, token);
  },

  answerSwitchboardQueuedCall(token       , switchboardUuid      , callId        ) {
    return client.put(`${baseUrl}/switchboards/${switchboardUuid}/calls/queued/${callId}/answer`, null, token);
  },

  sendFax(token       , extension        , fax        , callerId          = null) {
    const headers = {
      'Content-type': 'application/pdf',
      'X-Auth-Token': token,
    };
    const params = ApiRequester.getQueryString({ extension, caller_id: callerId });

    return client.post(`${baseUrl}/users/me/faxes?${params}`, fax, headers);
  },
});

/*       */
                                                    
                                                                                   
                                        

const getContactPayload = (contact                      ) => ({
  email: contact.email,
  firstname: contact.firstName ? contact.firstName : '',
  lastname: contact.lastName ? contact.lastName : '',
  number: contact.phoneNumber ? contact.phoneNumber : '',
  entreprise: contact.entreprise ? contact.entreprise : '',
  birthday: contact.birthday ? contact.birthday : '',
  address: contact.address ? contact.address : '',
  note: contact.note ? contact.note : '',
});

                                 
                 
                             
                 
                  
                  
         

var dirdMethods = (client              , baseUrl        ) => ({
  search(token       , context        , term        )                          {
    return client
      .get(`${baseUrl}/directories/lookup/${context}`, { term }, token)
      .then(response => Contact.parseMany(response));
  },

  listPersonalContacts(token       , queryParams                           = null)                          {
    return client
      .get(`${baseUrl}/personal`, queryParams, token)
      .then(response => Contact.parseManyPersonal(response.items));
  },

  addContact(token       , contact            )                   {
    return client
      .post(`${baseUrl}/personal`, getContactPayload(contact), token)
      .then(response => Contact.parsePersonal(response));
  },

  editContact(token       , contact         )                   {
    return client
      .put(`${baseUrl}/personal/${contact.sourceId || contact.id || ''}`, getContactPayload(contact), token)
      .then(response => Contact.parsePersonal(response));
  },

  deleteContact(token       , contactUuid      ) {
    return client.delete(`${baseUrl}/personal/${contactUuid}`, null, token);
  },

  listFavorites(token       , context        )                          {
    return client
      .get(`${baseUrl}/directories/favorites/${context}`, null, token)
      .then(response => Contact.parseMany(response));
  },

  markAsFavorite(token       , source        , sourceId        )                   {
    const url = `${baseUrl}/directories/favorites/${source}/${sourceId}`;

    return client.put(url, null, token, ApiRequester.successResponseParser);
  },

  removeFavorite(token       , source        , sourceId        ) {
    return client.delete(`${baseUrl}/directories/favorites/${source}/${sourceId}`, null, token);
  },

  fetchOffice365Source(token       , context        )                            {
    return client
      .get(`${baseUrl}/directories/${context}/sources`, { backend: 'office365' }, token)
      .then(response => response);
  },

  fetchOffice365Contacts(
    token       ,
    source                 ,
    queryParams                           = null,
  )                     {
    return client
      .get(`${baseUrl}/backends/office365/sources/${source.uuid}/contacts`, queryParams, token)
      .then(response => Contact.parseManyOffice365(response.items, source));
  },

  fetchWazoSource(token       , context        )                   {
    return client
      .get(`${baseUrl}/directories/${context}/sources`, { backend: 'wazo' }, token)
      .then(response => response);
  },

  fetchWazoContacts(
    token       ,
    source                 ,
    queryParams                           = null,
  )                     {
    return client
      .get(`${baseUrl}/backends/wazo/sources/${source.uuid}/contacts`, queryParams, token)
      .then(response => Contact.parseManyWazo(response.items, source));
  },

  fetchGoogleSource(token       , context        )                   {
    return client
      .get(`${baseUrl}/directories/${context}/sources`, { backend: 'google' }, token)
      .then(response => response);
  },

  fetchGoogleContacts(
    token       ,
    source                 ,
    queryParams                           = null,
  )                     {
    return client
      .get(`${baseUrl}/backends/google/sources/${source.uuid}/contacts`, queryParams, token)
      .then(response => Contact.parseManyGoogle(response.items, source));
  },

  fetchConferenceSource(token       , context        )                   {
    return client
      .get(`${baseUrl}/directories/${context}/sources`, { backend: 'conference' }, token)
      .then(response => response);
  },

  fetchConferenceContacts(token       , source                 )                     {
    return client
      .get(`${baseUrl}/backends/conference/sources/${source.uuid}/contacts`, null, token)
      .then(response => Contact.parseManyConference(response.items, source));
  },
});

//      

                        
                 
                    
                         
                                
                            
                   
              
             
                           
                      
                
  

                 
                   
                                
                
  

                         
               
                    
                          
                        
                
                      
                 
    
           
                      
                 
    
             
                   
              
            
  

class CallLog {
               

               
                    
                         
                        
                
                      
                 
    

           
                      
                 
    

             
                   
              
            

  static merge(current                , toMerge                )                  {
    const onlyUnique = (value, index, self) => self.indexOf(value) === index;

    const allLogs                 = current.concat(toMerge);
    const onlyUniqueIds                = allLogs.map(c => c.id).filter(onlyUnique);

    return onlyUniqueIds.map(id => allLogs.find(log => log.id === id));
  }

  static parseMany(plain          )                 {
    return plain.items.map(item => CallLog.parse(item));
  }

  static parse(plain                 )          {
    return new CallLog({
      answer: moment(plain.answer).toDate(),
      answered: plain.answered,
      callDirection: plain.call_direction,
      destination: {
        extension: plain.destination_extension,
        name: plain.destination_name || '',
      },
      source: {
        extension: plain.source_extension,
        name: plain.source_name,
      },
      id: plain.id,
      duration: (plain.duration || 0) * 1000, // duration is in seconds
      start: moment(plain.start).toDate(),
      end: moment(plain.end).toDate(),
    });
  }

  static parseNew(plain                 , session         )          {
    return new CallLog({
      answer: moment(plain.answer).toDate(),
      answered: plain.answered,
      callDirection: plain.call_direction,
      destination: {
        extension: plain.destination_extension,
        name: plain.destination_name || '',
      },
      source: {
        extension: plain.source_extension,
        name: plain.source_name,
      },
      id: plain.id,
      duration: (plain.duration || 0) * 1000, // duration is in seconds
      start: moment(plain.start).toDate(),
      end: moment(plain.end).toDate(),
      // @TODO: FIXME add verification declined vs missed call
      newMissedCall: session.hasExtension(plain.destination_extension) && !plain.answered,
    });
  }

  static newFrom(profile         ) {
    return newFrom(profile, CallLog);
  }

  constructor({
    answer,
    answered,
    callDirection,
    destination,
    source,
    id,
    duration,
    start,
    end,
  }                   = {}) {
    this.answer = answer;
    this.answered = answered;
    this.callDirection = callDirection;
    this.destination = destination;
    this.source = source;
    this.id = id;
    this.duration = duration;
    this.start = start;
    this.end = end;

    // Useful to compare instead of instanceof with minified code
    this.type = 'CallLog';
  }

  isFromSameParty(other         , session         )          {
    return this.theOtherParty(session).extension === other.theOtherParty(session).extension;
  }

  theOtherParty(session         )                                      {
    if (session.hasExtension(this.source.extension)) {
      return this.destination;
    }
    return this.source;
  }

  isNewMissedCall()          {
    return this.newMissedCall;
  }

  acknowledgeCall()          {
    this.newMissedCall = false;

    return this;
  }

  isAcknowledged()          {
    return this.newMissedCall;
  }

  isAnswered()          {
    return this.answered;
  }

  isOutgoing(session         )          {
    if (this.callDirection === 'internal') {
      return session.hasExtension(this.source.extension);
    }

    return this.callDirection === 'outbound';
  }

  isIncoming(session         )          {
    if (this.callDirection === 'internal') {
      return session.hasExtension(this.destination.extension);
    }

    return this.callDirection === 'inbound';
  }

  isAnOutgoingCall(session         )          {
    console.warn(`@wazo/sdk 
      CallLog.isAnOutgoingcall(session) method is obsolete.
      Please use CallLog.isOutgoing(session).
    `);

    return session.hasExtension(this.source.extension) && this.answered;
  }

  isAMissedOutgoingCall(session         )          {
    return session.hasExtension(this.source.extension) && !this.answered;
  }

  isAnIncomingCall(session         )          {
    console.warn(`@wazo/sdk
      CallLog.isAnIncomingCall(session) method is obsolete.
      Please use CallLog.isIncoming(session).
    `);

    return session.hasExtension(this.destination.extension) && this.answered;
  }

  isADeclinedCall(session         )          {
    return !this.answered && session.hasExtension(this.destination.extension);
  }
}

/*       */

var callLogdMethods = (client              , baseUrl        ) => ({
  search(token       , search        , limit         = 5)                          {
    return client
      .get(`${baseUrl}/users/me/cdr`, { search, limit }, token)
      .then(response => CallLog.parseMany(response));
  },

  listCallLogs(token       , offset        , limit         = 5)                          {
    return client
      .get(`${baseUrl}/users/me/cdr`, { offset, limit }, token)
      .then(response => CallLog.parseMany(response));
  },

  listCallLogsFromDate(token       , from      , number        )                          {
    return client
      .get(`${baseUrl}/users/me/cdr`, { from: from.toISOString(), number }, token)
      .then(response => CallLog.parseMany(response));
  },
});

//      

                            
               
               
                         
  

                                
                   
                
                             
  

class ChatRoom {
               

               
               
                         

  static parseMany(plain                  )                  {
    return plain.items.map(item => ChatRoom.parse(item));
  }

  static parse(plain              )           {
    return new ChatRoom({
      uuid: plain.uuid,
      name: plain.name,
      users: plain.users,
    });
  }

  static newFrom(room          ) {
    return newFrom(room, ChatRoom);
  }

  constructor({ uuid, name, users }         = {}) {
    this.uuid = uuid;
    this.name = name;
    this.users = users;

    // Useful to compare instead of instanceof with minified code
    this.type = 'ChatRoom';
  }
}

/*       */

                                
                                              
                                                     
                
                 
                    
  

                             
                   
                
                                 
  

                           
                     
                 
                 
                  
                 
  

var chatdMethods = (client              , baseUrl        ) => ({
  updatePresence: (token       , contactUuid      , state        )                   =>
    client.put(`${baseUrl}/users/${contactUuid}/presences`, { state }, token, ApiRequester.successResponseParser),

  updateStatus: (token       , contactUuid      , state        , status        )                   => {
    const body = { state, status };

    return client.put(`${baseUrl}/users/${contactUuid}/presences`, body, token, ApiRequester.successResponseParser);
  },

  getPresence: async (token       , contactUuid      )                  =>
    client
      .get(`${baseUrl}/users/${contactUuid}/presences`, null, token)
      .then((response                  ) => response.state),

  getContactStatusInfo: async (token       , contactUuid      )                            =>
    client.get(`${baseUrl}/users/${contactUuid}/presences`, null, token).then((response                  ) => response),

  getLineState: async (token       , contactUuid      )                  =>
    client
      .get(`${baseUrl}/users/${contactUuid}/presences`, null, token)
      .then((response                  ) => Profile.getLinesState(response.lines)),

  getMultipleLineState: async (token       , contactUuids             )                  =>
    client
      .get(`${baseUrl}/users/presences`, { user_uuid: contactUuids.join(',') }, token)
      .then((response                      ) => response.items),

  getUserRooms: async (token       )                           =>
    client.get(`${baseUrl}/users/me/rooms`, null, token).then(ChatRoom.parseMany),

  createRoom: async (token       , name        , users                 )                    =>
    client.post(`${baseUrl}/users/me/rooms`, { name, users }, token).then(ChatRoom.parse),

  getRoomMessages: async (token       , roomUuid        )                              =>
    client
      .get(`${baseUrl}/users/me/rooms/${roomUuid}/messages`, null, token)
      .then((response                         ) => ChatMessage.parseMany(response)),

  sendRoomMessage: async (token       , roomUuid        , message             )                       =>
    client.post(`${baseUrl}/users/me/rooms/${roomUuid}/messages`, message, token).then(ChatMessage.parse),

  getMessages: async (token       , options                    )                       =>
    client.get(`${baseUrl}/users/me/rooms/messages`, options, token),
});

/*       */
                                             
                                                                   

var calldMethods = (client              , baseUrl        ) => ({
  getConferenceParticipantsAsUser: async (token       , conferenceId        )                                  =>
    client.get(`${baseUrl}/users/me/conferences/${conferenceId}/participants`, null, token),
});

/*       */

const AUTH_VERSION = '0.1';
const APPLICATION_VERSION = '1.0';
const CONFD_VERSION = '1.1';
const ACCESSD_VERSION = '1.0';
const CTIDNG_VERSION = '1.0';
const DIRD_VERSION = '0.1';
const CALL_LOGD_VERSION = '1.0';
const CHATD_VERSION = '1.0';
const CALLD_VERSION = '1.0';

class ApiClient {
                       
               
                      
                
                  
                 
               
                   
                
                

  // @see https://github.com/facebook/flow/issues/183#issuecomment-358607052
  constructor({ server, agent = null }                                               ) {
    this.updatePatemers({ server, agent });
  }

  initializeEndpoints()       {
    this.auth = authMethods(this.client, `auth/${AUTH_VERSION}`);
    this.application = applicationMethods(this.client, `ctid-ng/${APPLICATION_VERSION}/applications`);
    this.confd = confdMethods(this.client, `confd/${CONFD_VERSION}`);
    this.accessd = accessdMethods(this.client, `accessd/${ACCESSD_VERSION}`);
    this.ctidNg = ctidNgMethods(this.client, `ctid-ng/${CTIDNG_VERSION}`);
    this.dird = dirdMethods(this.client, `dird/${DIRD_VERSION}`);
    this.callLogd = callLogdMethods(this.client, `call-logd/${CALL_LOGD_VERSION}`);
    this.chatd = chatdMethods(this.client, `chatd/${CHATD_VERSION}`);
    this.calld = calldMethods(this.client, `calld/${CALLD_VERSION}`);
  }

  updatePatemers({ server, agent }                                    ) {
    this.client = new ApiRequester({ server, agent });

    this.initializeEndpoints();
  }
}

/*       */

const clients = {};

var getApiClient = (server        )                => {
  if (server in clients) {
    return clients[server];
  }

  clients[server] = new ApiClient({ server });

  return clients[server];
};

export default getApiClient;
