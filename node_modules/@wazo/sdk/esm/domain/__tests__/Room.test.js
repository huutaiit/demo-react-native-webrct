import 'moment';
import { KEYUTIL } from 'jsrsasign';

//      

var newFrom = (instance     , ToClass     ) => {
  const args = {};
  Object.getOwnPropertyNames(instance).forEach(prop => {
    args[prop] = instance[prop];
  });

  return new ToClass(args);
};

//      

const swarmPublicKey  = `-----BEGIN PUBLIC KEY-----
MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAmkXOuNfY8u5xoTiIhkb8
djnbIwG/Wrz3vpo8BZir8L5e1a1nSy740qBjP7ZINBQoALDhFfmdOfJnCyEGiHuz
ZW6jbG6C3PryE3Bu6GKwqSmD6k3q4Zk27fpwYAnNl+rWhYYM563rJZBda/INyHNN
pK7M1mixWi7gNdjjXwoEXSSBx+VpYMkY6LiAB2mvHXTY9M1qI14dvgGoQISZQoKi
NMTRCg5UP2ic0Dd9nSz/XpcOxGfa+0fwIl1F7RC1tJXOqvkGGPTOV4LLfg/Yta3h
nUPX9EZZDIX6vO/0IBV1LzjSl2A1bYFYAjJfowv3i1CpvONBOClHjSY5t9Y8MH6p
BwIDAQAB
-----END PUBLIC KEY-----`;

//      

const swarmKey = KEYUTIL.getKey(swarmPublicKey);

//      
/* eslint-disable no-param-reassign */

var updateFrom = (instance     , from     ) => {
  Object.keys(from).forEach(key => {
    // $FlowFixMe
    if (
      (!instance[key] && from[key])
      || (typeof instance[key] !== 'undefined' && typeof from[key] !== 'undefined' && instance[key] !== from[key])
    ) {
      // $FlowFixMe
      instance[key] = from[key];
    }
  });
};

//      

                             
                    
              
                 
                       
                         
                                  
                      
                    
                 
                 
                  
                   
                    
                 
                     
                    
  

class CallSession {
              

                 

                      

                 

                       

                    

                    

                    

                          

                   

  // Should be computed ?
                  

                    

                     

                 

                         

               

  constructor({
    answered,
    isCaller,
    displayName,
    callId,
    muted,
    number,
    paused,
    ringing,
    startTime,
    cameraEnabled,
    dialedExtension,
    sipCallId,
    sipStatus,
    callerNumber,
    call,
  }                      ) {
    this.callId = callId;
    this.sipCallId = sipCallId;
    this.displayName = displayName;
    this.number = number;
    this.startTime = startTime;
    this.isCaller = isCaller;
    this.answered = answered;
    this.ringing = ringing;
    this.paused = paused;
    this.muted = muted;
    this.callerNumber = callerNumber;
    this.cameraEnabled = cameraEnabled;
    this.dialedExtension = dialedExtension || '';
    this.call = call;
    this.sipStatus = sipStatus;

    // Useful to compare instead of instanceof with minified code
    this.type = 'CallSession';
  }

  resume() {
    this.paused = false;
  }

  hold() {
    this.paused = true;
  }

  mute() {
    this.muted = true;
  }

  unmute() {
    this.muted = false;
  }

  answer() {
    this.answered = true;
  }

  enableCamera() {
    this.cameraEnabled = true;
  }

  isIncoming()          {
    return !this.isCaller && !this.answered;
  }

  isOutgoing()          {
    return this.isCaller && !this.answered;
  }

  isActive()          {
    return this.answered || this.isOutgoing();
  }

  isAnswered()          {
    return this.answered;
  }

  isRinging()          {
    return this.ringing;
  }

  isOnHold()          {
    return this.paused;
  }

  isMuted()          {
    return this.muted;
  }

  isCameraEnabled()          {
    return this.cameraEnabled;
  }

  hasAnInitialInterceptionNumber()          {
    return this.number.startsWith('*8');
  }

  isAnInterception()          {
    return this.dialedExtension.startsWith('*8');
  }

  getElapsedTimeInSeconds() {
    if (!this.startTime) {
      return 0;
    }
    return (Date.now() - this.startTime) / 1000;
  }

  getId() {
    return this.sipCallId || this.callId;
  }

  is(callSession             ) {
    return this.isId(callSession.getId());
  }

  isId(id        )          {
    return (
      this.getId() === id || (this.sipCallId && this.sipCallId === id) || (Boolean(this.callId) && this.callId === id)
    );
  }

  updateFrom(session             ) {
    updateFrom(this, session);
  }

  separateDisplayName()                                          {
    const names = this.displayName.split(' ');
    const firstName = names[0];
    const lastName = names.slice(1).join(' ');

    return { firstName, lastName };
  }

  static newFrom(callSession             ) {
    return newFrom(callSession, CallSession);
  }

  static parseCall(session         , call      )              {
    return new CallSession({
      callId: call.id,
      sipCallId: call.sipCallId,
      displayName: call.calleeName || call.calleeNumber,
      number: call.calleeNumber,
      callerNumber: call.callerNumber,
      startTime: +call.startingTime,
      paused: call.isOnHold(),
      isCaller: call.isCaller,
      muted: false,
      ringing: call.isRinging(),
      answered: call.isUp(),
      cameraEnabled: false,
      dialedExtension: call.dialedExtension,
      call,
    });
  }
}

//      

                             
                                           
             
                
                                                           
  

// Represents a conference room, like `9000`.
class Room {
             

                                  

                                           

                                                           

  constructor({ id, connectedCallSession, participants, name }               ) {
    this.id = id;
    this.connectedCallSession = connectedCallSession;
    this.participants = participants;
    this.name = name;
  }

  getExtension()                {
    return this.connectedCallSession ? this.connectedCallSession.number : null;
  }

  connect(callSession             )       {
    return new Room({ ...this, connectedCallSession: callSession });
  }

  has(callSession             )          {
    return !!this.connectedCallSession && this.connectedCallSession.is(callSession);
  }

  addParticipant(uuid        , extension        ) {
    if (!this.participants.some(participant => participant.uuid === uuid || participant.extension === extension)) {
      return new Room({ ...this, participants: [...this.participants, { uuid, extension }] });
    }

    return this;
  }

  hasCallWithId(id        )          {
    return !!this.connectedCallSession && this.connectedCallSession.getId() === id;
  }

  disconnect()       {
    return new Room({ ...this, connectedCallSession: null });
  }

  removeParticipantWithUUID(uuid        ) {
    return new Room({
      ...this,
      participants: this.participants.filter(participant => participant.uuid !== uuid),
    });
  }

  removeParticipantWithExtension(extension        ) {
    return new Room({
      ...this,
      participants: this.participants.filter(participant => participant.extension !== extension),
    });
  }

  updateFrom(room      ) {
    updateFrom(this, room);
  }

  static newFrom(room      ) {
    return newFrom(room, Room);
  }
}

describe('Room', () => {
  describe('on get extension', () => {
    describe('given a connected call', () => {
      it('should return the number of the cal', async () => {
        const number = 'some-number';
        const room = new Room({ id: 'some-id', connectedCallSession: new CallSession({ number }), participants: [] });

        const extension = room.getExtension();

        expect(extension).toEqual(number);
      });
    });

    describe('given NO connected call', () => {
      it('should return nothing', async () => {
        const room = new Room({ id: 'some-id', connectedCallSession: null, participants: [] });

        const extension = room.getExtension();

        expect(extension).toBeNull();
      });
    });
  });

  describe('on connect call', () => {
    it('should add call to room', async () => {
      const room = new Room({ id: 'some-id' });
      const callSession = new CallSession({ callId: 'some-call-id' });

      const connectedRoom = room.connect(callSession);

      expect(connectedRoom.connectedCallSession).toBe(callSession);
    });
  });

  describe('on room has call', () => {
    describe('given no connected call', () => {
      it('should be false', async () => {
        const room = new Room({ connectedCallSession: null });
        const callSession = new CallSession({});

        const roomHasCall = room.has(callSession);

        expect(roomHasCall).toBeFalsy();
      });
    });

    describe('given a connected call', () => {
      it('should be true if same calls', async () => {
        const callSession = new CallSession({ callId: 'some-call-id' });
        const room = new Room({ connectedCallSession: callSession });

        const roomHasCall = room.has(callSession);

        expect(roomHasCall).toBeTruthy();
      });

      it('should be false if different calls', async () => {
        const call1 = new CallSession({ callId: 'some-call-id' });
        const call2 = new CallSession({ callId: 'some-other-call-id' });
        const room = new Room({ connectedCallSession: call1 });

        const roomHasCall = room.has(call2);

        expect(roomHasCall).toBeFalsy();
      });
    });
  });

  describe('on add participant', () => {
    it('should add participant to room', async () => {
      const participants = [{}];
      const room = new Room({ connectedCallSession: null, participants });

      const participantUuid = 'some-uuid';
      const participantExtension = 'some-extension';
      const updatedRoom = room.addParticipant(participantUuid, participantExtension);

      expect(updatedRoom.participants[1].uuid).toEqual(participantUuid);
      expect(updatedRoom.participants[1].extension).toEqual(participantExtension);
    });
  });

  describe('on room has call with id', () => {
    describe('given no connected call', () => {
      it('should be false', async () => {
        const room = new Room({ connectedCallSession: null });
        const callId = 'some-call-id';

        const roomHasCall = room.hasCallWithId(callId);

        expect(roomHasCall).toBeFalsy();
      });
    });

    describe('given a connected call', () => {
      it('should be true if same calls', async () => {
        const callId = 'some-call-id';
        const room = new Room({ connectedCallSession: new CallSession({ callId }) });

        const roomHasCall = room.hasCallWithId(callId);

        expect(roomHasCall).toBeTruthy();
      });

      it('should be false if different calls', async () => {
        const callId = 'some-call-id';
        const room = new Room({ connectedCallSession: new CallSession({ callId: 'some-other-call-id' }) });

        const roomHasCall = room.hasCallWithId(callId);

        expect(roomHasCall).toBeFalsy();
      });
    });
  });

  describe('on disconnect', () => {
    it('should destroy connected call', async () => {
      const room = new Room({ connectedCallSession: new CallSession({}) });

      expect(room.connectedCallSession).not.toBeNull();

      const updatedRoom = room.disconnect();

      expect(updatedRoom.connectedCallSession).toBeNull();
    });
  });

  describe('on remove participant with UUID', () => {
    it('should remove participant with corresponding UUID', async () => {
      const uuid = 'some-uuid';
      const room = new Room({ participants: [{ uuid }] });

      expect(room.participants.some(participant => participant.uuid === uuid)).toBeTruthy();

      const updatedRoom = room.removeParticipantWithUUID(uuid);

      expect(updatedRoom.participants.some(participant => participant.uuid === uuid)).toBeFalsy();
    });
  });

  describe('on remove participant with extension', () => {
    it('should remove participant with corresponding UUID', async () => {
      const extension = 'some-extension';
      const room = new Room({ participants: [{ extension }] });

      expect(room.participants.some(participant => participant.extension === extension)).toBeTruthy();

      const updatedRoom = room.removeParticipantWithExtension(extension);

      expect(updatedRoom.participants.some(participant => participant.extension === extension)).toBeFalsy();
    });
  });
});
