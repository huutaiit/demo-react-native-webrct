'use strict';

var jsrsasign = require('jsrsasign');

//      

const swarmPublicKey  = `-----BEGIN PUBLIC KEY-----
MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAmkXOuNfY8u5xoTiIhkb8
djnbIwG/Wrz3vpo8BZir8L5e1a1nSy740qBjP7ZINBQoALDhFfmdOfJnCyEGiHuz
ZW6jbG6C3PryE3Bu6GKwqSmD6k3q4Zk27fpwYAnNl+rWhYYM563rJZBda/INyHNN
pK7M1mixWi7gNdjjXwoEXSSBx+VpYMkY6LiAB2mvHXTY9M1qI14dvgGoQISZQoKi
NMTRCg5UP2ic0Dd9nSz/XpcOxGfa+0fwIl1F7RC1tJXOqvkGGPTOV4LLfg/Yta3h
nUPX9EZZDIX6vO/0IBV1LzjSl2A1bYFYAjJfowv3i1CpvONBOClHjSY5t9Y8MH6p
BwIDAQAB
-----END PUBLIC KEY-----`;

//      

var newFrom = (instance     , ToClass     ) => {
  const args = {};
  Object.getOwnPropertyNames(instance).forEach(prop => {
    args[prop] = instance[prop];
  });

  return new ToClass(args);
};

//      

                  
                  
                
             
                                               
  

                        
             
                                              
                    
  

                     
                             
                           
                          
                               
             
  

                      
             
                               
                                   
                                 
                                
  

class Line {
               

             
                               
                                  
                                
                               

  static parse(plain              )       {
    return new Line({
      id: plain.id,
      extensions: plain.extensions,
      endpointCustom: plain.endpoint_custom || null,
      endpointSccp: plain.endpoint_sccp || null,
      endpointSip: plain.endpoint_sip || null,
    });
  }

  static newFrom(profile      ) {
    return newFrom(profile, Line);
  }

  is(line      ) {
    return this.id === line.id;
  }

  hasExtension(extension        ) {
    return this.extensions.some(ext => ext.exten === extension);
  }

  constructor({ id, extensions, endpointCustom, endpointSccp, endpointSip }                = {}) {
    this.id = id;
    this.extensions = extensions;
    this.endpointCustom = endpointCustom || null;
    this.endpointSccp = endpointSccp || null;
    this.endpointSip = endpointSip || null;

    // Useful to compare instead of instanceof with minified code
    this.type = 'Line';
  }
}

//      

                 
                      
                   
  

const FORWARD_KEYS = {
  BUSY: 'busy',
  NO_ANSWER: 'noanswer',
  UNCONDITIONAL: 'unconditional',
};

                               
                      
                   
              
  

class ForwardOption {
                      
                   
              

  static parse(plain          , key        )                {
    return new ForwardOption({
      destination: plain.destination || '',
      enabled: plain.enabled,
      key,
    });
  }

  static newFrom(profile               ) {
    return newFrom(profile, ForwardOption);
  }

  constructor({ destination, enabled, key }                         = {}) {
    this.destination = destination;
    this.enabled = enabled;
    this.key = key;
  }

  setDestination(number        )                {
    this.destination = number;

    return this;
  }

  setEnabled(enabled         )                {
    this.enabled = enabled;

    return this;
  }

  is(other               ) {
    return this.key === other.key;
  }
}

//      

const LINE_STATE = {
  AVAILABLE: 'available',
  HOLDING: 'holding',
  RINGING: 'ringing',
  TALKING: 'talking',
  UNAVAILABLE: 'unavailable',
};

                        
                                              
                    
                     
                   
                    
               
                
               
                                                                                                                    
                                      
                                    
                                   
     
             
                   
                    
                   
                
             
           
                          
                       
      
               
                          
                       
      
                    
                          
                       
      
    
                               
                             
             
          
                       
      
    
                           
               
               
                 
    
  

                         
             
                    
                   
                
                     
                            
                   
                       
                                 
                         
                 
                 
                            
               
               
                 
    
                           
  

class Profile {
             
                    
                   
                
                     
                           
                   
                       
                                 
                         
                 
                                           
                 
                            
                           

  static parse(plain                 )          {
    return new Profile({
      id: plain.uuid,
      firstName: plain.firstName || plain.firstname || '',
      lastName: plain.lastName || plain.lastname || '',
      email: plain.email,
      lines: plain.lines.map(line => Line.parse(line)),
      username: plain.username,
      mobileNumber: plain.mobile_phone_number || '',
      forwards: [
        ForwardOption.parse(plain.forwards.unconditional, FORWARD_KEYS.UNCONDITIONAL),
        ForwardOption.parse(plain.forwards.noanswer, FORWARD_KEYS.NO_ANSWER),
        ForwardOption.parse(plain.forwards.busy, FORWARD_KEYS.BUSY),
      ],
      doNotDisturb: plain.services.dnd.enabled,
      subscriptionType: plain.subscription_type,
      voicemail: plain.voicemail,
      switchboards: plain.switchboards || [],
      status: '',
    });
  }

  static newFrom(profile         ) {
    return newFrom(profile, Profile);
  }

  constructor({
    id,
    firstName,
    lastName,
    email,
    lines,
    username,
    mobileNumber,
    forwards,
    doNotDisturb,
    state,
    subscriptionType,
    voicemail,
    switchboards,
    status,
    sipLines,
  }                           = {}) {
    this.id = id;
    this.firstName = firstName;
    this.lastName = lastName;
    this.email = email;
    this.lines = lines;
    this.username = username;
    this.mobileNumber = mobileNumber;
    this.forwards = forwards;
    this.doNotDisturb = doNotDisturb;
    this.state = state;
    this.voicemail = voicemail;
    this.subscriptionType = subscriptionType;
    this.switchboards = switchboards;
    this.status = status;

    this.sipLines = sipLines || [];
  }

  static getLinesState(lines               ) {
    let result = LINE_STATE.UNAVAILABLE;

    // eslint-disable-next-line
    for (const line of lines) {
      if (line.state === LINE_STATE.RINGING) {
        result = LINE_STATE.RINGING;
        break;
      }

      if (line.state === LINE_STATE.TALKING) {
        result = LINE_STATE.TALKING;
        break;
      }

      if (line.state === LINE_STATE.AVAILABLE) {
        result = LINE_STATE.AVAILABLE;
      }
    }

    return result;
  }

  hasId(id        ) {
    return id === this.id;
  }

  setMobileNumber(number        ) {
    this.mobileNumber = number;

    return this;
  }

  setForwardOption(forwardOption               ) {
    const updatedForwardOptions = this.forwards.slice();
    const index = updatedForwardOptions.findIndex(forward => forward.is(forwardOption));
    updatedForwardOptions.splice(index, 1, forwardOption);

    this.forwards = updatedForwardOptions;

    return this;
  }

  setDoNotDisturb(enabled         ) {
    this.doNotDisturb = enabled;

    return this;
  }

  setState(state        ) {
    this.state = state;

    return this;
  }
}

// Can't use `semver` package as Wazo version aren't in semver format

const compareVersions = (a, b) => {
  let i;
  let diff;
  const regExStrip0 = /(\.0+)+$/;
  const segmentsA = a.replace(regExStrip0, '').split('.');
  const segmentsB = b.replace(regExStrip0, '').split('.');
  const l = Math.min(segmentsA.length, segmentsB.length);

  for (i = 0; i < l; i++) {
    diff = parseInt(segmentsA[i], 10) - parseInt(segmentsB[i], 10);
    if (diff) {
      return diff;
    }
  }
  return segmentsA.length - segmentsB.length;
};

//      

const swarmKey = jsrsasign.KEYUTIL.getKey(swarmPublicKey);
const MINIMUM_WAZO_ENGINE_VERSION_FOR_DEFAULT_CONTEXT = '19.08';

                 
         
                 
                          
                       
                        
                           
                      
                      
                    
                       
                            
                
                   
                        
                 
                         
                            
                             
                       
                                      
                     
      
    
  

                      
               
                                                  
                   
  

                         
                
                         
                        
                 
                       
                     
                  
                                        
                          
  

class Session {
                
                        
                
                      
                       
                         
                    
                  
                                       

  static parse(plain          )           {
    const token = plain.data.metadata ? plain.data.metadata.jwt : null;
    let authorizations = [];

    // Add authorizations from JWT
    if (token) {
      const isValid = jsrsasign.jws.JWS.verifyJWT(token, swarmKey, { alg: ['RS256'], verifyAt: new Date() });
      if (isValid) {
        const decodedToken = jsrsasign.jws.JWS.readSafeJSONString(jsrsasign.b64utoutf8(token.split('.')[1]));
        authorizations = decodedToken ? decodedToken.authorizations : [];
      }
    }

    return new Session({
      token: plain.data.token,
      refreshToken: plain.data.refresh_token || null,
      uuid: plain.data.metadata ? plain.data.metadata.uuid : null,
      sessionUuid: plain.data.session_uuid,
      authorizations,
      tenantUuid: plain.data.metadata ? plain.data.metadata.tenant_uuid : undefined,
      expiresAt: new Date(`${plain.data.utc_expires_at}z`),
    });
  }

  static newFrom(profile         ) {
    return newFrom(profile, Session);
  }

  constructor({
    token,
    uuid,
    tenantUuid,
    profile,
    expiresAt,
    authorizations,
    engineVersion,
    refreshToken,
    sessionUuid,
  }                   = {}) {
    this.token = token;
    this.uuid = uuid;
    this.tenantUuid = tenantUuid || null;
    this.profile = profile;
    this.expiresAt = expiresAt;
    this.authorizations = authorizations || [];
    this.engineVersion = engineVersion;
    this.refreshToken = refreshToken;
    this.sessionUuid = sessionUuid;
  }

  hasExpired(date       = new Date())          {
    return date >= this.expiresAt;
  }

  is(contact         )          {
    return Boolean(contact) && this.uuid === contact.uuid;
  }

  using(profile         )          {
    this.profile = profile;

    return this;
  }

  hasAuthorizations() {
    return this.authorizations && !!this.authorizations.length;
  }

  displayName()         {
    return this.profile ? `${this.profile.firstName} ${this.profile.lastName}` : '';
  }

  hasAccessToVoicemail()          {
    if (!this.profile) {
      return false;
    }
    return !!this.profile.voicemail;
  }

  primaryLine()        {
    return this.profile && this.profile.lines.length > 0 ? this.profile.lines[0] : null;
  }

  primarySipLine()           {
    return this.profile && this.profile.sipLines.length > 0 ? this.profile.sipLines[0] : null;
  }

  primaryWebRtcLine()           {
    return this.profile && this.profile.sipLines.find(sipLine => sipLine.isWebRtc());
  }

  primaryCtiLine()           {
    return this.profile && this.profile.sipLines.find(sipLine => !sipLine.isWebRtc());
  }

  primaryContext()         {
    if (this.engineVersion) {
      if (this.hasEngineVersionGte(MINIMUM_WAZO_ENGINE_VERSION_FOR_DEFAULT_CONTEXT)) {
        return 'default';
      }
    }

    const line = this.primaryLine();

    return line && line.extensions.length > 0 ? line.extensions[0].context : 'default';
  }

  hasEngineVersionGte(version        ) {
    return this.engineVersion && compareVersions(String(this.engineVersion), String(version)) >= 0;
  }

  primaryNumber()          {
    const line = this.primaryLine();

    return line ? line.extensions[0].exten : null;
  }

  allLines()         {
    return this.profile ? this.profile.lines || [] : [];
  }

  allNumbers()           {
    const extensions = this.allLines().map(line => line.extensions.map(extension => extension.exten));
    if (!extensions.length) {
      return [];
    }

    return extensions.reduce((a, b) => a.concat(b));
  }

  hasExtension(extension        )          {
    return this.allNumbers().some(number => number === extension);
  }
}

//      

describe('Session domain', () => {
  it('can parse a plain session to domain', () => {
    const plain = {
      data: {
        token: 'b93ae6bd-08d7-4001-9e61-057e72bbc4b3',
        acls: [
          'confd.infos.read',
          'confd.users.me.read',
          'confd.users.me.update',
          'confd.users.me.funckeys.*',
          'confd.users.me.funckeys.*.*',
          'confd.users.me.#.read',
          'confd.users.me.services.*.*',
          'confd.users.me.forwards.*.*',
          'ctid-ng.users.me.#',
          'ctid-ng.users.*.presences.read',
          'ctid-ng.lines.*.presences.read',
          'ctid-ng.switchboards.#',
          'ctid-ng.transfers.*.read',
          'ctid-ng.transfers.*.delete',
          'ctid-ng.transfers.*.complete.update',
          'dird.#.me.read',
          'dird.directories.favorites.#',
          'dird.directories.lookup.*.headers.read',
          'dird.directories.lookup.*.read',
          'dird.directories.personal.*.read',
          'dird.personal.#',
          'events.calls.me',
          'events.chat.message.*.me',
          'events.config.users.me.#',
          'events.statuses.*',
          'events.switchboards.#',
          'events.transfers.me',
          'events.users.me.#',
          'events.directory.me.#',
          'websocketd',
          'call-logd.users.me.cdr.read',
        ],
        utc_expires_at: '2017-07-19T21:27:53.086990',
        session_uuid: 'f14dd6d6-547c-434d-bd5c-e882b5b83b32',
        xivo_uuid: '6cd695d2-cdb9-4444-8b2d-27425ab85fa8',
        issued_at: '2017-07-19T16:27:53.086990',
        utc_issued_at: '2017-07-19T20:27:53.086990',
        auth_id: 'a14dd6d6-547c-434d-bd5c-e882b5b83b54',
        metadata: {
          uuid: 'a14dd6d6-547c-434d-bd5c-e882b5b83b54',
        },
        expires_at: '2017-07-19T17:27:53.086990',
        xivo_user_uuid: null,
      },
    };

    const session = Session.parse(plain);

    expect(session).toEqual(
      new Session({
        token: 'b93ae6bd-08d7-4001-9e61-057e72bbc4b3',
        refreshToken: null,
        uuid: 'a14dd6d6-547c-434d-bd5c-e882b5b83b54',
        expiresAt: new Date('2017-07-19T21:27:53.086990z'),
        sessionUuid: 'f14dd6d6-547c-434d-bd5c-e882b5b83b32',
      }),
    );
  });

  describe('about voicemails', () => {
    const A_DATE = new Date(2999, 5, 6, 14, 30, 1);
    it('has access to voicemail given there is a voicemail configured', () => {
      const session = new Session({
        token: 'ref-12345',
        uuid: '1234',
        profile: new Profile({
          voicemail: {
            id: 1234,
            name: 'inbox',
          },
        }),
        expiresAt: A_DATE,
      });

      expect(session.hasAccessToVoicemail()).toBeTruthy();
    });

    describe('When getting all numbers', () => {
      describe('and the user has multiple lines', () => {
        it('should return multiple extensions', () => {
          const session = new Session({
            token: 'ref-12345',
            uuid: '1234',
            profile: new Profile({
              lines: [
                new Line({ id: 9012, extensions: [{ id: 1, exten: '8000', context: 'default' }] }),
                new Line({ id: 3421, extensions: [{ id: 2, exten: '9980', context: 'internal' }] }),
              ],
            }),
            expiresAt: A_DATE,
          });

          expect(session.allNumbers().length).toBeGreaterThan(1);
        });
      });
      describe('and the user has one line', () => {
        it('should return only one extension', () => {
          const session = new Session({
            token: 'ref-12345',
            uuid: '1234',
            profile: new Profile({
              lines: [new Line({ id: 9012, extensions: [{ id: 1, exten: '8000', context: 'default' }] })],
            }),
            expiresAt: A_DATE,
          });

          expect(session.allNumbers().length).toEqual(1);
        });
      });
    });

    it('does not have access to voicemail given there is no voicemail configured', () => {
      const session = new Session({
        token: 'ref-12345',
        uuid: '1234',
        profile: new Profile({
          voicemail: undefined,
        }),
        expiresAt: A_DATE,
      });

      expect(session.hasAccessToVoicemail()).toBeFalsy();
    });

    it('does not have access to voicemail given there is no profile', () => {
      const session = new Session({
        token: 'ref-12345',
        uuid: '1234',
        expiresAt: A_DATE,
      });

      expect(session.hasAccessToVoicemail()).toBeFalsy();
    });
  });

  describe('Session expiration', () => {
    const EXPIRATION_DATE = new Date(2006, 5, 6, 14, 30, 1);

    it('session should be expired given date is equal to expiration date', () => {
      const session = new Session({
        token: 'ref-12345',
        uuid: '1234',
        expiresAt: EXPIRATION_DATE,
      });
      const currentDate = new Date(2006, 5, 6, 14, 30, 1);

      expect(session.hasExpired(currentDate)).toBeTruthy();
    });

    it('session should be expired given date is after expiration', () => {
      const session = new Session({
        token: 'ref-12345',
        uuid: '1234',
        expiresAt: EXPIRATION_DATE,
      });
      const currentDate = new Date(2006, 5, 6, 14, 32, 0);

      expect(session.hasExpired(currentDate)).toBeTruthy();
    });

    it('session should not be expired given date is before expiration', () => {
      const session = new Session({
        token: 'ref-12345',
        uuid: '1234',
        expiresAt: EXPIRATION_DATE,
      });
      const currentDate = new Date(2006, 5, 6, 14, 29, 0);

      expect(session.hasExpired(currentDate)).toBeFalsy();
    });
  });

  describe('when checking if session has a specific extension', () => {
    const session = new Session({
      token: 'ref-12345',
      uuid: '1234',
      profile: new Profile({
        lines: [
          new Line({ id: 9012, extensions: [{ id: 1, exten: '8000', context: 'default' }] }),
          new Line({ id: 3421, extensions: [{ id: 2, exten: '9980', context: 'internal' }] }),
        ],
      }),
      expiresAt: new Date(9999, 0, 1),
    });

    it('should return true given it owns the extension', () => {
      expect(session.hasExtension('8000')).toBeTruthy();
    });

    it("should return true given it owns the extension even if it's not the default one", () => {
      expect(session.hasExtension('9980')).toBeTruthy();
    });

    it("should return false given it does't own the extension", () => {
      expect(session.hasExtension('12')).toBeFalsy();
    });
  });

  describe('when getting the primary context', () => {
    const DEFAULT_CONTEXT = 'default';
    const SOME_CONTEXT = 'some-context';

    let A_SESSION;

    beforeEach(() => {
      A_SESSION = new Session({
        token: 'ref-12345',
        uuid: '1234',
        expiresAt: new Date(9999, 0, 1),
        engineVersion: null,
      });
    });

    describe('given NO engine version', () => {
      beforeEach(() => {
        A_SESSION = new Session({ ...A_SESSION, engineVersion: null });
      });

      describe('and NO profile', () => {
        beforeEach(() => {
          A_SESSION = new Session({ ...A_SESSION, profile: null });
        });

        it('should return default context', async () => {
          const context = A_SESSION.primaryContext();

          expect(context).toEqual(DEFAULT_CONTEXT);
        });
      });

      describe('and NO lines', () => {
        beforeEach(() => {
          A_SESSION = new Session({ ...A_SESSION, profile: new Profile({ lines: [] }) });
        });

        it('should return default context', async () => {
          const context = A_SESSION.primaryContext();

          expect(context).toEqual(DEFAULT_CONTEXT);
        });
      });

      describe('and some lines', () => {
        beforeEach(() => {
          const line = new Line({ extensions: [{ context: SOME_CONTEXT, id: 1, exten: '1' }], id: 1, exten: 1 });
          const profile = new Profile({ lines: [line] });
          A_SESSION = new Session({ ...A_SESSION, profile });
        });

        it('should return line context', async () => {
          const context = A_SESSION.primaryContext();

          expect(context).toEqual(SOME_CONTEXT);
        });
      });
    });

    describe('given an engine version', () => {
      describe('that is invalid', () => {
        beforeEach(() => {
          A_SESSION = new Session({ ...A_SESSION, engineVersion: '19.09' });
        });

        describe('and NO lines', () => {
          beforeEach(() => {
            const profile = new Profile({ lines: [] });
            A_SESSION = new Session({ ...A_SESSION, profile });
          });

          it('should return default context', async () => {
            const context = A_SESSION.primaryContext();

            expect(context).toEqual(DEFAULT_CONTEXT);
          });
        });

        describe('and some lines', () => {
          beforeEach(() => {
            const line = new Line({ extensions: [{ context: SOME_CONTEXT, id: 1, exten: '1' }], id: 1, exten: 1 });
            const profile = new Profile({ lines: [line] });
            A_SESSION = new Session({ ...A_SESSION, profile, engineVersion: '18.08' });
          });

          it('should return line context', async () => {
            const context = A_SESSION.primaryContext();

            expect(context).toEqual(SOME_CONTEXT);
          });
        });
      });

      describe('that is valid', () => {
        describe('and under 19.08', () => {
          describe('and NO lines', () => {
            it('should return default context', async () => {
              const context = A_SESSION.primaryContext();

              expect(context).toEqual(DEFAULT_CONTEXT);
            });
          });

          describe('and some lines', () => {
            beforeEach(() => {
              const line = new Line({ extensions: [{ context: SOME_CONTEXT, id: 1, exten: '1' }], id: 1, exten: 1 });
              const profile = new Profile({ lines: [line] });
              A_SESSION = new Session({ ...A_SESSION, profile });
            });

            it('should return line context', async () => {
              const context = A_SESSION.primaryContext();

              expect(context).toEqual(SOME_CONTEXT);
            });
          });
        });

        describe('and equal to 19.08', () => {
          it('should return default context', async () => {
            const context = A_SESSION.primaryContext();

            expect(context).toEqual(DEFAULT_CONTEXT);
          });
        });

        describe('and higher then 19.08', () => {
          it('should return default context', async () => {
            const context = A_SESSION.primaryContext();

            expect(context).toEqual(DEFAULT_CONTEXT);
          });
        });
      });

      describe('when version is 19.10', () => {
        it('should not consider that version is 19.1', () => {
          A_SESSION = new Session({ ...A_SESSION, engineVersion: '19.10' });
          expect(A_SESSION.hasEngineVersionGte('19.10')).toBeTruthy();
          expect(A_SESSION.hasEngineVersionGte('19.11')).toBeFalsy();
          expect(A_SESSION.hasEngineVersionGte('19.09')).toBeTruthy();
          expect(A_SESSION.hasEngineVersionGte('19.1')).toBeTruthy();
          expect(A_SESSION.hasEngineVersionGte('19.2')).toBeTruthy();
        });
      });
    });
  });
});
