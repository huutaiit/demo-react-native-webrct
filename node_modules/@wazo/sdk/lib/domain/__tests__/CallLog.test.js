'use strict';

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var moment = _interopDefault(require('moment'));
var jsrsasign = require('jsrsasign');

//      

const swarmPublicKey  = `-----BEGIN PUBLIC KEY-----
MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAmkXOuNfY8u5xoTiIhkb8
djnbIwG/Wrz3vpo8BZir8L5e1a1nSy740qBjP7ZINBQoALDhFfmdOfJnCyEGiHuz
ZW6jbG6C3PryE3Bu6GKwqSmD6k3q4Zk27fpwYAnNl+rWhYYM563rJZBda/INyHNN
pK7M1mixWi7gNdjjXwoEXSSBx+VpYMkY6LiAB2mvHXTY9M1qI14dvgGoQISZQoKi
NMTRCg5UP2ic0Dd9nSz/XpcOxGfa+0fwIl1F7RC1tJXOqvkGGPTOV4LLfg/Yta3h
nUPX9EZZDIX6vO/0IBV1LzjSl2A1bYFYAjJfowv3i1CpvONBOClHjSY5t9Y8MH6p
BwIDAQAB
-----END PUBLIC KEY-----`;

//      

var newFrom = (instance     , ToClass     ) => {
  const args = {};
  Object.getOwnPropertyNames(instance).forEach(prop => {
    args[prop] = instance[prop];
  });

  return new ToClass(args);
};

//      

const swarmKey = jsrsasign.KEYUTIL.getKey(swarmPublicKey);

//      

                        
                 
                    
                         
                                
                            
                   
              
             
                           
                      
                              
                
  

                 
                   
                                
                
  

                         
               
                    
                          
                        
                
                      
                 
    
           
                      
                 
    
             
                   
              
            
  

class CallLog {
               

               
                    
                         
                        
                
                      
                 
    

           
                      
                 
    

             
                   
              
            

  static merge(current                , toMerge                )                  {
    const onlyUnique = (value, index, self) => self.indexOf(value) === index;

    const allLogs                 = current.concat(toMerge);
    const onlyUniqueIds                = allLogs.map(c => c.id).filter(onlyUnique);

    return onlyUniqueIds.map(id => allLogs.find(log => log.id === id));
  }

  static parseMany(plain          )                 {
    return plain.items.map(item => CallLog.parse(item));
  }

  static parse(plain                 )          {
    return new CallLog({
      answer: moment(plain.answer).toDate(),
      answered: plain.answered,
      callDirection: plain.call_direction,
      destination: {
        extension: plain.destination_extension || plain.requested_extension,
        name: plain.destination_name || '',
      },
      source: {
        extension: plain.source_extension,
        name: plain.source_name,
      },
      id: plain.id,
      duration: (plain.duration || 0) * 1000, // duration is in seconds
      start: moment(plain.start).toDate(),
      end: moment(plain.end).toDate(),
    });
  }

  static parseNew(plain                 , session         )          {
    return new CallLog({
      answer: moment(plain.answer).toDate(),
      answered: plain.answered,
      callDirection: plain.call_direction,
      destination: {
        extension: plain.destination_extension || plain.requested_extension,
        name: plain.destination_name || '',
      },
      source: {
        extension: plain.source_extension,
        name: plain.source_name,
      },
      id: plain.id,
      duration: (plain.duration || 0) * 1000, // duration is in seconds
      start: moment(plain.start).toDate(),
      end: moment(plain.end).toDate(),
      // @TODO: FIXME add verification declined vs missed call
      newMissedCall: session && session.hasExtension(plain.destination_extension) && !plain.answered,
    });
  }

  static newFrom(profile         ) {
    return newFrom(profile, CallLog);
  }

  constructor({
    answer,
    answered,
    callDirection,
    destination,
    source,
    id,
    duration,
    start,
    end,
  }                   = {}) {
    this.answer = answer;
    this.answered = answered;
    this.callDirection = callDirection;
    this.destination = destination;
    this.source = source;
    this.id = id;
    this.duration = duration;
    this.start = start;
    this.end = end;

    // Useful to compare instead of instanceof with minified code
    this.type = 'CallLog';
  }

  isFromSameParty(other         , session         )          {
    return this.theOtherParty(session).extension === other.theOtherParty(session).extension;
  }

  theOtherParty(session         )                                      {
    if (this.callDirection === 'inbound') {
      return this.source;
    }

    if (this.callDirection === 'outbound') {
      return this.destination;
    }

    return session.hasExtension(this.source.extension) ? this.destination : this.source;
  }

  isNewMissedCall()          {
    return this.newMissedCall;
  }

  acknowledgeCall()          {
    this.newMissedCall = false;

    return this;
  }

  isAcknowledged()          {
    return this.newMissedCall;
  }

  isAnswered()          {
    return this.answered;
  }

  isOutgoing(session         )          {
    if (this.callDirection === 'internal') {
      return session.hasExtension(this.source.extension);
    }

    return this.callDirection === 'outbound';
  }

  isIncoming(session         )          {
    if (this.callDirection === 'internal') {
      return session.hasExtension(this.destination.extension);
    }

    return this.callDirection === 'inbound';
  }

  isAnOutgoingCall(session         )          {
    console.warn(`@wazo/sdk 
      CallLog.isAnOutgoingcall(session) method is obsolete.
      Please use CallLog.isOutgoing(session).
    `);

    return session.hasExtension(this.source.extension) && this.answered;
  }

  isAMissedOutgoingCall(session         )          {
    return session.hasExtension(this.source.extension) && !this.answered;
  }

  isAnIncomingCall(session         )          {
    console.warn(`@wazo/sdk
      CallLog.isAnIncomingCall(session) method is obsolete.
      Please use CallLog.isIncoming(session).
    `);

    return session.hasExtension(this.destination.extension) && this.answered;
  }

  isADeclinedCall(session         )          {
    return !this.answered && session.hasExtension(this.destination.extension);
  }
}

//      

describe('CallLog domain', () => {
  it('can parse a plain call log to domain', () => {
    const response = {
      filtered: 6,
      items: [
        {
          answer: moment('2017-08-07T13:51:18.892002+00:00').toDate(),
          answered: true,
          call_direction: 'outbound',
          source_extension: '8020',
          source_name: 'Jonathan Lessard',
          destination_extension: '4182250459',
          destination_name: null,
          duration: 4,
          start: '2017-08-06T13:50:55.819057+00:00',
          end: '2017-08-08T13:51:23.822529+00:00',
          requested_extension: '',
          id: 215,
        },
      ],
      total: 233,
    };

    const logs = CallLog.parseMany(response);

    expect(logs).toEqual([
      new CallLog({
        answer: moment('2017-08-07T13:51:18.892002+00:00').toDate(),
        answered: true,
        callDirection: 'outbound',
        destination: {
          extension: '4182250459',
          name: '',
        },
        source: {
          extension: '8020',
          name: 'Jonathan Lessard',
        },
        id: 215,
        duration: 4000,
        start: moment('2017-08-06T13:50:55.819057+00:00').toDate(),
        end: moment('2017-08-08T13:51:23.822529+00:00').toDate(),
      }),
    ]);
  });
});
