'use strict';

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

require('moment');
var jsrsasign = require('jsrsasign');
require('webrtc-adapter');
var Enums = require('sip.js/lib/Enums');
require('sip.js/lib/UA');
require('sip.js/lib/Utils');
require('sip.js/lib/Exceptions');
require('sip.js/lib/Web');
var SIP = _interopDefault(require('sip.js'));
var EventEmitter = _interopDefault(require('events'));
require('js-base64');
require('sip.js/lib/Web/SessionDescriptionHandlerObserver');

//      

var newFrom = (instance     , ToClass     ) => {
  const args = {};
  Object.getOwnPropertyNames(instance).forEach(prop => {
    args[prop] = instance[prop];
  });

  return new ToClass(args);
};

//      

const swarmPublicKey  = `-----BEGIN PUBLIC KEY-----
MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAmkXOuNfY8u5xoTiIhkb8
djnbIwG/Wrz3vpo8BZir8L5e1a1nSy740qBjP7ZINBQoALDhFfmdOfJnCyEGiHuz
ZW6jbG6C3PryE3Bu6GKwqSmD6k3q4Zk27fpwYAnNl+rWhYYM563rJZBda/INyHNN
pK7M1mixWi7gNdjjXwoEXSSBx+VpYMkY6LiAB2mvHXTY9M1qI14dvgGoQISZQoKi
NMTRCg5UP2ic0Dd9nSz/XpcOxGfa+0fwIl1F7RC1tJXOqvkGGPTOV4LLfg/Yta3h
nUPX9EZZDIX6vO/0IBV1LzjSl2A1bYFYAjJfowv3i1CpvONBOClHjSY5t9Y8MH6p
BwIDAQAB
-----END PUBLIC KEY-----`;

//      

const swarmKey = jsrsasign.KEYUTIL.getKey(swarmPublicKey);

//      
/* eslint-disable no-param-reassign */

var updateFrom = (instance     , from     ) => {
  Object.keys(from).forEach(key => {
    // $FlowFixMe
    if (
      (!instance[key] && from[key])
      || (typeof instance[key] !== 'undefined' && typeof from[key] !== 'undefined' && instance[key] !== from[key])
    ) {
      // $FlowFixMe
      instance[key] = from[key];
    }
  });
};

//      

                             
                    
              
                 
                       
                         
                                  
                      
                    
                 
                 
                  
                   
                    
                 
                     
                    
  

class CallSession {
              

                 

                      

                 

                       

                    

                    

                    

                          

                   

  // Should be computed ?
                  

                    

                     

                 

                         

               

  constructor({
    answered,
    isCaller,
    displayName,
    callId,
    muted,
    number,
    paused,
    ringing,
    startTime,
    cameraEnabled,
    dialedExtension,
    sipCallId,
    sipStatus,
    callerNumber,
    call,
  }                      ) {
    this.callId = callId;
    this.sipCallId = sipCallId;
    this.displayName = displayName;
    this.number = number;
    this.startTime = startTime;
    this.isCaller = isCaller;
    this.answered = answered;
    this.ringing = ringing;
    this.paused = paused;
    this.muted = muted;
    this.callerNumber = callerNumber;
    this.cameraEnabled = cameraEnabled;
    this.dialedExtension = dialedExtension || '';
    this.call = call;
    this.sipStatus = sipStatus;

    // Useful to compare instead of instanceof with minified code
    this.type = 'CallSession';
  }

  resume() {
    this.paused = false;
  }

  hold() {
    this.paused = true;
  }

  mute() {
    this.muted = true;
  }

  unmute() {
    this.muted = false;
  }

  answer() {
    this.answered = true;
  }

  enableCamera() {
    this.cameraEnabled = true;
  }

  isIncoming()          {
    return !this.isCaller && !this.answered;
  }

  isOutgoing()          {
    return this.isCaller && !this.answered;
  }

  isActive()          {
    return this.answered || this.isOutgoing();
  }

  isAnswered()          {
    return this.answered;
  }

  isRinging()          {
    return this.ringing;
  }

  isOnHold()          {
    return this.paused;
  }

  isMuted()          {
    return this.muted;
  }

  isCameraEnabled()          {
    return this.cameraEnabled;
  }

  hasAnInitialInterceptionNumber()          {
    return this.number.startsWith('*8');
  }

  isAnInterception()          {
    return this.dialedExtension.startsWith('*8');
  }

  getElapsedTimeInSeconds() {
    if (!this.startTime) {
      return 0;
    }
    return (Date.now() - this.startTime) / 1000;
  }

  getId() {
    return this.sipCallId || this.callId;
  }

  is(callSession             ) {
    return this.isId(callSession.getId());
  }

  isId(id        )          {
    return (
      this.getId() === id || (this.sipCallId && this.sipCallId === id) || (Boolean(this.callId) && this.callId === id)
    );
  }

  updateFrom(session             ) {
    updateFrom(this, session);
  }

  separateDisplayName()                                          {
    const names = this.displayName.split(' ');
    const firstName = names[0];
    const lastName = names.slice(1).join(' ');

    return { firstName, lastName };
  }

  static newFrom(callSession             ) {
    return newFrom(callSession, CallSession);
  }

  static parseCall(session         , call      )              {
    return new CallSession({
      callId: call.id,
      sipCallId: call.sipCallId,
      displayName: call.calleeName || call.calleeNumber,
      number: call.calleeNumber,
      callerNumber: call.callerNumber,
      startTime: +call.startingTime,
      paused: call.isOnHold(),
      isCaller: call.isCaller,
      muted: false,
      ringing: call.isRinging(),
      answered: call.isUp(),
      cameraEnabled: false,
      dialedExtension: call.dialedExtension,
      call,
    });
  }
}

//      

class Emitter {
                             

  constructor() {
    this.eventEmitter = new EventEmitter();
  }

  on(event        , callback          ) {
    this.eventEmitter.on(event, callback);
  }

  once(event        , callback          ) {
    this.eventEmitter.once(event, callback);
  }

  off(event        , callback          ) {
    this.eventEmitter.removeListener(event, callback);
  }

  unbind() {
    this.eventEmitter.removeAllListeners();
  }
}

/* global window */
//      

global.wazoIssueReporterLogs = [];

class IssueReporter {
               
              
               
                

                           
                            
                   

  constructor() {
    this.INFO = 'info';
    this.LOG = 'log';
    this.WARN = 'warn';
    this.ERROR = 'error';

    this.consoleMethods = [this.INFO, this.LOG, this.WARN, this.ERROR];
    this.oldConsoleMethods = {};
    this.enabled = false;
  }

  init() {
    this._catchConsole();
  }

  enable() {
    this.enabled = true;
  }

  disable() {
    this.enabled = false;
  }

  log(level        , ...args     ) {
    if (!this.enabled) {
      return;
    }
    global.wazoIssueReporterLogs.push({
      level,
      date: new Date(),
      message: args.join(', '),
    });
  }

  getReport() {
    return global.wazoIssueReporterLogs
      .map(log => `${log.date.toString().substr(0, 24)} - ${log.level} - ${log.message}`)
      .join('\r\n');
  }

  getLogs() {
    return global.wazoIssueReporterLogs;
  }

  _catchConsole() {
    this.consoleMethods.forEach((methodName        ) => {
      // eslint-disable-next-line
      this.oldConsoleMethods[methodName] = console[methodName];
      window.console[methodName] = (...args) => {
        // Store message
        this.log(methodName, args.join(' '));
        // Use old console method to log it normally
        this.oldConsoleMethods[methodName].apply(null, args);
      };
    });
  }
}

var IssueReporter$1 = new IssueReporter();

/* eslint-disable */

// Avoid issue with sip.js :
// `window.addEventListener` is not a function. (In 'window.addEventListener("unload",this.unloadListener)')`
if (!window.addEventListener) {
  window.addEventListener = () => {};
  window.removeEventListener = () => {};
}

({
  sessionDescriptionHandler: SIP.sessionDescriptionHandler,
  InviteServerContext: SIP.InviteServerContext,
  C: {
    REASON_PHRASE: {
      100: 'Trying',
      180: 'Ringing',
      181: 'Call Is Being Forwarded',
      182: 'Queued',
      183: 'Session Progress',
      199: 'Early Dialog Terminated', // draft-ietf-sipcore-199
      200: 'OK',
      202: 'Accepted', // RFC 3265
      204: 'No Notification', // RFC 5839
      300: 'Multiple Choices',
      301: 'Moved Permanently',
      302: 'Moved Temporarily',
      305: 'Use Proxy',
      380: 'Alternative Service',
      400: 'Bad Request',
      401: 'Unauthorized',
      402: 'Payment Required',
      403: 'Forbidden',
      404: 'Not Found',
      405: 'Method Not Allowed',
      406: 'Not Acceptable',
      407: 'Proxy Authentication Required',
      408: 'Request Timeout',
      410: 'Gone',
      412: 'Conditional Request Failed', // RFC 3903
      413: 'Request Entity Too Large',
      414: 'Request-URI Too Long',
      415: 'Unsupported Media Type',
      416: 'Unsupported URI Scheme',
      417: 'Unknown Resource-Priority', // RFC 4412
      420: 'Bad Extension',
      421: 'Extension Required',
      422: 'Session Interval Too Small', // RFC 4028
      423: 'Interval Too Brief',
      428: 'Use Identity Header', // RFC 4474
      429: 'Provide Referrer Identity', // RFC 3892
      430: 'Flow Failed', // RFC 5626
      433: 'Anonymity Disallowed', // RFC 5079
      436: 'Bad Identity-Info', // RFC 4474
      437: 'Unsupported Certificate', // RFC 4744
      438: 'Invalid Identity Header', // RFC 4744
      439: 'First Hop Lacks Outbound Support', // RFC 5626
      440: 'Max-Breadth Exceeded', // RFC 5393
      469: 'Bad Info Package', // draft-ietf-sipcore-info-events
      470: 'Consent Needed', // RFC 5360
      478: 'Unresolvable Destination', // Custom code copied from Kamailio.
      480: 'Temporarily Unavailable',
      481: 'Call/Transaction Does Not Exist',
      482: 'Loop Detected',
      483: 'Too Many Hops',
      484: 'Address Incomplete',
      485: 'Ambiguous',
      486: 'Busy Here',
      487: 'Request Terminated',
      488: 'Not Acceptable Here',
      489: 'Bad Event', // RFC 3265
      491: 'Request Pending',
      493: 'Undecipherable',
      494: 'Security Agreement Required', // RFC 3329
      500: 'Internal Server Error',
      501: 'Not Implemented',
      502: 'Bad Gateway',
      503: 'Service Unavailable',
      504: 'Server Time-out',
      505: 'Version Not Supported',
      513: 'Message Too Large',
      580: 'Precondition Failure', // RFC 3312
      600: 'Busy Everywhere',
      603: 'Decline',
      604: 'Does Not Exist Anywhere',
      606: 'Not Acceptable',
    },
    causes: {
      CONNECTION_ERROR: 'Connection Error',
      INTERNAL_ERROR: 'Internal Error',
      REQUEST_TIMEOUT: 'Request Timeout',
      SIP_FAILURE_CODE: 'SIP Failure Code',

      // SIP error causes
      ADDRESS_INCOMPLETE: 'Address Incomplete',
      AUTHENTICATION_ERROR: 'Authentication Error',
      BUSY: 'Busy',
      DIALOG_ERROR: 'Dialog Error',
      INCOMPATIBLE_SDP: 'Incompatible SDP',
      NOT_FOUND: 'Not Found',
      REDIRECTED: 'Redirected',
      REJECTED: 'Rejected',
      UNAVAILABLE: 'Unavailable',

      // Session error causes

      BAD_MEDIA_DESCRIPTION: 'Bad Media Description',
      CANCELED: 'Canceled',
      EXPIRES: 'Expires',
      NO_ACK: 'No ACK',
      NO_ANSWER: 'No Answer',
      NO_PRACK: 'No PRACK',
      RTP_TIMEOUT: 'RTP Timeout',
      USER_DENIED_MEDIA_ACCESS: 'User Denied Media Access',
      WEBRTC_ERROR: 'WebRTC Error',
      WEBRTC_NOT_SUPPORTED: 'WebRTC Not Supported',
    },
  },
  SessionStatus: Enums.SessionStatus,
});

//      

class WebRTCPhone extends Emitter                  {
                           

                      

                               

                                                           

                             

                                                   

                                                 

                                               

                          

                           

                           

  constructor(
    client                  ,
    audioOutputDeviceId         ,
    allowVideo          = false,
    audioRingDeviceId         ,
  ) {
    super();

    this.client = client;
    this.allowVideo = allowVideo;
    this.sipSessions = {};
    this.audioOutputDeviceId = audioOutputDeviceId;
    this.audioRingDeviceId = audioRingDeviceId || audioOutputDeviceId;
    this.incomingSessions = [];
    this.ringingEnabled = true;
    this.shouldRegisterAgain = true;

    this.client.on('invite', (sipSession                               , wantsToDoVideo         ) => {
      const callSession = this._createIncomingCallSession(sipSession, this.allowVideo ? wantsToDoVideo : false);
      this.incomingSessions.push(callSession.getId());
      this._bindEvents(sipSession);

      this.sipSessions[callSession.getId()] = sipSession;

      if (!this.currentSipSession) {
        this.eventEmitter.emit('terminateSound');

        if (this.ringingEnabled) {
          this.eventEmitter.emit('playRingingSound', this.audioRingDeviceId);
        }
      }

      this.eventEmitter.emit('onCallIncoming', callSession);
    });

    this.client.on('accepted', () => {});
    this.client.on('ended', () => {});

    this.client.on('unregistered', () => {
      this.eventEmitter.emit('onUnRegistered');

      if (this.shouldRegisterAgain) {
        this.register();
      }
    });

    this.client.on('registered', () => {
      this.eventEmitter.emit('onRegistered');
    });

    this.client.on('disconnected', () => {
      this.eventEmitter.emit('onUnRegistered');
    });

    this.acceptedSessions = {};
    this.rejectedSessions = {};
  }

  register() {
    this.shouldRegisterAgain = true;

    if (!this.client) {
      return;
    }

    try {
      this.client.register();
    } catch (e) {
      // Avoid exception on `t.server.scheme` in sip transport when losing the webrtc socket connection
    }
  }

  unregister() {
    if (!this.client || !this.client.isRegistered()) {
      return;
    }
    this.shouldRegisterAgain = false;

    this.client.unregister();
  }

  stop() {
    if (!this.client) {
      return;
    }
    IssueReporter$1.log(IssueReporter$1.INFO, '[WebRtcPhone] stop');
    this.client.stop();
  }

  removeIncomingSessions(id        ) {
    this.incomingSessions = this.incomingSessions.filter(sessionId => sessionId !== id);
  }

  isWebRTC() {
    return true;
  }

  getOptions()                        {
    return {
      accept: true,
      decline: true,
      mute: true,
      hold: true,
      transfer: true,
      sendKey: true,
      addParticipant: false,
      record: true,
      merge: true,
    };
  }

  _bindEvents(sipSession                               ) {
    sipSession.on('accepted', () => {
      this._onCallAccepted(sipSession, this.client.sessionHasVideo(this.client.getSipSessionId(sipSession)));

      if (this.audioOutputDeviceId) {
        this.client.changeAudioOutputDevice(this.audioOutputDeviceId);
      }
    });
    sipSession.on('progress', () => {
      // When receiving a progress event, we know we are the caller so we have to force incoming to false
      this.eventEmitter.emit(
        'onProgress',
        this._createCallSession(sipSession, null, { incoming: false, ringing: true }),
        this.audioOutputDeviceId,
      );
    });
    sipSession.on('muted', callSession => {
      this.eventEmitter.emit('onCallMuted', this._createMutedCallSession(sipSession, callSession));
    });
    sipSession.on('unmuted', callSession => {
      this.eventEmitter.emit('onCallUnmuted', this._createUnmutedCallSession(sipSession, callSession));
    });
    sipSession.on('cameraOn', callSession => {
      this.eventEmitter.emit('onCameraResumed', this._createCameraResumedCallSession(sipSession, callSession));
    });
    sipSession.on('cameraOff', callSession => {
      this.eventEmitter.emit('onCameraDisabled', this._createCameraDisabledCallSession(sipSession, callSession));
    });

    sipSession.on('failed', reason => {
      this.eventEmitter.emit('onCallFailed', this._createCallSession(sipSession), reason);

      this._onCallTerminated(sipSession);
    });

    sipSession.on('rejected', () => {
      this._onCallTerminated(sipSession);

      this.eventEmitter.emit('onCallEnded', this._createCallSession(sipSession));
    });

    sipSession.on('terminated', () => {
      this._onCallTerminated(sipSession);

      this.eventEmitter.emit('onCallEnded', this._createCallSession(sipSession));
    });

    sipSession.on('cancel', () => {
      this._onCallTerminated(sipSession);

      this.eventEmitter.emit('onCallEnded', this._createCallSession(sipSession));
    });
  }

  _onCallAccepted(sipSession                               , videoEnabled         )              {
    const callSession = this._createAcceptedCallSession(sipSession, videoEnabled);
    this.sipSessions[callSession.getId()] = sipSession;
    this.currentSipSession = sipSession;

    this.eventEmitter.emit('terminateSound');
    const sipSessionId = this.client.getSipSessionId(sipSession);
    if (sipSessionId) {
      this.removeIncomingSessions(sipSessionId);
    }

    this.eventEmitter.emit('onCallAccepted', callSession);
    return callSession;
  }

  changeAudioDevice(id        ) {
    this.audioOutputDeviceId = id;
    this.client.changeAudioOutputDevice(id);
  }

  changeRingDevice(id        ) {
    this.audioRingDeviceId = id;
  }

  changeAudioInputDevice(id        ) {
    this.client.changeAudioInputDevice(id, this.currentSipSession);
  }

  changeVideoInputDevice(id        ) {
    this.client.changeVideoInputDevice(id, this.currentSipSession);
  }

  _onCallTerminated(sipSession                               ) {
    const callSession = this._createCallSession(sipSession);

    this.eventEmitter.emit('terminateSound');

    const sipSessionId = this.client.getSipSessionId(sipSession);
    if (sipSessionId) {
      this.removeIncomingSessions(sipSessionId);
    }

    delete this.sipSessions[callSession.getId()];
    if (this.isCurrentCallSipSession(callSession)) {
      this.currentSipSession = undefined;
    }
  }

  setActiveSipSession(callSession             ) {
    const sipSessionId = this._findSipSession(callSession);
    if (!sipSessionId) {
      return;
    }

    this.currentSipSession = sipSessionId;
  }

  hasAnActiveCall() {
    return !!this.currentSipSession;
  }

  isCurrentCallSipSession(callSession             )          {
    if (!this.currentSipSession) {
      return false;
    }

    return this.currentSipSession && this.client.getSipSessionId(this.currentSipSession) === callSession.getId();
  }

  isCallUsingVideo(callSession             )          {
    return this.client.sessionHasVideo(callSession.getId());
  }

  getLocalStreamForCall(callSession             )          {
    return this.client.videoSessions[callSession.getId()].local;
  }

  getRemoteStreamForCall(callSession             )          {
    return this.client.videoSessions[callSession.getId()].remotes[0];
  }

  startConference(participants               ) {
    const targetedSessions = participants.map(callSession => this.sipSessions[callSession.getId()]);

    this.client.merge(Object.values(targetedSessions));
  }

  async addToConference(callSessions               )                {
    const targetedSessions = callSessions.map(callSession => this.sipSessions[callSession.getId()]);

    const mergingSessions = targetedSessions.map(async sipSession => this.client.addToMerge(sipSession));
    await Promise.all(mergingSessions);
  }

  accept(callSession             , videoEnabled          )                {
    if (this.currentSipSession) {
      this.holdSipSession(this.currentSipSession);
    }

    if (!callSession || callSession.getId() in this.acceptedSessions) {
      return null;
    }

    this.acceptedSessions[callSession.getId()] = true;

    this.eventEmitter.emit('onCallAnswered', callSession);

    const sipSession = this.sipSessions[callSession.getId()];
    if (sipSession) {
      this.client.answer(sipSession, this.allowVideo ? videoEnabled : false);

      return callSession.sipCallId;
    }

    return null;
  }

  async reject(callSession             )                {
    this.eventEmitter.emit('terminateSound');
    if (!callSession || callSession.getId() in this.rejectedSessions) {
      return;
    }

    this.rejectedSessions[callSession.getId()] = true;

    const sipSession = this._findSipSession(callSession);
    if (sipSession) {
      this.client.reject(sipSession);
    }
  }

  hold(callSession             , withEvent          = true)       {
    const sipSession = this._findSipSession(callSession);
    this.holdSipSession(sipSession, withEvent);
  }

  unhold(callSession             , withEvent          = true)       {
    const sipSession = this._findSipSession(callSession);
    this.unholdSipSession(sipSession, withEvent);
  }

  holdSipSession(sipSession                               , withEvent          = true)       {
    if (!sipSession) {
      return;
    }

    this.client.hold(sipSession);
    if (withEvent) {
      this.eventEmitter.emit('onCallHeld', this._createCallSession(sipSession));
    }
  }

  unholdSipSession(sipSession                               , withEvent          = true)       {
    if (!sipSession) {
      return;
    }

    this.client.unhold(sipSession);
    if (withEvent) {
      this.eventEmitter.emit('onCallUnHeld', this._createCallSession(sipSession));
    }
  }

  holdConference(participants               )       {
    participants.forEach(participant => {
      const sipSession = this.sipSessions[participant.sipCallId];

      if (sipSession && !participant.isOnHold()) {
        this.client.hold(sipSession);
        participant.hold();
      }
    });
  }

  resumeConference(participants               )       {
    participants.forEach(participant => {
      const sipSession = this.sipSessions[participant.sipCallId];

      if (sipSession && participant.isOnHold()) {
        this.client.unhold(sipSession);
        participant.resume();
      }
    });
  }

  resume(callSession              )       {
    if (this.currentSipSession) {
      this.holdSipSession(this.currentSipSession);
    }

    const sipSession = this._findSipSession(callSession);
    if (!sipSession) {
      return;
    }

    this.client.unhold(sipSession);
    this.eventEmitter.emit('onCallResumed', this._createCallSession(sipSession, callSession));
    this.currentSipSession = sipSession;
  }

  mute(callSession              , withEvent          = true)       {
    const sipSession = this._findSipSession(callSession);
    if (!sipSession) {
      return;
    }

    this.client.mute(sipSession);

    if (withEvent) {
      sipSession.emit('muted', callSession);
    }
  }

  unmute(callSession              , withEvent          = true)       {
    const sipSession = this._findSipSession(callSession);
    if (!sipSession) {
      return;
    }

    this.client.unmute(sipSession);

    if (withEvent) {
      sipSession.emit('unmuted', callSession);
    }
  }

  turnCameraOn(callSession              )       {
    const sipSession = this._findSipSession(callSession);
    if (!sipSession) {
      return;
    }

    this.client.toggleCameraOn(sipSession);

    sipSession.emit('cameraOn', callSession);
  }

  turnCameraOff(callSession              )       {
    const sipSession = this._findSipSession(callSession);
    if (!sipSession) {
      return;
    }

    this.client.toggleCameraOff(sipSession);
    sipSession.emit('cameraOff', callSession);
  }

  sendKey(callSession              , tone        )       {
    const sipSession = this._findSipSession(callSession);
    if (!sipSession) {
      return;
    }

    this.client.sendDTMF(sipSession, tone);
  }

  // Should be async to match CTIPhone definition
  async makeCall(number        , line     , enableVideo          )                        {
    if (!number) {
      return new Promise(resolve => resolve(null));
    }
    if (!this.client.isRegistered()) {
      this.client.register();
    }
    if (this.currentSipSession) {
      this.holdSipSession(this.currentSipSession);
    }

    let sipSession;
    try {
      sipSession = this.client.call(number, this.allowVideo ? enableVideo : false);
    } catch (error) {
      console.warn(error);
      return new Promise(resolve => resolve(null));
    }
    const callSession = this._createOutgoingCallSession(sipSession, enableVideo || false);

    this.sipSessions[callSession.getId()] = sipSession;

    this.eventEmitter.emit('playProgressSound', this.audioOutputDeviceId);

    this.currentSipSession = sipSession;
    this._bindEvents(sipSession);

    this.eventEmitter.emit('onCallOutgoing', callSession);

    return new Promise(resolve => resolve(callSession));
  }

  transfer(callSession              , target        )       {
    const sipSession = this._findSipSession(callSession);
    if (!sipSession) {
      return;
    }

    this.client.transfer(sipSession, target);
  }

  async indirectTransfer(source             , destination             )                {
    const sipSession = this.sipSessions[source.sipCallId];
    const sipSessionTarget = this.sipSessions[destination.sipCallId];

    await sipSessionTarget.refer(sipSession);
  }

  async hangup(callSession              )                {
    const sipSession = this._findSipSession(callSession);
    if (!sipSession) {
      throw new Error('Call is unknown to the WebRTC phone');
    }

    const sipSessionId = this.client.getSipSessionId(sipSession);
    if (sipSessionId) {
      delete this.sipSessions[sipSessionId];
    }

    this.client.hangup(sipSession);
    if (callSession) {
      this.endCurrentCall(callSession);
    }
  }

  async hangupConference(participants               )                {
    participants.forEach(participant => {
      const sipSession = this.sipSessions[participant.sipCallId];
      if (!sipSession) {
        return;
      }

      this.client.removeFromMerge(sipSession, false);

      const sipSessionId = this.client.getSipSessionId(sipSession);
      if (sipSessionId) {
        delete this.sipSessions[sipSessionId];
      }

      this.client.hangup(sipSession);
      this.endCurrentCall(participant);
    });
  }

  async removeFromConference(participants               )                {
    participants.forEach(participant => {
      const sipSession = this.sipSessions[participant.sipCallId];
      if (!sipSession || participant.isOnHold()) {
        return;
      }

      this.client.removeFromMerge(sipSession, false);
      this.client.hold(sipSession);
      participant.hold();
    });
  }

  muteConference(participants               )       {
    participants.forEach(participant => {
      const sipSession = this.sipSessions[participant.sipCallId];
      if (!sipSession) {
        return;
      }

      this.client.mute(sipSession);
      participant.mute();
      sipSession.emit('muted', participant);
    });
  }

  unmuteConference(participants               )       {
    participants.forEach(participant => {
      const sipSession = this.sipSessions[participant.sipCallId];
      if (!sipSession) {
        return;
      }

      this.client.unmute(sipSession);
      participant.unmute();
      sipSession.emit('unmuted', participant);
    });
  }

  endCurrentCall(callSession             )       {
    if (this.isCurrentCallSipSession(callSession)) {
      this.currentSipSession = undefined;
    }

    this.eventEmitter.emit('terminateSound', this.audioOutputDeviceId);

    if (!this.currentSipSession && this.incomingSessions.length > 0) {
      this.eventEmitter.emit('playRingingSound', this.audioOutputDeviceId);
    }
  }

  onConnectionMade()       {}

  close()       {
    IssueReporter$1.log(IssueReporter$1.INFO, '[WebRtcPhone] close');
    this.unregister();
    this.client.close();
    this.unbind();
  }

  isRegistered()          {
    return this.client && this.client.isRegistered();
  }

  enableRinging()                       {
    this.ringingEnabled = true;
  }

  disableRinging()                       {
    this.ringingEnabled = false;
  }

  getCurrentCallSession()               {
    if (!this.currentSipSession) {
      return null;
    }

    return this._createCallSession(this.currentSipSession);
  }

  hasIncomingCallSession()          {
    return this.incomingSessions.length > 0;
  }

  getIncomingCallSession()               {
    if (!this.hasIncomingCallSession()) {
      return null;
    }

    const sessionId = this.incomingSessions[0];

    return this._createCallSession(this.sipSessions[sessionId]);
  }

  _createIncomingCallSession(
    sipSession                               ,
    cameraEnabled         ,
    fromSession              ,
  )              {
    return this._createCallSession(sipSession, fromSession, { incoming: true, ringing: true, cameraEnabled });
  }

  _createOutgoingCallSession(
    sipSession                               ,
    cameraEnabled         ,
    fromSession              ,
  )              {
    return this._createCallSession(sipSession, fromSession, { incoming: false, ringing: true, cameraEnabled });
  }

  _createAcceptedCallSession(
    sipSession                               ,
    cameraEnabled          ,
    fromSession              ,
  )              {
    return this._createCallSession(sipSession, fromSession, {
      cameraEnabled: cameraEnabled !== undefined ? cameraEnabled : false,
    });
  }

  _createMutedCallSession(sipSession                               , fromSession              )              {
    return this._createCallSession(sipSession, fromSession, {
      muted: true,
      cameraEnabled: this.client.sessionHasLocalVideo(this.client.getSipSessionId(sipSession)),
    });
  }

  _createUnmutedCallSession(sipSession                               , fromSession              )              {
    return this._createCallSession(sipSession, fromSession, {
      cameraEnabled: this.client.sessionHasLocalVideo(this.client.getSipSessionId(sipSession)),
    });
  }

  _createCameraResumedCallSession(sipSession                               , fromSession              )              {
    return this._createCallSession(sipSession, fromSession, {
      muted: !this.client.sessionHasAudio(sipSession),
      cameraEnabled: true,
    });
  }

  _createCameraDisabledCallSession(sipSession                               , fromSession              )              {
    return this._createCallSession(sipSession, fromSession, {
      muted: !this.client.sessionHasAudio(sipSession),
      cameraEnabled: false,
    });
  }

  _createCallSession(
    sipSession                               ,
    fromSession               ,
    extra         = {},
  )              {
    // eslint-disable-next-line
    const number = sipSession.remoteIdentity.uri._normal.user;

    return new CallSession({
      callId: fromSession && fromSession.callId,
      sipCallId: this.client.getSipSessionId(sipSession),
      sipStatus: sipSession.status,
      displayName: sipSession.remoteIdentity.displayName || number,
      startTime: sipSession.startTime,
      answered: sipSession.hasAnswer,
      paused: sipSession.localHold,
      isCaller: 'incoming' in extra ? !extra.incoming : false,
      number,
      ringing: false,
      muted: false,
      ...extra,
    });
  }

  // Find a corresponding sipSession from a CallSession
  _findSipSession(callSession              )                                 {
    const keys = Object.keys(this.sipSessions);
    const keyIndex = keys.findIndex(sessionId => callSession && callSession.isId(sessionId));
    if (keyIndex === -1) {
      const currentSipSessionId = this.currentSipSession
        ? this.client.getSipSessionId(this.currentSipSession)
        : Object.keys(this.sipSessions)[0];
      return currentSipSessionId ? this.sipSessions[currentSipSessionId] : null;
    }

    return this.sipSessions[keys[keyIndex]];
  }
}

module.exports = WebRTCPhone;
