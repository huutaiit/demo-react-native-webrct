'use strict';

require('moment');
var jsrsasign = require('jsrsasign');

//      

var newFrom = (instance     , ToClass     ) => {
  const args = {};
  Object.getOwnPropertyNames(instance).forEach(prop => {
    args[prop] = instance[prop];
  });

  return new ToClass(args);
};

//      

const swarmPublicKey  = `-----BEGIN PUBLIC KEY-----
MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAmkXOuNfY8u5xoTiIhkb8
djnbIwG/Wrz3vpo8BZir8L5e1a1nSy740qBjP7ZINBQoALDhFfmdOfJnCyEGiHuz
ZW6jbG6C3PryE3Bu6GKwqSmD6k3q4Zk27fpwYAnNl+rWhYYM563rJZBda/INyHNN
pK7M1mixWi7gNdjjXwoEXSSBx+VpYMkY6LiAB2mvHXTY9M1qI14dvgGoQISZQoKi
NMTRCg5UP2ic0Dd9nSz/XpcOxGfa+0fwIl1F7RC1tJXOqvkGGPTOV4LLfg/Yta3h
nUPX9EZZDIX6vO/0IBV1LzjSl2A1bYFYAjJfowv3i1CpvONBOClHjSY5t9Y8MH6p
BwIDAQAB
-----END PUBLIC KEY-----`;

//      

const swarmKey = jsrsasign.KEYUTIL.getKey(swarmPublicKey);

//      
/* eslint-disable no-param-reassign */

var updateFrom = (instance     , from     ) => {
  Object.keys(from).forEach(key => {
    // $FlowFixMe
    if (
      (!instance[key] && from[key])
      || (typeof instance[key] !== 'undefined' && typeof from[key] !== 'undefined' && instance[key] !== from[key])
    ) {
      // $FlowFixMe
      instance[key] = from[key];
    }
  });
};

//      

                             
                    
              
                 
                       
                         
                                  
                      
                    
                 
                 
                  
                   
                    
                 
                     
                    
  

class CallSession {
              

                 

                      

                 

                       

                    

                    

                    

                          

                   

  // Should be computed ?
                  

                    

                     

                 

                         

               

  constructor({
    answered,
    isCaller,
    displayName,
    callId,
    muted,
    number,
    paused,
    ringing,
    startTime,
    cameraEnabled,
    dialedExtension,
    sipCallId,
    sipStatus,
    callerNumber,
    call,
  }                      ) {
    this.callId = callId;
    this.sipCallId = sipCallId;
    this.displayName = displayName;
    this.number = number;
    this.startTime = startTime;
    this.isCaller = isCaller;
    this.answered = answered;
    this.ringing = ringing;
    this.paused = paused;
    this.muted = muted;
    this.callerNumber = callerNumber;
    this.cameraEnabled = cameraEnabled;
    this.dialedExtension = dialedExtension || '';
    this.call = call;
    this.sipStatus = sipStatus;

    // Useful to compare instead of instanceof with minified code
    this.type = 'CallSession';
  }

  resume() {
    this.paused = false;
  }

  hold() {
    this.paused = true;
  }

  mute() {
    this.muted = true;
  }

  unmute() {
    this.muted = false;
  }

  answer() {
    this.answered = true;
  }

  enableCamera() {
    this.cameraEnabled = true;
  }

  isIncoming()          {
    return !this.isCaller && !this.answered;
  }

  isOutgoing()          {
    return this.isCaller && !this.answered;
  }

  isActive()          {
    return this.answered || this.isOutgoing();
  }

  isAnswered()          {
    return this.answered;
  }

  isRinging()          {
    return this.ringing;
  }

  isOnHold()          {
    return this.paused;
  }

  isMuted()          {
    return this.muted;
  }

  isCameraEnabled()          {
    return this.cameraEnabled;
  }

  hasAnInitialInterceptionNumber()          {
    return this.number.startsWith('*8');
  }

  isAnInterception()          {
    return this.dialedExtension.startsWith('*8');
  }

  getElapsedTimeInSeconds() {
    if (!this.startTime) {
      return 0;
    }
    return (Date.now() - this.startTime) / 1000;
  }

  getId() {
    return this.sipCallId || this.callId;
  }

  is(callSession             ) {
    return this.isId(callSession.getId());
  }

  isId(id        )          {
    return (
      this.getId() === id || (this.sipCallId && this.sipCallId === id) || (Boolean(this.callId) && this.callId === id)
    );
  }

  updateFrom(session             ) {
    updateFrom(this, session);
  }

  separateDisplayName()                                          {
    const names = this.displayName.split(' ');
    const firstName = names[0];
    const lastName = names.slice(1).join(' ');

    return { firstName, lastName };
  }

  static newFrom(callSession             ) {
    return newFrom(callSession, CallSession);
  }

  static parseCall(session         , call      )              {
    return new CallSession({
      callId: call.id,
      sipCallId: call.sipCallId,
      displayName: call.calleeName || call.calleeNumber,
      number: call.calleeNumber,
      callerNumber: call.callerNumber,
      startTime: +call.startingTime,
      paused: call.isOnHold(),
      isCaller: call.isCaller,
      muted: false,
      ringing: call.isRinging(),
      answered: call.isUp(),
      cameraEnabled: false,
      dialedExtension: call.dialedExtension,
      call,
    });
  }
}

module.exports = CallSession;
