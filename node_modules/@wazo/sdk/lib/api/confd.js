'use strict';

var jsBase64 = require('js-base64');

/*       */

class BadResponse extends Error {
  static fromResponse(error        , status        ) {
    return new BadResponse(error.message, status, error.timestamp, error.error_id, error.details);
  }

  static fromText(response        , status        ) {
    return new BadResponse(response, status);
  }

                  
                 
                     
                   
                   

  constructor(
    message        ,
    status        ,
    timestamp          = null,
    errorId          = null,
    details          = null,
  ) {
    super(message);

    this.timestamp = timestamp;
    this.status = status;
    this.errorId = errorId;
    this.details = details;
  }
}

/*       */

class ServerError extends BadResponse {
  static fromResponse(error        , status        ) {
    return new ServerError(error.message, status, error.timestamp, error.error_id, error.details);
  }

  static fromText(response        , status        ) {
    return new ServerError(response, status);
  }
}

/*       */

class Logger {
  static hasDebug() {
    return typeof process !== 'undefined' && (+process.env.DEBUG === 1 || process.env.DEBUG === 'true');
  }

  static logRequest(url        , { method, body, headers }        , response        ) {
    if (!Logger.hasDebug()) {
      return;
    }

    const { status } = response;

    let curl = `${status} - curl ${method !== 'get' ? `-X ${method.toUpperCase()}` : ''}`;
    Object.keys(headers).forEach(headerName => {
      curl += ` -H '${headerName}: ${headers[headerName]}'`;
    });

    curl += ` ${url}`;

    if (body) {
      curl += ` -d '${body}'`;
    }

    console.info(curl);
  }
}

/*       */
/* global navigator */
const isMobile = () => typeof navigator !== 'undefined' && navigator.product === 'ReactNative';

/*       */
                                             

                          
                 
                 
                    
                                 
  

const methods = ['head', 'get', 'post', 'put', 'delete'];

// Use a function here to be able to mock it in tests
const realFetch = () => {
  if (typeof document !== 'undefined') {
    // Browser
    return window.fetch;
  }

  if (isMobile()) {
    // React native
    return fetch;
  }

  // nodejs
  // this package is disable for react-native in package.json because it requires nodejs modules
  return require('node-fetch/lib/index');
};

class ApiRequester {
                 
                 
                    
                
                  
                                 

                 
                
                 
                
                   

  // eslint-disable-next-line
  static successResponseParser(response        , isJson         ) {
    return response.status === 204;
  }

  static defaultParser(response        ) {
    return response.json().then((data        ) => data);
  }

  static getQueryString(obj        )         {
    return Object.keys(obj)
      .filter(key => obj[key])
      .map(key => `${key}=${encodeURIComponent(obj[key])}`)
      .join('&');
  }

  static base64Encode(str        )         {
    return typeof btoa !== 'undefined' ? btoa(str) : jsBase64.Base64.encode(str);
  }

  // @see https://github.com/facebook/flow/issues/183#issuecomment-358607052
  constructor({ server, refreshTokenCallback, clientId, agent = null }                   ) {
    this.server = server;
    this.agent = agent;
    this.clientId = clientId;
    this.refreshTokenCallback = refreshTokenCallback;

    methods.forEach(method => {
      // $FlowFixMe
      ApiRequester.prototype[method] = function sugar(...args) {
        // Add method in arguments passed to `call`
        args.splice(1, 0, method);

        return this.call.call(this, ...args);
      };
    });
  }

  setTenant(tenant         ) {
    this.tenant = tenant;
  }

  call(
    path        ,
    method         = 'get',
    body          = null,
    headers                    = null,
    parse           = ApiRequester.defaultParser,
    firstCall          = true,
  )               {
    const url = this.computeUrl(method, path, body);
    const newHeaders = this.getHeaders(headers);
    let newBody = method === 'get' ? null : body;
    if (newBody && newHeaders['Content-Type'] === 'application/json') {
      newBody = JSON.stringify(newBody);
    }
    const isHead = method === 'head';
    const hasEmptyResponse = method === 'delete' || isHead;
    const newParse = hasEmptyResponse ? ApiRequester.successResponseParser : parse;
    const options = {
      method,
      body: newBody,
      headers: this.getHeaders(headers),
      agent: this.agent,
    };

    return realFetch()(url, options).then(response => {
      const contentType = response.headers.get('content-type') || '';
      const isJson = contentType.indexOf('application/json') !== -1;

      Logger.logRequest(url, options, response);

      // Throw an error only if status >= 400
      if ((isHead && response.status >= 500) || (!isHead && response.status >= 400)) {
        const promise = isJson ? response.json() : response.text();
        const exceptionClass = response.status >= 500 ? ServerError : BadResponse;

        return promise.then(async err => {
          // Check if the token is still valid
          if (firstCall && this._checkTokenExpired(response, err)) {
            // Replay the call after refreshing the token
            return this._replayWithNewToken(err, path, method, body, headers, parse);
          }

          throw typeof err === 'string'
            ? exceptionClass.fromText(err, response.status)
            : exceptionClass.fromResponse(err, response.status);
        });
      }

      return newParse(response, isJson);
    });
  }

  _checkTokenExpired(response        , err        ) {
    // Special case when authenticating form a token: we got a 404
    const isTokenNotFound = response.status === 404 && this._isTokenNotFound(err);

    return response.status === 401 || isTokenNotFound;
  }

  _isTokenNotFound(err        ) {
    return err.reason && err.reason[0] === 'No such token';
  }

  _replayWithNewToken(
    err        ,
    path        ,
    method        ,
    body          = null,
    headers                    = null,
    parse          ,
  ) {
    const isTokenNotFound = this._isTokenNotFound(err);
    let newPath = path;

    return this.refreshTokenCallback().then(() => {
      if (isTokenNotFound) {
        const pathParts = path.split('/');
        pathParts.pop();
        pathParts.push(this.token);
        newPath = pathParts.join('/');
      }

      return this.call(newPath, method, body, headers, parse, false);
    });
  }

  getHeaders(header                  )         {
    if (header instanceof Object) {
      return header;
    }

    return {
      'X-Auth-Token': this.token,
      ...(this.tenant ? { 'Wazo-Tenant': this.tenant } : null),
      Accept: 'application/json',
      'Content-Type': 'application/json',
    };
  }

  computeUrl(method        , path        , body         )         {
    const url = `${this.baseUrl}/${path}`;

    return method === 'get' && body && Object.keys(body).length ? `${url}?${ApiRequester.getQueryString(body)}` : url;
  }

  get baseUrl()         {
    return `https://${this.server}/api`;
  }
}

//      

var newFrom = (instance     , ToClass     ) => {
  const args = {};
  Object.getOwnPropertyNames(instance).forEach(prop => {
    args[prop] = instance[prop];
  });

  return new ToClass(args);
};

//      

                  
                  
                
             
                                               
  

                        
             
                                              
                    
  

                     
                             
                           
                          
                               
             
  

                      
             
                               
                                   
                                 
                                
  

class Line {
               

             
                               
                                  
                                
                               

  static parse(plain              )       {
    return new Line({
      id: plain.id,
      extensions: plain.extensions,
      endpointCustom: plain.endpoint_custom || null,
      endpointSccp: plain.endpoint_sccp || null,
      endpointSip: plain.endpoint_sip || null,
    });
  }

  static newFrom(profile      ) {
    return newFrom(profile, Line);
  }

  is(line      ) {
    return this.id === line.id;
  }

  hasExtension(extension        ) {
    return this.extensions.some(ext => ext.exten === extension);
  }

  constructor({ id, extensions, endpointCustom, endpointSccp, endpointSip }                = {}) {
    this.id = id;
    this.extensions = extensions;
    this.endpointCustom = endpointCustom || null;
    this.endpointSccp = endpointSccp || null;
    this.endpointSip = endpointSip || null;

    // Useful to compare instead of instanceof with minified code
    this.type = 'Line';
  }
}

//      

                 
                      
                   
  

const FORWARD_KEYS = {
  BUSY: 'busy',
  NO_ANSWER: 'noanswer',
  UNCONDITIONAL: 'unconditional',
};

                               
                      
                   
              
  

class ForwardOption {
                      
                   
              

  static parse(plain          , key        )                {
    return new ForwardOption({
      destination: plain.destination || '',
      enabled: plain.enabled,
      key,
    });
  }

  static newFrom(profile               ) {
    return newFrom(profile, ForwardOption);
  }

  constructor({ destination, enabled, key }                         = {}) {
    this.destination = destination;
    this.enabled = enabled;
    this.key = key;
  }

  setDestination(number        )                {
    this.destination = number;

    return this;
  }

  setEnabled(enabled         )                {
    this.enabled = enabled;

    return this;
  }

  is(other               ) {
    return this.key === other.key;
  }
}

//      
                                       

                        
             
                      
                   
                 
               
               
                                
                       
                 
                 
  

                         
             
                     
                   
                 
               
               
                                
                       
                 
                 
  

class SipLine {
               

             
                     
                   
                 
               
               
                                
                       
                 
                 

  static parse(plain                 )          {
    return new SipLine({
      id: plain.id,
      tenantUuid: plain.tenant_uuid,
      username: plain.username,
      secret: plain.secret,
      type: plain.type,
      host: plain.host,
      options: plain.options,
      links: plain.links,
      trunk: plain.trunk,
      line: plain.line,
    });
  }

  static newFrom(sipLine         ) {
    return newFrom(sipLine, SipLine);
  }

  is(line         ) {
    return this.id === line.id;
  }

  isWebRtc() {
    return this.options.some(option => option[0] === 'webrtc' && option[1] === 'yes');
  }

  constructor({ id, tenantUuid, username, secret, type, host, options, links, trunk, line }                   = {}) {
    this.id = id;
    this.tenantUuid = tenantUuid;
    this.username = username;
    this.secret = secret;
    this.type = type;
    this.host = host;
    this.options = options;
    this.links = links;
    this.trunk = trunk;
    this.line = line;

    // Useful to compare instead of instanceof with minified code
    this.type = 'SipLine';
  }
}

//      

const LINE_STATE = {
  AVAILABLE: 'available',
  HOLDING: 'holding',
  RINGING: 'ringing',
  TALKING: 'talking',
  UNAVAILABLE: 'unavailable',
};

                        
                                              
                    
                     
                   
                    
               
                
               
                                                                                                                    
                                      
                                    
                                   
     
             
                   
                    
                   
                
             
           
                          
                       
      
               
                          
                       
      
                    
                          
                       
      
    
                               
                             
             
          
                       
      
    
                           
               
               
                 
    
  

                         
             
                    
                   
                
                     
                            
                   
                       
                                 
                         
                 
                 
                            
               
               
                 
    
                           
  

class Profile {
             
                    
                   
                
                     
                           
                   
                       
                                 
                         
                 
                                           
                 
                            
                           

  static parse(plain                 )          {
    return new Profile({
      id: plain.uuid,
      firstName: plain.firstName || plain.firstname || '',
      lastName: plain.lastName || plain.lastname || '',
      email: plain.email,
      lines: plain.lines.map(line => Line.parse(line)),
      username: plain.username,
      mobileNumber: plain.mobile_phone_number || '',
      forwards: [
        ForwardOption.parse(plain.forwards.unconditional, FORWARD_KEYS.UNCONDITIONAL),
        ForwardOption.parse(plain.forwards.noanswer, FORWARD_KEYS.NO_ANSWER),
        ForwardOption.parse(plain.forwards.busy, FORWARD_KEYS.BUSY),
      ],
      doNotDisturb: plain.services.dnd.enabled,
      subscriptionType: plain.subscription_type,
      voicemail: plain.voicemail,
      switchboards: plain.switchboards || [],
      status: '',
    });
  }

  static newFrom(profile         ) {
    return newFrom(profile, Profile);
  }

  constructor({
    id,
    firstName,
    lastName,
    email,
    lines,
    username,
    mobileNumber,
    forwards,
    doNotDisturb,
    state,
    subscriptionType,
    voicemail,
    switchboards,
    status,
    sipLines,
  }                           = {}) {
    this.id = id;
    this.firstName = firstName;
    this.lastName = lastName;
    this.email = email;
    this.lines = lines;
    this.username = username;
    this.mobileNumber = mobileNumber;
    this.forwards = forwards;
    this.doNotDisturb = doNotDisturb;
    this.state = state;
    this.voicemail = voicemail;
    this.subscriptionType = subscriptionType;
    this.switchboards = switchboards;
    this.status = status;

    this.sipLines = sipLines || [];
  }

  static getLinesState(lines               ) {
    let result = LINE_STATE.UNAVAILABLE;

    // eslint-disable-next-line
    for (const line of lines) {
      if (line.state === LINE_STATE.RINGING) {
        result = LINE_STATE.RINGING;
        break;
      }

      if (line.state === LINE_STATE.TALKING) {
        result = LINE_STATE.TALKING;
        break;
      }

      if (line.state === LINE_STATE.AVAILABLE) {
        result = LINE_STATE.AVAILABLE;
      }
    }

    return result;
  }

  hasId(id        ) {
    return id === this.id;
  }

  setMobileNumber(number        ) {
    this.mobileNumber = number;

    return this;
  }

  setForwardOption(forwardOption               ) {
    const updatedForwardOptions = this.forwards.slice();
    const index = updatedForwardOptions.findIndex(forward => forward.is(forwardOption));
    updatedForwardOptions.splice(index, 1, forwardOption);

    this.forwards = updatedForwardOptions;

    return this;
  }

  setDoNotDisturb(enabled         ) {
    this.doNotDisturb = enabled;

    return this;
  }

  setState(state        ) {
    this.state = state;

    return this;
  }
}

/*       */

var confd = (client              , baseUrl        ) => ({
  listUsers: ()                                  => client.get(`${baseUrl}/users`, null),

  getUser: (userUuid        )                   => client.get(`${baseUrl}/users/${userUuid}`, null).then(Profile.parse),

  updateUser: (userUuid        , profile         )                   => {
    const body = {
      firstname: profile.firstName,
      lastname: profile.lastName,
      email: profile.email,
      mobile_phone_number: profile.mobileNumber,
    };

    return client.put(`${baseUrl}/users/${userUuid}`, body, null, ApiRequester.successResponseParser);
  },

  updateForwardOption: (userUuid        , key        , destination        , enabled         )                   => {
    const url = `${baseUrl}/users/${userUuid}/forwards/${key}`;
    return client.put(url, { destination, enabled }, null, ApiRequester.successResponseParser);
  },

  updateDoNotDisturb: (userUuid      , enabled         )                   =>
    client.put(`${baseUrl}/users/${userUuid}/services/dnd`, { enabled }, null, ApiRequester.successResponseParser),

  getUserLineSip: (userUuid        , lineId        )                   =>
    client.get(`${baseUrl}/users/${userUuid}/lines/${lineId}/associated/endpoints/sip`).then(SipLine.parse),

  getUserLinesSip(userUuid        , lineIds          )                     {
    // $FlowFixMe
    return Promise.all(lineIds.map(lineId => this.getUserLineSip(userUuid, lineId)));
  },

  getUserLineSipFromToken(userUuid        ) {
    return this.getUser(userUuid).then(user => {
      if (!user.lines.length) {
        console.warn(`No sip line for user: ${userUuid}`);
        return null;
      }
      const line = user.lines[0];

      return this.getUserLineSip(userUuid, line.id);
    });
  },

  listApplications: ()                                    => client.get(`${baseUrl}/applications?recurse=true`, null),

  getInfos: ()                                                  => client.get(`${baseUrl}/infos`, null),
});

module.exports = confd;
