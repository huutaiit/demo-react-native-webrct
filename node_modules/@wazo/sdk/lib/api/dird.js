'use strict';

var jsBase64 = require('js-base64');
var jsrsasign = require('jsrsasign');

/*       */

class BadResponse extends Error {
  static fromResponse(error        , status        ) {
    return new BadResponse(error.message, status, error.timestamp, error.error_id, error.details);
  }

  static fromText(response        , status        ) {
    return new BadResponse(response, status);
  }

                  
                 
                     
                   
                   

  constructor(
    message        ,
    status        ,
    timestamp          = null,
    errorId          = null,
    details          = null,
  ) {
    super(message);

    this.timestamp = timestamp;
    this.status = status;
    this.errorId = errorId;
    this.details = details;
  }
}

/*       */

class ServerError extends BadResponse {
  static fromResponse(error        , status        ) {
    return new ServerError(error.message, status, error.timestamp, error.error_id, error.details);
  }

  static fromText(response        , status        ) {
    return new ServerError(response, status);
  }
}

/*       */

class Logger {
  static hasDebug() {
    return typeof process !== 'undefined' && (+process.env.DEBUG === 1 || process.env.DEBUG === 'true');
  }

  static logRequest(url        , { method, body, headers }        , response        ) {
    if (!Logger.hasDebug()) {
      return;
    }

    const { status } = response;

    let curl = `${status} - curl ${method !== 'get' ? `-X ${method.toUpperCase()}` : ''}`;
    Object.keys(headers).forEach(headerName => {
      curl += ` -H '${headerName}: ${headers[headerName]}'`;
    });

    curl += ` ${url}`;

    if (body) {
      curl += ` -d '${body}'`;
    }

    console.info(curl);
  }
}

/*       */
/* global navigator */
const isMobile = () => typeof navigator !== 'undefined' && navigator.product === 'ReactNative';

/*       */
                                             

                          
                 
                 
                    
                                 
  

const methods = ['head', 'get', 'post', 'put', 'delete'];

// Use a function here to be able to mock it in tests
const realFetch = () => {
  if (typeof document !== 'undefined') {
    // Browser
    return window.fetch;
  }

  if (isMobile()) {
    // React native
    return fetch;
  }

  // nodejs
  // this package is disable for react-native in package.json because it requires nodejs modules
  return require('node-fetch/lib/index');
};

class ApiRequester {
                 
                 
                    
                
                  
                                 

                 
                
                 
                
                   

  // eslint-disable-next-line
  static successResponseParser(response        , isJson         ) {
    return response.status === 204;
  }

  static defaultParser(response        ) {
    return response.json().then((data        ) => data);
  }

  static getQueryString(obj        )         {
    return Object.keys(obj)
      .filter(key => obj[key])
      .map(key => `${key}=${encodeURIComponent(obj[key])}`)
      .join('&');
  }

  static base64Encode(str        )         {
    return typeof btoa !== 'undefined' ? btoa(str) : jsBase64.Base64.encode(str);
  }

  // @see https://github.com/facebook/flow/issues/183#issuecomment-358607052
  constructor({ server, refreshTokenCallback, clientId, agent = null }                   ) {
    this.server = server;
    this.agent = agent;
    this.clientId = clientId;
    this.refreshTokenCallback = refreshTokenCallback;

    methods.forEach(method => {
      // $FlowFixMe
      ApiRequester.prototype[method] = function sugar(...args) {
        // Add method in arguments passed to `call`
        args.splice(1, 0, method);

        return this.call.call(this, ...args);
      };
    });
  }

  setTenant(tenant         ) {
    this.tenant = tenant;
  }

  call(
    path        ,
    method         = 'get',
    body          = null,
    headers                    = null,
    parse           = ApiRequester.defaultParser,
    firstCall          = true,
  )               {
    const url = this.computeUrl(method, path, body);
    const newHeaders = this.getHeaders(headers);
    let newBody = method === 'get' ? null : body;
    if (newBody && newHeaders['Content-Type'] === 'application/json') {
      newBody = JSON.stringify(newBody);
    }
    const isHead = method === 'head';
    const hasEmptyResponse = method === 'delete' || isHead;
    const newParse = hasEmptyResponse ? ApiRequester.successResponseParser : parse;
    const options = {
      method,
      body: newBody,
      headers: this.getHeaders(headers),
      agent: this.agent,
    };

    return realFetch()(url, options).then(response => {
      const contentType = response.headers.get('content-type') || '';
      const isJson = contentType.indexOf('application/json') !== -1;

      Logger.logRequest(url, options, response);

      // Throw an error only if status >= 400
      if ((isHead && response.status >= 500) || (!isHead && response.status >= 400)) {
        const promise = isJson ? response.json() : response.text();
        const exceptionClass = response.status >= 500 ? ServerError : BadResponse;

        return promise.then(async err => {
          // Check if the token is still valid
          if (firstCall && this._checkTokenExpired(response, err)) {
            // Replay the call after refreshing the token
            return this._replayWithNewToken(err, path, method, body, headers, parse);
          }

          throw typeof err === 'string'
            ? exceptionClass.fromText(err, response.status)
            : exceptionClass.fromResponse(err, response.status);
        });
      }

      return newParse(response, isJson);
    });
  }

  _checkTokenExpired(response        , err        ) {
    // Special case when authenticating form a token: we got a 404
    const isTokenNotFound = response.status === 404 && this._isTokenNotFound(err);

    return response.status === 401 || isTokenNotFound;
  }

  _isTokenNotFound(err        ) {
    return err.reason && err.reason[0] === 'No such token';
  }

  _replayWithNewToken(
    err        ,
    path        ,
    method        ,
    body          = null,
    headers                    = null,
    parse          ,
  ) {
    const isTokenNotFound = this._isTokenNotFound(err);
    let newPath = path;

    return this.refreshTokenCallback().then(() => {
      if (isTokenNotFound) {
        const pathParts = path.split('/');
        pathParts.pop();
        pathParts.push(this.token);
        newPath = pathParts.join('/');
      }

      return this.call(newPath, method, body, headers, parse, false);
    });
  }

  getHeaders(header                  )         {
    if (header instanceof Object) {
      return header;
    }

    return {
      'X-Auth-Token': this.token,
      ...(this.tenant ? { 'Wazo-Tenant': this.tenant } : null),
      Accept: 'application/json',
      'Content-Type': 'application/json',
    };
  }

  computeUrl(method        , path        , body         )         {
    const url = `${this.baseUrl}/${path}`;

    return method === 'get' && body && Object.keys(body).length ? `${url}?${ApiRequester.getQueryString(body)}` : url;
  }

  get baseUrl()         {
    return `https://${this.server}/api`;
  }
}

//      

const swarmPublicKey  = `-----BEGIN PUBLIC KEY-----
MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAmkXOuNfY8u5xoTiIhkb8
djnbIwG/Wrz3vpo8BZir8L5e1a1nSy740qBjP7ZINBQoALDhFfmdOfJnCyEGiHuz
ZW6jbG6C3PryE3Bu6GKwqSmD6k3q4Zk27fpwYAnNl+rWhYYM563rJZBda/INyHNN
pK7M1mixWi7gNdjjXwoEXSSBx+VpYMkY6LiAB2mvHXTY9M1qI14dvgGoQISZQoKi
NMTRCg5UP2ic0Dd9nSz/XpcOxGfa+0fwIl1F7RC1tJXOqvkGGPTOV4LLfg/Yta3h
nUPX9EZZDIX6vO/0IBV1LzjSl2A1bYFYAjJfowv3i1CpvONBOClHjSY5t9Y8MH6p
BwIDAQAB
-----END PUBLIC KEY-----`;

//      

var newFrom = (instance     , ToClass     ) => {
  const args = {};
  Object.getOwnPropertyNames(instance).forEach(prop => {
    args[prop] = instance[prop];
  });

  return new ToClass(args);
};

//      

const STATE = {
  AVAILABLE: 'available',
  UNAVAILABLE: 'unavailable',
  INVISIBLE: 'invisible',
  DISCONNECTED: 'disconnected',
  AWAY: 'away',
};

const LINE_STATE = {
  AVAILABLE: 'available',
  HOLDING: 'holding',
  RINGING: 'ringing',
  TALKING: 'talking',
  UNAVAILABLE: 'unavailable',
};

//      

const swarmKey = jsrsasign.KEYUTIL.getKey(swarmPublicKey);

//      
                                                         

const BACKEND = {
  OFFICE365: 'office365',
  PERSONAL: 'personal',
  GOOGLE: 'google',
  WAZO: 'wazo',
};

                          
                    
                   
                      
                 
                   
                      
                    
                
  

                               
                 
                  
                            
              
                    
                    
                      
                        
                      
                            
    
  

                                
                               
               
                                
                                  
  

                                       
             
                     
                    
                  
                                                     
                 
                      
                    
                   
                
                    
                     
                    
                   
                     
  

// @see: https://github.com/rt2zz/react-native-contacts#example-contact-record
                                     
                   
                  
                         
                  
                  
     
                    
                     
                     
                   
               
                       
                  
                
     
                       
                  
                   
     
                        
                        
                          
                   
                 
                  
                   
                     
                    
                  
     
             
                 
                  
                
    
  

                         
              
                
                
                  
                                                     
                      
                 
                                                   
                      
                    
                   
                
                      
                     
                 
                  
                    
                     
                   
                  
                   
                          
  

                          
                     
                
                       
                        
                             
                         
                    
                       
                   
                          
                  
                      
                                                           
                 
                  
                 
                   
                       
             
                   
                
                
                               
               
                  
                      
                
                      
                    
                         
                        
                  
                  
                  
             
                       
                     
                   
  

                     
                
                
                    
                   
                           
               
             
                        
  
                           
                  
               
             
                                                        
                                                     
  

                       
                   
             
               
                    
                        
  

const SOURCE_MOBILE = 'mobile';

class Contact {
               

              
                
                
                  
                                                     
                      
                 
                                                   
                      
                    
                   
                
                      
                     
                 
                     
                   
                  
                   
                  
                   
                         

  static merge(oldContacts                , newContacts                )                 {
    return newContacts.map(current => {
      const old = oldContacts.find(contact => contact.is(current));

      return typeof old !== 'undefined' ? current.merge(old) : current;
    });
  }

  static sortContacts(a         , b         ) {
    const aNames = a.separateName();
    const bNames = b.separateName();
    const aLastName = aNames.lastName;
    const bLastName = bNames.lastName;

    // last Name can be empty
    if (aLastName === bLastName) {
      return aNames.firstName.localeCompare(bNames.firstName);
    }

    return aLastName.localeCompare(bLastName);
  }

  static parseMany(response                  )                 {
    return response.results.map(r => Contact.parse(r, response.column_types));
  }

  static fetchNumbers(plain                 , columns                )                {
    const numberColumns = columns
      .map((e, index) => ({ index, columnName: e }))
      .filter(e => e.columnName === 'number' || e.columnName === 'callable')
      .map(e => e.index);

    return plain.column_values.filter((e, index) => numberColumns.some(i => i === index) && e !== null);
  }

  static parse(plain                 , columns                )          {
    const numbers = Contact.fetchNumbers(plain, columns);
    const email = plain.column_values[columns.indexOf('email')];

    return new Contact({
      name: plain.column_values[columns.indexOf('name')],
      number: numbers.length ? numbers[0] : '',
      numbers: numbers.map((number, i) => ({ label: i === 0 ? 'primary' : 'secondary', number })),
      favorited: plain.column_values[columns.indexOf('favorite')],
      email: email || '',
      emails: email ? [{ label: 'primary', email }] : [],
      entreprise: plain.column_values[columns.indexOf('entreprise')] || '',
      birthday: plain.column_values[columns.indexOf('birthday')] || '',
      address: plain.column_values[columns.indexOf('address')] || '',
      note: plain.column_values[columns.indexOf('note')] || '',
      endpointId: plain.relations.endpoint_id,
      personal: plain.column_values[columns.indexOf('personal')],
      source: plain.source,
      sourceId: plain.relations.source_entry_id,
      uuid: plain.relations.user_uuid,
      backend: plain.backend || '',
    });
  }

  static parseManyPersonal(results                                )                  {
    return results.map(r => Contact.parsePersonal(r));
  }

  static parsePersonal(plain                         )          {
    return new Contact({
      name: `${plain.firstName || plain.firstname || ''} ${plain.lastName || plain.lastname || ''}`,
      number: plain.number || '',
      numbers: plain.number ? [{ label: 'primary', number: plain.number }] : [],
      email: plain.email || '',
      emails: plain.email ? [{ label: 'primary', email: plain.email }] : [],
      source: 'personal',
      sourceId: plain.id,
      entreprise: plain.entreprise || '',
      birthday: plain.birthday || '',
      address: plain.address || '',
      note: plain.note || '',
      favorited: plain.favorited,
      personal: true,
      backend: plain.backend || BACKEND.PERSONAL,
    });
  }

  static parseMobile(plain                       )          {
    let address = '';
    if (plain.postalAddresses.length) {
      const postalAddress = plain.postalAddresses[0];

      address = `${postalAddress.street} ${postalAddress.city} ${postalAddress.postCode} ${postalAddress.country}`;
    }

    return new Contact({
      name: `${plain.givenName || ''} ${plain.familyName || ''}`,
      number: plain.phoneNumbers.length ? plain.phoneNumbers[0].number : '',
      numbers: plain.phoneNumbers.length ? [{ label: 'primary', number: plain.phoneNumbers[0].number }] : [],
      email: plain.emailAddresses.length ? plain.emailAddresses[0].email : '',
      emails: plain.emailAddresses.length ? [{ label: 'primary', email: plain.emailAddresses[0].email }] : [],
      source: SOURCE_MOBILE,
      sourceId: plain.recordID,
      birthday: plain.birthday ? `${plain.birthday.year}-${plain.birthday.month}-${plain.birthday.day}` : '',
      address,
      note: plain.note || '',
      favorited: false,
      personal: true,
    });
  }

  static parseManyOffice365(response                     , source                 )                 {
    return response.map(r => Contact.parseOffice365(r, source));
  }

  static parseOffice365(single                   , source                 )          {
    const emails = [];
    const numbers = [];

    if (single.emailAddresses) {
      const formattedEmails = single.emailAddresses.map(email => ({ label: 'email', email: email.address }));
      emails.push(...formattedEmails);
    }

    if (single.homePhones) {
      const formattedPhones = single.homePhones.map(phone => ({ label: 'home', number: phone }));
      numbers.push(...formattedPhones);
    }

    if (single.mobilePhone) {
      numbers.push({ label: 'mobile', number: single.mobilePhone });
    }

    return new Contact({
      sourceId: single.id,
      name: single.displayName,
      numbers,
      emails,
      source: source.name,
      backend: BACKEND.OFFICE365,
    });
  }

  static parseManyGoogle(response                  , source                 )                 {
    return response.map(r => Contact.parseGoogle(r, source));
  }

  static parseGoogle(single                , source                 )          {
    const emails = [];
    const numbers = [];

    if (single.emails) {
      const formattedEmails = single.emails.map(email => ({ label: 'email', email }));
      emails.push(...formattedEmails);
    }

    if (single.numbers) {
      const formattedPhones = single.numbers.map(phone => ({ label: 'mobile', number: phone }));
      numbers.push(...formattedPhones);
    }

    return new Contact({
      sourceId: single.id,
      name: single.name,
      numbers,
      emails,
      source: source.name,
      backend: BACKEND.GOOGLE,
    });
  }

  static parseManyWazo(response                , source                 )                 {
    return response.map(r => Contact.parseWazo(r, source));
  }

  static parseWazo(single              , source                 )          {
    const emails = [];
    const numbers = [];

    if (single.email) {
      emails.push({ label: 'email', email: single.email });
    }

    if (single.exten) {
      numbers.push({ label: 'exten', number: single.exten });
    }

    if (single.mobile_phone_number) {
      numbers.push({ label: 'mobile', number: single.mobile_phone_number });
    }

    return new Contact({
      uuid: single.uuid,
      sourceId: String(single.id),
      name: `${single.firstname} ${single.lastname}`,
      numbers,
      emails,
      source: source.name,
      backend: BACKEND.WAZO,
    });
  }

  static parseManyConference(response                      , source                 )                 {
    return response.map(r => Contact.parseConference(r, source));
  }

  static parseConference(single                    , source                 )          {
    const numbers = [];
    let firstNumber = '';

    if (single.extensions.length > 0 && single.extensions[0].exten) {
      firstNumber = single.extensions[0].exten;
      numbers.push({ label: 'exten', number: firstNumber });
    }

    return new Contact({
      sourceId: String(single.id),
      name: single.name,
      number: firstNumber,
      numbers,
      source: source.name,
      backend: 'conference',
    });
  }

  static newFrom(profile         ) {
    return newFrom(profile, Contact);
  }

  constructor({
    id,
    uuid,
    name,
    number,
    numbers,
    email,
    emails,
    source,
    sourceId,
    entreprise,
    birthday,
    address,
    note,
    state,
    lineState,
    mobile,
    status,
    endpointId,
    personal,
    favorited,
    backend,
    personalStatus,
  }                   = {}) {
    this.id = id;
    this.uuid = uuid;
    this.name = name;
    this.number = number;
    this.numbers = numbers;
    this.email = email;
    this.emails = emails;
    this.source = source;
    this.sourceId = sourceId || '';
    this.entreprise = entreprise;
    this.birthday = birthday;
    this.address = address;
    this.note = note;
    this.state = state;
    this.lineState = lineState;
    this.mobile = mobile;
    this.status = status;
    this.endpointId = endpointId;
    this.personal = personal;
    this.favorited = favorited;
    this.backend = backend;
    this.personalStatus = personalStatus || '';

    // Useful to compare instead of instanceof with minified code
    this.type = 'Contact';
  }

  setFavorite(value         ) {
    this.favorited = value;

    return this;
  }

  is(other         )          {
    const sameSourceId = !!this.sourceId && !!other.sourceId && this.sourceId === other.sourceId;
    const sameUuid = !!this.uuid && !!other.uuid && this.uuid === other.uuid;

    const hasSameId = sameSourceId || sameUuid;
    const hasSameBackend = !!this.backend && !!other.backend && this.backend === other.backend;
    const hasSameSource = !!this.source && !!other.source && this.source === other.source;

    return !!other && hasSameId && hasSameBackend && hasSameSource;
  }

  hasId(id        )          {
    return this.uuid === id;
  }

  hasNumber(number        )          {
    return this.number === number;
  }

  hasEndpointId(endpointId        )          {
    return this.endpointId === endpointId;
  }

  isAvailable()          {
    return this.state === STATE.AVAILABLE;
  }

  isAway()          {
    return this.state === STATE.AWAY;
  }

  isUnavailable()          {
    return this.state === STATE.UNAVAILABLE;
  }

  isInvisible()          {
    return this.state === STATE.INVISIBLE;
  }

  isInCall()          {
    return this.lineState === LINE_STATE.TALKING || this.lineState === LINE_STATE.HOLDING;
  }

  isRinging()          {
    return this.lineState === LINE_STATE.RINGING;
  }

  isInUseOrRinging()          {
    return this.lineState === LINE_STATE.TALKING || this.lineState === LINE_STATE.RINGING;
  }

  merge(old         )          {
    this.state = old.state;
    this.status = old.status;
    this.mobile = old.mobile;
    if (old.lineState && !this.lineState) {
      this.lineState = old.lineState;
    }

    return this;
  }

  isIntern()          {
    return !!this.uuid;
  }

  isCallable(session         )          {
    return !!this.number && !!session && !session.is(this);
  }

  isFromMobile() {
    return this.source === SOURCE_MOBILE;
  }

  isFavorite() {
    return this.favorited;
  }

  separateName()                                          {
    if (!this.name) {
      return {
        firstName: '',
        lastName: '',
      };
    }
    const names = this.name.split(/\s+/);
    const firstName = names[0];
    const lastName = names.slice(1).join(' ');

    return {
      firstName,
      lastName,
    };
  }
}

/*       */
                                                    
                                                                                   
                                        

const getContactPayload = (contact                      ) => ({
  email: contact.email,
  firstname: contact.firstName ? contact.firstName : '',
  lastname: contact.lastName ? contact.lastName : '',
  number: contact.phoneNumber ? contact.phoneNumber : '',
  entreprise: contact.entreprise ? contact.entreprise : '',
  birthday: contact.birthday ? contact.birthday : '',
  address: contact.address ? contact.address : '',
  note: contact.note ? contact.note : '',
});

                                 
                 
                             
                 
                  
                  
                
         

var dird = (client              , baseUrl        ) => ({
  search: (context        , term        )                          =>
    client.get(`${baseUrl}/directories/lookup/${context}`, { term }).then(Contact.parseMany),

  listPersonalContacts: (queryParams                           = null)                          =>
    client.get(`${baseUrl}/personal`, queryParams).then(response => Contact.parseManyPersonal(response.items)),

  addContact: (contact            )                   =>
    client.post(`${baseUrl}/personal`, getContactPayload(contact)).then(Contact.parsePersonal),

  editContact: (contact         )                   =>
    client
      .put(`${baseUrl}/personal/${contact.sourceId || contact.id || ''}`, getContactPayload(contact))
      .then(Contact.parsePersonal),

  deleteContact: (contactUuid      ) => client.delete(`${baseUrl}/personal/${contactUuid}`),

  listFavorites: (context        )                          =>
    client.get(`${baseUrl}/directories/favorites/${context}`).then(Contact.parseMany),

  markAsFavorite: (source        , sourceId        )                   => {
    const url = `${baseUrl}/directories/favorites/${source}/${sourceId}`;

    return client.put(url, null, null, ApiRequester.successResponseParser);
  },

  removeFavorite: (source        , sourceId        ) =>
    client.delete(`${baseUrl}/directories/favorites/${source}/${sourceId}`),

  fetchOffice365Source: (context        )                            =>
    client.get(`${baseUrl}/directories/${context}/sources`, { backend: 'office365' }),

  fetchOffice365Contacts: (source                 , queryParams                           = null)                     =>
    client
      .get(`${baseUrl}/backends/office365/sources/${source.uuid}/contacts`, queryParams)
      .then(response => Contact.parseManyOffice365(response.items, source)),

  fetchWazoSource: (context        )                   =>
    client.get(`${baseUrl}/directories/${context}/sources`, { backend: 'wazo' }),

  // Can be used with `queryParams = { uuid: uuid1, uuid2 }` to fetch multiple contacts
  fetchWazoContacts: (source                 , queryParams                           = null)                     =>
    client
      .get(`${baseUrl}/backends/wazo/sources/${source.uuid}/contacts`, queryParams)
      .then(response => Contact.parseManyWazo(response.items, source)),

  fetchGoogleSource: (context        )                   =>
    client.get(`${baseUrl}/directories/${context}/sources`, { backend: 'google' }),

  fetchGoogleContacts: (source                 , queryParams                           = null)                     =>
    client
      .get(`${baseUrl}/backends/google/sources/${source.uuid}/contacts`, queryParams)
      .then(response => Contact.parseManyGoogle(response.items, source)),

  fetchConferenceSource: (context        )                   =>
    client.get(`${baseUrl}/directories/${context}/sources`, { backend: 'conference' }),

  fetchConferenceContacts: (source                 )                     =>
    client
      .get(`${baseUrl}/backends/conference/sources/${source.uuid}/contacts`)
      .then(response => Contact.parseManyConference(response.items, source)),
});

module.exports = dird;
