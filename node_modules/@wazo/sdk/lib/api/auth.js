'use strict';

var jsBase64 = require('js-base64');
var jsrsasign = require('jsrsasign');

/*       */

class BadResponse extends Error {
  static fromResponse(error        , status        ) {
    return new BadResponse(error.message, status, error.timestamp, error.error_id, error.details);
  }

  static fromText(response        , status        ) {
    return new BadResponse(response, status);
  }

                  
                 
                     
                   
                   

  constructor(
    message        ,
    status        ,
    timestamp          = null,
    errorId          = null,
    details          = null,
  ) {
    super(message);

    this.timestamp = timestamp;
    this.status = status;
    this.errorId = errorId;
    this.details = details;
  }
}

/*       */

class ServerError extends BadResponse {
  static fromResponse(error        , status        ) {
    return new ServerError(error.message, status, error.timestamp, error.error_id, error.details);
  }

  static fromText(response        , status        ) {
    return new ServerError(response, status);
  }
}

/*       */

class Logger {
  static hasDebug() {
    return typeof process !== 'undefined' && (+process.env.DEBUG === 1 || process.env.DEBUG === 'true');
  }

  static logRequest(url        , { method, body, headers }        , response        ) {
    if (!Logger.hasDebug()) {
      return;
    }

    const { status } = response;

    let curl = `${status} - curl ${method !== 'get' ? `-X ${method.toUpperCase()}` : ''}`;
    Object.keys(headers).forEach(headerName => {
      curl += ` -H '${headerName}: ${headers[headerName]}'`;
    });

    curl += ` ${url}`;

    if (body) {
      curl += ` -d '${body}'`;
    }

    console.info(curl);
  }
}

/*       */
/* global navigator */
const isMobile = () => typeof navigator !== 'undefined' && navigator.product === 'ReactNative';

/*       */
                                             

                          
                 
                 
                    
                                 
  

const methods = ['head', 'get', 'post', 'put', 'delete'];

// Use a function here to be able to mock it in tests
const realFetch = () => {
  if (typeof document !== 'undefined') {
    // Browser
    return window.fetch;
  }

  if (isMobile()) {
    // React native
    return fetch;
  }

  // nodejs
  // this package is disable for react-native in package.json because it requires nodejs modules
  return require('node-fetch/lib/index');
};

class ApiRequester {
                 
                 
                    
                
                  
                                 

                 
                
                 
                
                   

  // eslint-disable-next-line
  static successResponseParser(response        , isJson         ) {
    return response.status === 204;
  }

  static defaultParser(response        ) {
    return response.json().then((data        ) => data);
  }

  static getQueryString(obj        )         {
    return Object.keys(obj)
      .filter(key => obj[key])
      .map(key => `${key}=${encodeURIComponent(obj[key])}`)
      .join('&');
  }

  static base64Encode(str        )         {
    return typeof btoa !== 'undefined' ? btoa(str) : jsBase64.Base64.encode(str);
  }

  // @see https://github.com/facebook/flow/issues/183#issuecomment-358607052
  constructor({ server, refreshTokenCallback, clientId, agent = null }                   ) {
    this.server = server;
    this.agent = agent;
    this.clientId = clientId;
    this.refreshTokenCallback = refreshTokenCallback;

    methods.forEach(method => {
      // $FlowFixMe
      ApiRequester.prototype[method] = function sugar(...args) {
        // Add method in arguments passed to `call`
        args.splice(1, 0, method);

        return this.call.call(this, ...args);
      };
    });
  }

  setTenant(tenant         ) {
    this.tenant = tenant;
  }

  call(
    path        ,
    method         = 'get',
    body          = null,
    headers                    = null,
    parse           = ApiRequester.defaultParser,
    firstCall          = true,
  )               {
    const url = this.computeUrl(method, path, body);
    const newHeaders = this.getHeaders(headers);
    let newBody = method === 'get' ? null : body;
    if (newBody && newHeaders['Content-Type'] === 'application/json') {
      newBody = JSON.stringify(newBody);
    }
    const isHead = method === 'head';
    const hasEmptyResponse = method === 'delete' || isHead;
    const newParse = hasEmptyResponse ? ApiRequester.successResponseParser : parse;
    const options = {
      method,
      body: newBody,
      headers: this.getHeaders(headers),
      agent: this.agent,
    };

    return realFetch()(url, options).then(response => {
      const contentType = response.headers.get('content-type') || '';
      const isJson = contentType.indexOf('application/json') !== -1;

      Logger.logRequest(url, options, response);

      // Throw an error only if status >= 400
      if ((isHead && response.status >= 500) || (!isHead && response.status >= 400)) {
        const promise = isJson ? response.json() : response.text();
        const exceptionClass = response.status >= 500 ? ServerError : BadResponse;

        return promise.then(async err => {
          // Check if the token is still valid
          if (firstCall && this._checkTokenExpired(response, err)) {
            // Replay the call after refreshing the token
            return this._replayWithNewToken(err, path, method, body, headers, parse);
          }

          throw typeof err === 'string'
            ? exceptionClass.fromText(err, response.status)
            : exceptionClass.fromResponse(err, response.status);
        });
      }

      return newParse(response, isJson);
    });
  }

  _checkTokenExpired(response        , err        ) {
    // Special case when authenticating form a token: we got a 404
    const isTokenNotFound = response.status === 404 && this._isTokenNotFound(err);

    return response.status === 401 || isTokenNotFound;
  }

  _isTokenNotFound(err        ) {
    return err.reason && err.reason[0] === 'No such token';
  }

  _replayWithNewToken(
    err        ,
    path        ,
    method        ,
    body          = null,
    headers                    = null,
    parse          ,
  ) {
    const isTokenNotFound = this._isTokenNotFound(err);
    let newPath = path;

    return this.refreshTokenCallback().then(() => {
      if (isTokenNotFound) {
        const pathParts = path.split('/');
        pathParts.pop();
        pathParts.push(this.token);
        newPath = pathParts.join('/');
      }

      return this.call(newPath, method, body, headers, parse, false);
    });
  }

  getHeaders(header                  )         {
    if (header instanceof Object) {
      return header;
    }

    return {
      'X-Auth-Token': this.token,
      ...(this.tenant ? { 'Wazo-Tenant': this.tenant } : null),
      Accept: 'application/json',
      'Content-Type': 'application/json',
    };
  }

  computeUrl(method        , path        , body         )         {
    const url = `${this.baseUrl}/${path}`;

    return method === 'get' && body && Object.keys(body).length ? `${url}?${ApiRequester.getQueryString(body)}` : url;
  }

  get baseUrl()         {
    return `https://${this.server}/api`;
  }
}

//      

const swarmPublicKey  = `-----BEGIN PUBLIC KEY-----
MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAmkXOuNfY8u5xoTiIhkb8
djnbIwG/Wrz3vpo8BZir8L5e1a1nSy740qBjP7ZINBQoALDhFfmdOfJnCyEGiHuz
ZW6jbG6C3PryE3Bu6GKwqSmD6k3q4Zk27fpwYAnNl+rWhYYM563rJZBda/INyHNN
pK7M1mixWi7gNdjjXwoEXSSBx+VpYMkY6LiAB2mvHXTY9M1qI14dvgGoQISZQoKi
NMTRCg5UP2ic0Dd9nSz/XpcOxGfa+0fwIl1F7RC1tJXOqvkGGPTOV4LLfg/Yta3h
nUPX9EZZDIX6vO/0IBV1LzjSl2A1bYFYAjJfowv3i1CpvONBOClHjSY5t9Y8MH6p
BwIDAQAB
-----END PUBLIC KEY-----`;

//      

var newFrom = (instance     , ToClass     ) => {
  const args = {};
  Object.getOwnPropertyNames(instance).forEach(prop => {
    args[prop] = instance[prop];
  });

  return new ToClass(args);
};

// Can't use `semver` package as Wazo version aren't in semver format

const compareVersions = (a, b) => {
  let i;
  let diff;
  const regExStrip0 = /(\.0+)+$/;
  const segmentsA = a.replace(regExStrip0, '').split('.');
  const segmentsB = b.replace(regExStrip0, '').split('.');
  const l = Math.min(segmentsA.length, segmentsB.length);

  for (i = 0; i < l; i++) {
    diff = parseInt(segmentsA[i], 10) - parseInt(segmentsB[i], 10);
    if (diff) {
      return diff;
    }
  }
  return segmentsA.length - segmentsB.length;
};

//      

const swarmKey = jsrsasign.KEYUTIL.getKey(swarmPublicKey);
const MINIMUM_WAZO_ENGINE_VERSION_FOR_DEFAULT_CONTEXT = '19.08';

                 
         
                 
                          
                       
                        
                           
                      
                      
                    
                       
                            
                
                   
                        
                 
                         
                            
                             
                       
                                      
                     
      
    
  

                      
               
                                                  
                   
  

                         
                
                         
                        
                 
                       
                     
                  
                                        
                          
  

class Session {
                
                        
                
                      
                       
                         
                    
                  
                                       

  static parse(plain          )           {
    const token = plain.data.metadata ? plain.data.metadata.jwt : null;
    let authorizations = [];

    // Add authorizations from JWT
    if (token) {
      const isValid = jsrsasign.jws.JWS.verifyJWT(token, swarmKey, { alg: ['RS256'], verifyAt: new Date() });
      if (isValid) {
        const decodedToken = jsrsasign.jws.JWS.readSafeJSONString(jsrsasign.b64utoutf8(token.split('.')[1]));
        authorizations = decodedToken ? decodedToken.authorizations : [];
      }
    }

    return new Session({
      token: plain.data.token,
      refreshToken: plain.data.refresh_token || null,
      uuid: plain.data.metadata ? plain.data.metadata.uuid : null,
      sessionUuid: plain.data.session_uuid,
      authorizations,
      tenantUuid: plain.data.metadata ? plain.data.metadata.tenant_uuid : undefined,
      expiresAt: new Date(`${plain.data.utc_expires_at}z`),
    });
  }

  static newFrom(profile         ) {
    return newFrom(profile, Session);
  }

  constructor({
    token,
    uuid,
    tenantUuid,
    profile,
    expiresAt,
    authorizations,
    engineVersion,
    refreshToken,
    sessionUuid,
  }                   = {}) {
    this.token = token;
    this.uuid = uuid;
    this.tenantUuid = tenantUuid || null;
    this.profile = profile;
    this.expiresAt = expiresAt;
    this.authorizations = authorizations || [];
    this.engineVersion = engineVersion;
    this.refreshToken = refreshToken;
    this.sessionUuid = sessionUuid;
  }

  hasExpired(date       = new Date())          {
    return date >= this.expiresAt;
  }

  is(contact         )          {
    return Boolean(contact) && this.uuid === contact.uuid;
  }

  using(profile         )          {
    this.profile = profile;

    return this;
  }

  hasAuthorizations() {
    return this.authorizations && !!this.authorizations.length;
  }

  displayName()         {
    return this.profile ? `${this.profile.firstName} ${this.profile.lastName}` : '';
  }

  hasAccessToVoicemail()          {
    if (!this.profile) {
      return false;
    }
    return !!this.profile.voicemail;
  }

  primaryLine()        {
    return this.profile && this.profile.lines.length > 0 ? this.profile.lines[0] : null;
  }

  primarySipLine()           {
    return this.profile && this.profile.sipLines.length > 0 ? this.profile.sipLines[0] : null;
  }

  primaryWebRtcLine()           {
    return this.profile && this.profile.sipLines.find(sipLine => sipLine.isWebRtc());
  }

  primaryCtiLine()           {
    return this.profile && this.profile.sipLines.find(sipLine => !sipLine.isWebRtc());
  }

  primaryContext()         {
    if (this.engineVersion) {
      if (this.hasEngineVersionGte(MINIMUM_WAZO_ENGINE_VERSION_FOR_DEFAULT_CONTEXT)) {
        return 'default';
      }
    }

    const line = this.primaryLine();

    return line && line.extensions.length > 0 ? line.extensions[0].context : 'default';
  }

  hasEngineVersionGte(version        ) {
    return this.engineVersion && compareVersions(String(this.engineVersion), String(version)) >= 0;
  }

  primaryNumber()          {
    const line = this.primaryLine();

    return line ? line.extensions[0].exten : null;
  }

  allLines()         {
    return this.profile ? this.profile.lines || [] : [];
  }

  allNumbers()           {
    const extensions = this.allLines().map(line => line.extensions.map(extension => extension.exten));
    if (!extensions.length) {
      return [];
    }

    return extensions.reduce((a, b) => a.concat(b));
  }

  hasExtension(extension        )          {
    return this.allNumbers().some(number => number === extension);
  }
}

/*       */

const DEFAULT_BACKEND_USER = 'wazo_user';
const DETAULT_EXPIRATION = 3600;

var auth = (client              , baseUrl        ) => ({
  checkToken: (token       )                   => client.head(`${baseUrl}/token/${token}`, null, {}),

  authenticate: (token       )                    =>
    client.get(`${baseUrl}/token/${token}`, null, {}).then(response => Session.parse(response)),

  logIn(params   
                     
                     
                    
                       
                     
   )                    {
    const body         = {
      backend: params.backend || DEFAULT_BACKEND_USER,
      expiration: params.expiration || DETAULT_EXPIRATION,
    };
    const headers         = {
      Authorization: `Basic ${ApiRequester.base64Encode(`${params.username}:${params.password}`)}`,
      'Content-Type': 'application/json',
    };

    if (client.clientId) {
      body.access_type = 'offline';
      body.client_id = client.clientId;
    }

    if (params.mobile) {
      headers['Wazo-Session-Type'] = 'mobile';
    }

    return client.post(`${baseUrl}/token`, body, headers).then(response => Session.parse(response));
  },

  logOut: (token       )                          =>
    client.delete(`${baseUrl}/token/${token}`, null, {}, ApiRequester.successResponseParser),

  refreshToken: (refreshToken        , backend        , expiration        )                    => {
    const body         = {
      backend: backend || DEFAULT_BACKEND_USER,
      expiration: expiration || DETAULT_EXPIRATION,
      refresh_token: refreshToken,
      client_id: client.clientId,
    };

    const headers         = {
      'Content-Type': 'application/json',
    };

    return client.post(`${baseUrl}/token`, body, headers, ApiRequester.defaultParser, false).then(Session.parse);
  },

  updatePassword: (userUuid      , oldPassword        , newPassword        )                   => {
    const body = {
      new_password: newPassword,
      old_password: oldPassword,
    };

    return client.put(`${baseUrl}/users/${userUuid}/password`, body, null, ApiRequester.successResponseParser);
  },

  sendDeviceToken: (userUuid      , deviceToken        , apnsToken         ) => {
    const body         = {
      token: deviceToken,
    };

    if (apnsToken) {
      body.apns_token = apnsToken;
    }

    return client.post(`${baseUrl}/users/${userUuid}/external/mobile`, body);
  },

  getPushNotificationSenderId: (userUuid      ) =>
    client.get(`${baseUrl}/users/${userUuid}/external/mobile/sender_id`, null).then(response => response.sender_id),

  /**
   * `username` or `email` should be set.
   */
  sendResetPasswordEmail: ({ username, email }                                       ) => {
    const body = {};
    if (username) {
      body.username = username;
    }
    if (email) {
      body.email = email;
    }

    return client.get(`${baseUrl}/users/password/reset`, body, {}, ApiRequester.successResponseParser);
  },

  resetPassword: (userUuid        , password        ) => {
    const body = {
      password,
    };

    return client.post(
      `${baseUrl}/users/password/reset?user_uuid=${userUuid}`,
      body,
      null,
      ApiRequester.successResponseParser,
    );
  },

  removeDeviceToken: (userUuid      ) => client.delete(`${baseUrl}/users/${userUuid}/external/mobile`),

  createUser: (
    username        ,
    password        ,
    firstname        ,
    lastname        ,
  )                               => {
    const body = {
      username,
      password,
      firstname,
      lastname,
    };

    return client.post(`${baseUrl}/users`, body);
  },

  addUserEmail: (userUuid      , email        , main          ) => {
    const body = {
      emails: [
        {
          address: email,
          main,
        },
      ],
    };

    return client.put(`${baseUrl}/users/${userUuid}/emails`, body);
  },

  addUserPolicy: (userUuid      , policyUuid      ) =>
    client.put(`${baseUrl}/users/${userUuid}/policies/${policyUuid}`),

  deleteUserPolicy: (userUuid      , policyUuid      ) =>
    client.delete(`${baseUrl}/users/${userUuid}/policies/${policyUuid}`),

  addUserGroup: (userUuid      , groupUuid      ) => client.put(`${baseUrl}/groups/${groupUuid}/users/${userUuid}`),

  listUsersGroup: (groupUuid      ) => client.get(`${baseUrl}/groups/${groupUuid}/users`),

  deleteUserGroup: (userUuid      , groupUuid      ) =>
    client.delete(`${baseUrl}/groups/${groupUuid}/users/${userUuid}`),

  getUser: (userUuid      )                           => client.get(`${baseUrl}/users/${userUuid}`),

  getUserSession: (userUuid      ) => client.get(`${baseUrl}/users/${userUuid}/sessions`),

  deleteUserSession: (userUuid      , sessionUuids      ) =>
    client.delete(`${baseUrl}/users/${userUuid}/sessions/${sessionUuids}`),

  listUsers: ()                             => client.get(`${baseUrl}/users`),

  deleteUser: (userUuid      )                                  => client.delete(`${baseUrl}/users/${userUuid}`),

  listTenants: ()                               => client.get(`${baseUrl}/tenants`),

  getTenant: (tenantUuid      )                             => client.get(`${baseUrl}/tenants/${tenantUuid}`),

  createTenant: (name        )                                 => client.post(`${baseUrl}/tenants`, { name }),

  updateTenant: (
    uuid      ,
    name        ,
    contact        ,
    phone        ,
    address               ,
  )                                 => {
    const body = {
      name,
      contact,
      phone,
      address,
    };

    return client.put(`${baseUrl}/tenants/${uuid}`, body);
  },

  deleteTenant: (uuid      )                                  => client.delete(`${baseUrl}/tenants/${uuid}`),

  createGroup: (name        ) => client.post(`${baseUrl}/groups`, { name }),

  listGroups: ()                              => client.get(`${baseUrl}/groups`),

  deleteGroup: (uuid      )                                  => client.delete(`${baseUrl}/groups/${uuid}`),

  createPolicy: (name        , description        , aclTemplates               ) => {
    const body = {
      name,
      description,
      acl_templates: aclTemplates,
    };

    client.post(`${baseUrl}/policies`, body);
  },

  listPolicies: ()                                => client.get(`${baseUrl}/policies`),

  deletePolicy: (policyUuid      )                                  =>
    client.delete(`${baseUrl}/policies/${policyUuid}`),

  getProviders: (userUuid      ) => client.get(`${baseUrl}/users/${userUuid}/external`),

  getProviderToken: (userUuid      , provider        ) =>
    client.get(`${baseUrl}/users/${userUuid}/external/${provider}`),

  getProviderAuthUrl: (userUuid      , provider        ) =>
    client.post(`${baseUrl}/users/${userUuid}/external/${provider}`, {}),

  deleteProviderToken: (userUuid      , provider        ) =>
    client.delete(`${baseUrl}/users/${userUuid}/external/${provider}`),
});

module.exports = auth;
