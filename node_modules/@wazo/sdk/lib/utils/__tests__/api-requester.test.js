'use strict';

var jsBase64 = require('js-base64');

/*       */

class BadResponse extends Error {
  static fromResponse(error        , status        ) {
    return new BadResponse(error.message, status, error.timestamp, error.error_id, error.details);
  }

  static fromText(response        , status        ) {
    return new BadResponse(response, status);
  }

                  
                 
                     
                   
                   

  constructor(
    message        ,
    status        ,
    timestamp          = null,
    errorId          = null,
    details          = null,
  ) {
    super(message);

    this.timestamp = timestamp;
    this.status = status;
    this.errorId = errorId;
    this.details = details;
  }
}

/*       */

class ServerError extends BadResponse {
  static fromResponse(error        , status        ) {
    return new ServerError(error.message, status, error.timestamp, error.error_id, error.details);
  }

  static fromText(response        , status        ) {
    return new ServerError(response, status);
  }
}

/*       */

class Logger {
  static hasDebug() {
    return typeof process !== 'undefined' && (+process.env.DEBUG === 1 || process.env.DEBUG === 'true');
  }

  static logRequest(url        , { method, body, headers }        , response        ) {
    if (!Logger.hasDebug()) {
      return;
    }

    const { status } = response;

    let curl = `${status} - curl ${method !== 'get' ? `-X ${method.toUpperCase()}` : ''}`;
    Object.keys(headers).forEach(headerName => {
      curl += ` -H '${headerName}: ${headers[headerName]}'`;
    });

    curl += ` ${url}`;

    if (body) {
      curl += ` -d '${body}'`;
    }

    console.info(curl);
  }
}

/*       */
/* global navigator */
const isMobile = () => typeof navigator !== 'undefined' && navigator.product === 'ReactNative';

/*       */
                                             

                          
                 
                 
                    
                                 
  

const methods = ['head', 'get', 'post', 'put', 'delete'];

// Use a function here to be able to mock it in tests
const realFetch = () => {
  if (typeof document !== 'undefined') {
    // Browser
    return window.fetch;
  }

  if (isMobile()) {
    // React native
    return fetch;
  }

  // nodejs
  // this package is disable for react-native in package.json because it requires nodejs modules
  return require('node-fetch/lib/index');
};

class ApiRequester {
                 
                 
                    
                
                  
                                 

                 
                
                 
                
                   

  // eslint-disable-next-line
  static successResponseParser(response        , isJson         ) {
    return response.status === 204;
  }

  static defaultParser(response        ) {
    return response.json().then((data        ) => data);
  }

  static getQueryString(obj        )         {
    return Object.keys(obj)
      .filter(key => obj[key])
      .map(key => `${key}=${encodeURIComponent(obj[key])}`)
      .join('&');
  }

  static base64Encode(str        )         {
    return typeof btoa !== 'undefined' ? btoa(str) : jsBase64.Base64.encode(str);
  }

  // @see https://github.com/facebook/flow/issues/183#issuecomment-358607052
  constructor({ server, refreshTokenCallback, clientId, agent = null }                   ) {
    this.server = server;
    this.agent = agent;
    this.clientId = clientId;
    this.refreshTokenCallback = refreshTokenCallback;

    methods.forEach(method => {
      // $FlowFixMe
      ApiRequester.prototype[method] = function sugar(...args) {
        // Add method in arguments passed to `call`
        args.splice(1, 0, method);

        return this.call.call(this, ...args);
      };
    });
  }

  setTenant(tenant         ) {
    this.tenant = tenant;
  }

  call(
    path        ,
    method         = 'get',
    body          = null,
    headers                    = null,
    parse           = ApiRequester.defaultParser,
    firstCall          = true,
  )               {
    const url = this.computeUrl(method, path, body);
    const newHeaders = this.getHeaders(headers);
    let newBody = method === 'get' ? null : body;
    if (newBody && newHeaders['Content-Type'] === 'application/json') {
      newBody = JSON.stringify(newBody);
    }
    const isHead = method === 'head';
    const hasEmptyResponse = method === 'delete' || isHead;
    const newParse = hasEmptyResponse ? ApiRequester.successResponseParser : parse;
    const options = {
      method,
      body: newBody,
      headers: this.getHeaders(headers),
      agent: this.agent,
    };

    return realFetch()(url, options).then(response => {
      const contentType = response.headers.get('content-type') || '';
      const isJson = contentType.indexOf('application/json') !== -1;

      Logger.logRequest(url, options, response);

      // Throw an error only if status >= 400
      if ((isHead && response.status >= 500) || (!isHead && response.status >= 400)) {
        const promise = isJson ? response.json() : response.text();
        const exceptionClass = response.status >= 500 ? ServerError : BadResponse;

        return promise.then(async err => {
          // Check if the token is still valid
          if (firstCall && this._checkTokenExpired(response, err)) {
            // Replay the call after refreshing the token
            return this._replayWithNewToken(err, path, method, body, headers, parse);
          }

          throw typeof err === 'string'
            ? exceptionClass.fromText(err, response.status)
            : exceptionClass.fromResponse(err, response.status);
        });
      }

      return newParse(response, isJson);
    });
  }

  _checkTokenExpired(response        , err        ) {
    // Special case when authenticating form a token: we got a 404
    const isTokenNotFound = response.status === 404 && this._isTokenNotFound(err);

    return response.status === 401 || isTokenNotFound;
  }

  _isTokenNotFound(err        ) {
    return err.reason && err.reason[0] === 'No such token';
  }

  _replayWithNewToken(
    err        ,
    path        ,
    method        ,
    body          = null,
    headers                    = null,
    parse          ,
  ) {
    const isTokenNotFound = this._isTokenNotFound(err);
    let newPath = path;

    return this.refreshTokenCallback().then(() => {
      if (isTokenNotFound) {
        const pathParts = path.split('/');
        pathParts.pop();
        pathParts.push(this.token);
        newPath = pathParts.join('/');
      }

      return this.call(newPath, method, body, headers, parse, false);
    });
  }

  getHeaders(header                  )         {
    if (header instanceof Object) {
      return header;
    }

    return {
      'X-Auth-Token': this.token,
      ...(this.tenant ? { 'Wazo-Tenant': this.tenant } : null),
      Accept: 'application/json',
      'Content-Type': 'application/json',
    };
  }

  computeUrl(method        , path        , body         )         {
    const url = `${this.baseUrl}/${path}`;

    return method === 'get' && body && Object.keys(body).length ? `${url}?${ApiRequester.getQueryString(body)}` : url;
  }

  get baseUrl()         {
    return `https://${this.server}/api`;
  }
}

const server = 'localhost';
const path = 'auth';
const method = 'get';
const body = { a: 1 };
const url = `https://${server}/api/${path}?a=1`;
const token = 'abc';
const newToken = 'newToken';
const headers = {
  Accept: 'application/json',
  'Content-Type': 'application/json',
  'X-Auth-Token': token,
};

describe('Generating query string', () => {
  it('should generate a simple query string from an object', () => {
    expect(ApiRequester.getQueryString({ a: 1, b: 'someString' })).toBe('a=1&b=someString');
    expect(ApiRequester.getQueryString({ bool: true, b: 'boolÃ©en' })).toBe('bool=true&b=bool%C3%A9en');
    expect(ApiRequester.getQueryString({ nope: undefined, b: 'yep' })).toBe('b=yep');
  });
});

describe('Computing fetch URL', () => {
  it('should add query string to URL in get method with body', () => {
    const client = new ApiRequester({ server: 'localhost' });

    expect(client.computeUrl('get', 'auth', { a: 1 })).toBe('https://localhost/api/auth?a=1');
    expect(client.computeUrl('post', 'auth', { a: 1 })).toBe('https://localhost/api/auth');
    expect(client.computeUrl('get', 'auth', null)).toBe('https://localhost/api/auth');
    expect(client.computeUrl('get', 'auth', {})).toBe('https://localhost/api/auth');
  });
});

describe('Retrieving headers', () => {
  it('should send a tenant if exists', () => {
    const tenant = 'abc234';

    const requester = new ApiRequester({ server });
    requester.setTenant(tenant);

    expect(requester.getHeaders()['Wazo-Tenant']).toBe(tenant);
  });

  it('should not send a tenant if not present', () => {
    const requester = new ApiRequester({ server });

    expect(requester.getHeaders()).not.toHaveProperty('Wazo-Tenant');
  });
});

describe('Calling fetch', () => {
  it('should call fetch without body but query string in get method', () => {
    jest.mock('node-fetch/lib/index', () => {});
    global.fetch = jest.fn(() => Promise.resolve({ json: () => Promise.resolve({}) }));

    new ApiRequester({ server }).call(path, method, body, {});
    expect(global.fetch).toBeCalledWith(url, { method: 'get', body: null, headers: {}, agent: null });
  });
});

describe('With a refresh token', () => {
  it('should retry the call with a new token', async () => {
    jest.mock('node-fetch/lib/index', () => {});
    let calls = 0;
    global.fetch = jest.fn(() => {
      calls++;
      return Promise.resolve({
        headers: {
          get: () => 'application/json',
        },
        status: calls === 1 ? 401 : 200,
        json: () => Promise.resolve({}),
      });
    });

    const requester = new ApiRequester({ server });
    requester.token = token;

    requester.refreshTokenCallback = () => {
      requester.token = newToken;
      return new Promise(resolve => resolve());
    };

    const updatedHeaders = {
      Accept: 'application/json',
      'Content-Type': 'application/json',
      'X-Auth-Token': newToken,
    };

    await requester.call(path, method, body, null);

    expect(global.fetch).toHaveBeenNthCalledWith(1, url, { method: 'get', body: null, headers, agent: null });
    expect(global.fetch).toHaveBeenNthCalledWith(2, url, {
      method: 'get',
      body: null,
      headers: updatedHeaders,
      agent: null,
    });
  });
});
